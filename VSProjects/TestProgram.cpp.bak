#pragma warning(disable: 4091 4101)

#include "TestProgram.h"

namespace SS293502B2_00_47J
{
	// TestProgram Constructor
	TestProgram::TestProgram(void)
	{
		OffsetFile = String::Empty;
		offset = gcnew Dictionary <String ^ , array<double> ^>;

		TesterCalFile = String::Empty;
		calfactor = gcnew Dictionary <String ^ , array<double> ^>;

		DIOSettingFile = String::Empty;
		DIOSetting = gcnew Dictionary <String ^ , array<String ^> ^>;

		DMSettingFile = String::Empty;
		DMSetting = gcnew Dictionary <String ^ , array<String ^> ^>;

		CBitSettingFile = String::Empty;
		CBitSetting = gcnew Dictionary <String ^ , array<String ^> ^>;

		MuxSettingFile = String::Empty;
		MuxSetting = gcnew Dictionary <String ^ , array<String ^> ^>;
		
		VectorSetNo = gcnew Dictionary <String ^ , int>;
		VectorLineCount = gcnew Dictionary <String ^ , int>;

		//SPI
		SPISetNo = gcnew Dictionary <String ^ , int>;
		SPISetIndex = gcnew Dictionary <String ^ , int>;

		VectorFileDirectory = String::Empty;

		SetupFileDirectory = String::Empty;

		Vswg_calibrated = gcnew Dictionary <double, double>;
		Vswg_at_dut = gcnew Dictionary <double, double>;

		Vswg_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_hth_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hth_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_bias_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_bias_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_itr_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_itr_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_fhsgain_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_spd_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_fhsgain_spd_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_lpd_spd_calibrated = gcnew Dictionary <double, double>;
		Vswg_lpd_spd_at_dut = gcnew Dictionary <double, double>;

		Vswg_filter_calibrated = gcnew Dictionary <double, double>;
		Vswg_filter_at_dut = gcnew Dictionary <double, double>;

		wr_timing_siggen_del_index = gcnew Dictionary <String ^, int>;
		wr_timing_vset = gcnew Dictionary <String ^, int>;
		wr_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		rw_timing_vset = gcnew Dictionary <String ^, int>;
		rw_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		Debug_Enable = false;

		Power_Line_Freq = 50;

		HDS = 0;

		Test = TEST_IF4600_PKG;
		MultiSite = SINGLESITE;

		testHead = 0;
		testSite = 0;

		TIByPassed = false;

		CBitHist = gcnew Dictionary <int, int>;

		IsRunningEditor = true;

		Barrier_Debug_Enable = false;
	}

	// Private Methods
	void TestProgram::InitializeGlobalVariables(Site ^ site)
	{
		_glob->VectorListFile = String::Empty;

		_glob->contact_open_l_short_h = 0;
		_glob->contact_fail = 0;

		_glob->SPD_Channel_Number = 2;

		_glob->spi_clk_freq = SPI_CLK_FREQ;

		_glob->Global_Result = gcnew array<double> (TOTAL_GLOBAL_VARIABLE);
		for (int i=0; i<TOTAL_GLOBAL_VARIABLE; i++)
		{
			_glob->Global_Result[i] = 0;
		}

		_glob->global_who_i = gcnew array<double>(HDS); 
		_glob->global_who_v = gcnew array<double>(HDS); 

		for (int i=0; i<HDS; i++)
		{
			_glob->global_who_i[i] = -999;
			_glob->global_who_v[i] = -999;
		}

		//Trimming test global variable
		_glob->TrimReg = gcnew array<int,2>(10,5);
		_glob->TrimRegWHD = gcnew array<int,2>(10,5);
		_glob->TrimRegRHD = gcnew array<int,2>(10,5);

		_glob->trimlock		= 0;
		_glob->FuseBlown	= 0;
		_glob->testpass		= 0;
		_glob->GoodDIE		= 0;

		_glob->vref_pre		= 0;
		_glob->iabs_pre		= 0;
		_glob->atemp_pre	= 0;
		
		_glob->mux_offset	= 0;

		_glob->vref_blown_fuse			= 0;
		_glob->atemp_blown_fuse			= 0;
		_glob->iabs_blown_fuse			= 0;
		_glob->waferid_blown_fuse		= 0;
		_glob->quadrantid_blown_fuse	= 0;
		_glob->radiusid_blown_fuse		= 0;

		_glob->vref_fuse_toblow			= 0;
		_glob->atemp_fuse_toblow		= 0;
		_glob->iabs_fuse_toblow			= 0;
		_glob->waferid_fuse_toblow		= 0;
		_glob->quadrantid_fuse_toblow	= 0;
		_glob->radiusid_fuse_toblow		= 0;

		_glob->Center_X = 0;
		_glob->Center_Y = 0;
		_glob->Die_Size_X = 0;
		_glob->Die_Size_Y = 0;

			// SPI global variable
		_glob->SPI_Data_Arr = gcnew array<int,3>(MAX_SPI_SET,MAX_SPI_SET_INDEX,3); // for loading all SPI data
		_glob->SPI_Data_Index = gcnew array<int,1>(MAX_SPI_SET_INDEX);

		_glob->jump_on_fail = false;
	
	}
	void TestProgram::LoadTrimReg(void)
	{
		int trim_reg[10][5] = 
		//// pg, reg, bitshift, fuse count , dac
		{
		{ 2, 23, 0, 4, 16},		// 0: VREF
		{ 2, 22, 0, 6, 64},		// 1: IABS
		{ 2, 23, 4, 4, 16},		// 2: ATEMP
		{ 2, 24, 3, 5, 32},		// 3: WAFERID
		{ 2, 24, 1, 2,  3},		// 4: QUADID
		{ 2, 24, 0, 1,  1},		// 5: RADID
		{ 2, 14, 3, 3,  8},		// 6: WHTRCORE
		{ 2, 14, 0, 3,  8},		// 7: RHTRCORE
		{ 2, 25, 5, 1,	1},		// 8: Test
		{ 2, 25, 4, 1,	1},		// 9: Lock
		};
		
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 5; j++)
			{	
				_glob->TrimReg[i,j] = trim_reg[i][j]; 				
			}		
		}

		int trim_reg_WHD[10][5] = 
		// pg, reg, bitshift, fuse count 
		{
		{ 2, 9, 2, 2, 3},	// WHTR_HD_0: 
		{ 2, 9, 6, 2, 3},	// WHTR_HD_1:
		{ 2, 10, 2, 2, 3},	// WHTR_HD_2: 
		{ 2, 10, 6, 2, 3},	// WHTR_HD_3:
		{ 2, 11, 2, 2, 3},	// WHTR_HD_4: 
		{ 2, 11, 6, 2, 3},	// WHTR_HD_5:
		{ 2, 12, 2, 2, 3},	// WHTR_HD_6: 
		{ 2, 12, 6, 2, 3},	// WHTR_HD_7:
		{ 2, 13, 2, 2, 3},	// WHTR_HD_8:
		{ 2, 13, 6, 2, 3},	// WHTR_HD_9:
		};
		
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 5; j++)
			{	
				_glob->TrimRegWHD[i,j] = trim_reg_WHD[i][j]; 				
			}		
		}

		int trim_reg_RHD[10][5] = 
		// pg, reg, bitshift, fuse count 
		{
		{ 2, 9, 0, 2, 3},	// WHTR_HD_0: 
		{ 2, 9, 4, 2, 3},	// WHTR_HD_1:
		{ 2, 10, 0, 2, 3},	// WHTR_HD_2: 
		{ 2, 10, 4, 2, 3},	// WHTR_HD_3:
		{ 2, 11, 0, 2, 3},	// WHTR_HD_4: 
		{ 2, 11, 4, 2, 3},	// WHTR_HD_5:
		{ 2, 12, 0, 2, 3},	// WHTR_HD_6: 
		{ 2, 12, 4, 2, 3},	// WHTR_HD_7:
		{ 2, 13, 0, 2, 3},	// WHTR_HD_8:
		{ 2, 13, 4, 2, 3},	// WHTR_HD_9:
		};
		
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 5; j++)
			{	
				_glob->TrimRegRHD[i,j] = trim_reg_RHD[i][j]; 				
			}		
		}
	}
	int TestProgram::LoadVectorFileList(Site ^ site)
	{
		int ret = 0;

		_glob->VectorListFile = site->GetExternalDependency("VECTOR_LIST_FILE");
		if (!File::Exists(_glob->VectorListFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(_glob->VectorListFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(_glob->VectorListFile);

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != 2)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain correct format!", ER_READ_FILE_ERROR);
				}
		
				if (VectorSetNo->ContainsKey(ArrStr[0]) == false)
					VectorSetNo->Add(ArrStr[0], _util->StrToInt(ArrStr[1]));
					_glob->VectorArrSetNo++;
			}
		}

		_glob->VectorArrSetNo = _glob->VectorArrSetNo + 10; 

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::LoadVectorFiles(Site ^ site)
	{
		//if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// Load vector files:");
		}

		//VectorFileDirectory = SetupFileDirectory + "\\Vector";
		VectorFileDirectory = site->GetExternalDependency("VECTOR");

		array<int>^ resourceArr = gcnew array<int>(DM_CONST_MAX_VECTOR_SET);

		for(int i=0; i<DM_CONST_MAX_VECTOR_SET; i++)
		{
			resourceArr[i] = 1;
		}

		ret = dm->ConfigureVectorEngineAttribute("DM_2", 0, 0);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("ConfigureVectorEngineAttribute return: " + ret.ToString());
		}

		ret = dm->DPINVectorResourceAllocation("DM_2", DM_CONST_MAX_VECTOR_SET, resourceArr);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINVectorResourceAllocation return: " + ret.ToString());
		}
				
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		StreamReader ^ sr;
		int vector_count = 0;
		int flag = 0;
		int coun = 0;
		for each (String ^ s in VectorSetNo->Keys)
		{
			ret = dm->DPINVecLoad("DM_2", DM_CONST_BIDIRECTIONAL_IO, VectorSetNo[s], VectorFileDirectory + "\\" + s + ".txt");
			if (ret < 0) 
			{
				CheckError(ret, __LINE__);
			}

			coun++;
			//Get total vector lines in each vector file (VectorCount)
			sr = gcnew StreamReader(VectorFileDirectory + "\\" + s + ".txt");

			vector_count = 0;

			while((line = sr->ReadLine()) != nullptr)
			{
				if (line->StartsWith("X") == true ||
					line->StartsWith("x") == true ||
					line->StartsWith("L") == true ||
					line->StartsWith("l") == true ||
					line->StartsWith("H") == true ||
					line->StartsWith("h") == true ||
					line->StartsWith("Z") == true ||
					line->StartsWith("x") == true ||
					line->StartsWith("1") == true ||
					line->StartsWith("0") == true)
				{
					vector_count++;
				}
			}

			if (VectorLineCount->ContainsKey(s) == false)
				VectorLineCount->Add(s, vector_count);

			if(Debug_Enable)
			{
				sb->AppendLine("DPINVecLoad return: " + ret.ToString());
				sb->AppendLine("	vector set=" + VectorSetNo[s]);
				sb->AppendLine("	vector file=" + VectorFileDirectory + "\\" + s + ".txt");
				sb->AppendLine("	vector count=" + vector_count.ToString());
			}
			
			sr->Close();
			sr = nullptr;
		}
		
		ret = dm->DPINPeriod("DM_2", 1, DM_CONST_VECTOR_PERIOD_1MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=1,1MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 2, DM_CONST_VECTOR_PERIOD_2MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=2,2MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 10, DM_CONST_VECTOR_PERIOD_10MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=10,10MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 20, DM_CONST_VECTOR_PERIOD_20MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=20,20MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 25, DM_CONST_VECTOR_PERIOD_25MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=25,25MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 40, DM_CONST_VECTOR_PERIOD_40MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=40,40MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 50, DM_CONST_VECTOR_PERIOD_50MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=50,50MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 60, DM_CONST_VECTOR_PERIOD_60MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=60,60MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 70, DM_CONST_VECTOR_PERIOD_70MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=70,70MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 80, DM_CONST_VECTOR_PERIOD_80MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=80,80MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 90, DM_CONST_VECTOR_PERIOD_90MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=90,90MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 100, DM_CONST_VECTOR_PERIOD_100MHZ);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=100,100MHz) return: " + ret.ToString());
		}

		ret = dm->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("DPINPeriod (tset=0,100ns) return: " + ret.ToString());
		}

		return ret;
	}

	int TestProgram::GetDataByteFromHistoryRam(String^ VectorFileName, array<int>^ HistoryRam, int % data_one_byte, int data_channel)
	{
		int ret = 0;

		array<String ^, 2>^ res_Arr = gcnew array<String ^, 2>(VectorLineCount[VectorFileName], DM_CONST_TOTAL_CHANNEL_PER_CARD);
		String ^ res_out = String::Empty;

		int i=0, j=0, k=0;

		//Convert 2-bit to corresponding logic state, for every vector line (excluding t0 and t1)
		for(i=0; i<VectorLineCount[VectorFileName]; i++)
		{
			bitset<24> b(HistoryRam[i]); //12 channels, where each channel logic is represented by 2 bits (00, 01, or 10) -> 24
			for (j=0; j<24; j=j+2)
			{
				if ((b[j]==0) && (b[j+1]==0)) 
				{
					res_Arr[i, j/2] = "L";
				}
				else if ((b[j+1]==0) && (b[j]==1)) 
				{
					res_Arr[i, j/2] = "H";
				}
				else if ((b[j+1]== 1) && (b[j]==0)) 
				{
					res_Arr[i, j/2] = "Z";
				}
			}
		}

		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = "//"; //to filter out comments

		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = " ";

		int vector_count = 0;
		int data = 0;
		i = 0;

		StreamReader ^ sr = gcnew StreamReader(VectorFileDirectory + "\\" + VectorFileName + ".txt");

		while((line = sr->ReadLine()) != nullptr)
		{
			if (line->StartsWith("X") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("L") == true ||
				line->StartsWith("l") == true ||
				line->StartsWith("H") == true ||
				line->StartsWith("h") == true ||
				line->StartsWith("Z") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("1") == true ||
				line->StartsWith("0") == true)
			{
				vector_count++;

				ArrStr = line->Split(Separator, StringSplitOptions::None);

				if(ArrStr[0]->Contains("L") == true ||
					ArrStr[0]->Contains("l") == true ||
					ArrStr[0]->Contains("H") == true ||
					ArrStr[0]->Contains("h") == true)
				{
					if (res_Arr[vector_count-1, data_channel] == "H")
						data = data | (1 << i);

					if (res_Arr[vector_count-1, data_channel] == "L" || res_Arr[vector_count, data_channel] == "Z")
						data = data | (0 << i);

					i++;
				}
			}
		}
	
		sr->Close();

		sr = nullptr;

		data_one_byte = data;

		return ret;
	}

	int TestProgram::LoadDIOSettingFile(Site ^ site)
	{
		int ret = 0;

		DIOSettingFile = SetupFileDirectory + "\\DIO_Setting.csv";

		if (!File::Exists(DIOSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(DIOSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(DIOSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			//Remove " " double-quotes generated by Open-Office, if any
			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);

					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != IOM_CONST_TOTAL_IO + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + IOM_CONST_TOTAL_IO + " I/O(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(IOM_CONST_TOTAL_IO);

				index = ArrStr[1];

				for (i=0; i<IOM_CONST_TOTAL_IO; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //first col=testname, second col=index
				}

				DIOSetting->Add(ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}

	int TestProgram::LoadDMSettingFile(Site ^ site)
	{
		int ret = 0;

		DMSettingFile = site->GetExternalDependency("DM_Setting");
		if (!File::Exists(DMSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(DMSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(DMSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != TOTAL_DM_IN_SETTING_FILE + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + TOTAL_DM_IN_SETTING_FILE + " I/O(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(TOTAL_DM_IN_SETTING_FILE);

				index = ArrStr[1];

				for (i=0; i<TOTAL_DM_IN_SETTING_FILE; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //include "Index" column
				}

				DMSetting->Add(ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}

	int TestProgram::LoadCBitSettingFile(Site ^ site)
	{
		int ret = 0;

		switch (testSite)
		{
			case 0:
				CBitSettingFile = SetupFileDirectory + "\\CBITA_Setting.csv";
				break;

			case 1:
				CBitSettingFile = SetupFileDirectory + "\\CBITB_Setting.csv";
				break;

			case 2:
				CBitSettingFile = SetupFileDirectory + "\\CBITC_Setting.csv";
				break;

			case 3:
				CBitSettingFile = SetupFileDirectory + "\\CBITD_Setting.csv";
				break;

			default:
				CBitSettingFile = SetupFileDirectory + "\\CBITA_Setting.csv";
		}

		if (!File::Exists(CBitSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(CBitSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(CBitSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != IOM_CONST_TOTAL_CBITS + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + IOM_CONST_TOTAL_CBITS + " CBit(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(IOM_CONST_TOTAL_CBITS);

				index = ArrStr[1];

				for (i=0; i<IOM_CONST_TOTAL_CBITS; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //include "Index" column
				}

				CBitSetting->Add(ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}

	int TestProgram::LoadMuxSettingFile(Site ^ site)
	{
		int ret = 0;
		
		switch (testSite)
		{
			case 0:
				MuxSettingFile = SetupFileDirectory + "\\MUXA_Setting.csv";
				break;

			case 1:
				MuxSettingFile = SetupFileDirectory + "\\MUXB_Setting.csv";
				break;

			case 2:
				MuxSettingFile = SetupFileDirectory + "\\MUXC_Setting.csv";
				break;

			case 3:
				MuxSettingFile = SetupFileDirectory + "\\MUXD_Setting.csv";
				break;

			default:
				MuxSettingFile = SetupFileDirectory + "\\MUXA_Setting.csv";
		}

		if (!File::Exists(MuxSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(MuxSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(MuxSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != IFBRD_CONST_TOTAL_MUX_IO + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + IFBRD_CONST_TOTAL_MUX_IO + " MUX I/O(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(IFBRD_CONST_TOTAL_MUX_IO);

				index = ArrStr[1];

				for (i=0; i<IFBRD_CONST_TOTAL_MUX_IO; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //include "Index" column 
				}

				MuxSetting->Add(ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}

	int TestProgram::DriveDIOPin(String ^ TestParamDisplayName)
	{
		int ret = 0;

		int index = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveDIOPin:");
		}

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DIOSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_IO; i++)
			{
				if (DIOSetting[TestParamDisplayName][i] == "1")
				{
					ret = dio->DrivePin("DIO_" + i, 1);
					CheckError(ret, __LINE__);
				}

				if (DIOSetting[TestParamDisplayName][i] == "0")
				{
					ret = dio->DrivePin("DIO_" + i, 0);
					CheckError(ret, __LINE__);
				}

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin DIO_" + i.ToString() + " (Val=" + DIOSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}
	int TestProgram::DriveDIOPin(String ^ TestParamDisplayName, int index)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveDIOPin:");
		}

		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (DIOSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_IO; i++)
			{
				if (DIOSetting[TestParamDisplayName][i] == "1")
				{
					ret = dio->DrivePin("DIO_" + i, 1);
					CheckError(ret, __LINE__);
				}

				if (DIOSetting[TestParamDisplayName][i] == "0")
				{
					ret = dio->DrivePin("DIO_" + i, 0);
					CheckError(ret, __LINE__);
				}

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin DIO_" + i.ToString() + " (Val=" + DIOSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}
	int TestProgram::ResetDIOPin(String ^ TestParamDisplayName)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// ResetDIOPin:");
		}

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DIOSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_IO; i++)
			{
				if (DIOSetting[TestParamDisplayName][i] == "1")
				{
					ret = dio->DrivePin("DIO_" + i, 0);
					CheckError(ret, __LINE__);
				}

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin DIO_" + i.ToString() + " (Val=" + DIOSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}
	int TestProgram::ResetDIOPin(String ^ TestParamDisplayName, int index)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// ResetDIOPin:");
		}

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (DIOSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_IO; i++)
			{
				if (DIOSetting[TestParamDisplayName][i] == "1")
				{
					ret = dio->DrivePin("DIO_" + i, 0);
					CheckError(ret, __LINE__);
				}

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin DIO_" + i.ToString() + " (Val=" + DIOSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}

	int TestProgram::LoadOffsetFile(Site ^ site)
	{
		int ret = 0;

		OffsetFile = site->GetExternalDependency("Offset");
		if (!File::Exists(OffsetFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(OffsetFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(OffsetFile);
		array<double> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != TOTAL_SITES + 1)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + TOTAL_SITES + " site(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<double>(TOTAL_SITES);

				for (i=0; i<TOTAL_SITES; i++)
				{
					ArrTemp[i] = _util->StrToDouble(ArrStr[i+1]); 
				}

				offset->Add(ArrStr[0], ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}

	double TestProgram::GetOffset(String ^ TestParamDisplayName)
	{
		double val = 0.0;

		if (offset->ContainsKey(TestParamDisplayName))
			val = offset[TestParamDisplayName][testSite];
		else
			val = 0.0;

		return val;
	}

	int TestProgram::SetupDigital(Site ^ site)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// SetupDigital:");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		//vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm->Force("FHCW_FETS", DM_CONST_FORCE_STATE_DIO);
		//CheckError(ret, __LINE__);
		//ret = dm->ConfigurePEAttribute("FHCW_FETS", 0, 0, 0, 0);
		//CheckError(ret, __LINE__);
		//ret = dm->DPINLevel("FHCW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(ret, __LINE__);
		//ret = dm->SetPinDirection("FHCW_FETS", DM_CONST_DIR_OUTPUT);
		//CheckError(ret, __LINE__);

		//if(Debug_Enable)
		//{
		//	sb->AppendLine("FHCW_FETS: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		//}

		//vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm->Force("FHCR_FETS", DM_CONST_FORCE_STATE_DIO);
		//CheckError(ret, __LINE__);
		//ret = dm->ConfigurePEAttribute("FHCR_FETS", 0, 0, 0, 0);
		//CheckError(ret, __LINE__);
		//ret = dm->DPINLevel("FHCR_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(ret, __LINE__);
		//ret = dm->SetPinDirection("FHCR_FETS", DM_CONST_DIR_OUTPUT);
		//CheckError(ret, __LINE__);

		//if(Debug_Enable)
		//{
		//	sb->AppendLine("FHCR_FETS: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		//}

		//vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm->Force("HW_FETS", DM_CONST_FORCE_STATE_DIO);
		//CheckError(ret, __LINE__);
		//ret = dm->ConfigurePEAttribute("HW_FETS", 0, 0, 0, 0);
		//CheckError(ret, __LINE__);
		//ret = dm->DPINLevel("HW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(ret, __LINE__);
		//ret = dm->SetPinDirection("HW_FETS", DM_CONST_DIR_OUTPUT);
		//CheckError(ret, __LINE__);

		//if(Debug_Enable)
		//{
		//	sb->AppendLine("HW_FETS: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		//}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("RWN", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("RWN: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		//vih = 1.8;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		vih = 2;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("WDX", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDX", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("WDX", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("WDX: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 1.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("WDY", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDY", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("WDY", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("WDY: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("PWR_SAVE", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("PWR_SAVE", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("PWR_SAVE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("PWR_SAVE", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("PWR_SAVE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 2e-3;	iol = 2e-3;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("FLTMUX", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("FLTMUX", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("FLTMUX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("FLTMUX", DM_CONST_DIR_INPUT);
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("FLTMUX: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		return ret;
	}

	int TestProgram::DriveDMPin(String ^ TestParamDisplayName)
	{
		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveDMPin:");
		}
		
		int ret = 0;
		int i = 0;

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("HW_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("HW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin HW_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}
			
			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("FHCR_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("FHCR_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin FHCR_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}

			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("FHCW_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("FHCW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin FHCW_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("RWN");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("RWN", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin RWN (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("WDX");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("WDX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDX (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("WDY");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("WDY", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDY (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("PWR_SAVE");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("PWR_SAVE", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin PWR_SAVE (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("FLTMUX");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("FLTMUX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin FLTMUX (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}

	int TestProgram::DriveDMPin(String ^ TestParamDisplayName, int index)
	{
		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveDMPin:");
		}
		
		int ret = 0;
		int i = 0;

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("HW_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("HW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin HW_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}
			
			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("FHCR_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("FHCR_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin FHCR_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}

			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("FHCW_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("FHCW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin FHCW_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("RWN");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("RWN", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin RWN (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("WDX");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("WDX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDX (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("WDY");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("WDY", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDY (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("PWR_SAVE");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("PWR_SAVE", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin PWR_SAVE (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm->DPINOn("FLTMUX");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("FLTMUX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin FLTMUX (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}

	int TestProgram::DriveDMPin2(String ^ TestParamDisplayName)
	{
		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveDMPin:");
		}
		
		int ret = 0;
		int i = 0;

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("HW_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("HW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin HW_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}
			
			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("FHCR_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("FHCR_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin FHCR_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}

			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm->DPINOn("FHCW_FETS");
			//	CheckError(ret, __LINE__);
			//	ret = dm->DrivePin("FHCW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(ret, __LINE__);

			//	if(Debug_Enable)
			//	{
			//		sb->AppendLine("DrivePin FHCW_FETS (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
			//	}
			//}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm->DPINOn("RWN");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("RWN", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin RWN (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm->DPINOn("WDX");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("WDX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDX (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm->DPINOn("WDY");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("WDY", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDY (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm->DPINOn("PWR_SAVE");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("PWR_SAVE", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin PWR_SAVE (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm->DPINOn("FLTMUX");
				CheckError(ret, __LINE__);
				ret = dm->DrivePin("FLTMUX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin FLTMUX (Val=" + DMSetting[TestParamDisplayName][i]+ ") return=" + ret.ToString());
				}
			}
		}

		return ret;
	}

	int TestProgram::ResetDMPin(String ^ TestParamDisplayName)
	{
		int ret = 0;

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// ResetDMPin:");
		}

		int i = 3; //start with RWN

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("RWN", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("RWN");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin RWN (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("WDX", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("WDX");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDX (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("WDY", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("WDY");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDY (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{	
				ret = dm->DrivePin("PWR_SAVE", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("PWR_SAVE");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin PWR_SAVE (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("FLTMUX", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("FLTMUX");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin FLTMUX (Val=0) return=" + ret.ToString());
				}
			}
		}

		return ret;
	}

	int TestProgram::ResetDMPin(String ^ TestParamDisplayName, int index)
	{
		int ret = 0;

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// ResetDMPin:");
		}

		int i = 3; //start with RWN

		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("RWN", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("RWN");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin RWN (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("WDX", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("WDX");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDX (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("WDY", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("WDY");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin WDY (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{	
				ret = dm->DrivePin("PWR_SAVE", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("PWR_SAVE");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin PWR_SAVE (Val=0) return=" + ret.ToString());
				}
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm->DrivePin("FLTMUX", 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff("FLTMUX");
				CheckError(ret, __LINE__);

				if(Debug_Enable)
				{
					sb->AppendLine("DrivePin FLTMUX (Val=0) return=" + ret.ToString());
				}
			}
		}

		return ret;
	}

	int TestProgram::Digital_Init_State(Site ^ site)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// Digital_Init_State:");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("RWN", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);
		
		if(Debug_Enable)
		{
			sb->AppendLine("RWN: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 1.8;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("WDX", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDX", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("WDX", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDX");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("WDX: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 1.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("WDY", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDY", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("WDY", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDY");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("WDY: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("PWR_SAVE", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("PWR_SAVE", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("PWR_SAVE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("PWR_SAVE", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("PWR_SAVE", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("PWR_SAVE");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("PWR_SAVE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 2e-3;	iol = 2e-3;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("FLTMUX", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("FLTMUX", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("FLTMUX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("FLTMUX", DM_CONST_DIR_INPUT);
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("PWR_SAVE");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("FLTMUX: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("SPE", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("SPE", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("SPE", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("SPD", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("SPD", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("SPD", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("SPC", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("SPC", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("SPC", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		return ret;

	}

	int TestProgram::SetupDIO(Site ^ site)
	{
		int ret = 0;

		for (int i=0; i<IOM_CONST_TOTAL_PORTS; i++)
		{
			ret = dio->DrivePort("IOM_Port_" + i, 0x0);
			CheckError(ret, __LINE__);
		}

		//Reset CBits
		ret = dio->DrivePin("DIO_19", 0);		// CLR	
		CheckError(ret, __LINE__);
		ret = dio->DrivePin("DIO_20", 1);		// Reset 
		CheckError(ret, __LINE__);

		//Reset MuxIO
		ret = dio->DrivePin("DIO_8", 0);	
		CheckError(ret, __LINE__);

		//Reset Gnd Mux
		//double vih;
		//double vil;
		//double voh; 
		//double vol;
		//double ioh;
		//double iol;
		//double vch;
		//double vcl;
		//double vt;

		//vih = 3.3;	vil = 0;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm->Force("GNDMUX_RST", DM_CONST_FORCE_STATE_DIO);
		//CheckError(ret, __LINE__);
		//ret = dm->ConfigurePEAttribute("GNDMUX_RST", 0, 0, 0, 0);
		//CheckError(ret, __LINE__);
		//ret = dm->DPINLevel("GNDMUX_RST", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(ret, __LINE__);
		//ret = dm->SetPinDirection("GNDMUX_RST", DM_CONST_DIR_OUTPUT);
		//CheckError(ret, __LINE__);
		//ret = dm->DrivePin("GNDMUX_RST", 0);
		//CheckError(ret, __LINE__);

		return ret;
	}

	int TestProgram::OnOffCbit(int Cbit, int value)
	{
		int ret =0;

		int adc[8][3] = {
			//A0, A1, A2
			{0,	0, 0,},
			{1,	0, 0,},
			{0,	1, 0,},
			{1,	1, 0,},
			{0,	0, 1,},
			{1,	0, 1,},
			{0,	1, 1,},
			{1,	1, 1}};
	
		array<String ^> ^ CH_Sel = gcnew array<String ^>(8);
		CH_Sel[0] = "DIO_24";
		CH_Sel[1] = "DIO_25";
		CH_Sel[2] = "DIO_26";
		CH_Sel[3] = "DIO_27";
		CH_Sel[4] = "DIO_28";
		CH_Sel[5] = "DIO_29";
		CH_Sel[6] = "DIO_30";
		CH_Sel[7] = "DIO_31";

		String ^ Clk_Sel_Cbit_A0 = "DIO_23";
		String ^ Clk_Sel_Cbit_A1 = "DIO_22";
		String ^ Clk_Sel_Cbit_A2 = "DIO_21";

		//Reset latch
		for (int i = 0; i <= 7; i++)
		{
			ret = dio->DrivePin(CH_Sel[i], 0);
			CheckError(ret, __LINE__);
		}

		int Cbit_CH = Cbit/8;
		int s = (Cbit -(Cbit /8)*8);
		int k = 0;
		int start_Cbit = Cbit_CH * 8; 

		//Load Same latch Cbit from CbitHis
		for (int i = start_Cbit ; i <= 7 + start_Cbit; i++)
		{
			if (CBitHist[i] == 1)
			{
				k = (i -(i /8)*8);
				ret = dio->DrivePin(CH_Sel[k], 1);
				CheckError(ret, __LINE__);
			}
		}

		//record to CbitHist
		CBitHist[Cbit] = value;
		ret = dio->DrivePin(CH_Sel[s], value);		
		CheckError(ret, __LINE__);

		//select CLK
		ret = dio->DrivePin(Clk_Sel_Cbit_A0, adc[Cbit_CH][0]);		
		CheckError(ret, __LINE__);
		ret = dio->DrivePin(Clk_Sel_Cbit_A1, adc[Cbit_CH][1]);		
		CheckError(ret, __LINE__);
		ret = dio->DrivePin(Clk_Sel_Cbit_A2, adc[Cbit_CH][2]);
		CheckError(ret, __LINE__);

		ret = dio->DrivePin("DIO_19", 1);	
		CheckError(ret, __LINE__);
		ret = dio->DrivePin("DIO_19", 0);	//Clock in
		CheckError(ret, __LINE__);
		ret = dio->DrivePin("DIO_20", 0);   //Set Output Enable
		CheckError(ret, __LINE__);

		return ret;

	}

	int TestProgram::DriveCBit(String ^ TestParamDisplayName)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveCBit:");
		}

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (CBitSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_CBITS; i++)
			{
				if ((i != 53) && (i != 54))   // maintain smu mode
				{
					if (CBitSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnOffCbit(i, 1);
						CheckError(ret, __LINE__);
					}

					if (CBitSetting[TestParamDisplayName][i] == "0")
					{
						ret = OnOffCbit(i, 0);
						CheckError(ret, __LINE__);
					}

					if(Debug_Enable)
					{
						sb->AppendLine("DriveCBit CBIT_" + i.ToString() + " (Val=" + CBitSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
					}
				}
			}
		}
		
		return ret;
	}

	int TestProgram::DriveCBit(String ^ TestParamDisplayName, int index)
	{
		int ret = 0;

		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveCBit:");
		}

		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (CBitSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_CBITS; i++)
			{
				if ((i != CBIT_VCC_FORWARD) && (i != CBIT_VEE_FORWARD))   // maintain smu mode
				{
					if (CBitSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnOffCbit(i, 1);
						CheckError(ret, __LINE__);
					}

					if (CBitSetting[TestParamDisplayName][i] == "0")
					{
						ret = OnOffCbit(i, 0);
						CheckError(ret, __LINE__);
					}

					if(Debug_Enable)
					{
						sb->AppendLine("DriveCBit CBIT_" + i.ToString() + " (Val=" + CBitSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
					}
				}
			}
		}
		
		return ret;
	}

	int TestProgram::ResetCBit(void)
	{
		int ret = 0;

		int adc[8][3] = {
			//A0, A1, A2
			{0,	0,	0,},
			{1,	0,	0,},
			{0,	1,	0,},
			{1,	1,	0,},
			{0,	0,	1,},
			{1,	0,	1,},
			{0,	1,	1,},
			{1,	1,	1}};
	
		array<String ^> ^ CH_Sel = gcnew array<String ^>(8);
		CH_Sel[0] = "DIO_24";
		CH_Sel[1] = "DIO_25";
		CH_Sel[2] = "DIO_26";
		CH_Sel[3] = "DIO_27";
		CH_Sel[4] = "DIO_28";
		CH_Sel[5] = "DIO_29";
		CH_Sel[6] = "DIO_30";
		CH_Sel[7] = "DIO_31";

		String ^ Clk_Sel_Cbit_A0 = "DIO_23";
		String ^ Clk_Sel_Cbit_A1 = "DIO_22";
		String ^ Clk_Sel_Cbit_A2 = "DIO_21";

		// Reset all Latch except 6
		for (int i = 0; i <= 7; i++)
		{
			ret = dio->DrivePin(CH_Sel[i], 0);	// Reset All Input
			CheckError(ret, __LINE__);
		}
				
		for (int i = 0; i <= 7; i++)
		{
			if (i !=6)
			{
				ret = dio->DrivePin(Clk_Sel_Cbit_A0, adc[i][0]);		//Sel CLK except 6
				CheckError(ret, __LINE__);
				ret = dio->DrivePin(Clk_Sel_Cbit_A1, adc[i][1]);		
				CheckError(ret, __LINE__);
				ret = dio->DrivePin(Clk_Sel_Cbit_A2, adc[i][2]);
				CheckError(ret, __LINE__);

				ret = dio->DrivePin("DIO_19", 1);	
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_19", 0);		
				CheckError(ret, __LINE__);
			}
		}

		// Reset Latch6
		for (int i = 0; i <= 7; i++)
		{
			if ((i != 6) && (i != 5))
			{
				ret = dio->DrivePin(CH_Sel[i], 0);	// Reset Input except 5 & 6
				CheckError(ret, __LINE__);
			}
		    else
			{
				ret = dio->DrivePin(CH_Sel[i], 1);	// Reset Input except 5 & 6
				CheckError(ret, __LINE__);
			}
		}
		
		ret = dio->DrivePin(Clk_Sel_Cbit_A0, adc[6][0]);		//Sel CLK 6
		CheckError(ret, __LINE__);
		ret = dio->DrivePin(Clk_Sel_Cbit_A1, adc[6][1]);		
		CheckError(ret, __LINE__);
		ret = dio->DrivePin(Clk_Sel_Cbit_A2, adc[6][2]);
		CheckError(ret, __LINE__);

		ret = dio->DrivePin("DIO_19", 1);	
		CheckError(ret, __LINE__);
		ret = dio->DrivePin("DIO_19", 0);		
		CheckError(ret, __LINE__);

		ret = dio->DrivePin(Clk_Sel_Cbit_A0, 0);	
		CheckError(ret, __LINE__);
		ret = dio->DrivePin(Clk_Sel_Cbit_A1, 0);		
		CheckError(ret, __LINE__);
		ret = dio->DrivePin(Clk_Sel_Cbit_A2, 0);
		CheckError(ret, __LINE__);

		ret = InitCBitHist();
		CheckError(ret, __LINE__);

		//Set Vcc relay on adaptor board
		ret = OnOffCbit(CBIT_VCC_FORWARD, 1);
		CheckError(ret, __LINE__);
		ret = OnOffCbit(CBIT_VEE_FORWARD, 1);
		CheckError(ret, __LINE__);
		
		return ret;
	}

	int TestProgram::OnMux(int mux_grp, int mux_pin)  
	{
		int ret = 0;
		int pin_index = 0;

		if (!(mux_grp == -1))
		{ 
			int adc[16][4] = {
			//A0, A1, A2, A3
			{0,	0, 0, 0,},	//S1
			{1,	0, 0, 0,},	//S2
			{0,	1, 0, 0,},	//S3
			{1,	1, 0, 0,},	//S4
			{0,	0, 1, 0,},	//S5
			{1,	0, 1, 0,},	//S6
			{0,	1, 1, 0,},	//S7
			{1,	1, 1, 0,},	//S8
			{0,	0, 0, 1,},	//S9
			{1,	0, 0, 1,},	//S10
			{0,	1, 0, 1,},	//S11
			{1,	1, 0, 1,},	//S12
			{0,	0, 1, 1,},	//S13
			{1,	0, 1, 1,},	//S14
			{0,	1, 1, 1,},	//S15
			{1,	1, 1, 1}};	//S16
			
			array<String ^> ^ Mux_WR	= gcnew array<String ^>(8);
			Mux_WR[0] = "DIO_0";	//G1-FH
			Mux_WR[1] = "DIO_1";	//G1-SH
			Mux_WR[2] = "DIO_2";	//G1-SL
			Mux_WR[3] = "DIO_3";	//G1-FL
			Mux_WR[4] = "DIO_4";	//G2-FH
			Mux_WR[5] = "DIO_5";	//G2-SH
			Mux_WR[6] = "DIO_6";	//G2-SL
			Mux_WR[7] = "DIO_7";	//G2-FL

			//init mux
			for (int i = 0; i <= 7; i++)
			{
				ret = dio->DrivePin(Mux_WR[i], 1);
				CheckError(ret, __LINE__);
			}

			String ^ MuxAddr_A0 = "DIO_13";
			String ^ MuxAddr_A1 = "DIO_12";
			String ^ MuxAddr_A2 = "DIO_11";
			String ^ MuxAddr_A3 = "DIO_10";

			String ^ Mux_EN = "DIO_9";
			String ^ Mux_RS = "DIO_8";

			pin_index = mux_pin - 1;					

			ret = dio->DrivePin(Mux_EN, 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin(Mux_RS, 1);
			CheckError(ret, __LINE__);

			ret = dio->DrivePin(Mux_WR[mux_grp], 0);
			CheckError(ret, __LINE__);
			
			ret = dio->DrivePin(MuxAddr_A0, adc[pin_index][0]);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin(MuxAddr_A1, adc[pin_index][1]);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin(MuxAddr_A2, adc[pin_index][2]);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin(MuxAddr_A3, adc[pin_index][3]);
			CheckError(ret, __LINE__);			
		}

		return ret;
	}

	int TestProgram::OnOffGndMux(int mux_grp, int mux_pin, int value)  
	{
		int ret = 0;
		
		return ret;
	}

	int TestProgram::DriveMuxIO(String ^ TestParamDisplayName)
	{
		int ret = 0;
		int switch_number = 0;
		int mux_group = 0;
		
		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveMuxIO:");
		}

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (MuxSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IFBRD_CONST_TOTAL_MUX_IO; i++)
			{
				if (i >= 0 && i <= 127)
				{
					if (i >= 0 && i <= 15)
					{
						mux_group = 0;
						switch_number = i;
					}
					else if(i >= 16 && i <= 31)
					{
						mux_group = 1;
						switch_number = i - 16;
					}
					else if(i >= 32 && i <= 47)
					{
						mux_group = 3;
						switch_number = i - 32;
					}
					else if(i >= 48 && i <= 63)
					{
						mux_group = 2;
						switch_number = i - 48;
					}
					else if(i >= 64 && i <= 79)
					{
						mux_group = 4;
						switch_number = i - 64;
					}
					else if(i >= 80 && i <= 95)
					{
						mux_group = 5;
						switch_number = i - 80;
					}
					else if(i >= 96 && i <= 111)
					{
						mux_group = 7;
						switch_number = i - 96;
					}
					else if(i >= 112 && i <= 127)
					{
						mux_group = 6;
						switch_number = i - 112;
					}

					if (MuxSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnMux(mux_group, switch_number + 1);
						CheckError(ret, __LINE__);
					}

					if(Debug_Enable)
					{
						sb->AppendLine("DriveMuxIO Mux (GroupNo: " + mux_group.ToString() + ", SwitchNo:" + switch_number.ToString() + ") (Val=" + MuxSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
					}
				}
				else //GND and GNDS MUX
				{
					if (i >= 128 && i <= 135)
					{
						mux_group = 8;
						switch_number = i - 128;
					}
					else if(i >= 136 && i <= 143)
					{
						mux_group = 9;
						switch_number = i - 136;
					}

					if (MuxSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnOffGndMux(mux_group, switch_number, 1);
						CheckError(ret, __LINE__);
					}

					if (MuxSetting[TestParamDisplayName][i] == "0")
					{
						ret = OnOffGndMux(mux_group, switch_number, 0);
						CheckError(ret, __LINE__);
					}

					if(Debug_Enable)
					{
						sb->AppendLine("DriveMuxIO GndMux (GroupNo: " + mux_group.ToString() + ", SwitchNo:" + switch_number.ToString() + ") (Val=" + MuxSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
					}
				}
			}
		}
		
		return ret;
	}

	int TestProgram::DriveMuxIO(String ^ TestParamDisplayName, int index)
	{
		int ret = 0;
		int switch_number = 0;
		int mux_group = 0;
		
		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveMuxIO:");
		}

		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (MuxSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IFBRD_CONST_TOTAL_MUX_IO; i++)
			{
				if (i >= 0 && i <= 127)
				{
					if (i >= 0 && i <= 15)
					{
						mux_group = 0;
						switch_number = i;
					}
					else if(i >= 16 && i <= 31)
					{
						mux_group = 1;
						switch_number = i - 16;
					}
					else if(i >= 32 && i <= 47)
					{
						mux_group = 3;
						switch_number = i - 32;
					}
					else if(i >= 48 && i <= 63)
					{
						mux_group = 2;
						switch_number = i - 48;
					}
					else if(i >= 64 && i <= 79)
					{
						mux_group = 4;
						switch_number = i - 64;
					}
					else if(i >= 80 && i <= 95)
					{
						mux_group = 5;
						switch_number = i - 80;
					}
					else if(i >= 96 && i <= 111)
					{
						mux_group = 7;
						switch_number = i - 96;
					}
					else if(i >= 112 && i <= 127)
					{
						mux_group = 6;
						switch_number = i - 112;
					}

					if (MuxSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnMux(mux_group, switch_number + 1);
						CheckError(ret, __LINE__);
					}

					if(Debug_Enable)
					{
						sb->AppendLine("DriveMuxIO Mux (GroupNo: " + mux_group.ToString() + ", SwitchNo:" + switch_number.ToString() + ") (Val=" + MuxSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
					}
				}
				else //GND and GNDS MUX
				{
					if (i >= 128 && i <= 135)
					{
						mux_group = 8;
						switch_number = i - 128;
					}
					else if(i >= 136 && i <= 143)
					{
						mux_group = 9;
						switch_number = i - 136;
					}

					if (MuxSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnOffGndMux(mux_group, switch_number, 1);
						CheckError(ret, __LINE__);
					}

					if (MuxSetting[TestParamDisplayName][i] == "0")
					{
						ret = OnOffGndMux(mux_group, switch_number, 0);
						CheckError(ret, __LINE__);
					}

					if(Debug_Enable)
					{
						sb->AppendLine("DriveMuxIO GndMux (GroupNo: " + mux_group.ToString() + ", SwitchNo:" + switch_number.ToString() + ") (Val=" + MuxSetting[TestParamDisplayName][i] + ") return=" + ret.ToString());
					}
				}
			}
		}
		
		return ret;
	}

	int TestProgram::ResetMuxIO(void)
	{
		int ret = 0;
		
		if(Debug_Enable)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("// DriveMuxIO:");
		}

		String ^ Mux_RS = "DIO_8";
		
		ret = dio->DrivePin(Mux_RS, 0);
		CheckError(ret, __LINE__);
		
		return ret;
	}
	int TestProgram::InitCBitHist(void)
	{
		int ret = 0;
			
		CBitHist->Clear(); 
		
		for (int i = 0; i <= 64; i++)
		{
			CBitHist->Add(i, 0);
		}

		return ret;	
	}

	int TestProgram::Configure_GND_FET(Site ^ site)
	{
		int ret = 0;

		ret = dm->Force("GND_FETS", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("GND_FETS", DM_CONST_DVCI);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLimitRange("GND_FETS", 0.025);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("GND_FETS", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GND_FETS");
		CheckError(ret, __LINE__);

		return 0;
	}
	int TestProgram::OnOffFETGnd(int On_h_Off_l)
	{
		int ret = 0;

		if (On_h_Off_l == 1)
		{
			ret = dm->ConfigurePMUVoltageLevel("GND_FETS", -2);
			CheckError(ret, __LINE__);
		}
		else if (On_h_Off_l == 0)
		{
			ret = dm->ConfigurePMUVoltageLevel("GND_FETS", 0);
			CheckError(ret, __LINE__);
		}

		return ret;
	}

	int TestProgram::LoadTesterCalFile(Site ^ site)
	{
		int ret = 0;

		TesterCalFile = "C:\\Aemulus\\TesterInfo\\Calibration.csv";
		if (!File::Exists(TesterCalFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(TesterCalFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(TesterCalFile);
		array<double> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != TOTAL_SITES + 1)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + TOTAL_SITES + " site(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<double>(TOTAL_SITES);

				for (i=0; i<TOTAL_SITES; i++)
				{
					ArrTemp[i] = _util->StrToDouble(ArrStr[i+1]); 
				}

				calfactor->Add(ArrStr[0], ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::Measure_GNDS_Voltage(Site ^ site, double nplc, double meas_delay, double % volt)
	{
		int ret = 0;

		volt = 0;

		int data = 0;

		if (Test == TEST_QS_BLKDGN_PROBE_IF2 || Test == TEST_QS_BLKDGN_DUT_IF2)
		{
			data = 0x10;
		}
		else
		{
			switch (testSite)
			{
				// (D7 D6 D5 D4 D3 D2 D1 D0)1 (D7 D6 D5 D4 D3 D2 D1 D0)0
				case 0: // 0000 0000 0001 0000
					data = 0x10;
					break;

				case 1: // 0000 0000 0010 0000
					data = 0x20;
					break;

				case 2: // 0000 0000 0100 0000
					data = 0x40;				
					break;

				case 3: // 0000 0000 1000 0000
					data = 0x80;
					break;

				default:
					data = 0x0;
			}
		}

		int spi_status = 0;
		int spi_group = 1;
		int spi_byte_length = 1;

		array<int> ^ spi_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_data_dir = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_biterror = gcnew array<int>(spi_byte_length);
		array<double> ^ delay_s_after_byte = gcnew array<double>(spi_byte_length);

		for (int i=0; i<spi_byte_length; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		spi_data[0]		= ((0x200 << 16) & 0xffff0000) | (data & 0xffff); //write (D7->D0 for GNDS, and then D7->D0 for GND)=16 bit data, then deassert NCS
		spi_data_dir[0] = 0x0000000; 

		ret = dm->SPI_RUN("DM_1", spi_group, spi_data, spi_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
		CheckError(ret, __LINE__);
		
		if (Debug_Enable == true)
		{
			Stopwatch swatch;

			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < 0.1)
			{
				swatch.Start();

				ret = dm->SPI_STATUS("DM_1", spi_group, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}
		}

		ret = smu->ConfigureSamplingTime("GND_MUX_SENSE", nplc, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(ret, __LINE__);
		ret = _util->Wait_Sec(meas_delay);
		CheckError(ret, __LINE__);
		ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
		CheckError(ret, __LINE__);

		return ret;
	}

	int TestProgram::Configure_GNDS_Mux(Site ^ site, double nplc)
	{
		int ret = 0;

		int data = 0;

		if (Test == TEST_QS_BLKDGN_PROBE_IF2 || Test == TEST_QS_BLKDGN_DUT_IF2)
		{
			data = 0x10;
		}
		else
		{
			switch (testSite)
			{
				// (D7 D6 D5 D4 D3 D2 D1 D0)1 (D7 D6 D5 D4 D3 D2 D1 D0)0
				case 0: // 0000 0000 0001 0000
					data = 0x10;
					break;

				case 1: // 0000 0000 0010 0000
					data = 0x20;
					break;

				case 2: // 0000 0000 0100 0000
					data = 0x40;				
					break;

				case 3: // 0000 0000 1000 0000
					data = 0x80;
					break;

				default:
					data = 0x0;
			}
		}

		int spi_status = 0;
		int spi_group = 1;
		int spi_byte_length = 1;

		array<int> ^ spi_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_data_dir = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_biterror = gcnew array<int>(spi_byte_length);
		array<double> ^ delay_s_after_byte = gcnew array<double>(spi_byte_length);

		for (int i=0; i<spi_byte_length; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		spi_data[0]		= ((0x200 << 16) & 0xffff0000) | (data & 0xffff); //write (D7->D0 for GNDS, and then D7->D0 for GND)=16 bit data, then deassert NCS
		spi_data_dir[0] = 0x0000000; 

		ret = dm->SPI_RUN("DM_1", spi_group, spi_data, spi_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
		CheckError(ret, __LINE__);
		
		if (Debug_Enable == true)
		{
			Stopwatch swatch;

			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < 0.1)
			{
				swatch.Start();

				ret = dm->SPI_STATUS("DM_1", spi_group, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}
		}

		ret = smu->ConfigureSamplingTime("GND_MUX_SENSE", nplc, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::Configure_GNDS(Site ^ site)
	{
		int ret = 0;

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		vih = 3.3;	vil = 0;	voh = 1;	 vol = 1;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
       
		ret = dm->Force("GND_MUX_RST_N", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("GND_MUX_RST_N", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("GND_MUX_RST_N", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("GND_MUX_RST_N", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("GND_MUX_RST_N", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GND_MUX_RST_N");
		CheckError(ret, __LINE__);

		ret = dm->Force("GND_MUX_SCLK", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("GND_MUX_SCLK", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("GND_MUX_SCLK", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("GND_MUX_SCLK", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("GND_MUX_SCLK", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GND_MUX_SCLK");
		CheckError(ret, __LINE__);

		ret = dm->Force("GND_MUX_SYNC", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("GND_MUX_SYNC", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("GND_MUX_SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("GND_MUX_SYNC", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("GND_MUX_SYNC", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GND_MUX_SYNC");
		CheckError(ret, __LINE__);

		ret = dm->Force("GND_MUX_SDIN", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("GND_MUX_SDIN", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("GND_MUX_SDIN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("GND_MUX_SDIN", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("GND_MUX_SDIN", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GND_MUX_SDIN");
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("GND_MUX_RST_N", 1);
		CheckError(ret, __LINE__);

		int spi_group = 1;
		double spi_clk_freq = 100e3;
		//int spi_clk_divider = (int)(200e6/spi_clk_freq - 1);
		int spi_clk_divider = (int)(100e6/spi_clk_freq - 1);
		int cpol = 0;
		int cpha = 1;

		ret = dm->SPI_CHSEL("DM_1", spi_group, "GND_MUX_SCLK", "GND_MUX_SYNC", "GND_MUX_SDIN", "GND_MUX_SDIN");
		CheckError(ret, __LINE__);
		ret = dm->SPI_NCS_ACTIVE_STATE("DM_1", spi_group, DM_CONST_SPI_NCS_ACTIVE_LOW);
		CheckError(ret, __LINE__);
		ret = dm->SPI_ConfigureInputDelay("DM_1", spi_group, 0);
		CheckError(ret, __LINE__);
		ret = dm->SPI_CONFIGURE("DM_1", spi_group, spi_clk_divider, cpol, cpha);
		CheckError(ret, __LINE__);

		ret = smu->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("GND_MUX_SENSE", true, false);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::find_target(int target_range_dac, double lsb, int % target_dac, double % target_result, double Measure_Delay_s, int dac, int parameter,int DACmode)
	{
		int ret = 0;
		// create vector array on the fly for to sweep trim fuse setting
			array<int>^ vec_arr		= gcnew array<int>(37); 
			array<int>^ vec1_arr	= gcnew array<int>(37); 
			double result			= 0.0;

			int dat_bit			= 0;
			int direction		= 0;    // 0 -> stop; 1 -> up; -1 -> down
			int dac_sweep		= target_range_dac;
			double min_dev		= lsb;	
			int FOUND			= 0;				
			int mode			= 0;
			double target		= 0;
			double dev = 0.0;
			int counter = 0;
			
			double Gnds_val = 0.0;

			do
			{
				dat_bit = (dac_sweep << _glob->TrimReg[parameter,BIT]);// & 16);			
				#ifndef USE_SPI
				vec_arr = make_vector( 0, _glob->TrimReg[parameter,PG], _glob->TrimReg[parameter,REG], dat_bit); // rw, pg, reg, dat
				ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(ret, __LINE__);
				ret = RunVectorArray(_glob->VectorArrSetNo);
				CheckError(ret, __LINE__);
				#else
				ret = WriteSPI(_glob->TrimReg[parameter,PG]-1, _glob->TrimReg[parameter,REG], dat_bit); // rw, pg, reg, dat
				CheckError(ret, __LINE__);
				#endif
				// measurement
				String ^ Test_Pin  = "MTX_SMU";
				
				ret = smu->OnSmuPin(Test_Pin, false,false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				switch (parameter)
				{
					case VREF:
						target = _glob->Vref_Target;
						mode =AM_CONST_DICV;
						break;
					case IABS:
						target = _glob->Iabs_Target;						
						mode = AM_CONST_DVCI;
						break;
					case ATEMP: 
						target = _glob->Atemp_Target;	
						mode = AM_CONST_DICV;
						break;
				}

				if(mode == AM_CONST_DVCI) // 1: 
				{
					ret = smu->ReadCurrent(Test_Pin, result);
					CheckError(ret, __LINE__);
				}
				else if(mode == AM_CONST_DICV)
				{
					#ifdef USE_GNDS
					ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
					#endif

					ret = smu->ReadVoltage(Test_Pin, result);
					result = result - Gnds_val;
					CheckError(ret, __LINE__);
				}
			
				ret = smu->OffSmuPin(Test_Pin);
				CheckError(ret, __LINE__);
				
				double RawResult = result;

				ProcessReading(parameter , result);
				
				// check for direction
				dev = abs(result - target);
				if (min_dev > dev )
				{
					target_dac = dac_sweep;
					min_dev = dev;
					if (parameter == ATEMP)
					{
						target_result = RawResult - TRIM_COMP;
					}
					else
					{
						target_result = result;
					}

				}
				// check target found
				if ((min_dev < lsb) || (counter > 32))
				{
					FOUND = 1;
				}
				// check for sweep direction
				if (!FOUND)
				{
					if ((result - target) > 0 )
					{
						direction = -1 * DACmode;
					}else{
						direction = 1 * DACmode;
					}
				dac_sweep = dac_sweep + direction;
				}
			
				//timeout
				if (counter > 32)
				{
					target_result = -999;			
					FOUND = 1;
				}	
			counter++;
			} while (!FOUND);
			target_dac = dac_sweep;

		return ret;
	}

	void TestProgram::ProcessReading(int parameter, double % reading) 
	{	
		// roundoff to neareast int
		
		switch(parameter)
		{
		case VREF:
			reading = reading - TRIM_COMP - _glob->mux_offset;
			break;
		case IABS:
			reading = -reading;
			break;
		case ATEMP:
			reading = reading;
			double atemp_V  = reading - TRIM_COMP - _glob->mux_offset; // Compensate value
			double atemp_offset = 131.7/182.5;
			double atemp_step = 1/182.5;
			double atemp_raw = (atemp_V - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
			reading = atemp_raw;
			break;
		}
	}
	array<int>^ TestProgram::make_vector(int rw, int page, int reg, int dat)
	{
		int ret = 0;
		int debug = 0;
		// vector mapping	
		int SPD	= 3; // pin 2
		int SPC	= 5; // pin 4
		int SPE	= 2; // pin 1
		int t0		= 0; // t0
		
		int bit_length = 0;
		int clk = 0;
		int coun = 0;
		int dac_en =0;
		int dum = 0;

		string  str_e;
		string  str_o;

		string str_lb;
	
		page--;

		// DM vector format
		string vec[5] = 
		{"000"	, "001"	, "010"	,"011"	, "100",};
		//    0		,   1		,	L		,	H		,	X 
		array<int>^ vec0_arr = gcnew array<int>(37);
		
		if(debug)
		{
			
			_util->SampleRes("vec",1, 0, "rw: " );
			_util->SampleRes("vec",0, rw, "" );

			_util->SampleRes("vec",1, 0, "pg: " );
			_util->SampleRes("vec",0, page, "" );

			_util->SampleRes("vec",1, 0, "reg: " );
			_util->SampleRes("vec",0, reg, "" );
			
			_util->SampleRes("vec",1, 0, "data: " );
			_util->SampleRes("vec",0, dat, "" );
			_util->SampleRes("vec",0, 999, "" );
			
		}

		// convert databit 
		string dat_str = _util->dec2bin(dat, 8);
		
		int dat_bit[8];
		for (int i = 0; i < 8 ;i++)
		{
			dat_bit[7-i] = dat_str[i] - 48;
		}

		// convert regbit
		string reg_str = _util->dec2bin(reg, 5);
		
		int reg_bit[5];
		for (int i = 0; i < 5 ;i++)
		{
			reg_bit[4-i] = reg_str[i] - 48;
		}

		for (int c=-1; c < 6 ; c++)
		{
			switch(c)
			{
			case -1:
				bit_length = 1;
				dac_en = 0;
				dum = 1;
				str_lb = "--";
				break;				

			case 0: // rw
				bit_length = 1;
				dac_en = 3;
				dum = 0;
				str_lb = "rw";
				break;				
			
			case 1: // pg
				bit_length = 1;
				dac_en = 4;
				dum = 0;
				str_lb = "pg";
				break;				

			case 2 : // reg
				bit_length = 5;
				dac_en = 2;
				dum = 0;
				str_lb = "reg";
				break;				
		
			case 3: // t
				bit_length = 1;
				dac_en = 0;
				dum = 0;
				str_lb = "t";
				break;				

			case 4: // data
				bit_length = 8;
				dac_en = 1;
				str_lb = "data";
				dum = 0;
				break;	
			
			case 5:
				bit_length = 1;
				dac_en = 0;
				str_lb = "--";
				dum = 1;
				break;			

			}

			for (int j =0; j < bit_length; j++)
			{
				for (int i = 0; i < 7; i++)
				{
					if (i == SPE)				
					{
						if(!dum)
						{
							str_e =  vec[1] + str_e;
							str_o =  vec[1] + str_o;
						}else{
							str_e =  vec[0] + str_e;
							str_o =  vec[0] + str_o;
						}
					}
					else if(i == SPD)
					{
						if(dac_en == 1) // databit
						{
							str_e =   vec[dat_bit[j]] + str_e;
							str_o =   vec[dat_bit[j]] + str_o;
						}
						else if (dac_en == 2) // regbit
						{
							str_e =   vec[reg_bit[j]] + str_e;
							str_o =   vec[reg_bit[j]] + str_o;
						}
						else if (dac_en == 3) // rw
						{
							str_e =   vec[rw] + str_e ;
							str_o =   vec[rw] + str_o ;
						}else if (dac_en == 4) // pg
						{
							str_e =   vec[page] + str_e ;
							str_o =   vec[page] + str_o ;
						}else{
							str_e =   vec[0] + str_e ;
							str_o =   vec[0] + str_o ;
						}
					}
					else if(i == SPC)
					{
						if(!dum)
						{
							str_e =  vec[0] + str_e;
							str_o =  vec[1] + str_o;
						}else{
							str_e =  vec[0] + str_e;
							str_o =  vec[0] + str_o;
						}
					}
					else if(i == t0)
					{
						str_e = "0" + str_e ; //0 , 0
						str_o = "0" + str_o ;
					}
					else
					{
						str_e = vec[4] +str_e  ; // X , 4
						str_o = vec[4] +str_o  ; 
					}
				}
			
				int value_e = std::bitset<19>(str_e).to_ulong();
  				int value_o = std::bitset<19>(str_o).to_ulong();
				
				if(debug)
				{
					_util->SampleRes("vec",0, coun, "" );
					_util->SampleRes("vec",1, 0, str_e );
					_util->SampleRes("vec",1, 0, str_lb );
					_util->SampleRes("vec", 0 , value_e, "" );
					
					_util->SampleRes( "vec", 0 , 999,"");

					_util->SampleRes("vec",0, coun+1, "" );
					_util->SampleRes("vec",1, 0, str_o );
					_util->SampleRes("vec",1, 0, str_lb );
					_util->SampleRes("vec", 0 , value_o, "" );
					
					_util->SampleRes( "vec", 0 , 999,"");
				}

				vec0_arr[coun] = value_e;
				vec0_arr[coun+1] = value_o;
				
				coun = coun + 2;
				str_e = "";
				str_o ="";
			}
			
		}

		if(debug)
		{
			_util->SampleRes( "vec", 0 , 999,"");
		}

		if (0)
		{
			for (int i = 0; i < 37; i++)
			{
				_util->SampleRes( "vec0", 0 , i ,"");
				_util->SampleRes( "vec0", 0 , vec0_arr[i] ,"");
				_util->SampleRes( "vec0", 0 , 999,"");
			}
		}

		return vec0_arr ;
	}
	int TestProgram::RunVectorFile(String ^ Vector_str)
	{
		// Run vector from vector file
		int ret =0;

		Stopwatch swatch;
		int vector_engine_status = 0;
		double Vector_Timeout_s = 0.1;

		if (VectorSetNo->ContainsKey(Vector_str))
		{
			ret = dm->RunVector("DM_2", VectorSetNo[Vector_str]);
			//CheckError(ret, __LINE__);
		}

		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
		{
			swatch.Start();

			ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
			CheckError(ret, __LINE__);

			if (vector_engine_status == 0)
				break;

			swatch.Stop();
		}

		if (vector_engine_status != 0)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ " + Vector_str + " (line#" + __LINE__ + ")", ER_TIMEOUT);
		}

		return ret;
	
	}
	int TestProgram::RunVectorArray(int Vector_set_no)
	{
		// Run vector Array
		int ret = 0;

		Stopwatch swatch;
		int vector_engine_status = 0;
		double Vector_Timeout_s = 0.1;
		
		ret = dm->RunVector("DM_2", Vector_set_no);
		//CheckError(ret, __LINE__);

		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
		{
			swatch.Start();

			ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
			CheckError(ret, __LINE__);

			if (vector_engine_status == 0)
				break;

			swatch.Stop();
		}

		if (vector_engine_status != 0)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
		}

		return ret;
	
	}
	int TestProgram::CorrectDac(int % dac, int fuse_count)
	{
		// correct neg dac to pos dac// 2's comp 
		int ret = 0 ;
		double converted_dac = 0;
		
		if (dac < 0)
		{
			converted_dac = pow (2.0, fuse_count) + dac;							
			dac = (int)converted_dac;
		}

		return ret;
	}

	int TestProgram::ReadVector(String ^ Vector_str, int % data)
	{
		int ret = 0; 
		int result_adc = 0;
		int vector_engine_status = 0;
		double Vector_Timeout_s = 0.3;

		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		if (VectorSetNo->ContainsKey(Vector_str))
		{
			ret = dm->RunVector("DM_2", VectorSetNo[Vector_str]);
			//CheckError(ret, __LINE__);
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("RunVector return=" + ret.ToString());
		}
		
		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
		{
			swatch.Start();

			ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
			CheckError(ret, __LINE__);

			if (vector_engine_status == 0)
				break;

			swatch.Stop();
		}
				
		if (vector_engine_status == 0)
		{
			ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_str], 0, VectorSetNo[Vector_str], HistoryRam);
			CheckError(ret, __LINE__);
	
			ret = GetDataByteFromHistoryRam(Vector_str, HistoryRam, data, _glob->SPD_Channel_Number);
			CheckError(ret, __LINE__);

			result_adc = data ;
		}
		else
		{
			throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ " + Vector_str + " (line#" + __LINE__ + ")", ER_TIMEOUT);
			//result_adc = -999;
		}

		return ret;

	}

	int TestProgram::blow_fuse(int parameter, int fuse_bit)
		{
		int ret			= 0;			
		int dat_bit		= 0;
		int vector_enginSbeee_status = 0;
		int bitCount = 0;

		double Vector_Timeout_s = 0.1;
		Stopwatch swatch;

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); 
		String ^ Vector_File = "";

		#ifndef USE_SPI
		ret = RunVectorFile("write_set_ext_reg");
		CheckError(ret, __LINE__);
		#else
		//ret = OnOffSPI(1);
		//CheckError(ret, __LINE__);
		ret = RunSPI("write_set_ext_reg");
		CheckError(ret, __LINE__);
		#endif	
		
		int fuse_mask = 1;
		fuse_mask = fuse_mask << _glob->TrimReg[parameter, BIT];
		fuse_bit = fuse_bit << _glob->TrimReg[parameter, BIT];

		for (int i = 0; i < _glob->TrimReg[parameter, FUSE]; i++)  // blow fuse bit one by one
		{
			
			dat_bit = (fuse_bit & fuse_mask) ;
			if (dat_bit != 0)
			{
				{
					// set fuse bit to be blown
					#ifndef USE_SPI
					vec_arr = make_vector( 0, _glob->TrimReg[parameter, PG], _glob->TrimReg[parameter, REG], dat_bit); // rw, pg, reg, dat
					ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
					CheckError(ret, __LINE__);
					ret = RunVectorArray(_glob->VectorArrSetNo);
					CheckError(ret, __LINE__);
					#else
					ret = WriteSPI( _glob->TrimReg[parameter, PG]-1, _glob->TrimReg[parameter, REG], dat_bit);
					CheckError(ret, __LINE__);
					#endif
				}
			
				if(Blow_Fuse)	//blowfusecmd execution
				{		
					#ifndef USE_SPI
					ret = RunVectorFile("write_blow_fuse_cmd_on");
					CheckError(ret, __LINE__);
					_util->Wait_Sec(0.1);
					ret = RunVectorFile("write_blow_fuse_cmd_off");
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI("write_blow_fuse_cmd_on");
					CheckError(ret, __LINE__);

					//_util->Wait_Sec(0.1);
					_util->Wait_Sec(5e-3);

					ret = RunSPI("write_blow_fuse_cmd_off");
					CheckError(ret, __LINE__);
					#endif				
				}
			}
			
			fuse_mask = fuse_mask << 1;
		}
		
		// clear fuse bit after blown
		dat_bit = 0 ;
		#ifndef USE_SPI	
		vec_arr = make_vector( 0, _glob->TrimReg[parameter, PG], _glob->TrimReg[parameter, REG], dat_bit); // rw, pg, reg, dat
		ret = dm->DPINVecLoadArray("DM_2",0, 2, 0,_glob-> VectorArrSetNo, 36, vec_arr, vec_arr);
		CheckError(ret, __LINE__);
		ret = RunVectorArray(_glob->VectorArrSetNo);
		CheckError(ret, __LINE__);
		#else
		ret = WriteSPI( _glob->TrimReg[parameter, PG]-1, _glob->TrimReg[parameter, REG], dat_bit);
		CheckError(ret, __LINE__);
		#endif

		return ret;
	}

	int TestProgram::blow_fuse_WHD(int HD, int fuse_bit)
	{
		int ret			= 0;			
		int dat_bit		= 0;
		int bitCount = 0;

		double Vector_Timeout_s = 0.1;
		Stopwatch swatch;

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); 
		String ^ Vector_File = "";

		RunVectorFile("write_set_ext_reg");
		int fuse_mask = 1;
		fuse_mask = fuse_mask << _glob->TrimRegWHD[HD, BIT];
		fuse_bit = fuse_bit << _glob->TrimRegWHD[HD, BIT];

		for (int i = 0; i < _glob->TrimRegWHD[HD, FUSE]; i++)  // blow fuse bit one by one
		{
			;
			dat_bit = (fuse_bit & fuse_mask) ;
			if (dat_bit != 0)
			{
				{
					// set fuse bit to be blown
					#ifndef USE_SPI
					vec_arr = make_vector( 0, _glob->TrimRegWHD[HD, PG], _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
					ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
					CheckError(ret, __LINE__);
					ret = RunVectorArray(_glob->VectorArrSetNo);
					CheckError(ret, __LINE__);

					#else
					ret = WriteSPI( _glob->TrimRegWHD[HD, PG], _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
					CheckError(ret, __LINE__);
					#endif
				}
				if(Blow_Fuse)	//blowfusecmd execution
				{		
					#ifndef USE_SPI
					ret = RunVectorFile("write_blow_fuse_cmd_on");
					CheckError(ret, __LINE__);
					_util->Wait_Sec(0.1);
					ret = RunVectorFile("write_blow_fuse_cmd_off");
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI("write_blow_fuse_cmd_on");
					CheckError(ret, __LINE__);
					_util->Wait_Sec(0.1);
					ret = RunSPI("write_blow_fuse_cmd_off");
					CheckError(ret, __LINE__);
					#endif
				}
			}
			
			fuse_mask = fuse_mask << 1;
		}
		
		// clear fuse bit after blown
		dat_bit = 0 ;
		#ifndef USE_SPI
		vec_arr = make_vector( 0, _glob->TrimRegWHD[HD, PG], _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
		ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
		CheckError(ret, __LINE__);
		ret = RunVectorArray(_glob->VectorArrSetNo);
		CheckError(ret, __LINE__);
		#else
		ret = WriteSPI( _glob->TrimRegWHD[HD, PG], _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
		CheckError(ret, __LINE__);
		#endif

		return ret;
	}

	int TestProgram::blow_fuse_RHD(int HD, int fuse_bit)
	{
		int ret			= 0;			
		int dat_bit		= 0;
		int bitCount = 0;

		double Vector_Timeout_s = 0.1;
		Stopwatch swatch;

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); 
		String ^ Vector_File = "";

		RunVectorFile("write_set_ext_reg");
		int fuse_mask = 1;
		fuse_mask = fuse_mask << _glob->TrimRegRHD[HD, BIT];
		fuse_bit = fuse_bit << _glob->TrimRegRHD[HD, BIT];

		for (int i = 0; i < _glob->TrimRegRHD[HD, FUSE]; i++)  // blow fuse bit one by one
		{
			
			dat_bit = (fuse_bit & fuse_mask);
			if (dat_bit != 0)
			{
				{
					#ifndef USE_SPI
					// set fuse bit to be blown
					vec_arr = make_vector( 0, _glob->TrimRegRHD[HD, PG], _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
					ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
					CheckError(ret, __LINE__);
					ret = RunVectorArray(_glob->VectorArrSetNo);
					CheckError(ret, __LINE__);
					#else
					ret = WriteSPI(_glob->TrimRegRHD[HD, PG], _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
					CheckError(ret, __LINE__);
					#endif
				}
			
				if(Blow_Fuse)	//blowfusecmd execution
				{			
					#ifndef USE_SPI
					ret = RunVectorFile("write_blow_fuse_cmd_on");
					CheckError(ret, __LINE__);
					_util->Wait_Sec(0.1);
					ret = RunVectorFile("write_blow_fuse_cmd_off");
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI("write_blow_fuse_cmd_on");
					CheckError(ret, __LINE__);
					_util->Wait_Sec(0.1);
					ret = RunSPI("write_blow_fuse_cmd_off");
					CheckError(ret, __LINE__);
					#endif
				}
			}
			
			fuse_mask = fuse_mask << 1;
		}
		
		// clear fuse bit after blown
		dat_bit = 0 ;
		#ifndef USE_SPI
		vec_arr = make_vector( 0, _glob->TrimRegRHD[HD, PG], _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
		ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
		CheckError(ret, __LINE__);
		ret = RunVectorArray(_glob->VectorArrSetNo);
		CheckError(ret, __LINE__);
		#else
		ret = WriteSPI(_glob->TrimRegRHD[HD, PG], _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
		CheckError(ret, __LINE__);
		#endif

		return ret;
	}
	int TestProgram::SPI_Configure(int spiGroup, double clk_freq, String ^ clk, String ^ ncs, String ^ mosi, String ^ miso, double input_delay)
	{
		int ret = 0;

		//int spi_clk_divider = (int)(200e6/clk_freq - 1);
		int spi_clk_divider = (int)(100e6/clk_freq - 1);
		int cpol = 0;
		int cpha = 0;

		ret = dm->SPI_CHSEL("DM_2", spiGroup, clk, ncs, mosi, miso);
		CheckError(ret, __LINE__);

		ret = dm->SPI_NCS_ACTIVE_STATE("DM_2", spiGroup, DM_CONST_SPI_NCS_ACTIVE_HIGH);
		CheckError(ret, __LINE__);
	
		if (input_delay == 0)
		{
			ret = dm->SPI_ConfigureInputDelay("DM_2", spiGroup, 0);
			CheckError(ret, __LINE__);
		}
		else if (input_delay < 5e-9)
		{
			ret = dm->SPI_ConfigureInputDelay("DM_2", spiGroup, 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = dm->SPI_ConfigureInputDelay("DM_2", spiGroup, 2);
			CheckError(ret, __LINE__);
		}

		ret = dm->SPI_CONFIGURE("DM_2", spiGroup, spi_clk_divider, cpol, cpha);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::SPI(int spiGroup, array<int> ^ spi_data_array, int spi_array_length, array<double> ^ delay_s_after_byte, int bit_width, array<int> ^ spi_data_direction, int % spiStatus)
	{
		int ret = 0;

		Stopwatch swatch;
		spiStatus = 0;
		double Vector_Timeout_s = 0.1;

		ret = dm->SPI_RUN("DM_2", spiGroup, spi_data_array, spi_array_length, delay_s_after_byte, bit_width, spi_data_direction);
		CheckError(ret, __LINE__);

		if (_glob->spi_clk_freq < 8e6)
		{
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->SPI_STATUS("DM_2", spiGroup, spiStatus);
				CheckError(ret, __LINE__);

				if (spiStatus == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}
		}

		return ret;
	}
	int TestProgram::Digitizer_Configure(array<double> ^ data)
	{
		int ret = 0;
	
		//data:
		//[0] = sampInterval
		//[1] = delayTime
		//[2] = nbrSamples
		//[3] = nbrSegments
		//[4] = coupling
		//[5] = bandwidth
		//[6] = fullScale
		//[7] = offset
		//[8] = trigClass
		//[9] = sourcePattern
		//[10] = trigCoupling
		//[11] = trigSlope
		//[12] = trigLevel
		//[13] = timeOut_ms

		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval	= data[0];
		double delayTime	= data[1];
		int nbrSamples		= (int)data[2]; 
		int nbrSegments		= (int)data[3];
		double fullScale	= data[4]; //1V or 2V
		double offset		= data[5];	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		int coupling		= (int)data[6];	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth		= (int)data[7];	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		long trigClass		= (int)data[8];		//0 edge trigger 
		long sourcePattern	= (int)data[9];//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2
		int trigCoupling	= (int)data[10];
		int trigSlope		= (int)data[11];
		double trigLevel	= data[12];
		int timeOut_ms		= (int)data[13];
		int Decimation_Factor = (int)data[14];

		//ret = digitizer->Reset("DIGITIZER");
		//CheckError(ret, __LINE__);

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);

		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
		}

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::Digitizer_CaptureVpp(array<double> ^ data, double % vpp)
	{
		int ret = 0;

		vpp = 0;

		double sampInterval	= data[0];
		int nbrSamples		= (int)data[2];
		int timeOut_ms		= (int)data[13];
		int Decimation_Factor = (int)data[14];

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		ret = digitizer->StartAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		ret = digitizer->ForceTrigger("DIGITIZER");
		if (ret == -1074116410) //ERROR: Instrument already stopped
			ret = 0;
		CheckError(ret, __LINE__);

		ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
		if (ret == -1074116410) //ERROR: Instrument already stopped
			ret = 0;
		CheckError(ret, __LINE__);

		ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
		CheckError(ret, __LINE__);

		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
			CheckError(ret, __LINE__);
		}

		if (Debug_Enable == true)
		{
			ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
			for (int i = 0; i < nbrSamples; i++) 
			{
				outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
			}
			outFile.close();
		}

		if (Test == TEST_IF4600_PKG)
		{
			for (int i=0; i<dataArrayP->Length; i++)
			{
				dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
			}
		}

		vpp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

		vpp = vpp * diff2se_digitizer_factor;

		return ret;
	}
	int TestProgram::DigitizerFFT_Configure(array<double> ^ data)
	{
		int ret = 0;
	
		//data:
		//[0] = sampInterval
		//[1] = delayTime
		//[2] = nbrSamples
		//[3] = nbrSegments
		//[4] = coupling
		//[5] = bandwidth
		//[6] = fullScale
		//[7] = offset
		//[8] = trigClass
		//[9] = sourcePattern
		//[10] = trigCoupling
		//[11] = trigSlope
		//[12] = trigLevel
		//[13] = timeOut_ms

		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval	= data[0];
		double delayTime	= data[1];
		int nbrSamples		= (int)data[2]; 
		int nbrSegments		= (int)data[3];
		double fullScale	= data[4]; //1V or 2V
		double offset		= data[5];	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		int coupling		= (int)data[6];	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth		= (int)data[7];	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		long trigClass		= (int)data[8];		//0 edge trigger 
		long sourcePattern	= (int)data[9];//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2
		int trigCoupling	= (int)data[10];
		int trigSlope		= (int)data[11];
		double trigLevel	= data[12];
		int timeOut_ms		= (int)data[13];
		int Decimation_Factor = (int)data[14];

		//ret = digitizer->Reset("DIGITIZER");
		//CheckError(ret, __LINE__);

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);

		ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
		CheckError(ret, __LINE__);

		ret = digitizer->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
		//if (ret) 
		//{
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
		//}

		return ret;
	}
	int TestProgram::DigitizerFFT_CaptureVpp(array<double> ^ data, double diff2se_digitizer_factor, double % vpp)
	{
		int ret = 0;

		vpp = 0;

		double sampInterval	= data[0];
		int nbrSamples		= (int)data[2];
		int timeOut_ms		= (int)data[13];
		//double fullScale	= data[6];
		double fullScale	= data[4];
		int Decimation_Factor = (int)data[14];

		double RawSamplingRate = 1000000000; //1 / sampInterval;

		int RDY = 0;

		int FFTLength = 0xA; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details

		if (nbrSamples == 128) {FFTLength = 0x7;}
		else if (nbrSamples == 256) {FFTLength = 0x8;}
		else if (nbrSamples == 512) {FFTLength = 0x9;}
		else if (nbrSamples == 1024) {FFTLength = 0xA;}
		else if (nbrSamples == 2048) {FFTLength = 0xB;}
		else if (nbrSamples == 4096) {FFTLength = 0xC;}
		else if (nbrSamples == 8192) {FFTLength = 0xD;}
		else if (nbrSamples == 16384) {FFTLength = 0xE;}
		else
			return ER_INVALID_SETTING;

		int FFTnbrSamples = 0;
		if(FFTLength == 0x7) { FFTnbrSamples = 128; }
		if(FFTLength == 0x8) { FFTnbrSamples = 256; }
		if(FFTLength == 0x9) { FFTnbrSamples = 512; }
		if(FFTLength == 0xA) { FFTnbrSamples = 1024; }
		if(FFTLength == 0xB) { FFTnbrSamples = 2048; }
		if(FFTLength == 0xC) { FFTnbrSamples = 4096; }
		if(FFTLength == 0xD) { FFTnbrSamples = 8192; }
		if(FFTLength == 0xE) { FFTnbrSamples = 16384; }

		int Decimation = 0x0; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details
		int DecimationFactor = 1;

		if (Decimation_Factor == 1) {Decimation = 0x0;}
		else if (Decimation_Factor == 2) {Decimation = 0x1;}
		else if (Decimation_Factor == 4) {Decimation = 0x2;}
		else if (Decimation_Factor == 8) {Decimation = 0x3;}
		else if (Decimation_Factor == 16) {Decimation = 0x4;}
		else
			return ER_INVALID_SETTING;

		if( Decimation == 0x0 ) { DecimationFactor = 1; }
		if( Decimation == 0x1 ) { DecimationFactor = 2; }
		if( Decimation == 0x2 ) { DecimationFactor = 4; }
		if( Decimation == 0x3 ) { DecimationFactor = 8; }
		if( Decimation == 0x4 ) { DecimationFactor = 16; }

		double FFTSamplingRate = RawSamplingRate / double(DecimationFactor);
		double FFTBinValue = FFTSamplingRate / FFTnbrSamples;
		double NyquistFreq = FFTSamplingRate / 2.0;

		int Accumulation = 0x0; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		//int Accumulation = 0x5; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		int AccumulationNbr = Accumulation+1;

		int FFTStart     = 0x1; // To start FFT
		int FFTStop      = 0x2; // To Stop FFT
		int FFTStopped   = 0x0; // To check FFT stopped

		int FFTConfigure = FFTLength * 256 + Accumulation * 16 + Decimation; // "shift bits to the corresponding position
		int ReadConfig = 0x0; // to read config register
		int MaxPeakPos = 0x0; // to handle read maxpos result 

		double PeakPosA = 0;

		ret = digitizer->WriteLogicDeviceIO("DIGITIZER", 320, FFTStop, 0); //init start/stop
		CheckError(ret, __LINE__);

		ret = digitizer->WriteLogicDeviceIO("DIGITIZER", 321, FFTConfigure, 0); //configure
		CheckError(ret, __LINE__);

		//ret = digitizer->ReadLogicDeviceIO("DIGITIZER", 321, ReadConfig); //configure
		//CheckError(ret, __LINE__);

		int Write0 = 0;
		ret = digitizer->WriteLogicDeviceIO("DIGITIZER", 320, Write0, 0); //reset start bit
		CheckError(ret, __LINE__);

		ret = digitizer->WriteLogicDeviceIO("DIGITIZER", 320, FFTStart, 0); //start
		CheckError(ret, __LINE__);

		Stopwatch swatch;
		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		double TimeOut_s = 0.1;

		while (swatch.Elapsed.TotalSeconds < TimeOut_s)
		{
			swatch.Start();

			ret = digitizer->ReadLogicDeviceIO("DIGITIZER", 322, MaxPeakPos); //check end of measure & read max peak position
			CheckError(ret, __LINE__);
			RDY = MaxPeakPos & 0x80000000;

			if (RDY == 0x80000000)
				break;

			swatch.Stop();
		}

		if (RDY == 0x80000000)
		{
			#ifndef DIGITIZER_795
			PeakPosA = (double(double(MaxPeakPos & 0x00FFFFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			#else
			PeakPosA = (double(double(MaxPeakPos & 0x0000FFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			#endif
		
			int BiggestNbrSample = FFTnbrSamples;
			int rdStartAddr = 0x0;

			if (Debug_Enable == true)
			{
				ret = digitizer->WriteLogicDeviceIO("DIGITIZER", 324, rdStartAddr, 0);
				CheckError(ret, __LINE__);

				array<int> ^ rddata = gcnew array<int>(BiggestNbrSample);
				for(int i = 0; i < BiggestNbrSample; i++)
				{
					ret = digitizer->ReadLogicDeviceIO("DIGITIZER", 323, rddata[i]);
					CheckError(ret, __LINE__);
					
					//ofstream outFile("C:\\Aemulus\\Debug\\rawdata_fast.txt");
					//for (int i = 0; i < nbrSamples; i++) 
					//{
					//	outFile << rddata[i] << endl;
					//}
					//outFile.close();
				}
			}

			rdStartAddr = (int)(PeakPosA / FFTBinValue);
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", 324, rdStartAddr, 0);
			CheckError(ret, __LINE__);

			int readdata = 0;
			ret = digitizer->ReadLogicDeviceIO("DIGITIZER", 323, readdata);
			CheckError(ret, __LINE__);

			double FS = 0;
			if (BiggestNbrSample == 1024 || BiggestNbrSample == 4096 || BiggestNbrSample == 16384)
				FS = 16383;
			else
				FS = 32767;

			vpp = (double)readdata * (1/FS) * fullScale / AccumulationNbr;

			vpp = vpp * diff2se_digitizer_factor;
		}
		else
		{
			vpp = 999;
		}

		return ret;
	}
	int TestProgram::DigitizerFFT_CaptureVpp(int ch, array<double> ^ data, double diff2se_digitizer_factor, double % vpp)
	{
		int ret = 0;

		vpp = 0;

		double sampInterval	= data[0];
		int nbrSamples		= (int)data[2];
		int timeOut_ms		= (int)data[13];
		//double fullScale	= data[6];
		double fullScale	= data[4];
		int Decimation_Factor = (int)data[14];

		double RawSamplingRate = 1000000000; //1 / sampInterval;

		int RDY = 0;

		int FFTLength = 0xA; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details

		if (nbrSamples == 128) {FFTLength = 0x7;}
		else if (nbrSamples == 256) {FFTLength = 0x8;}
		else if (nbrSamples == 512) {FFTLength = 0x9;}
		else if (nbrSamples == 1024) {FFTLength = 0xA;}
		else if (nbrSamples == 2048) {FFTLength = 0xB;}
		else if (nbrSamples == 4096) {FFTLength = 0xC;}
		else if (nbrSamples == 8192) {FFTLength = 0xD;}
		else if (nbrSamples == 16384) {FFTLength = 0xE;}
		else
			return ER_INVALID_SETTING;

		int FFTnbrSamples = 0;
		if(FFTLength == 0x7) { FFTnbrSamples = 128; }
		if(FFTLength == 0x8) { FFTnbrSamples = 256; }
		if(FFTLength == 0x9) { FFTnbrSamples = 512; }
		if(FFTLength == 0xA) { FFTnbrSamples = 1024; }
		if(FFTLength == 0xB) { FFTnbrSamples = 2048; }
		if(FFTLength == 0xC) { FFTnbrSamples = 4096; }
		if(FFTLength == 0xD) { FFTnbrSamples = 8192; }
		if(FFTLength == 0xE) { FFTnbrSamples = 16384; }

		int Decimation = 0x0; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details
		int DecimationFactor = 1;

		if (Decimation_Factor == 1) {Decimation = 0x0;}
		else if (Decimation_Factor == 2) {Decimation = 0x1;}
		else if (Decimation_Factor == 4) {Decimation = 0x2;}
		else if (Decimation_Factor == 8) {Decimation = 0x3;}
		else if (Decimation_Factor == 16) {Decimation = 0x4;}
		else if (Decimation_Factor == 32) {Decimation = 0x5;}
		else if (Decimation_Factor == 64) {Decimation = 0x6;}
		else
			return ER_INVALID_SETTING;

		if( Decimation == 0x0 ) { DecimationFactor = 1; }
		if( Decimation == 0x1 ) { DecimationFactor = 2; }
		if( Decimation == 0x2 ) { DecimationFactor = 4; }
		if( Decimation == 0x3 ) { DecimationFactor = 8; }
		if( Decimation == 0x4 ) { DecimationFactor = 16; }
		if( Decimation == 0x5 ) { DecimationFactor = 32; }
		if( Decimation == 0x6 ) { DecimationFactor = 64; }

		double FFTSamplingRate = RawSamplingRate / double(DecimationFactor);
		double FFTBinValue = FFTSamplingRate / FFTnbrSamples;
		double NyquistFreq = FFTSamplingRate / 2.0;

		int Accumulation = 0x0; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		//int Accumulation = 0x5; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		int AccumulationNbr = Accumulation+1;

		int FFTStart     = 0x1; // To start FFT
		int FFTStop      = 0x2; // To Stop FFT
		int FFTStopped   = 0x0; // To check FFT stopped

		int FFTConfigure = FFTLength * 256 + Accumulation * 16 + Decimation; // "shift bits to the corresponding position
		int ReadConfig = 0x0; // to read config register
		int MaxPeakPos = 0x0; // to handle read maxpos result 

		double PeakPosA = 0;
		
		if (ch == 1)
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
		else
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
		CheckError(ret, __LINE__);

		if (ch == 1)
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONFIGURATION1, FFTConfigure, 0); //configure
		else
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONFIGURATION1, FFTConfigure, 0); //configure
		CheckError(ret, __LINE__);

		//if (ch == 1)
		//	ret = digitizer->ReadLogicDeviceIO("DIGITIZER", CH1_CONFIGURATION1, ReadConfig); //configure
		//else
		//	ret = digitizer->ReadLogicDeviceIO("DIGITIZER", CH2_CONFIGURATION1, ReadConfig); //configure
		//CheckError(ret, __LINE__);

		int Write0 = 0;
		if (ch == 1)
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, Write0, 0); //reset start bit
		else
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, Write0, 0); //reset start bit
		CheckError(ret, __LINE__);

		if (ch == 1)
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStart, 0); //start
		else
			ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStart, 0); //start
		CheckError(ret, __LINE__);

		Stopwatch swatch;
		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		double TimeOut_s = 0.1;

		while (swatch.Elapsed.TotalSeconds < TimeOut_s)
		{
			swatch.Start();

			if (ch == 1)
				ret = digitizer->ReadLogicDeviceIO("DIGITIZER", REG_CH1_STATUS, MaxPeakPos); //check end of measure & read max peak position
			else
				ret = digitizer->ReadLogicDeviceIO("DIGITIZER", REG_CH2_STATUS, MaxPeakPos); //check end of measure & read max peak position
			CheckError(ret, __LINE__);
			RDY = MaxPeakPos & 0x80000000;

			if (RDY == 0x80000000)
				break;

			swatch.Stop();
		}

		if (RDY == 0x80000000)
		{
			#ifndef DIGITIZER_795
			PeakPosA = (double(double(MaxPeakPos & 0x00FFFFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			#else
			PeakPosA = (double(double(MaxPeakPos & 0x0000FFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			#endif
		
			int BiggestNbrSample = FFTnbrSamples;
			int rdStartAddr = 0x0;

			if (Debug_Enable == true)
			{
				if (ch == 1)
					ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr, 0);
				else
					ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr, 0);
				CheckError(ret, __LINE__);

				array<int> ^ rddata = gcnew array<int>(BiggestNbrSample);
				for(int i = 0; i < BiggestNbrSample; i++)
				{
					if (ch == 1)
						ret = digitizer->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, rddata[i]);
					else
						ret = digitizer->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, rddata[i]);
					CheckError(ret, __LINE__);
					
					//ofstream outFile("C:\\Aemulus\\Debug\\rawdata_fast.txt");
					//for (int i = 0; i < nbrSamples; i++) 
					//{
					//	outFile << rddata[i] << endl;
					//}
					//outFile.close();
				}
			}

			rdStartAddr = (int)(PeakPosA / FFTBinValue);
			if (ch == 1)
				ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr, 0);
			else
				ret = digitizer->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr, 0);
			CheckError(ret, __LINE__);

			int readdata = 0;
			if (ch == 1)
				ret = digitizer->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, readdata);
			else
				ret = digitizer->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, readdata);
			CheckError(ret, __LINE__);

			double FS = 0;
			if (BiggestNbrSample == 1024 || BiggestNbrSample == 4096 || BiggestNbrSample == 16384)
				FS = 16383;
			else
				FS = 32767;

			vpp = (double)readdata * (1/FS) * fullScale / AccumulationNbr;

			vpp = vpp * diff2se_digitizer_factor;
		}
		else
		{
			vpp = 999;
		}

		return ret;
	}
	int TestProgram::SWG_Configure()
	{
		int ret = 0;

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureFGSineWaveform("ACM_CH", 1e-3, -1e-3, 0, 0);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::ReadFaultStatusBits()
	{	
		int ret = 0;

		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		int data = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//Pg1 Reg30 WIPO
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x9E00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg5
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xA800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg7
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xB800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg6
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x9800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg8
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x8400; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg20
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x8A00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg23
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xBA00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg29
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xAE00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg39
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xF800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg62
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xDE00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::readlockbit(void)
	{	
		int ret		= 0;
		int data	= 0;

		//read lock bit

		#ifndef USE_SPI
		ret = RunVectorFile("write_trimlock_init");
		CheckError(ret, __LINE__);
		ret = ReadVector("read_p2_reg48", data);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_trimlock_init");
		CheckError(ret, __LINE__);
		ret = ReadSPI("read_p2_reg48", data);
		CheckError(ret, __LINE__);
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		_glob->trimlock = (data >> 7) & 0x1;

		if (_glob->trimlock == 1)
		{
			_glob->FuseBlown = 1;
		}
	
		return ret;
	}

	int TestProgram::blow_testlockfuse()
	{
		int ret = 0;

		#ifndef USE_SPI
		ret = RunVectorFile("write_set_ext_reg");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_set_ext_reg");
		CheckError(ret, __LINE__);
		#endif

		if(Blow_Fuse)	//blowfusecmd execution
		{		

			#ifndef USE_SPI
			ret = RunVectorFile("write_blow_testfuse");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(0.1);
			ret = RunVectorFile("write_blow_fuse_cmd_off");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_blow_testfuse");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(0.1);
			ret = RunSPI("write_blow_fuse_cmd_off");
			CheckError(ret, __LINE__);
			#endif

		}

		if(Blow_Fuse)	//blowfusecmd execution
		{		

			#ifndef USE_SPI
			ret = RunVectorFile("write_blow_lockfuse");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(0.1);
			ret = RunVectorFile("write_blow_fuse_cmd_off");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_blow_lockfuse");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(0.1);
			ret = RunSPI("write_blow_fuse_cmd_off");
			CheckError(ret, __LINE__);
			#endif

		}
		return ret;
	}

	void TestProgram::CheckError(int return_code, int line_number)
	{
		String ^ errorMsg = String::Empty;

		if (return_code.ToString("X")->StartsWith("AE"))
		{
			//Check whether it's AEM resources (error code starts with 0xAE)
			if (return_code.ToString("X")->StartsWith("AE0F")) //0xAE0F = ACM
			{
				errorMsg = "Sinewave generator module error! @ line#" + line_number;
			}	
			else if (return_code.ToString("X")->StartsWith("AE0C")) //0xAE0C = TM
			{
				errorMsg = "Time measurement module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE0B")) //0xAE0B = DM
			{
				errorMsg = "Digital module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE0A")) //0xAE0A = DM
			{
				errorMsg = "Digital module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE09")) //0xAE09 = General
			{
				errorMsg = "General PXI error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE08")) //0xAE08 = IOM
			{
				errorMsg = "IO module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE07")) //0xAE07 = AM
			{
				errorMsg = "Analog module error! @ line#" + line_number;
			}
			else
			{
				errorMsg = "Unknown error! @ line#" + line_number;
			}

			throw gcnew Aemulus::Hardware::AlarmException(errorMsg, return_code);
		}
		else if (return_code == 160) //ERROR_BAD_ARGUMENTS
		{
			throw gcnew Aemulus::Hardware::AlarmException("ERROR_BAD_ARGUMENTS @ line#" + line_number, return_code);
		}
		else if (return_code == 8) //ERROR_NOT_ENOUGH_MEMORY
		{
			throw gcnew Aemulus::Hardware::AlarmException("ERROR_NOT_ENOUGH_MEMORY @ line#" + line_number, return_code);
		}
		else if (return_code == 110) //ERROR_OPEN_FAILED
		{
			throw gcnew Aemulus::Hardware::AlarmException("ERROR_OPEN_FAILED @ line#" + line_number, return_code);
		}
		else if (return_code.ToString("X")->StartsWith("BFFA") || return_code.ToString("X")->StartsWith("BFFC")) //Digitizer
		{
			StringBuilder ^ sa = gcnew StringBuilder();

			int ret = digitizer->GetErrorMessage("DIGITIZER", return_code, sa);

			throw gcnew Aemulus::Hardware::AlarmException(sa->ToString() + " @ line#" + line_number, return_code);
		}
		else if (return_code > 0) //ignore warning
		{
			return_code = 0;
		}
	}
	int TestProgram::InitPowerSupplies()
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		int Bandwidth = 0;
		double Clamp_Vcc_Current_A = 0.099;

		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		
		_util->Wait_Sec(0.001); 

		return ret;
	}
	int TestProgram::ReadReg(int page, int reg, int % data)
	{
		int ret = 0;
	
		int index			= 0;
		int readback		= 0;
		int datain			= 0;
		int spi_group		= 0;
		int addr			= 0;
		int	Sweep_Reg_Addr	= 0;
		double spi_clk_freq = 2e6;
		int spi_status		= 0;
		
		int spi_wr_byte_length = 1;
		int spi_rd_byte_length = 0;
		
		array<int> ^ spi_data = gcnew array<int>(1);
		array<int> ^ spi_data_dir = gcnew array<int>(1);
		array<int> ^ spi_rd_data = gcnew array<int>(1);
		array<int> ^ spi_rd_biterror = gcnew array<int>(1);
		array<double> ^ delay_s_after_byte = gcnew array<double>(1);

		for (int i=0; i<1; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0.000;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}
		
		ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
		CheckError(ret, __LINE__);

		int	i = 0;
	
		datain			= 0;
		addr			= _util->SwapBitSequence(reg, 5);
		Sweep_Reg_Addr	= ((page << 6) | (addr << 1) );

		spi_data_dir[i] = 0x00000ff; 
		spi_data[i]	= 0x3008000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

		spi_status = 0;
	
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);
	
		ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
		CheckError(ret, __LINE__);

		for (int m=0; m<spi_rd_byte_length; m++)
		{
			if (spi_rd_biterror[m] == 0)
			{
				data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
				readback = (data & 0xff);
			}
			else
			{
				readback = -999;
			}
		}
		
			
		data = readback;
				
		return ret;
	}
	int TestProgram::ReadAllReg(string filename)
	{   
		// Customization:-
		int mode	 = 1;	// 0: vector		1: SPI
		int datatype = 2;	// 1: hexadecimal,	2: binary string MSB->LSB,	3: decimal
		string filepath = "C:/Aemulus/Debug/" + filename + ".txt";
		//
		int ret		= 0;
		int setno	= 0;
		int data	= 0;
		int page	= 1;
		int reg		= 0;
		int reg_count= 64;
		int reg_c	= 0;
		
		String ^ vec_str = "" ;
		char hexString[8];
		string binString;
		
		ofstream myfile;
		myfile.open(filepath.c_str(), ofstream::out);

		string dataString;
		
		myfile << "Page\tReg\tdata\n" ; 
		
		for (int c = 0; c < 2; c++)
		{
			// ExtSP reg

			if (c == 1) // extSP reg
			{
				if(mode == 0)
				{
					ret = RunVectorFile("write_set_ext_reg");
					CheckError(ret, __LINE__);
				}
				else if(mode == 1)
				{
					ret = WriteSPI(1, 63, 1);
					CheckError(ret, __LINE__);
				}
			}

			for (int i = 0; i < reg_count; i++)
			{	
				if (i > 31)
				{
					page = 2;
				}
				else
				{
					page = 1;
				}
				
				reg = i;

				if (mode == 0)	// vector mode
				{
					vec_str = "read_p" + page + "_reg" + reg  ;
					ret = ReadVector(vec_str, data);
					CheckError(ret, __LINE__);
				}
				else if (mode == 1)	// SPI mode
				{
					ret = OnOffSPI(1); 
					CheckError(ret, __LINE__);
					ret = ReadReg(page-1, reg, data);
					CheckError(ret, __LINE__);
				}

				reg_c = reg;
				if (reg_c > 31)
				{
					reg_c = reg_c - 32;	
				}
			
				// Print result
				if(datatype == 1)
				{ //hexadecimal
					_itoa(data, hexString, 16);
					myfile << page << "\t" << reg_c << "\t0x" << hexString << "\n" ; 
				}
				else if(datatype == 2)
				{ // binary string
					binString = _util->dec2bin(data, 8);
					myfile << page << "\t" << reg_c << "\t" << binString << "\n" ; 
				}
				else if(datatype == 3)
				{ // decimal
					myfile << page << "\t" << reg_c << "\t" << data << "\n" ; 
				}
				
			}
			myfile << "\n\nEXTSP\n";
		}

		if (mode == 1)  //SPI
		{
			ret = OnOffSPI(0);
			CheckError(ret, __LINE__);
		}

		myfile.close();
		
		return ret;
	
	}
	void TestProgram::CheckTestItemByPassed(Site ^ site)
	{
		int TICount = 0;
		for each(AFlowItem^ fi in site->FlowItems)
		{
			TestItem^ ti = dynamic_cast<TestItem^>(fi);
			if(ti != nullptr) {
				// This is Test Item
				if(ti->Bypass)
				{
					TIByPassed = true;
					break;// If bypassed
				}
				TICount++;
			}
		}

	}

	void TestProgram::InitDieID(Site ^ site)
	{

		_glob->Die_Size_X = (wafer_diameter / high_x);
		_glob->Die_Size_Y = (wafer_diameter / high_y);
		if (((int)high_x % 2) != 1) 
			high_x++;
		if (((int)high_y % 2) != 1) 
			high_y++;

		_glob->Center_X = (int)(high_x / 2);
		_glob->Center_Y = (int)(high_y / 2);


	}

	void TestProgram::UpdateXY(Site ^ site)
	{
		Result::CustomResultCollection^ fields = site->ResultsByOffset[site->UUTOffsetResolver->UUTOffsets[0]]->CurrentResult->CustomFieldResults;
		
        // If the project has wafer testing enabled in Recipe Editor > Sublot, then there will be X and Y in CustomFieldResults collection.
        //    But the project could be otherwise, so we use ContainsKey() to check first to avoid exception.
        if(fields->ContainsKey("X"))
			_glob->Xcoord = (short)fields["X"]->Value;
    
		if(fields->ContainsKey("Y"))
            _glob->Ycoord = (short)fields["Y"]->Value;
	}

	int TestProgram::CalibrateDiffAmp2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		_glob->DA_OffsetError = gcnew array<double>(TOTAL_MUX_GROUP_PER_SITE);
		_glob->DA_GainError = gcnew array<double>(TOTAL_MUX_GROUP_PER_SITE);

		for (int i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			_glob->DA_OffsetError[i] = 0;
			_glob->DA_GainError[i] = 0;
		}

		double nplc = 1;
		int step = 1; //0.1 * 10; 
		int start = 0;
		int p_end = 19; //1.9 * 10; //to avoid data type decimation error. e.g. 1.9 as 1.899999
		int n_end = 6; //0.6 * 10;

		double res = 0;
		int i = 0;
		int j = 0;

		//Cal strategy
		// Set n_in=0, vary p_in from start to p_end
		// Set p_in=0, vary n_in from start to n_end
		// Construct best fit line to get y=mx+c
		// Short DA input, measure output, and get c1
		// Final equation = y=mx+c+c1

		int size = (int)((p_end - start) / step) + 1 + (int)((n_end - start) / step) + 1;

		array<double, 2>^ y = gcnew array<double, 2>(2, size); 
		array<double, 2>^ x = gcnew array<double, 2>(2, size); 
		array<double>^ x_tmp = gcnew array<double>(size);
		array<double>^ y_tmp = gcnew array<double>(size);
		double m = 0;
		double c1 = 0;
		double c2 = 0;

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			for (j=0; j<size; j++)
			{		
				x[i, j] = 0;
				y[i, j] = 0;
			}	
		}

		/////////////////////
		//Resource Configuration
		/////////////////////
		//Configure Source

		String ^ p_in = "MTX_SMU";

		ret = smu->ConfigureSamplingTime(p_in, nplc, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent(p_in, 0.1);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage(p_in, 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(p_in, true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(10e-3);

		String ^ n_in = "MTX_SMU_2";

		ret = smu->ConfigureSamplingTime(n_in, nplc, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent(n_in, 0.1);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage(n_in, 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(n_in, true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(10e-3);

		//Configure Measure

		ret = dm->Force("GRP1_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("GRP1_DIFF_SENSE", DM_CONST_DICV);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLimit("GRP1_DIFF_SENSE", 6, -2);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel("GRP1_DIFF_SENSE", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("GRP1_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GRP1_DIFF_SENSE");
		CheckError(ret, __LINE__);
		_util->Wait_Sec(10e-3);

		ret = dm->Force("GRP2_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("GRP2_DIFF_SENSE", DM_CONST_DICV);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLimit("GRP2_DIFF_SENSE", 6, -2);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel("GRP2_DIFF_SENSE", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("GRP2_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GRP2_DIFF_SENSE");
		CheckError(ret, __LINE__);
		_util->Wait_Sec(10e-3);

		/////////////////////
		//Group 1
		/////////////////////
					
		ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT0, 1); //Connect "MTX_SMU" to p
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT1, 1); //Connect "MTX_SMU_2" to n
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_RLY_GRP1_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu->DriveVoltage(n_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(p_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[0, i] = (double)k/10;
			y[0, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu->DriveVoltage(p_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(n_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[0, i] = (-1 * (double)k/10);
			y[0, i] = res;

			i++;
		}

		//Get best fit line from x and y

		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[0, i];
			y_tmp[i] = y[0, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		//_glob->DA_OffsetError[0] = c1;
		_glob->DA_GainError[0] = m;

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		/////////////////////
		//Group 2
		/////////////////////
			
		ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT3, 1); //Connect "MTX_SMU" to p
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT4, 1); //Connect "MTX_SMU_2" to n
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_RLY_GRP2_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu->DriveVoltage(n_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(p_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[1, i] = (double)k/10;
			y[1, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu->DriveVoltage(p_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(n_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[1, i] = (-1 * (double)k/10);
			y[1, i] = res;

			i++;
		}

		//Get best fit line from x and y
		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[1, i];
			y_tmp[i] = y[1, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		//_glob->DA_OffsetError[1] = c1;
		_glob->DA_GainError[1] = m;

		//End

		ret = smu->DriveVoltage(p_in, 0);
		CheckError(ret, __LINE__);

		ret = smu->DriveVoltage(n_in, 0);
		CheckError(ret, __LINE__);

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		/////////////////////
		//Check offset error by shorting DA inputs to GND directly
		/////////////////////

		ret = smu->OffSmuPin(p_in);
		CheckError(ret, __LINE__);

		ret = smu->ClampVoltage(p_in, 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent(p_in, 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(p_in, true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(10e-3);

		//Group 1

		ret = OnOffCbit(CBIT_RLY_GRP1_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
		CheckError(ret, __LINE__);

		_util->Wait_Sec(10e-3);

		ret = smu->ReadVoltage(p_in, res);

		res = res / _glob->DA_GainError[0];

		//ret = smu->ConfigureSamplingTime(p_in, 0.1, AM_CONST_PLC);
		//CheckError(ret, __LINE__);
		//array<double>^ tmp = gcnew array<double>(1000);
		//for (int z=0; z<1000; z++)
		//{
		//	ret = smu->ReadVoltage(p_in, res);
		//	tmp[z] = res;
		//}

		_glob->DA_OffsetError[0] = res;

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		//Group 2

		ret = OnOffCbit(CBIT_RLY_GRP2_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
		CheckError(ret, __LINE__);

		_util->Wait_Sec(10e-3);

		ret = smu->ReadVoltage(p_in, res);

		res = res / _glob->DA_GainError[1];

		_glob->DA_OffsetError[1] = res;

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		/////////////////////
		//Print results
		/////////////////////
	
		DateTime _now = DateTime::Now;
		//String ^ DA_calFile = String::Format("{0}_{1:00}{2:00}{3:00}{4:00}{5:00}{6:00}.txt",
		//	"C:\\Aemulus\\TesterInfo\\DiffAmpCal" + testSite.ToString(), _now.Year, _now.Month, _now.Day, 
		//	_now.Hour, _now.Minute, _now.Second);

		String ^ DA_calFile = "C:\\Aemulus\\TesterInfo\\DiffAmpCal" + testSite + ".txt";

		StringBuilder ^ sbl = gcnew StringBuilder();
		StreamWriter ^ swl = gcnew StreamWriter(DA_calFile);

		String ^ temp = String::Format("{0} : {1:00}{2:00}{3:00}{4:00}{5:00}{6:00}", 
			"Last Cal", _now.Year, _now.Month, _now.Day, _now.Hour, _now.Minute, _now.Second);
		sbl->AppendLine(temp);

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			sbl->AppendLine("------------------");
			sbl->AppendLine("Group " + (i+1).ToString());
			sbl->AppendLine("------------------");

			for (j=0; j<size; j++)
			{
				sbl->AppendLine("x[" + (j).ToString() + "] = " + x[i, j] + "; y[" + (j).ToString() + "] = " + y[i, j]);
			}
				
			sbl->AppendLine("DA_GainError[" + (i).ToString() + "] = " + _glob->DA_GainError[i]);
			sbl->AppendLine("DA_OffsetError[" + (i).ToString() + "] = " + _glob->DA_OffsetError[i]);

			sbl->AppendLine("");
		}

		//Check for nominal values
		int err = 0;
		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			String ^ errorMsg = String::Empty;

			double error = Math::Abs(_glob->DA_GainError[i] - DA_IDEAL_GAIN) / DA_IDEAL_GAIN;

			if (error * 100 > DA_GAIN_ERROR_TOL_PERCENT)
			{
				sbl->AppendLine("");

				errorMsg = "Gain error for Site " + testSite + ", Mux Group " + (i+1).ToString() + " is larger than " + 
					DA_GAIN_ERROR_TOL_PERCENT + "% from ideal gain (" + DA_IDEAL_GAIN + ")";

				sbl->AppendLine(errorMsg);

				err++;
			}

			if (_glob->DA_OffsetError[i] > DA_OFFSET_ERR_TOL)
			{
				errorMsg = "Gain offset for Site " + testSite + ", Mux Group " + (i+1).ToString() + " is larger than " + 
					DA_OFFSET_ERR_TOL + ")";

				sbl->AppendLine(errorMsg);

				err++;
			}
		}

		swl->Write(sbl);	
		sbl = nullptr;
		swl->Close();
		swl = nullptr;

		if (err)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Differential Amp self-cal failed! Check DiffAmpCal file for details!", ER_GENERAL);
		}

		return ret;
	}
	int TestProgram::CalibrateDiffAmp(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		_glob->DA_OffsetError = gcnew array<double>(TOTAL_MUX_GROUP_PER_SITE);
		_glob->DA_GainError = gcnew array<double>(TOTAL_MUX_GROUP_PER_SITE);

		for (int i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			_glob->DA_OffsetError[i] = 0;
			_glob->DA_GainError[i] = 0;
		}

		int nplc = 1;
		int step = 1; //0.1; 
		int start = 0;
		int p_end = 19; //1.9; //to avoid data type decimation error. e.g. 1.9 as 1.899999
		int n_end = 6; //0.6;

		double res = 0;
		int i = 0;
		int j = 0;

		//Cal strategy
		// Set n_in=0, vary p_in from start to p_end
		// Set p_in=0, vary n_in from start to n_end
		// Construct best fit line to get y=mx+c
		// Short DA input, measure output, and get c1
		// Final equation = y=mx+c+c1

		int size = (int)((p_end - start) / step) + 1 + (int)((n_end - start) / step) + 1;

		array<double, 2>^ y = gcnew array<double, 2>(2, size); 
		array<double, 2>^ x = gcnew array<double, 2>(2, size); 
		array<double>^ x_tmp = gcnew array<double>(size);
		array<double>^ y_tmp = gcnew array<double>(size);
		double m = 0;
		double c1 = 0;
		double c2 = 0;

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			for (j=0; j<size; j++)
			{		
				x[i, j] = 0;
				y[i, j] = 0;
			}	
		}

		/////////////////////
		//Resource Configuration
		/////////////////////
		//Configure Source

		String ^ p_in = "MTX_SMU";

		ret = smu->ConfigureSamplingTime(p_in, nplc, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent(p_in, 0.1);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage(p_in, 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(p_in, true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(1e-3);

		String ^ n_in = "MTX_SMU_2";

		ret = smu->ConfigureSamplingTime(n_in, nplc, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent(n_in, 0.1);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage(n_in, 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(n_in, true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(1e-3);

		//Configure Measure

		ret = dm->Force("GRP1_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("GRP1_DIFF_SENSE", DM_CONST_DICV);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLimit("GRP1_DIFF_SENSE", 6, -2);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel("GRP1_DIFF_SENSE", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("GRP1_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GRP1_DIFF_SENSE");
		CheckError(ret, __LINE__);
		_util->Wait_Sec(1e-3);

		ret = dm->Force("GRP2_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("GRP2_DIFF_SENSE", DM_CONST_DICV);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLimit("GRP2_DIFF_SENSE", 6, -2);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel("GRP2_DIFF_SENSE", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("GRP2_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("GRP2_DIFF_SENSE");
		CheckError(ret, __LINE__);
		_util->Wait_Sec(1e-3);

		/////////////////////
		//Group 1
		/////////////////////
					
		ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT0, 1); //Connect "MTX_SMU" to p
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT1, 1); //Connect "MTX_SMU_2" to n
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_RLY_GRP1_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu->DriveVoltage(n_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(p_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[0, i] = (double)k/10;
			y[0, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu->DriveVoltage(p_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(n_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[0, i] = (-1 * (double)k/10);
			y[0, i] = res;

			i++;
		}

		//Check offset error by shorting DA inputs to GND directly

		ret = OnOffCbit(CBIT_RLY_GRP1_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(ret, __LINE__);

		_util->Wait_Sec(10e-3);
		
		ret = dm->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
		CheckError(ret, __LINE__);

		c2 = res;

		//Get best fit line from x and y

		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[0, i];
			y_tmp[i] = y[0, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		_glob->DA_OffsetError[0] = c1 + c2;
		_glob->DA_GainError[0] = m;

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		/////////////////////
		//Group 2
		/////////////////////
			
		ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT3, 1); //Connect "MTX_SMU" to p
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT4, 1); //Connect "MTX_SMU_2" to n
		CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_RLY_GRP2_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu->DriveVoltage(n_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(p_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[1, i] = (double)k/10;
			y[1, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu->DriveVoltage(p_in, 0);
			CheckError(ret, __LINE__);

			ret = smu->DriveVoltage(n_in, (double)k/10);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(ret, __LINE__);
			
			x[1, i] = (-1 * (double)k/10);
			y[1, i] = res;

			i++;
		}

		//Check offset error by shorting DA inputs to GND directly

		ret = OnOffCbit(CBIT_RLY_GRP2_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(ret, __LINE__);

		_util->Wait_Sec(10e-3);
		
		ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
		CheckError(ret, __LINE__);

		c2 = res;

		//Get best fit line from x and y
		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[1, i];
			y_tmp[i] = y[1, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		_glob->DA_OffsetError[1] = c1 + c2;
		_glob->DA_GainError[1] = m;

		//End

		ret = smu->DriveVoltage(p_in, 0);
		CheckError(ret, __LINE__);

		ret = smu->DriveVoltage(n_in, 0);
		CheckError(ret, __LINE__);

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		/////////////////////
		//Print results
		/////////////////////
	
		DateTime _now = DateTime::Now;
		//String ^ DA_calFile = String::Format("{0}_{1:00}{2:00}{3:00}{4:00}{5:00}{6:00}.txt",
		//	"C:\\Aemulus\\TesterInfo\\DiffAmpCal" + testSite.ToString(), _now.Year, _now.Month, _now.Day, 
		//	_now.Hour, _now.Minute, _now.Second);

		String ^ DA_calFile = "C:\\Aemulus\\TesterInfo\\DiffAmpCal" + testSite + ".txt";

		StringBuilder ^ sbl = gcnew StringBuilder();
		StreamWriter ^ swl = gcnew StreamWriter(DA_calFile);

		String ^ temp = String::Format("{0} : {1:00}{2:00}{3:00}{4:00}{5:00}{6:00}", 
			"Last Cal", _now.Year, _now.Month, _now.Day, _now.Hour, _now.Minute, _now.Second);
		sbl->AppendLine(temp);

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			sbl->AppendLine("------------------");
			sbl->AppendLine("Group " + (i+1).ToString());
			sbl->AppendLine("------------------");

			for (j=0; j<size; j++)
			{
				sbl->AppendLine("x[" + (j).ToString() + "] = " + x[i, j] + "; y[" + (j).ToString() + "] = " + y[i, j]);
			}
				
			sbl->AppendLine("DA_GainError[" + (i).ToString() + "] = " + _glob->DA_GainError[i]);
			sbl->AppendLine("DA_OffsetError[" + (i).ToString() + "] = " + _glob->DA_OffsetError[i]);

			sbl->AppendLine("");
		}

		//Check for nominal values
		int err = 0;
		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			String ^ errorMsg = String::Empty;

			double error = Math::Abs(_glob->DA_GainError[i] - DA_IDEAL_GAIN) / DA_IDEAL_GAIN;

			if (error * 100 > DA_GAIN_ERROR_TOL_PERCENT)
			{
				sbl->AppendLine("");

				errorMsg = "Gain error for Site " + testSite + ", Mux Group " + (i+1).ToString() + " is larger than " + 
					DA_GAIN_ERROR_TOL_PERCENT + "% from ideal gain (" + DA_IDEAL_GAIN + ")";

				sbl->AppendLine(errorMsg);

				err++;
			}

			if (_glob->DA_OffsetError[i] > DA_OFFSET_ERR_TOL)
			{
				errorMsg = "Gain offset for Site " + testSite + ", Mux Group " + (i+1).ToString() + " is larger than " + 
					DA_OFFSET_ERR_TOL + ")";

				sbl->AppendLine(errorMsg);

				err++;
			}
		}

		swl->Write(sbl);	
		sbl = nullptr;
		swl->Close();
		swl = nullptr;

		if (err)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Differential Amp self-cal failed! Check DiffAmpCal file for details!", ER_GENERAL);
		}

		return ret;
	}
	// Public Methods
	int TestProgram::Load(Site ^ site)
	{
		int ret	= 0;

		Debug_Enable = (bool)(tf_ControlItemCondition_Cast("Debug_Enable"));
		HDS = (int)(tf_FlowCondition_Cast("HDS"));

		if(Debug_Enable)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\Load.txt");
		}

		offline = false;
		int powerlinefreq = 0;
		int Blow_Fuse_Enable = 0 ;

		IsRunningEditor = true;

		pxi_controller = nullptr;
		smu = nullptr;
		dio = nullptr;
		dm  = nullptr;
		tm	= nullptr;
		acm	= nullptr;
		digitizer = nullptr;
		HardwareProfile = nullptr;
				
		testHead = site->FlowEngine->HeadNumber;

		testSite = (int)(tf_FlowCondition_Cast("testSite"));
		if (testSite == -1)
			testSite = site->Index;
		
		if(String::IsNullOrEmpty(site->Recipe->ResourceMappingFilePath))
			throw gcnew Aemulus::Hardware::AlarmException("Hardware profile unspecified!", ER_INVALID_SETTING);
		else
			HardwareProfile = site->Recipe->ResourceMappingFilePath;

		if (tf_AppWideVariable_exist("PowerLineFreq"))
			powerlinefreq = (int)(tf_AppWideVariable_Cast("PowerLineFreq"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Power line freq unspecified!", ER_INVALID_SETTING);

		if (powerlinefreq == 0)
			Power_Line_Freq = 50;
		else
			Power_Line_Freq = 60;

		if (tf_AppWideVariable_exist("offline"))
			offline = (bool)(tf_AppWideVariable_Cast("offline"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("offline mode unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("Test"))
			Test = (int)(tf_AppWideVariable_Cast("Test"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Test mode unspecified!", ER_INVALID_SETTING);

		if (Test < 1 || Test > 4)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Invalid Test mode specified!", ER_INVALID_SETTING);
		}

		if (tf_AppWideVariable_exist("Blow_Fuse_Enable"))
			Blow_Fuse = (int)(tf_AppWideVariable_Cast("Blow_Fuse_Enable"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Blow_Fuse unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("high_x"))
			high_x = (float)(tf_AppWideVariable_Cast("high_x"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("high_x unspecified!", ER_INVALID_SETTING);


		if (tf_AppWideVariable_exist("high_y"))
			high_y = (float)(tf_AppWideVariable_Cast("high_y"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("high_y unspecified!", ER_INVALID_SETTING);


		if (tf_AppWideVariable_exist("wafer_diameter"))
			wafer_diameter = (float)(tf_AppWideVariable_Cast("wafer_diameter"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Wafer diameter unspecified!", ER_INVALID_SETTING);


		if (tf_AppWideVariable_exist("ForceBlowFuseSim"))
			ForceBlowFuseSim = (bool)(tf_AppWideVariable_Cast("ForceBlowFuseSim"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("ForceBlowFuseSim unspecified!", ER_INVALID_SETTING);


		if (tf_AppWideVariable_exist("ForceSingleSite"))
			ForceSingleSite = (bool)(tf_AppWideVariable_Cast("ForceSingleSite"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("ForceSingleSite unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("ForceSingleSiteNumber"))
			ForceSingleSiteNumber = (int)(tf_AppWideVariable_Cast("ForceSingleSiteNumber"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("ForceSingleSiteNumber unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("Barrier_Debug_Enable"))
			Barrier_Debug_Enable = (bool)(tf_AppWideVariable_Cast("Barrier_Debug_Enable"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Barrier_Debug_Enable unspecified!", ER_INVALID_SETTING);
		
		try
		{
			SetupFileDirectory = site->GetExternalDependency(Test.ToString());
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Setup file directory not present! (" + e->ToString() + ")", ER_GENERAL);
		}

		if (ForceSingleSite == false)
		{
			if (site->FlowEngine->Sites->Count > 1)
			{
				MultiSite = MULTISITE;
			}
			else
			{
				MultiSite = SINGLESITE; 
			}
		}
		else
		{
			MultiSite = SINGLESITE; 
		}

		if(Debug_Enable)
		{
			sb->AppendLine("testHead=" + testHead.ToString());
			sb->AppendLine("testSite=" + testSite.ToString());
			sb->AppendLine("HardwareProfile=" + HardwareProfile);
			sb->AppendLine("powerlinefreq (0=50Hz,1=60Hz)=" + powerlinefreq.ToString());
			sb->AppendLine("offline=" + offline.ToString());
			sb->AppendLine("MultiSite (0=Single,1=Multi)=" + MultiSite.ToString());
		}

		//if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		_fft = gcnew FFT();
		_util = gcnew Utilities();
		_glob = gcnew Global();

#pragma region "Barrier"

		if (Barrier_Debug_Enable == true)
		{
			sb_sync = gcnew StringBuilder();
			sw_sync = gcnew StreamWriter("C:\\Aemulus\\Debug\\Barrier" + testSite + ".txt");
		}

		if (tf_AppWideVariable_exist("Barrier_Count"))
			__barrierCount = (int)(tf_AppWideVariable_Cast("Barrier_Count"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Barrier_Count unspecified!", ER_INVALID_SETTING);

		Check_Barrier_Flow(site);

		if(IsRunningProduction(site) == true && ForceSingleSite == false)
		{
			IsRunningEditor = false;

			msclr::lock enter(__barrierLoadLock);
			if(!__barrierLoaded)
			{
				AEquipmentDriver^ ed = site->FlowEngine->EquipmentDrivers[0];
				IMultiUutED^ med = dynamic_cast<IMultiUutED^>(ed);
				if(med != nullptr) {
					__barrierEdUuts = med->UUTsData;
					__barrierFlags = gcnew array<bool>(__barrierEdUuts->Count);

					__barriers = gcnew array<CountdownEvent^>(__barrierCount);

					for (int i=0; i<__barrierCount-1; i++)
					{
						__barriers[i] = gcnew CountdownEvent(site->FlowEngine->Sites->Count); //normal barrier
					}
					__barriers[__barrierCount-1] = gcnew CountdownEvent(site->FlowEngine->Sites->Count, //last barrier - reset all barriers
						gcnew Action<CountdownEvent^>(this, &TestProgram::ResetBarrier) );

					__barrierActive = true;
				}
				__barrierLoaded = true;
			}
		}
		else
		{
			IsRunningEditor = true;
		}

		if(__barrierActive) {
			site->RunPhaseEnded += gcnew RunEnd(this, &TestProgram::RunEnded);
			site->RunPhaseStopped += gcnew RunStop(this, &TestProgram::RunStopped);
		}

#pragma endregion "Barrier"

#pragma region "CM"

		pxi_controller = gcnew CM(HardwareProfile, testHead, testSite, offline);

		int pxi_trigger_enable = 0;
		int pxi_trigger_direction = 0;

		if (testSite == 0 || testSite == 2)
		{
			//PXI_TRIGGER0, from A->B
			pxi_trigger_enable = 0x1;
			pxi_trigger_direction = 0x0;

			ret = pxi_controller->ConfigurePXES2780_TriggerBusAB("PXI_CONTROLLER", pxi_trigger_enable, pxi_trigger_direction);
		}
		if (testSite == 1 || testSite == 3)
		{
			//PXI_TRIGGER1, from C->B
			pxi_trigger_enable = 0x2;
			pxi_trigger_direction = 0x2;

			ret = pxi_controller->ConfigurePXES2780_TriggerBusBC("PXI_CONTROLLER", pxi_trigger_enable, pxi_trigger_direction);
		}
		
#pragma endregion "CM"

#pragma region "DM"

		//dm = gcnew DM(HardwareProfile, 3, testHead, testSite, offline, 0xf); //Should not reset DM_0 as its resources that control FETs are shared. Reset will reset those independent channels (GND_FETS and VCM_SE_DIFF_CONVERT) as well
		dm = gcnew DM(HardwareProfile, 3, testHead, testSite, offline, 0x0);

		ret = dm->ConfigureMultiSiteMode("DM_0", 1);
		CheckError(ret, __LINE__);

		//ret = dm->Reset("DM_0"); //Should not reset DM_0 as its resources that control FETs are shared. Reset will reset those independent channels (GND_FETS and VCM_SE_DIFF_CONVERT) as well
		//CheckError(ret, __LINE__);
		ret = dm->Reset("DM_1");
		CheckError(ret, __LINE__);
		ret = dm->Reset("DM_2");
		CheckError(ret, __LINE__);

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			for each (String ^ resource in resourceManager->MapNames)
			{
				Resource ^ hardwareResource = resourceManager->ResolveResource(resource)[0];

				if (hardwareResource->Hierarchy->Length > 1 && 
					hardwareResource->Hierarchy[0]->StartsWith("DM") == true)
				{
					ret = dm->ConfigurePMUSense(resource, DM_CONST_LOCAL);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePowerLineFrequency(resource, Power_Line_Freq);
					CheckError(ret, __LINE__);

					if (resource == "SPD")
					{
						_glob->SPD_Channel_Number = _util->StrToInt(hardwareResource->Value);
					}
				}
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		ret = dm->DrivePin("GND_MUX_RST_N", 0);
		CheckError(ret, __LINE__);

		ret = Configure_GND_FET(site);
		CheckError(ret, __LINE__);
		ret = OnOffFETGnd(0);
		CheckError(ret, __LINE__);

		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		try
		{
			ret = LoadVectorFileList(site);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load Vector File error! (" + e->ToString() + ")", ER_GENERAL);
		}
		
		ret = LoadVectorFiles(site);
		CheckError(ret, __LINE__);

		// Always enable VCM_SE_DIFF_CONVERT
		double vih = 2.5;
        double vil = 0.00;
        double voh = 0.75; 
        double vol = 0.75;
        double ioh = 0.002;
		double iol = 0.002;
        double vch = 6;
        double vcl = -0.1;
		double vt = 0;

		ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		CheckError(ret, __LINE__);

		vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		ret = dm->Force("FHCW_FETS", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("FHCW_FETS", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("FHCW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("FHCW_FETS", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("FHCW_FETS", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("FHCW_FETS");
		CheckError(ret, __LINE__);		

		if(Debug_Enable)
		{
			sb->AppendLine("FHCW_FETS: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("FHCR_FETS", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("FHCR_FETS", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("FHCR_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("FHCR_FETS", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("FHCR_FETS", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("FHCR_FETS");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("FHCR_FETS: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}

		vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm->Force("HW_FETS", DM_CONST_FORCE_STATE_DIO);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("HW_FETS", 0, 0, 0, 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("HW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->SetPinDirection("HW_FETS", DM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("HW_FETS", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("HW_FETS");
		CheckError(ret, __LINE__);

		if(Debug_Enable)
		{
			sb->AppendLine("HW_FETS: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
		}
	
#pragma endregion "DM"

#pragma region "AM"

		if (MultiSite == MULTISITE)
		{
			try
			{
				smu = gcnew SMU(HardwareProfile, testHead, testSite, offline, 0x8);
			}
			catch (Exception ^ e)
			{
				smu = gcnew SMU(HardwareProfile, testHead, testSite, offline, 0x8); //reset lock bit-3 if initialization fails
			}

			ret = smu->ConfigureMultiSiteMode("AM_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			smu = gcnew SMU(HardwareProfile, testHead, testSite, offline, 0x1f); //0x1f
			ret = smu->ConfigureMultiSiteMode("AM_2", 0);
			CheckError(ret, __LINE__);
		}

		if (MultiSite == MULTISITE)
		{
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			for each (String ^ resource in resourceManager->MapNames)
			{
				Resource ^ hardwareResource = resourceManager->ResolveResource(resource)[0];

				if (hardwareResource->Hierarchy->Length > 1 && 
					hardwareResource->Hierarchy[0]->StartsWith("AM") == true)
				{
					ret = smu->ConfigurePLF(resource, Power_Line_Freq);
					CheckError(ret, __LINE__);

					//ret = smu->VoltageNulling(resource, AM_CONST_10V_RANGE);
					//CheckError(ret, __LINE__);
					//ret = smu->ResetChannel(resource);
					//CheckError(ret, __LINE__);
					//_util->Wait_Sec(5e-3);

					if (hardwareResource->Hierarchy[0]->StartsWith("AM430"))
					{
						ret = smu->VoltageNulling(resource, AM_CONST_1V_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->VoltageNulling(resource, AM_CONST_2V_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->VoltageNulling(resource, AM_CONST_5V_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);
					}

					ret = smu->CurrentNulling(resource, AM_CONST_1UA_RANGE);
					CheckError(ret, __LINE__);
					ret = smu->ResetChannel(resource);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(5e-3);

					ret = smu->CurrentNulling(resource, AM_CONST_10UA_RANGE);
					CheckError(ret, __LINE__);
					ret = smu->ResetChannel(resource);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(5e-3);

					ret = smu->CurrentNulling(resource, AM_CONST_100UA_RANGE);
					CheckError(ret, __LINE__);
					ret = smu->ResetChannel(resource);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(5e-3);

					ret = smu->CurrentNulling(resource, AM_CONST_1MA_RANGE);
					CheckError(ret, __LINE__);
					ret = smu->ResetChannel(resource);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(5e-3);

					ret = smu->CurrentNulling(resource, AM_CONST_10MA_RANGE);
					CheckError(ret, __LINE__);
					ret = smu->ResetChannel(resource);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(5e-3);

					ret = smu->CurrentNulling(resource, AM_CONST_100MA_RANGE);
					CheckError(ret, __LINE__);
					ret = smu->ResetChannel(resource);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(5e-3);

					//if (hardwareResource->Hierarchy[0]->StartsWith("AM471"))
					//{
					//	ret = smu->CurrentNulling(resource, AM_CONST_1A_RANGE);
					//	CheckError(ret, __LINE__);
					//	ret = smu->ResetChannel(resource);
					//	CheckError(ret, __LINE__);
					//	_util->Wait_Sec(5e-3);

					//	ret = smu->CurrentNulling(resource, AM_CONST_3A_RANGE);
					//	CheckError(ret, __LINE__);
					//	ret = smu->ResetChannel(resource);
					//	CheckError(ret, __LINE__);
					//	_util->Wait_Sec(5e-3);
					//}
				}
			}

			if (resourceManager)
				delete resourceManager;
		}

#pragma endregion "AM"

#pragma region "IOM"

		dio = gcnew DIO(HardwareProfile, testHead, testSite, offline);

		ret = dio->PowerOnOff("IOM", IOM_CONST_OUTPUT_VCCOUT5_OFF, IOM_CONST_OUTPUT_VCCOUT12_ON);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(5e-3);
		ret = dio->PowerOnOff("IOM", IOM_CONST_OUTPUT_VCCOUT5_ON, IOM_CONST_OUTPUT_VCCOUT12_ON);
		CheckError(ret, __LINE__);
		ret = dio->SetVIO("IOM", IOM_CONST_OUTPUT_VIO_3_3V);
		CheckError(ret, __LINE__);
		ret = dio->SetPortDirection("IOM_Port_0", IOM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dio->SetPortDirection("IOM_Port_1", IOM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dio->SetPortDirection("IOM_Port_2", IOM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dio->SetPortDirection("IOM_Port_3", IOM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);
		ret = dio->SetPortDirection("IOM_Port_4", IOM_CONST_DIR_OUTPUT);
		CheckError(ret, __LINE__);

#pragma endregion "IOM"

#pragma region "TM"

		if (MultiSite == MULTISITE)
		{
			try
			{
				tm = gcnew TM(HardwareProfile, testHead, testSite, offline, 0x0);
			}
			catch (Exception ^ e)
			{
				tm = gcnew TM(HardwareProfile, testHead, testSite, offline, 0x8); //reset lock bit-3 if initialization fails
			}

			ret = tm->ConfigureMultiSiteMode("TM", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			tm = gcnew TM(HardwareProfile, testHead, testSite, offline, 0xf);
			ret = tm->ConfigureMultiSiteMode("TM", 0);
			CheckError(ret, __LINE__);
		}

#pragma endregion "TM"

#pragma region "ACM"

		if (MultiSite == MULTISITE)
		{
			try
			{
				acm = gcnew ACM(HardwareProfile, testHead, testSite, offline, 0x0);
			}
			catch (Exception ^ e)
			{
				acm = gcnew ACM(HardwareProfile, testHead, testSite, offline, 0x8); //reset lock bit-3 if initialization fails
			}

			digitizer = acm;
	
			ret = acm->ConfigureMultiSiteMode("ACM", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			acm = gcnew ACM(HardwareProfile, testHead, testSite, offline, 0xf);
			digitizer = acm;
	
			ret = acm->ConfigureMultiSiteMode("ACM", 0);
			CheckError(ret, __LINE__);
		}

#pragma endregion "ACM"

#pragma region "External Dependencies"

		SPIFileDirectory = site->GetExternalDependency("SPI");

		try
		{
			ret = LoadOffsetFile(site);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load Offset File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		try
		{
			ret = LoadDMSettingFile(site);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load DM Setting File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		//try
		//{
		//	ret = LoadDIOSettingFile(site);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^e)
		//{
		//	throw gcnew Aemulus::Hardware::AlarmException("Load DIO Setting File error! (" + e->ToString() + ")", ER_GENERAL);
		//}

		try
		{
			ret = LoadCBitSettingFile(site);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load CBit Setting File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		try
		{
			ret = LoadMuxSettingFile(site);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load Mux Setting File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		try 
		{
			ret = LoadTesterCalFile(site);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load IF Board Calibration File error! (" + e->ToString() + ")", ER_GENERAL);
		}

#pragma endregion "External Dependencies"

		InitializeGlobalVariables(site);

		#ifdef USE_SPI
		LoadSPIFiles(site);
		#endif

#pragma region "Trimming Test"
		
		LoadTrimReg();

#pragma endregion "Trimming Test"

		ret = SetupDIO(site);
		CheckError(ret, __LINE__);
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		
		ret = InitCBitHist();
		CheckError(ret, __LINE__);

		//Set Vcc relay on adaptor board
		ret = OnOffCbit(CBIT_VCC_FORWARD, 1);
		CheckError(ret, __LINE__);
		ret = OnOffCbit(CBIT_VEE_FORWARD, 1);
		CheckError(ret, __LINE__);

		//Init SMU
		ret = InitPowerSupplies();
		CheckError(ret, __LINE__);

		CheckTestItemByPassed(site);
		InitDieID(site);

		// Diff Amp Self-Calibration
		ret = CalibrateDiffAmp2(site);
		CheckError(ret, __LINE__);

		#ifdef USE_GNDS
		ret = Configure_GNDS(site);
		CheckError(ret, __LINE__);
		#endif

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::Unload(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

#pragma region "Barrier"

		if(__barrierActive)
		{
			site->RunPhaseEnded -= gcnew RunEnd(this, &TestProgram::RunEnded);

			msclr::lock enter(__barrierLoadLock);
			if(__barriers != nullptr) {
				for(int i=0; i<__barriers->Length-1; i++)
					__barriers[i] = nullptr;
				__barriers = nullptr;
			}
			__barrierSetup = false;
			__barrierEdUuts = nullptr;
			__barrierFlags = nullptr;
			__barrierActive = false;
			__barrierLoaded = false;
		}

		if (Barrier_Debug_Enable == true)
		{
			sw_sync->Write(sb_sync);	
			sb_sync = nullptr;
			sw_sync->Close();
			sw_sync = nullptr;
		}

#pragma endregion "Barrier"
		
		if (MultiSite == MULTISITE)
		{
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				for each (String ^ resource in resourceManager->MapNames)
				{
					Resource ^ hardwareResource = resourceManager->ResolveResource(resource)[0];

					if (hardwareResource->Hierarchy->Length > 1 && 
						hardwareResource->Hierarchy[0]->StartsWith("AM") == true)
					{
						ret = smu->ConfigurePLF(resource, Power_Line_Freq);
						CheckError(ret, __LINE__);

						ret = smu->VoltageNulling(resource, AM_CONST_1V_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->VoltageNulling(resource, AM_CONST_10V_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						if (hardwareResource->Hierarchy[0]->StartsWith("AM430"))
						{
							ret = smu->VoltageNulling(resource, AM_CONST_2V_RANGE);
							CheckError(ret, __LINE__);
							ret = smu->ResetChannel(resource);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu->VoltageNulling(resource, AM_CONST_5V_RANGE);
							CheckError(ret, __LINE__);
							ret = smu->ResetChannel(resource);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(5e-3);
						}

						ret = smu->CurrentNulling(resource, AM_CONST_1UA_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->CurrentNulling(resource, AM_CONST_10UA_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->CurrentNulling(resource, AM_CONST_100UA_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->CurrentNulling(resource, AM_CONST_1MA_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->CurrentNulling(resource, AM_CONST_10MA_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu->CurrentNulling(resource, AM_CONST_100MA_RANGE);
						CheckError(ret, __LINE__);
						ret = smu->ResetChannel(resource);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(5e-3);

						if (hardwareResource->Hierarchy[0]->StartsWith("AM471"))
						{
							ret = smu->CurrentNulling(resource, AM_CONST_1A_RANGE);
							CheckError(ret, __LINE__);
							ret = smu->ResetChannel(resource);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu->CurrentNulling(resource, AM_CONST_3A_RANGE);
							CheckError(ret, __LINE__);
							ret = smu->ResetChannel(resource);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(5e-3);
						}
					}
				}

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}
		}
		else
		{
			ret = smu->Reset("AM_0");
			CheckError(ret, __LINE__);
			ret = smu->Reset("AM_1");
			CheckError(ret, __LINE__);
			ret = smu->Reset("AM_2");
			CheckError(ret, __LINE__);
		}

		ret = ResetMuxIO();
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = dio->PowerOnOff("IOM", IOM_CONST_OUTPUT_VCCOUT5_OFF, IOM_CONST_OUTPUT_VCCOUT12_OFF);
		CheckError(ret, __LINE__);
		ret = dio->Reset("IOM");
		CheckError(ret, __LINE__);

		ret = OnOffFETGnd(0);
		CheckError(ret, __LINE__);
		ret = SetupDIO(site);
		CheckError(ret, __LINE__);
		ret = dm->Reset("DM_0");
		CheckError(ret, __LINE__);
		ret = dm->Reset("DM_1");
		CheckError(ret, __LINE__);
		ret = dm->Reset("DM_2");
		CheckError(ret, __LINE__);

		ret = digitizer->Uninitialize("DIGITIZER");
		CheckError(ret, __LINE__);

		ret = pxi_controller->Uninitialize("PXI_CONTROLLER");
		CheckError(ret, __LINE__);
		
		return ret;
	}

	int TestProgram::seq_gnds_cont(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		String ^ TPName = tf_TestParameter_Name(0);
		String ^ TPDispName = tf_TestParameter_DisplayName(0);
		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		bool Debug_Enable		= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		int retest_count = 0;
		int GNDS_RESET_COUNT = 5;

RETEST:

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = smu->ClampVoltage("GND_MUX_SENSE", Clamp_Voltage_V);
		CheckError(ret, __LINE__);

		ret = smu->DriveCurrent("GND_MUX_SENSE", Drive_Current_A);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		ret = smu->ReadVoltage("GND_MUX_SENSE", result);
		CheckError(ret, __LINE__);

		result = result / Drive_Current_A;

		double max_limit = (double)(tf_TPHighLimit_Cast(TPName));
		double min_limit = (double)(tf_TPLowLimit_Cast(TPName));

		if ((result < min_limit) || (result > max_limit))
		{
			if (retest_count < GNDS_RESET_COUNT)
			{
				retest_count++;
				goto RETEST;
			}
		}

		tf_SetResult(TPName, result + GetOffset(TPDispName));

		if (_glob->contact_fail == 0)
		{
			if ((result + GetOffset(TPDispName)) < (double)(tf_TPLowLimit_Cast(TPName)))
			{
				_glob->contact_open_l_short_h = 1;
				_glob->contact_fail = 1;
			}

			if ((result + GetOffset(TPDispName)) > (double)(tf_TPHighLimit_Cast(TPName)))
			{
				_glob->contact_open_l_short_h = 0;
				_glob->contact_fail = 1;
			}
		}

		ret = smu->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(ret, __LINE__);

		ret = smu->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_depmos_test(Site ^ site)
	{	
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		int i = 0;

		double inf_p = std::numeric_limits<double>::infinity();
		double inf_n = -inf_p;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Drive_Pin_P;
		String ^ Drive_Pin_N;
		String ^ Measure_Pin_P;
		String ^ Measure_Pin_N;

		double result = 0;

		ret = OnOffFETGnd(1);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);

		//if (Test == TEST_IF4600_PKG)
		//{
		//	ret = DriveDIOPin(TPDispName[0]);
		//	CheckError(ret, __LINE__);
		//}
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		ret = dm->DPINOff("SPE");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPD");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType_DriveP = 0;
		unsigned int moduleType_DriveN = 0;
		unsigned int moduleType_MeasureP = 0;
		unsigned int moduleType_MeasureN = 0;
		
		double vp_ip = 0;
		double vn_ip = 0;
		double vp_in = 0;
		double vn_in = 0;

		double dep_n = 0;
		double dep_p = 0;
		double rmr_d = 0;
		double dep_d = 0;

		if (Test == TEST_IF4600_PKG)
		{
			#pragma region "TEST_PACKAGE"

			for (i=0; i<total_tp; i=i+3) //for every depmos measurement for RDxP/N pair, we get 3 results
			{
				TPName[i] = tf_TestParameter_Name(i);

				Drive_Pin_P = (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_P"));
				Drive_Pin_N = (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_N"));
				Measure_Pin_P = (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_P"));
				Measure_Pin_N = (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_N"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Drive_Pin_P=" + Drive_Pin_P);
					sb->AppendLine("Drive_Pin_N=" + Drive_Pin_N);
					sb->AppendLine("Measure_Pin_P=" + Measure_Pin_P);
					sb->AppendLine("Measure_Pin_N=" + Measure_Pin_N);
				}
			
				// Check whether resource is SMU or DM
				try
				{
					ret = smu->QueryModuleType(Drive_Pin_P, moduleType_DriveP);
					CheckError(ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveP = DM_CONST_MODULE_TYPE;
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("QueryModuleType returns " + ret.ToString());
					sb->AppendLine("Drive_Pin_P module type=" + moduleType_DriveP.ToString("X"));
				}

				try
				{
					ret = smu->QueryModuleType(Drive_Pin_N, moduleType_DriveN);
					CheckError(ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveN = DM_CONST_MODULE_TYPE;
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("QueryModuleType returns " + ret.ToString());
					sb->AppendLine("Drive_Pin_N module type=" + moduleType_DriveN.ToString("X"));
				}

				try
				{
					ret = smu->QueryModuleType(Measure_Pin_P, moduleType_MeasureP);
					CheckError(ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureP = DM_CONST_MODULE_TYPE;
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("QueryModuleType returns " + ret.ToString());
					sb->AppendLine("Measure_Pin_P module type=" + moduleType_MeasureP.ToString("X"));
				}

				try
				{
					ret = smu->QueryModuleType(Measure_Pin_N, moduleType_MeasureN);
					CheckError(ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureN = DM_CONST_MODULE_TYPE;
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("QueryModuleType returns " + ret.ToString());
					sb->AppendLine("Measure_Pin_N module type=" + moduleType_MeasureN.ToString("X"));
				}

				// Configure P
				if (moduleType_DriveP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Clamp_Voltage_V < 0)
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, 0, Clamp_Voltage_V);
					else
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, Clamp_Voltage_V, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);

					ret = dm->DPINOn(Drive_Pin_P);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ConfigureSamplingTime(Drive_Pin_P, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Drive_Pin_P, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Drive_Pin_P, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Drive_Pin_P, false, false);
					CheckError(ret, __LINE__);
				}

				if (Measure_Pin_P != Drive_Pin_P)
				{
					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->Force(Measure_Pin_P, DM_CONST_FORCE_STATE_PMU);
						CheckError(ret, __LINE__);
						ret = dm->ConfigurePMUOutputFunction(Measure_Pin_P, DM_CONST_DICV);
						CheckError(ret, __LINE__);
						if (Clamp_Voltage_V < 0)
							ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_P, 0, Clamp_Voltage_V);
						else
							ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_P, Clamp_Voltage_V, 0);
						CheckError(ret, __LINE__);
						ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_P, 0);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUSamplingTime(Measure_Pin_P, NPLC, DM_CONST_PLC);
						CheckError(ret, __LINE__);
						ret = dm->DPINOn(Measure_Pin_P);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ConfigureSamplingTime(Measure_Pin_P, NPLC, AM_CONST_PLC);
						CheckError(ret, __LINE__);
						ret = smu->ClampVoltage(Measure_Pin_P, Math::Abs(Clamp_Voltage_V));
						CheckError(ret, __LINE__);
						ret = smu->DriveCurrent(Measure_Pin_P, 0);
						CheckError(ret, __LINE__);
						ret = smu->OnSmuPin(Measure_Pin_P, false, false);
						CheckError(ret, __LINE__);
					}
				}

				// Configure N
				if (moduleType_DriveN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Clamp_Voltage_V < 0)
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, 0, Clamp_Voltage_V);
					else
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, Clamp_Voltage_V, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);

					ret = dm->DPINOn(Drive_Pin_N);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ConfigureSamplingTime(Drive_Pin_N, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Drive_Pin_N, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Drive_Pin_N, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Drive_Pin_N, false, false);
					CheckError(ret, __LINE__);
				}

				if (Measure_Pin_N != Drive_Pin_N)
				{
					if (moduleType_MeasureN == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->Force(Measure_Pin_N, DM_CONST_FORCE_STATE_PMU);
						CheckError(ret, __LINE__);
						ret = dm->ConfigurePMUOutputFunction(Measure_Pin_N, DM_CONST_DICV);
						CheckError(ret, __LINE__);
						if (Clamp_Voltage_V < 0)
							ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_N, 0, Clamp_Voltage_V);
						else
							ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_N, Clamp_Voltage_V, 0);
						CheckError(ret, __LINE__);
						ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_N, 0);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUSamplingTime(Measure_Pin_N, NPLC, DM_CONST_PLC);
						CheckError(ret, __LINE__);
						ret = dm->DPINOn(Measure_Pin_N);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ClampVoltage(Measure_Pin_N, Math::Abs(Clamp_Voltage_V));
						CheckError(ret, __LINE__);
						ret = smu->DriveCurrent(Measure_Pin_N, 0);
						CheckError(ret, __LINE__);
						ret = smu->ConfigureSamplingTime(Measure_Pin_N, NPLC, AM_CONST_PLC);
						CheckError(ret, __LINE__);
						ret = smu->OnSmuPin(Measure_Pin_N, false, false);
						CheckError(ret, __LINE__);
					}
				}

				_util->Wait_Sec(On_Delay_s);

				// Drive P
				if (moduleType_DriveP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Hi_A);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm->PMUMeasure(Drive_Pin_P, DM_CONST_MEASURECURRENT, res);
						CheckError(ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Hi_A);
					CheckError(ret, __LINE__);
				}

				// Drive N
				if (moduleType_DriveN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, Drive_Current_Lo_A);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm->PMUMeasure(Drive_Pin_N, DM_CONST_MEASURECURRENT, res);
						CheckError(ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu->DriveCurrent(Drive_Pin_N, Drive_Current_Lo_A);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				// Measure P

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Measure_Pin_P, DM_CONST_MEASUREVOLTAGE, vp_ip);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ReadCurrent(Measure_Pin_P, vp_ip);
					CheckError(ret, __LINE__);
				}
				
				// Measure N

				if (moduleType_MeasureN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Measure_Pin_N, DM_CONST_MEASUREVOLTAGE, vn_ip);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ReadCurrent(Measure_Pin_N, vn_ip);
					CheckError(ret, __LINE__);
				}

				//Reverse bias

				// Drive P
				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Lo_A);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Lo_A);
					CheckError(ret, __LINE__);
				}

				// Drive N
				if (moduleType_MeasureN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, Drive_Current_Hi_A);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->DriveCurrent(Drive_Pin_N, Drive_Current_Hi_A);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				// Measure P
				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Measure_Pin_P, DM_CONST_MEASUREVOLTAGE, vp_in);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ReadCurrent(Measure_Pin_P, vp_in);
					CheckError(ret, __LINE__);

					ret = smu->DriveCurrent(Drive_Pin_P, 0);
					CheckError(ret, __LINE__);
				}
				
				// Measure N
				if (moduleType_MeasureN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Measure_Pin_N, DM_CONST_MEASUREVOLTAGE, vn_in);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ReadCurrent(Measure_Pin_N, vn_in);
					CheckError(ret, __LINE__);

					ret = smu->DriveCurrent(Drive_Pin_N, 0);
					CheckError(ret, __LINE__);
				}
			
				double iforce_hi = Drive_Current_Hi_A;
				double iforce_lo = Drive_Current_Lo_A;
				double iforce_diff = Math::Abs(Drive_Current_Hi_A - Drive_Current_Lo_A);	

				dep_n = ((vn_in * vp_ip / vp_in) - vn_ip) / (iforce_diff * (1 - (vp_ip / vp_in)));
				dep_p = -1 * (vp_in / (iforce_diff + (vn_in / dep_n)));

				rmr_d = (vp_ip - vn_ip) * dep_n / vn_ip;

				dep_d = CONST_Rr1 * rmr_d / (CONST_Rr1 - rmr_d);

				if (_util->IsInf(dep_p) == true)
					dep_p = 1000;

				if (_util->IsInf(dep_n) == true)
					dep_n = 1000;

				if (_util->IsInf(dep_d) == true)
					dep_d = 1000;

				tf_SetResult(TPName[i], dep_p + GetOffset(TPDispName[i]));
				tf_SetResult(TPName[i+1], dep_n + GetOffset(TPDispName[i+1]));
				tf_SetResult(TPName[i+2], dep_d + GetOffset(TPDispName[i+2]));

				if (_glob->contact_fail == 0)
				{
					if ((dep_p + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}	
					
					if ((dep_p + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}

					if ((dep_n + GetOffset(TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}

					if ((dep_n + GetOffset(TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}

					
					if ((dep_d + GetOffset(TPDispName[i+2])) < (double)(tf_TPLowLimit_Cast(TPName[i+2])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}

					if ((dep_d + GetOffset(TPDispName[i+2])) > (double)(tf_TPHighLimit_Cast(TPName[i+2])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}
				}
			}

			#pragma endregion "TEST_PACKAGE"
		}
		else
		{
			double iforce_hi = 0;
			double iforce_lo = 0;
			double iforce_diff = 0;
	
			int c = 0;

			array<double>^ reading = gcnew array<double>(HDS*2);

			int retest_count = 0;
			int DEPMOS_RESET_COUNT = 1;

			array<double>^ max_limit = gcnew array<double>(3);
			array<double>^ min_limit = gcnew array<double>(3);

			int configure_once = 0;
			for (int i=0; i<HDS; i++)
			{
				Drive_Pin_P		= (String ^)(tf_TPCondition_Cast(TPName[i+(i*2)], "Drive_Pin_P"));
				Drive_Pin_N		= (String ^)(tf_TPCondition_Cast(TPName[i+(i*2)], "Drive_Pin_N"));
				Measure_Pin_P	= "MTX_SMU";
				Measure_Pin_N	= "MTX_SMU";
				
				double Drive_P = 0;
				double Drive_N = 0;

				configure_once = 0;

				retest_count = 0;
RETEST:
				c = 0;
				for (int j=0; j<2; j++)
				{
					switch (j)
					{
						case 0:		// forward
							{
								Drive_P = Drive_Current_Hi_A;
								Drive_N = Drive_Current_Lo_A;
						
								break;
							}
						case 1:		// reverse
							{
								Drive_P = Drive_Current_Lo_A;
								Drive_N = Drive_Current_Hi_A;
						
								break;
							}
					}
				
					// Configure Force Mux
					ret = DriveMuxIO(TPDispName[i+(i*2)], 0);
					CheckError(ret, __LINE__);

					if (configure_once == 0)
					{
						/////////////////////////
						// Configure P
						ret = dm->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
						CheckError(ret, __LINE__);
						
						if (Clamp_Voltage_V < 0)
							ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, 0, Clamp_Voltage_V);
						else
							ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, Clamp_Voltage_V, 0);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
						CheckError(ret, __LINE__);

						ret = dm->DPINOn(Drive_Pin_P);
						CheckError(ret, __LINE__);
			
						//  Config meas MTX_Meas
						ret = smu->SetNPLC("MTX_SMU", NPLC);
						CheckError(ret, __LINE__);
						ret = smu->ClampVoltage("MTX_SMU", Math::Abs(Clamp_Voltage_V));
						CheckError(ret, __LINE__);
						ret = smu->DriveCurrent("MTX_SMU", 0);
						CheckError(ret, __LINE__);
						ret = smu->OnSmuPin("MTX_SMU" , true, false);
						CheckError(ret, __LINE__);
						
						/////////////////////////
						// Configure N

						ret = dm->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
						CheckError(ret, __LINE__);
						
						if (Clamp_Voltage_V < 0)
							ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, 0, Clamp_Voltage_V);
						else
							ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, Clamp_Voltage_V, 0);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
						CheckError(ret, __LINE__);

						ret = dm->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
						CheckError(ret, __LINE__);

						ret = dm->DPINOn(Drive_Pin_N);
						CheckError(ret, __LINE__);

						configure_once = 1;
					}
						
					_util->Wait_Sec(On_Delay_s);

					// Drive P
					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_P);
					CheckError(ret, __LINE__);

					double tmp = 0;
					if (Debug_Enable == true)
					{
						ret = dm->PMUMeasure(Drive_Pin_P, DM_CONST_MEASURECURRENT, tmp);
						CheckError(ret, __LINE__);
					}

					// Drive N
					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, Drive_N);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						ret = dm->PMUMeasure(Drive_Pin_N, DM_CONST_MEASURECURRENT, tmp);
						CheckError(ret, __LINE__);
					}
				
					_util->Wait_Sec(Measure_Delay_s);

					// Measure P
					{
						ret = DriveCBit(TPDispName[i+(i*2)], 0);
						CheckError(ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);

						ret = smu->ReadVoltage(Measure_Pin_P, reading[c]);  
						CheckError(ret, __LINE__);

						ret = DriveCBit(TPDispName[i+(i*2)], 1);
						CheckError(ret, __LINE__);
					}

					//#ifdef USE_GNDS
					//double volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					//CheckError(ret, __LINE__);
					//reading[c] = reading[c] - volt;
					//#endif
					
					c++;								
					
					// Measure N
					{
						ret = DriveCBit(TPDispName[i+(i*2)], 2);
						CheckError(ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);
						
						ret = smu->ReadVoltage(Measure_Pin_N, reading[c]);
						CheckError(ret, __LINE__);

						ret = DriveCBit(TPDispName[i+(i*2)], 3);
						CheckError(ret, __LINE__);
					}
					
					//#ifdef USE_GNDS
					//volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					//CheckError(ret, __LINE__);
					//reading[c] = reading[c] - volt;
					//#endif
					
					c++;
				}

				ResetMuxIO();
				
				vp_ip = reading[0];
				vn_ip = reading[1];
				vp_in = reading[2];
				vn_in = reading[3];

				iforce_hi = Drive_Current_Hi_A;
				iforce_lo = Drive_Current_Lo_A;
				iforce_diff = Math::Abs(Drive_Current_Hi_A - Drive_Current_Lo_A);	

				dep_n = ((vn_in * vp_ip / vp_in) - vn_ip) / (iforce_diff * (1 - (vp_ip / vp_in)));
				dep_p = -1 * (vp_in / (iforce_diff + (vn_in / dep_n)));

				rmr_d = (vp_ip - vn_ip) * dep_n / vn_ip;

				dep_d = CONST_Rr1 * rmr_d / (CONST_Rr1 - rmr_d);

				if (_util->IsInf(dep_p))
					dep_p = 1000;

				if (_util->IsInf(dep_n))
					dep_n = 1000;

				if (_util->IsInf(dep_d))
					dep_d = 1000;

				tf_SetResult(TPName[i+(2*i)], dep_p + GetOffset(TPDispName[i+(2*i)]));
				tf_SetResult(TPName[i+(2*i)+1], dep_n + GetOffset(TPDispName[i+(2*i)+1]));
				tf_SetResult(TPName[i+(2*i)+2], dep_d + GetOffset(TPDispName[i+(2*i)+2]));

				max_limit[0] = (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)]));
				min_limit[0] = (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)]));

				max_limit[1] = (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+1]));
				min_limit[1] = (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+1]));

				max_limit[2] = (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+2]));
				min_limit[2] = (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+2]));

				if (((dep_p < min_limit[0]) || (dep_p > max_limit[0])) ||
					((dep_n < min_limit[1]) || (dep_n > max_limit[1])) ||
					((dep_d < min_limit[2]) || (dep_d > max_limit[2])))
				{
					if (retest_count < DEPMOS_RESET_COUNT)
					{
						retest_count++;
						goto RETEST;
					}
				}

				if (_glob->contact_fail == 0)
				{
					if ((dep_p + GetOffset(TPDispName[i+(2*i)])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}	
					
					if ((dep_p + GetOffset(TPDispName[i+(2*i)])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}

					if ((dep_n + GetOffset(TPDispName[i+(2*i)+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+1])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}

					if ((dep_n + GetOffset(TPDispName[i+(2*i)+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+1])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}

					
					if ((dep_d + GetOffset(TPDispName[i+(2*i)+2])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+2])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}

					if ((dep_d + GetOffset(TPDispName[i+(2*i)+2])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+2])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}
				}
			}
			
			//power down
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
					
			ret = dm->ConfigurePMUVoltageLevel(Drive_Pin_N, 0);	
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Drive_Pin_P, 0);	
			CheckError(ret, __LINE__);
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_depmos_test2(Site ^ site)
	{	
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//Use diff amp to measure

		int ret = 0;
		int i = 0;

		double inf_p = std::numeric_limits<double>::infinity();
		double inf_n = -inf_p;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Drive_Pin_P;
		String ^ Drive_Pin_N;
		String ^ Measure_Pin_P;
		String ^ Measure_Pin_N;

		double result = 0;

		ret = OnOffFETGnd(1);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);

		//if (Test == TEST_IF4600_PKG)
		//{
		//	ret = DriveDIOPin(TPDispName[0]);
		//	CheckError(ret, __LINE__);
		//}
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		ret = dm->DPINOff("SPE");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPD");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("GND_MUX_RST_N", 0); //reset SPI MUX as we need MTX_SMU2 for this test (no need GNDS)
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType_DriveP = 0;
		unsigned int moduleType_DriveN = 0;
		unsigned int moduleType_MeasureP = 0;
		unsigned int moduleType_MeasureN = 0;
		
		double vp_ip = 0;
		double vn_ip = 0;
		double vp_in = 0;
		double vn_in = 0;

		double dep_n = 0;
		double dep_p = 0;
		double rmr_d = 0;
		double dep_d = 0;
		
		double iforce_hi = 0;
		double iforce_lo = 0;
		double iforce_diff = 0;

		int c = 0;

		double m = 3;
		double c1 = 0;

		array<double>^ reading = gcnew array<double>(HDS*2);
		
		int configure_once = 0;
		for (int i=0; i<HDS; i++)
		{
			Drive_Pin_P		= (String ^)(tf_TPCondition_Cast(TPName[i+(i*2)], "Drive_Pin_P"));
			Drive_Pin_N		= (String ^)(tf_TPCondition_Cast(TPName[i+(i*2)], "Drive_Pin_N"));
			Measure_Pin_P	= "GRP2_DIFF_SENSE";
			Measure_Pin_N	= "GRP2_DIFF_SENSE";
			
			double Drive_P = 0;
			double Drive_N = 0;

			configure_once = 0;

			// Configure CBIT
			ret = DriveCBit(TPDispName[i+(i*2)]);
			CheckError(ret, __LINE__);

			c = 0;
			for (int j=0; j<2; j++)
			{
				switch (j)
				{
					case 0:		// forward
						{
							Drive_P = Drive_Current_Hi_A;
							Drive_N = Drive_Current_Lo_A;
					
							break;
						}
					case 1:		// reverse
						{
							Drive_P = Drive_Current_Lo_A;
							Drive_N = Drive_Current_Hi_A;
					
							break;
						}
				}

				// Configure Force Mux
				ret = DriveMuxIO(TPDispName[i+(i*2)], 0);
				CheckError(ret, __LINE__);

				if (configure_once == 0)
				{
					/////////////////////////
					// Configure P
					ret = dm->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Clamp_Voltage_V < 0)
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, 0, Clamp_Voltage_V);
					else
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, Clamp_Voltage_V, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);

					ret = dm->DPINOn(Drive_Pin_P);
					CheckError(ret, __LINE__);
		
					//  Config meas GRP2_DIFF_SENSE
					//ret = dm->Force("GRP2_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
					//CheckError(ret, __LINE__);

					//ret = dm->ConfigurePMUOutputFunction("GRP2_DIFF_SENSE", DM_CONST_DICV);
					//CheckError(ret, __LINE__);
					//
					//ret = dm->ConfigurePMUVoltageLimit("GRP2_DIFF_SENSE", 0, -2);
					//CheckError(ret, __LINE__);

					//ret = dm->ConfigurePMUCurrentLevel("GRP2_DIFF_SENSE", 0);
					//CheckError(ret, __LINE__);

					//ret = dm->ConfigurePMUSamplingTime("GRP2_DIFF_SENSE", NPLC, DM_CONST_PLC);
					//CheckError(ret, __LINE__);

					//ret = dm->DPINOn("GRP2_DIFF_SENSE");
					//CheckError(ret, __LINE__);
					
					/////////////////////////
					// Configure N

					ret = dm->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Clamp_Voltage_V < 0)
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, 0, Clamp_Voltage_V);
					else
						ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, Clamp_Voltage_V, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);

					ret = dm->DPINOn(Drive_Pin_N);
					CheckError(ret, __LINE__);

					//MTX_SMU
					ret = smu->ConfigureSamplingTime("MTX_SMU_2", NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage("MTX_SMU_2", 10);
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent("MTX_SMU_2", 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin("MTX_SMU_2", true, false);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);

					//query for DiffAmp gain
					
					if (Measure_Pin_P == "GRP1_DIFF_SENSE")
					{
						m = _glob->DA_GainError[0];
						c1 = _glob->DA_OffsetError[0];

						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT2, 1); //Connect to AM430e MTX_SMU_2 via switch matrix
						CheckError(ret, __LINE__);
					}
					else if (Measure_Pin_P == "GRP2_DIFF_SENSE")
					{
						m = _glob->DA_GainError[1];
						c1 = _glob->DA_OffsetError[1];

						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT5, 1); //Connect to AM430e MTX_SMU_2 via switch matrix
						CheckError(ret, __LINE__);
					}

					configure_once = 1;
				}
					
				_util->Wait_Sec(On_Delay_s);

				// Drive P
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_P);
				CheckError(ret, __LINE__);

				double tmp = 0;
				if (Debug_Enable == true)
				{
					ret = dm->PMUMeasure(Drive_Pin_P, DM_CONST_MEASURECURRENT, tmp);
					CheckError(ret, __LINE__);
				}

				// Drive N
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, Drive_N);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					ret = dm->PMUMeasure(Drive_Pin_N, DM_CONST_MEASURECURRENT, tmp);
					CheckError(ret, __LINE__);
				}
			
				_util->Wait_Sec(Measure_Delay_s);

				// Measure P
				{
					ret = DriveMuxIO(TPDispName[i+(i*2)], 1);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);

					//ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, reading[c]);
					//CheckError(ret, __LINE__);

					ret = smu->ReadVoltage("MTX_SMU_2", reading[c]);
					CheckError(ret, __LINE__);

					reading[c] = ((reading[c]-c1)/m);

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) || 
						((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i+(i*2)]->Contains("HR1"))))
					{
						reading[c] = -1 * reading[c];
					}

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
				}
				
				c++;								
				
				// Measure N
				{
					ret = DriveMuxIO(TPDispName[i+(i*2)], 2);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);
					
					//ret = dm->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, reading[c]);
					//CheckError(ret, __LINE__);

					ret = smu->ReadVoltage("MTX_SMU_2", reading[c]);
					CheckError(ret, __LINE__);

					reading[c] = ((reading[c]-c1)/m);

					if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i+(i*2)]->Contains("HR0")))
					{
						reading[c] = -1 * reading[c];
					}

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
				}
				
				c++;
			}
			
			vp_ip = reading[0];
			vn_ip = reading[1];
			vp_in = reading[2];
			vn_in = reading[3];

			iforce_hi = Drive_Current_Hi_A;
			iforce_lo = Drive_Current_Lo_A;
			iforce_diff = Math::Abs(Drive_Current_Hi_A - Drive_Current_Lo_A);	

			dep_n = ((vn_in * vp_ip / vp_in) - vn_ip) / (iforce_diff * (1 - (vp_ip / vp_in)));
			dep_p = -1 * (vp_in / (iforce_diff + (vn_in / dep_n)));

			rmr_d = (vp_ip - vn_ip) * dep_n / vn_ip;

			dep_d = CONST_Rr1 * rmr_d / (CONST_Rr1 - rmr_d);

			if (_util->IsInf(dep_p))
				dep_p = 1000;

			if (_util->IsInf(dep_n))
				dep_n = 1000;

			if (_util->IsInf(dep_d))
				dep_d = 1000;

			tf_SetResult(TPName[i+(2*i)], dep_p + GetOffset(TPDispName[i+(2*i)]));
			tf_SetResult(TPName[i+(2*i)+1], dep_n + GetOffset(TPDispName[i+(2*i)+1]));
			tf_SetResult(TPName[i+(2*i)+2], dep_d + GetOffset(TPDispName[i+(2*i)+2]));

			if (_glob->contact_fail == 0)
			{
				if ((dep_p + GetOffset(TPDispName[i+(2*i)])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
					continue;
				}	
				
				if ((dep_p + GetOffset(TPDispName[i+(2*i)])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
					continue;
				}

				if ((dep_n + GetOffset(TPDispName[i+(2*i)+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+1])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
					continue;
				}

				if ((dep_n + GetOffset(TPDispName[i+(2*i)+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+1])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
					continue;
				}

				
				if ((dep_d + GetOffset(TPDispName[i+(2*i)+2])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+2])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
					continue;
				}

				if ((dep_d + GetOffset(TPDispName[i+(2*i)+2])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+2])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
					continue;
				}
			}
		}
		
		//power down
		ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
		CheckError(ret, __LINE__);
				
		ret = dm->ConfigurePMUVoltageLevel(Drive_Pin_N, 0);	
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel(Drive_Pin_P, 0);	
		CheckError(ret, __LINE__);
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("GND_MUX_RST_N", 1); 
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vendor(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		int result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		//Vendor ID
		{
			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("// Vendor ID:");
			}

			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[0], "Vector_File"));

			if (VectorSetNo->ContainsKey(Vector_File))
			{
				ret = dm->RunVector("DM_2", VectorSetNo[Vector_File]);
				//CheckError(ret, __LINE__);
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("RunVector return=" + ret.ToString());
			}
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("AcquireVecEngineStatus return=" + ret.ToString());
				sb->AppendLine("AcquireVecEngineStatus status=" + vector_engine_status.ToString());
			}
					
			if (vector_engine_status == 0)
			{
				ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
				}

				ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
				CheckError(ret, __LINE__);
				result = (data >> 6) & 0x3;

				if (Debug_Enable == true)
				{
					sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
				}
			}
			else
			{
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
				//result = -999;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("Result=" + result.ToString());
			}

			tf_SetResult(TPName[0], result + (int)GetOffset(TPDispName[0]));
		}

		//Family ID
		{
			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("// Family ID:");
			}

			if (vector_engine_status == 0)
			{
				result = data & 0x3F;
			}
			else
			{
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
				//result = -999;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("Result=" + result.ToString());
			}

			tf_SetResult(TPName[1], result + (int)GetOffset(TPDispName[1]));
		}

		//Revision
		{		
			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("// Revision:");
			}

			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[2], "Vector_File"));

			if (VectorSetNo->ContainsKey(Vector_File))
			{
				ret = dm->RunVector("DM_2", VectorSetNo[Vector_File]);
				//CheckError(ret, __LINE__);
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("RunVector return=" + ret.ToString());
			}
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("AcquireVecEngineStatus return=" + ret.ToString());
				sb->AppendLine("AcquireVecEngineStatus status=" + vector_engine_status.ToString());
			}
					
			if (vector_engine_status == 0)
			{
				ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
				}

				ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
				CheckError(ret, __LINE__);
				result = (data) & 0xF;

				if (Debug_Enable == true)
				{
					sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
				}
			}
			else
			{
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
				//result = -999;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("Result=" + result.ToString());
			}

			tf_SetResult(TPName[2], result + (int)GetOffset(TPDispName[2]));
		}

		//FAB
		{
			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("// FAB:");
			}

			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[3], "Vector_File"));

			if (VectorSetNo->ContainsKey(Vector_File))
			{
				ret = dm->RunVector("DM_2", VectorSetNo[Vector_File]);
				//CheckError(ret, __LINE__);
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("RunVector return=" + ret.ToString());
			}
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("AcquireVecEngineStatus return=" + ret.ToString());
				sb->AppendLine("AcquireVecEngineStatus status=" + vector_engine_status.ToString());
			}
					
			if (vector_engine_status == 0)
			{
				ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
				}

				ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
				CheckError(ret, __LINE__);
				result = data & 0xFF;

				if (Debug_Enable == true)
				{
					sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
				}
			}
			else
			{
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
				//result = -999;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("Result=" + result.ToString());
			}

			tf_SetResult(TPName[3], result + (int)GetOffset(TPDispName[3]));
		}
		#else	

		//Use SPI commands
		if(0)
		{	
			//Hardcoded
			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_clk_divider = (int)(200e6/spi_clk_freq - 1);
			int cpol = 0;
			int cpha = 0;
			int spi_status = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
			CheckError(ret, __LINE__);
			ret = dm->SPI_NCS_ACTIVE_STATE("DM_2", spi_group, DM_CONST_SPI_NCS_ACTIVE_HIGH);
			CheckError(ret, __LINE__);
			ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
			CheckError(ret, __LINE__);
			ret = dm->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
			CheckError(ret, __LINE__);

			////////////////////////////////
			//vendor (read_p1_reg0)
			////////////////////////////////

			spi_data[0]		= 0x3008000; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
			spi_data_dir[0] = 0x00000ff; 
			spi_wr_byte_length = 1;

			ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
			CheckError(ret, __LINE__);

			spi_status = 0;
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}

			if (spi_status == 2)
			{
				ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
				CheckError(ret, __LINE__);

				for (int k=0; k<spi_rd_byte_length; k++)
				{
					if (spi_rd_biterror[k] == 0)
					{
						data = _util->SwapBitSequence(spi_rd_data[k], CONST_SERIAL_DATA_WIDTH);

						result = (data >> 6) & 0x3;
					}
					else
					{
						result = -999;
					}
				}
			}

			tf_SetResult(TPName[0], result + (int)GetOffset(TPDispName[0]));

			////////////////////////////////
			//Family ID
			////////////////////////////////
			if (spi_status == 2)
			{
				result = data & 0x3F;
			}
			else
			{
				result = -999;
			}

			tf_SetResult(TPName[1], result + (int)GetOffset(TPDispName[1]));

			////////////////////////////////
			//Revision
			////////////////////////////////

			spi_data[0]		= 0x300A000; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
			spi_data_dir[0] = 0x00000ff; 
			spi_wr_byte_length = 1;

			ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
			CheckError(ret, __LINE__);

			spi_status = 0;
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}

			if (spi_status == 2)
			{
				ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
				CheckError(ret, __LINE__);

				for (int k=0; k<spi_rd_byte_length; k++)
				{
					if (spi_rd_biterror[k] == 0)
					{
						data = _util->SwapBitSequence(spi_rd_data[k], CONST_SERIAL_DATA_WIDTH);

						result = (data) & 0xF;
					}
					else
					{
						result = -999;
					}
				}
			}
			

			tf_SetResult(TPName[2], result + (int)GetOffset(TPDispName[2]));

			////////////////////////////////
			//Fab
			////////////////////////////////

			spi_data[0]		= 0x300DA00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
			spi_data_dir[0] = 0x00000ff; 
			spi_wr_byte_length = 1;

			ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
			CheckError(ret, __LINE__);

			spi_status = 0;
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}

			if (spi_status == 2)
			{
				ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
				CheckError(ret, __LINE__);

				for (int k=0; k<spi_rd_byte_length; k++)
				{
					if (spi_rd_biterror[k] == 0)
					{
						data = _util->SwapBitSequence(spi_rd_data[k], CONST_SERIAL_DATA_WIDTH);

						result = data & 0xFF;
					}
					else
					{
						result = -999;
					}
				}
			}

			tf_SetResult(TPName[3], result + (int)GetOffset(TPDispName[3]));

			ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
			CheckError(ret, __LINE__);
		}
		else
		{
			// SPI method
			{
				ret = OnOffSPI(1);
				CheckError(ret, __LINE__);

				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[0], "Vector_File"));
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);
				
				result = (data >> 6) & 0x3;
		
				if (Debug_Enable == true)
				{
					sb->AppendLine("Result=" + result.ToString());
				}

				tf_SetResult(TPName[0], result + (int)GetOffset(TPDispName[0]));
			}

			//Family ID
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// Family ID:");
				}

				result = data & 0x3F;
				
				if (Debug_Enable == true)
				{
					sb->AppendLine("Result=" + result.ToString());
				}

				tf_SetResult(TPName[1], result + (int)GetOffset(TPDispName[1]));
			}

			//Revision
			{		
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// Revision:");
				}

				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[2], "Vector_File"));
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result = (data) & 0xF;

				if (Debug_Enable == true)
				{
					sb->AppendLine("Result=" + result.ToString());
				}

				tf_SetResult(TPName[2], result + (int)GetOffset(TPDispName[2]));
			}

			//FAB
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// FAB:");
				}

				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[3], "Vector_File"));
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);
				
				result = data & 0xFF;

				if (Debug_Enable == true)
				{
					sb->AppendLine("Result=" + result.ToString());
				}

				tf_SetResult(TPName[3], result + (int)GetOffset(TPDispName[3]));
				ret = OnOffSPI(0);
				CheckError(ret, __LINE__);
			}
			

		}
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_hsd_cont(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		int i = 0;
		for (i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		bool Debug_Enable		= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Test_Pin			= String::Empty;

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		//ret = SetupDigital(site);
		//CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power Supplies Setup
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Current_A=" + Drive_Current_A.ToString());
			sb->AppendLine("Clamp_Voltage_V=" + Clamp_Voltage_V.ToString());
		}

		for (i=0; i<total_tp; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}
				
				ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	Force return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUSamplingTime return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUOutputFunction return=" + ret.ToString());
				}

				if (Clamp_Voltage_V < 0)
					ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
				else 
					ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);

				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUVoltageLimit return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				ret = dm->DPINOn(Test_Pin);
				CheckError(ret, __LINE__);
			}
		}

		_util->Wait_Sec(On_Delay_s);

		for (i=0; i<total_tp; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}
				
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUCurrentLevel return=" + ret.ToString());
				}
			}
		}

		_util->Wait_Sec(Measure_Delay_s);

		for (i=0; i<total_tp; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}
				
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (Debug_Enable == true)
				{
					sb->AppendLine("	PMUMeasure voltage (res=" + result + ") return=" + ret.ToString());

					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, meas_curr);
					CheckError(ret, __LINE__);
					sb->AppendLine("	PMUMeasure current (res=" + meas_curr + ") return=" + ret.ToString());
				}

				if (_glob->contact_fail == 0)
				{
					if ((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}

					if ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}
				}
			}
		}

		for (i=0; i<total_tp; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
				
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				ret = dm->DPINOff(Test_Pin);
				CheckError(ret, __LINE__);
			}
		}
		
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_supply_cont(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		bool isCurrentTPBypassed	= false; 
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_A	= 0;
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Test_Pin			= String::Empty;

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		//ret = SetupDigital(site);
		//CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = DriveCBit(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = DriveMuxIO(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//ret = InitPowerSupplies(); //to discharge cap
		//CheckError(ret, __LINE__);

		//ret = smu->Reset("AM_0");
		//CheckError(ret, __LINE__);

		//ret = smu->Reset("AM_1");
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = OnOffCbit(CBIT_VCC_FORWARD, 0);
		CheckError(ret, __LINE__);
		ret = OnOffCbit(CBIT_VEE_FORWARD, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.01);

		if (Debug_Enable == true)
		{
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Current_A=" + Drive_Current_A.ToString());
			sb->AppendLine("Clamp_Voltage_V=" + Clamp_Voltage_V.ToString());
		}

		int i = 0;

		for (i=0; i<total_tp; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
				Drive_Current_A = (double)(tf_TPCondition_Cast(TPName[0], "Drive_Current_A"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePLF (" + Power_Line_Freq + ") return=" + ret.ToString());
				}

				ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				
				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigureSamplingTime (" + NPLC + ") return=" + ret.ToString());
				}
				
				ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ClampVoltage (" + Clamp_Voltage_V + "V) return=" + ret.ToString());
				}

				ret = smu->DriveCurrent(Test_Pin, 0, 0);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	DriveCurrent (0A) return=" + ret.ToString());
				}

				ret = smu->OnSmuPin(Test_Pin, false, false);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	OnSmuPin return=" + ret.ToString());
				}

				_util->Wait_Sec(On_Delay_s);

				if (Drive_Current_A < 0)
					ret = smu->DriveCurrent(Test_Pin, Math::Abs(Drive_Current_A));
				else
					ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);

				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	DriveCurrent (" + Drive_Current_A + "A) return=" + ret.ToString());
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu->ReadVoltage(Test_Pin, result);
				CheckError(ret, __LINE__);

				if (Drive_Current_A < 0)
					result = -1 * result;

				if (Test_Pin == "VEE")
					result = -1 * result;

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ReadVoltage return=" + ret.ToString());
					sb->AppendLine("	ReadVoltage voltage (res=" + result + ") return=" + ret.ToString());

					ret = smu->ReadCurrent(Test_Pin, result);
					CheckError(ret, __LINE__);
					sb->AppendLine("	ReadCurrent return=" + ret.ToString());
					sb->AppendLine("	ReadCurrent voltage (res=" + result + ") return=" + ret.ToString());
				}

				ret = smu->DriveCurrent(Test_Pin, 0);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(On_Delay_s);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	DriveCurrent (0A) return=" + ret.ToString());
				}		

				ret = smu->OffSmuPin(Test_Pin);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	OffSmuPin return=" + ret.ToString());
				}

				if (_glob->contact_fail == 0)
				{
					if ((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h = 1;
						_glob->contact_fail = 1;
						continue;
					}

					if ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h = 0;
						_glob->contact_fail = 1;
						continue;
					}
				}
			}
		}

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = ResetCBit();
		//CheckError(ret, __LINE__);
		//ret = ResetMuxIO();
		//CheckError(ret, __LINE__);

		ret = OnOffCbit(CBIT_VCC_FORWARD, 1);
		CheckError(ret, __LINE__);
		ret = OnOffCbit(CBIT_VEE_FORWARD, 1);
		CheckError(ret, __LINE__);

		ret = InitPowerSupplies();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_analog_rd_cont(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		double rdp = 0.0;
		double rdn = 0.0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Drive_Pin_Hi		= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_Hi"));
		String ^ Drive_Pin_Lo		= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_Lo"));
		String ^ Measure_Pin_Hi		= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_Hi"));
		String ^ Measure_Pin_Lo		= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_Lo"));

		unsigned int moduleType_DriveHi = 0;
		unsigned int moduleType_DriveLo = 0;
		unsigned int moduleType_MeasureHi = 0;
		unsigned int moduleType_MeasureLo = 0;

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Power Supplies Setup
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Current_Hi_A=" + Drive_Current_Hi_A.ToString());
			sb->AppendLine("Drive_Current_Lo_A=" + Drive_Current_Lo_A.ToString());
			sb->AppendLine("Clamp_Voltage_V=" + Clamp_Voltage_V.ToString());

			sb->AppendLine("Drive_Pin_Hi=" + Drive_Pin_Hi);
			sb->AppendLine("Drive_Pin_Lo=" + Drive_Pin_Lo);
			sb->AppendLine("Measure_Pin_Hi=" + Measure_Pin_Hi);
			sb->AppendLine("Measure_Pin_Lo=" + Measure_Pin_Lo);
		}

		ret = dm->DPINOff("SPE");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPD");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp/2; i++) //for every depmos measurement for RDxP/N pair, we get 2 results
		{
			TPName[i] = tf_TestParameter_Name(i);

			ret = DriveCBit(TPDispName[i]);
			CheckError(ret, __LINE__);
			ret = DriveMuxIO(TPDispName[i]);
			CheckError(ret, __LINE__);

			ret = DriveCBit(TPDispName[i+1]);
			CheckError(ret, __LINE__);
			ret = DriveMuxIO(TPDispName[i+1]);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
			}
		
			// Check whether resource is SMU or DM
			try
			{
				ret = smu->QueryModuleType(Drive_Pin_Hi, moduleType_DriveHi);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_DriveHi = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin_Hi module type=" + moduleType_DriveHi.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Drive_Pin_Lo, moduleType_DriveLo);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_DriveLo = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin_Lo module type=" + moduleType_DriveLo.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin_Hi, moduleType_MeasureHi);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureHi = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin_Hi module type=" + moduleType_MeasureHi.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin_Lo, moduleType_MeasureLo);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureLo = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin_Lo module type=" + moduleType_MeasureLo.ToString("X"));
			}

			// Configure Hi
			if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin_Hi, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_Hi_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUSamplingTime(Drive_Pin_Hi, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);

				ret = dm->DPINOn(Drive_Pin_Hi);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Drive_Pin_Hi, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin_Hi, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin_Hi != Drive_Pin_Hi)
			{
				if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_Hi, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_Hi_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_Hi, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_Hi, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_Hi);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ConfigureSamplingTime(Measure_Pin_Hi, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_Hi, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_Hi, false, false);
					CheckError(ret, __LINE__);
				}
			}

			// Configure Lo
			if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin_Lo, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_Lo_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Drive_Pin_Lo, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Drive_Pin_Lo);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Drive_Pin_Lo, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin_Lo, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin_Lo != Drive_Pin_Lo)
			{
				if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_Lo, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_Lo_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_Lo, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_Lo, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_Lo);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ConfigureSamplingTime(Measure_Pin_Lo, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_Lo, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_Lo, false, false);
					CheckError(ret, __LINE__);
				}
			}

			_util->Wait_Sec(On_Delay_s);

			// Drive Hi
			if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, Drive_Current_Hi_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					ret = dm->PMUMeasure(Drive_Pin_Hi, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin_Hi, Drive_Current_Hi_A);
				CheckError(ret, __LINE__);
			}

			// Drive Lo
			if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, Drive_Current_Lo_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					ret = dm->PMUMeasure(Drive_Pin_Lo, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin_Lo, Drive_Current_Lo_A);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(Measure_Delay_s);

			// Measure

			if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin_Hi, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin_Hi, result);
				CheckError(ret, __LINE__);
			}

			tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}

			if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin_Lo, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin_Lo, result);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
			}

			tf_SetResult(TPName[i+1], result + GetOffset(TPDispName[i+1]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
	
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_mux_cont_diff(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Drive_Pin_Hi		= String::Empty;
		String ^ Drive_Pin_Lo		= String::Empty;
		String ^ Measure_Pin_Hi		= String::Empty;
		String ^ Measure_Pin_Lo		= String::Empty;
		
		unsigned int moduleType_DriveHi = 0;
		unsigned int moduleType_DriveLo = 0;
		unsigned int moduleType_MeasureHi = 0;
		unsigned int moduleType_MeasureLo = 0;

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		//ret = SetupDigital(site);
		//CheckError(ret, __LINE__);

		//if (Test == TEST_IF4600_PKG)
		//{
		//	ret = DriveDIOPin(TPDispName[0]);
		//	CheckError(ret, __LINE__);
		//}
		
		//Power Supplies Setup
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Current_Hi_A=" + Drive_Current_Hi_A.ToString());
			sb->AppendLine("Drive_Current_Lo_A=" + Drive_Current_Lo_A.ToString());
			sb->AppendLine("Clamp_Voltage_V=" + Clamp_Voltage_V.ToString());
		}

		ret = dm->DPINOff("SPE");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPD");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPC");
		CheckError(ret, __LINE__);

		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		for (int i=0; i<total_tp; i=i+2) //for every measurement for P/N pair, we get 2 results
		{
			TPName[i] = tf_TestParameter_Name(i);

			ret = DriveCBit(TPDispName[i]);
			CheckError(ret, __LINE__);
			ret = DriveMuxIO(TPDispName[i]);
			CheckError(ret, __LINE__);

			Drive_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Hi"));
			Drive_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Lo"));
			Measure_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Hi"));
			Measure_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Lo"));

			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("Drive_Pin_Hi=" + Drive_Pin_Hi);
				sb->AppendLine("Drive_Pin_Lo=" + Drive_Pin_Lo);
				sb->AppendLine("Measure_Pin_Hi=" + Measure_Pin_Hi);
				sb->AppendLine("Measure_Pin_Lo=" + Measure_Pin_Lo);
			}
		
			// Check whether resource is SMU or DM
			try
			{
				ret = smu->QueryModuleType(Drive_Pin_Hi, moduleType_DriveHi);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_DriveHi = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin_Hi module type=" + moduleType_DriveHi.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Drive_Pin_Lo, moduleType_DriveLo);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_DriveLo = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin_Lo module type=" + moduleType_DriveLo.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin_Hi, moduleType_MeasureHi);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureHi = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin_Hi module type=" + moduleType_MeasureHi.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin_Lo, moduleType_MeasureLo);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureLo = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin_Lo module type=" + moduleType_MeasureLo.ToString("X"));
			}

			// Configure Hi
			if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin_Hi, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_Hi_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Hi, 0, Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Drive_Pin_Hi, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Drive_Pin_Hi);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Drive_Pin_Hi, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin_Hi, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin_Hi != Drive_Pin_Hi)
			{
				if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_Hi, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_Hi_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_Hi, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_Hi, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_Hi);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->SetBandwidth(Measure_Pin_Hi, 1);
					CheckError(ret, __LINE__);
					ret = smu->ConfigureSamplingTime(Measure_Pin_Hi, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_Hi, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_Hi, false, false);
					CheckError(ret, __LINE__);
				}
			}

			// Configure Lo
			if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin_Lo, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_Lo_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Drive_Pin_Lo, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Drive_Pin_Lo);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->SetBandwidth(Drive_Pin_Lo, 1);
				CheckError(ret, __LINE__);
				ret = smu->ConfigureSamplingTime(Drive_Pin_Lo, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin_Lo, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin_Lo != Drive_Pin_Lo)
			{
				if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_Lo, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_Lo_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_Lo, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_Lo, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_Lo);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->SetBandwidth(Measure_Pin_Lo, 1);
					CheckError(ret, __LINE__);
					ret = smu->ConfigureSamplingTime(Measure_Pin_Lo, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_Lo, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_Lo, false, false);
					CheckError(ret, __LINE__);
				}
			}

			_util->Wait_Sec(On_Delay_s);

			// Drive Hi
			if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, Drive_Current_Hi_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					ret = dm->PMUMeasure(Drive_Pin_Hi, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin_Hi, Drive_Current_Hi_A);
				CheckError(ret, __LINE__);
			}

			// Drive Lo
			if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, Drive_Current_Lo_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					ret = dm->PMUMeasure(Drive_Pin_Lo, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin_Lo, Drive_Current_Lo_A);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(Measure_Delay_s);

			// Measure

			if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin_Hi, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin_Hi, result);
				CheckError(ret, __LINE__);
			}

			tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}

			ret = ResetMuxIO();
			CheckError(ret, __LINE__);
			ret = DriveCBit(TPDispName[i+1]);
			CheckError(ret, __LINE__);
			ret = DriveMuxIO(TPDispName[i+1]);
			CheckError(ret, __LINE__);
	
			_util->Wait_Sec(Measure_Delay_s);

			if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin_Lo, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin_Lo, result);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
			}

			tf_SetResult(TPName[i+1], result + GetOffset(TPDispName[i+1]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}

			result = 0;
		}

		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Power down supplies
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
	
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_mux_cont_se_kelvin(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;
		double Drive_Current_A	= 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Drive_Pin		= String::Empty;
		String ^ Measure_Pin	= String::Empty;
		
		unsigned int moduleType_Drive = 0;
		unsigned int moduleType_Measure = 0;

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//ret = SetupDigital(site);
		//CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		
		//Power Supplies Setup
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		
		if (Debug_Enable == true)
		{
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Current_A=" + Drive_Current_A.ToString());
			sb->AppendLine("Clamp_Voltage_V=" + Clamp_Voltage_V.ToString());
		}

		ret = dm->DPINOff("SPE");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPD");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPC");
		CheckError(ret, __LINE__);

		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		Drive_Current_A = (2/CONST_RhNom)*0.9;

		for (int i=0; i<total_tp; i++) //for every measurement for P/N pair, we get 2 results
		{
			TPName[i] = tf_TestParameter_Name(i);

			ret = DriveCBit(TPDispName[i]);
			CheckError(ret, __LINE__);
			ret = DriveMuxIO(TPDispName[i]);
			CheckError(ret, __LINE__);
			
			String ^ Drive_Pin		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin"));
			String ^ Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));

			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("Drive_Pin=" + Drive_Pin);
				sb->AppendLine("Measure_Pin=" + Measure_Pin);
			}
		
			// Check whether resource is SMU or DM
			try
			{
				ret = smu->QueryModuleType(Drive_Pin, moduleType_Drive);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_Drive = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin module type=" + moduleType_Drive.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin, moduleType_Measure);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_Measure = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin module type=" + moduleType_Measure.ToString("X"));
			}

			// Configure Hi
			if (moduleType_Drive == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin, 0, Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Drive_Pin, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Drive_Pin);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Measure_Pin, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin != Drive_Pin)
			{
				if (moduleType_Measure == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ConfigureSamplingTime(Measure_Pin, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin, true, false);
					CheckError(ret, __LINE__);
				}
			}

			_util->Wait_Sec(On_Delay_s);

			// Drive 
			if (moduleType_Drive == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin, Drive_Current_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					double res1 = 0;
					ret = dm->PMUMeasure(Drive_Pin, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Drive_Pin, DM_CONST_MEASUREVOLTAGE, res1);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin, Drive_Current_A);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(Measure_Delay_s);

			// Measure

			if (moduleType_Measure == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin, result);
				CheckError(ret, __LINE__);
			}
			
			// Power down
			if (moduleType_Drive == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin, 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->DriveCurrent(Drive_Pin, 0);
				CheckError(ret, __LINE__);
			}

			ret = ResetCBit();
			CheckError(ret, __LINE__);
			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}

			result = 0;
		}

		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Power down supplies
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
	
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_analog_fhs_cont(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Drive_Pin_Hi		= String::Empty;
		String ^ Drive_Pin_Lo		= String::Empty;
		String ^ Measure_Pin_Hi		= String::Empty;
		String ^ Measure_Pin_Lo		= String::Empty;

		String ^ Drive_DIO			= String::Empty;
		
		unsigned int moduleType_DriveHi = 0;
		unsigned int moduleType_DriveLo = 0;
		unsigned int moduleType_MeasureHi = 0;
		unsigned int moduleType_MeasureLo = 0;

		double meas_curr = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		//ret = SetupDigital(site);
		//CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0], 0);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power Supplies Setup
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		
		if (Debug_Enable == true)
		{
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Current_Hi_A=" + Drive_Current_Hi_A.ToString());
			sb->AppendLine("Drive_Current_Lo_A=" + Drive_Current_Lo_A.ToString());
			sb->AppendLine("Clamp_Voltage_V=" + Clamp_Voltage_V.ToString());
		}

		ret = dm->DPINOff("SPE");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPD");
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("SPC");
		CheckError(ret, __LINE__);

		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//
		//_util->Wait_Sec(On_Delay_s);

		for (int i=0; i<total_tp; i=i+2) //for every measurement for P/N pair, we get 2 results
		{
			TPName[i] = tf_TestParameter_Name(i);

			//if (Test == TEST_IF4600_PKG)
			//{
			//	ret = DriveDIOPin(TPDispName[i], 0); //reset
			//	CheckError(ret, __LINE__);
			//	ret = DriveDIOPin(TPDispName[i], 1);
			//	CheckError(ret, __LINE__);
			//	ret = DriveDIOPin(TPDispName[i], 2); //sense
			//	CheckError(ret, __LINE__);
			//}
			//else
			{
				ret = DriveCBit(TPDispName[i]);
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[i]);
				CheckError(ret, __LINE__);

				ret = DriveCBit(TPDispName[i+1]);
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[i+1]);
				CheckError(ret, __LINE__);
			}

			Drive_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Hi"));
			Drive_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Lo"));
			Measure_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Hi"));
			Measure_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Lo"));

			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("Drive_Pin_Hi=" + Drive_Pin_Hi);
				sb->AppendLine("Drive_Pin_Lo=" + Drive_Pin_Lo);
				sb->AppendLine("Measure_Pin_Hi=" + Measure_Pin_Hi);
				sb->AppendLine("Measure_Pin_Lo=" + Measure_Pin_Lo);
			}
		
			// Check whether resource is SMU or DM
			try
			{
				ret = smu->QueryModuleType(Drive_Pin_Hi, moduleType_DriveHi);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_DriveHi = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin_Hi module type=" + moduleType_DriveHi.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Drive_Pin_Lo, moduleType_DriveLo);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_DriveLo = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Drive_Pin_Lo module type=" + moduleType_DriveLo.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin_Hi, moduleType_MeasureHi);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureHi = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin_Hi module type=" + moduleType_MeasureHi.ToString("X"));
			}

			try
			{
				ret = smu->QueryModuleType(Measure_Pin_Lo, moduleType_MeasureLo);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureLo = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Measure_Pin_Lo module type=" + moduleType_MeasureLo.ToString("X"));
			}

			// Configure Hi
			if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin_Hi, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_Hi_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Drive_Pin_Hi, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Drive_Pin_Hi);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Drive_Pin_Hi, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin_Hi, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin_Hi != Drive_Pin_Hi)
			{
				if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_Hi, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_Hi_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_Hi, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_Hi, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_Hi);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ConfigureSamplingTime(Measure_Pin_Hi, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_Hi, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_Hi, false, false);
					CheckError(ret, __LINE__);
				}
			}

			// Configure Lo
			if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Drive_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Drive_Pin_Lo, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				if (Drive_Current_Lo_A > 0)
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
				else
					ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Drive_Pin_Lo, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Drive_Pin_Lo);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Drive_Pin_Lo, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Drive_Pin_Lo, false, false);
				CheckError(ret, __LINE__);
			}

			if (Measure_Pin_Lo != Drive_Pin_Lo)
			{
				if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_Lo, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Drive_Current_Lo_A > 0)
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_Lo, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_Lo, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_Lo);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ConfigureSamplingTime(Measure_Pin_Lo, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_Lo, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_Lo, false, false);
					CheckError(ret, __LINE__);
				}
			}

			_util->Wait_Sec(On_Delay_s);

			// Drive Hi
			if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, Drive_Current_Hi_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					ret = dm->PMUMeasure(Drive_Pin_Hi, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin_Hi, Drive_Current_Hi_A);
				CheckError(ret, __LINE__);
			}

			// Drive Lo
			if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, Drive_Current_Lo_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					double res = 0;
					ret = dm->PMUMeasure(Drive_Pin_Lo, DM_CONST_MEASURECURRENT, res);
					CheckError(ret, __LINE__);
				}
			}
			else //smu
			{
				ret = smu->DriveCurrent(Drive_Pin_Lo, Drive_Current_Lo_A);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(Measure_Delay_s);

			// Measure

			if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin_Hi, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin_Hi, result);
				CheckError(ret, __LINE__);
			}

			tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Measure_Pin_Lo, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ReadVoltage(Measure_Pin_Lo, result);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Hi, 0);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Drive_Pin_Lo, 0);
				CheckError(ret, __LINE__);
			}

			tf_SetResult(TPName[i+1], result + GetOffset(TPDispName[i+1]));

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
				{
					_glob->contact_open_l_short_h = 1;
					_glob->contact_fail = 1;
				}
			}

			if (_glob->contact_fail == 0)
			{
				if ((result + GetOffset(TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
				{
					_glob->contact_open_l_short_h = 0;
					_glob->contact_fail = 1;
				}
			}

			//if (Test == TEST_IF4600_PKG)
			//{
			//	ret = ResetDIOPin(TPDispName[i]);
			//	CheckError(ret, __LINE__);
			//	ret = ResetDIOPin(TPDispName[i], 2);
			//	CheckError(ret, __LINE__);
			//}
			//else
			{
				ret = ResetCBit();
				CheckError(ret, __LINE__);
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
			}

			result = 0;
		}

		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Power down supplies
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
	
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_input_leakage(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));
		double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));

		String ^ Test_Pin			= String::Empty;

		double meas_volt = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		//IO setting
		//ret = SetupDigital(site);
		//CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power Supplies Setup
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Voltage_V=" + Drive_Voltage_V.ToString());
			sb->AppendLine("Clamp_Current_A=" + Clamp_Current_A.ToString());
		}

		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//
		//_util->Wait_Sec(On_Delay_s);

		int i = 0;

		for (i=0; i<total_tp-1; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}
				
				ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	Force return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUSamplingTime return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUOutputFunction return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Current_A);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUCurrentLimitRange return=" + ret.ToString());
				}

				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin);
				CheckError(ret, __LINE__);
			}
		}

		_util->Wait_Sec(On_Delay_s);

		for (i=0; i<total_tp-1; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}
				
				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Voltage_V);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("	ConfigurePMUVoltageLevel return=" + ret.ToString());
				}
			}
		}

		_util->Wait_Sec(Measure_Delay_s);

		double flag = 0.0;

		for (i=0; i<total_tp-1; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("Test_Pin=" + Test_Pin);
				}

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
				CheckError(ret, __LINE__);

				if (((result + GetOffset(TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i]))) || ((result + GetOffset(TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i]))))
					flag = 1;	
			
				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (Debug_Enable == true)
				{
					sb->AppendLine("	PMUMeasure current (res=" + result + ") return=" + ret.ToString());

					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, meas_volt);
					CheckError(ret, __LINE__);

					sb->AppendLine("	PMUMeasure voltage (res=" + meas_volt + ") return=" + ret.ToString());
				}
			}
		}

		tf_SetResult(TPName[total_tp-1], flag);
			
		for (i=0; i<total_tp-1; i++)
		{
			TPName[i] = tf_TestParameter_Name(i);

			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
				
				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);
			}
		}

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_supply_leakage(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Clamp_Current_A  = (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
		double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

		String ^ Test_Pin			= String::Empty;

		double meas_voltage = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("On_Delay_s=" + On_Delay_s.ToString());
			sb->AppendLine("Measure_Delay_s=" + Measure_Delay_s.ToString());
			sb->AppendLine("NPLC=" + NPLC.ToString());
			sb->AppendLine("Drive_Voltage_V=" + Drive_Voltage_V.ToString());
			sb->AppendLine("Clamp_Current_A=" + Clamp_Current_A.ToString());
		}

		ret = smu->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VCC ConfigureSamplingTime (" + NPLC + ") return=" + ret.ToString());
		}

		ret = smu->ClampCurrent("VCC", Clamp_Current_A);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VCC ClampCurrent (" + Clamp_Current_A + "A) return=" + ret.ToString());
		}

		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("	VCC DriveVoltage (0V) return=" + ret.ToString());
		//}

		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("	VCC OnSmuPin return=" + ret.ToString());
		//}

		ret = smu->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VEE ConfigureSamplingTime (" + NPLC + ") return=" + ret.ToString());
		}

		ret = smu->ClampCurrent("VEE", Clamp_Current_A);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VEE ClampCurrent (" + Clamp_Current_A + "A) return=" + ret.ToString());
		}

		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("	VEE DriveVoltage (0V) return=" + ret.ToString());
		//}

		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("	VEE OnSmuPin return=" + ret.ToString());
		//}

		//_util->Wait_Sec(On_Delay_s);

		ret = smu->DriveVoltage("VCC", Drive_Voltage_V);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VCC DriveVoltage (" + Drive_Voltage_V + "V) return=" + ret.ToString());
		}

		_util->Wait_Sec(Measure_Delay_s);

		ret = smu->ReadCurrent("VCC", result);
		CheckError(ret, __LINE__);

		tf_SetResult(TPName[0], result + GetOffset(TPDispName[0]));
		tf_SetResult(TPName[2], result + GetOffset(TPDispName[2]));

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VCC ReadCurrent return=" + ret.ToString());
			sb->AppendLine("	VCC ReadCurrent voltage (res=" + result + ") return=" + ret.ToString());

			ret = smu->ReadVoltage("VCC", result);
			CheckError(ret, __LINE__);
			sb->AppendLine("	VCC ReadVoltage return=" + ret.ToString());
			sb->AppendLine("	VCC ReadVoltage voltage (res=" + result + ") return=" + ret.ToString());
		}

		ret = smu->ClampCurrent("VCC", 10e-3);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VCC DriveVoltage (0V) return=" + ret.ToString());
		}

		_util->Wait_Sec(On_Delay_s);

		//VEE

		ret = smu->DriveVoltage("VEE", Drive_Voltage_V);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VEE DriveVoltage (" + Drive_Voltage_V + "V) return=" + ret.ToString());
		}

		_util->Wait_Sec(Measure_Delay_s);

		ret = smu->ReadCurrent("VEE", result);
		CheckError(ret, __LINE__);

		result = -1 * result;

		tf_SetResult(TPName[1], result + GetOffset(TPDispName[1]));
		tf_SetResult(TPName[3], result + GetOffset(TPDispName[3]));

		if (Debug_Enable == true)
		{
			sb->AppendLine("	VEE ReadCurrent return=" + ret.ToString());
			sb->AppendLine("	VEE ReadCurrent voltage (res=" + result + ") return=" + ret.ToString());

			ret = smu->ReadVoltage("VEE", result);
			CheckError(ret, __LINE__);
			sb->AppendLine("	VEE ReadVoltage return=" + ret.ToString());
			sb->AppendLine("	VEE ReadVoltage voltage (res=" + result + ") return=" + ret.ToString());
		}

		ret = smu->ClampCurrent("VEE", 10e-3);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);

		ret = smu->ClampCurrent("VCC", 0.5);
		CheckError(ret, __LINE__);

		ret = smu->ClampCurrent("VEE", 0.5);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		//Off

		//ret = smu->OffSmuPin("VEE");
		//CheckError(ret, __LINE__);

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("	VEE OffSmuPin return=" + ret.ToString());
		//}

		//ret = smu->OffSmuPin("VCC");
		//CheckError(ret, __LINE__);

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("	VCC OffSmuPin return=" + ret.ToString());
		//}

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = ResetDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = ResetCBit();
		//CheckError(ret, __LINE__);
		//ret = ResetMuxIO();
		//CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}	

		return ret;
	}

	int TestProgram::seq_open_short(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName		= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName	= gcnew array<String ^>(total_tp);
		int result = 0;

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Check for short
		result = 0;

		if (_glob->contact_fail == 1)
		{
			if (_glob->contact_open_l_short_h == 1)
			{
				result = 1;
			}
		}

		tf_SetResult(TPName[0], result + (int)GetOffset(TPDispName[0]));
		
		//Check for open
		result = 0;

		if (_glob->contact_fail == 1)
		{
			if (_glob->contact_open_l_short_h == 0)
			{
				result = 1;
			}
		}

		tf_SetResult(TPName[1], result + (int)GetOffset(TPDispName[1]));

		return 0;
	}
	//
	int TestProgram::seq_serial_pwrup(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_20"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_20"][testSite];

		int result				= 0;

		int Total_Fail_Count = 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}
		
		//_util->Wait_Sec(On_Delay_s);

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		ret = dm->AcquireVectorFailCount("DM_2", result);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
			sb->AppendLine("AcquireVectorFailCount=" + result.ToString());

			int First_Fail_Vector_Count = 0;
			if (result > 0)
			{
				ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
				CheckError(ret, __LINE__);
				sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
			}
		}

		Total_Fail_Count = result;

		if (Debug_Enable == true)
		{
			sb->AppendLine("Total fail count=" + Total_Fail_Count.ToString());
		}

		if (Total_Fail_Count == 0)
			Total_Fail_Count = 1;
		else
			Total_Fail_Count = 0;

		tf_SetResult(TPName[0], Total_Fail_Count + (int)GetOffset(TPDispName[0]));

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);

		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_serial_ck_brd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][testSite];

		int result				= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V"))
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
					ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V"))
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));
					ret = smu->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);
				}
				
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = dm->AcquireVectorFailCount("DM_2", result);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
					sb->AppendLine("AcquireVectorFailCount=" + result.ToString());

					int First_Fail_Vector_Count = 0;
					if (result > 0)
					{
						ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
						CheckError(ret, __LINE__);
						sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
					}
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("Total fail count=" + result.ToString());
				}

				if (result == 0)
					result = 1;
				else
					result = 0;

				tf_SetResult(TPName[i], result + (int)GetOffset(TPDispName[i]));
			
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_drive_gnd_fets(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		ret = OnOffFETGnd(1);		
		CheckError(ret, __LINE__);

		return ret;
	}

	int TestProgram::seq_reset_gnd_fets(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		ret = OnOffFETGnd(0);
		CheckError(ret, __LINE__);

		return ret;
	}

	int TestProgram::seq_serial_ck_brd_level(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File1	= (String ^)(tf_TestItemCondition_Cast("Vector_File1"));

		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_100"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_100"][testSite];

		double IO_Level_V = (double)(tf_TestItemCondition_Cast("IO_Level_V"));

		int result				= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//init_sif_tool

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		//Run checker board setup

		ret = RunVectorFile(Vector_File1);
		CheckError(ret, __LINE__);

		vih = IO_Level_V;
        vil = 0.0;
        voh = IO_Level_V/2/2; //Since we have input termination on (50-ohm to GND), Voh will be halved
        vol = IO_Level_V/2/2;
		vt  = 0.0;

		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s); 
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V"))
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
					ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V"))
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));
					ret = smu->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);
				}
				
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				
				ret = dm->AcquireVectorFailCount("DM_2", result);
				CheckError(ret, __LINE__);
				
				if (Debug_Enable == true)
				{
					sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
					sb->AppendLine("AcquireVectorFailCount=" + result.ToString());

					int First_Fail_Vector_Count = 0;
					if (result > 0)
					{
						ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
						CheckError(ret, __LINE__);
						sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
					}
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("Total fail count=" + result.ToString());
				}

				if (result == 0)
					result = 1;
				else
					result = 0;

				tf_SetResult(TPName[i], result + (int)GetOffset(TPDispName[i]));
				
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_dig_vol_voh(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Drive_Current_A  = 0;
		
		int Global_Result_Index = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int Drive_WRN_V			= 0;
		String ^ Test_Pin		= String::Empty;
		String ^ Vector_File_Prev = String::Empty;

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Chx via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Chx via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	
		
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigurePEAttribute("SPD", 1, 0, 1, 0); //Enable active load 
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0);  
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//init_sif_tool

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif
		
		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin")); 
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				Drive_WRN_V = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WRN_V"));
				Drive_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Current_A"));

				if (Vector_File != Vector_File_Prev)
				{
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);

					Vector_File_Prev = Vector_File;
				}

				ret = dm->DrivePin("RWN", Drive_WRN_V);
				CheckError(ret, __LINE__);

				ret = dm->DPINOff(Test_Pin);
				CheckError(ret, __LINE__);
				ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin, DM_CONST_VMAX, DM_CONST_VMIN);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					_util->SampleRes("dig_vol_voh", 0, result, "");
				}
				
				#ifdef USE_GNDS
				double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				ret = smu->ReadVoltage("GND_MUX_SENSE", volt); 
				CheckError(ret, __LINE__);
				result = result - volt;
				#endif

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

					_glob->Global_Result[Global_Result_Index] = result;
				}

				ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_VECTOR);	
				CheckError(ret, __LINE__);
			}
		}

		if (Debug_Enable == true)
		{
			_util->SampleRes("dig_vol_voh", 0, result, "");
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		
		//IO setting
		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_math(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		bool isCurrentTPBypassed = false;

		double result = 0;

		//Get test condition from techFlow
		String ^ Global_Result_Index_A	= String::Empty;
		String ^ Global_Result_Index_B	= String::Empty;
		String ^ Operation			= String::Empty;

		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

				if (Operation == "A-B")
				{
					Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
					Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));

					int A = 0;
					int B = 0;

					A = _util->StrToInt(Global_Result_Index_A);
					B = _util->StrToInt(Global_Result_Index_B);

					result = _glob->Global_Result[A] - _glob->Global_Result[B];

					tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
				}

				else if (Operation == "MAX[A]-MIN[B]")
				{
					Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
					Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));

					double max = 0;
					double min = 0;

					ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

					for (int j=0; j<ArrStr->Length; j++)
					{
						if (j == 0)
						{
							max = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
						else
						{
							if (max < _glob->Global_Result[_util->StrToInt(ArrStr[j])])
								max = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
					}

					ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);

					for (int j=0; j<ArrStr->Length; j++)
					{
						if (j == 0)
						{
							min = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
						else
						{
							if (min > _glob->Global_Result[_util->StrToInt(ArrStr[j])])
								min = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
					}

					result = max - min;

					tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
				}

				else if (Operation == "MAX[A]-MIN[A]")
				{
					Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));

					double max = 0;
					double min = 0;

					ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

					for (int j=0; j<ArrStr->Length; j++)
					{
						if (j == 0)
						{
							max = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
						else
						{
							if (max < _glob->Global_Result[_util->StrToInt(ArrStr[j])])
								max = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
					}

					ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

					for (int j=0; j<ArrStr->Length; j++)
					{
						if (j == 0)
						{
							min = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
						else
						{
							if (min > _glob->Global_Result[_util->StrToInt(ArrStr[j])])
								min = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
						}
					}

					result = Math::Abs(max - min);

					tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
				}
			}
		}

		return ret;
	}

	//int TestProgram::seq_digfunc(Site ^ site)
	//{
	//	if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

	//	int ret = 0;

	//	//Get test name from techFlow
	//	int total_tp = (int)tf_TPCount();
	//	array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//	array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//	array<String ^> ^ Vector_File = gcnew array<String ^>(total_tp);
	//	array<int> ^ data_pg1 = gcnew array<int>(32);
	//	array<int> ^ data_pg2 = gcnew array<int>(32);
	//	array<int> ^ data_pg4 = gcnew array<int>(32);

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		TPDispName[i] = tf_TestParameter_DisplayName(i);
	//		TPName[i] = tf_TestParameter_Name(i);
	//	}

	//	String ^ TIDispName = tf_TestItem_DisplayName();

	//	//Get test condition from techFlow
	//	int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//	double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//	double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//	double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//	double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//	double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//	Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//	double Input_Channel_Delay_s = 0;
	//	double Input_Channel_Delay_norm_s = 0;
	//	bool isCurrentTPBypassed = false;

	//	if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
	//		Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][testSite];

	//	if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//		Input_Channel_Delay_norm_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

	//	double _Input_Channel_Delay_s = 0;

	//	int result				= 0;

	//	if (Debug_Enable == true)
	//	{
	//		sb = gcnew StringBuilder();
	//		sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
	//	}
	//			
	//	double vih;
 //       double vil;
 //       double voh; 
 //       double vol;
 //       double ioh;
	//	double iol;
 //       double vch;
 //       double vcl;
	//	double vt;
	//	
	//	int vector_engine_status = 0;
	//	int data = 0;

	//	Stopwatch swatch;

	//	//IO setting
	//	ret = SetupDigital(site);
	//	CheckError(ret, __LINE__);
	//	//ret = DriveDIOPin(TPDispName[0]);
	//	//CheckError(ret, __LINE__);
	//	ret = DriveCBit(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = DriveMuxIO(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	
	//	//Setup Power supplies
	//	//ret = smu->SetBandwidth("VCC", Bandwidth);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->DriveVoltage("VCC", 0);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->OnSmuPin("VCC", true, false);
	//	//CheckError(ret, __LINE__);

	//	//ret = smu->SetBandwidth("VEE", Bandwidth);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->DriveVoltage("VEE", 0);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->OnSmuPin("VEE", true, false);
	//	//CheckError(ret, __LINE__);
	//	//_util->Wait_Sec(0.001);

	//	ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
	//	CheckError(ret, __LINE__);
	//	ret = smu->DriveVoltage("VEE", Drive_Vee_V);
	//	CheckError(ret, __LINE__);
	//	//_util->Wait_Sec(On_Delay_s);

	//	vih = 2.5;
 //       vil = 0.00;
 //       voh = 0.75; 
 //       vol = 0.75;
 //       ioh = 0.002;
	//	iol = 0.002;
 //       vch = 6;
 //       vcl = -0.1;
	//	vt = 0;

	//	ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPE");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPD");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPC");
	//	CheckError(ret, __LINE__);

	//	ret = DriveDMPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("RWN");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("PWR_SAVE", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("PWR_SAVE", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("PWR_SAVE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("PWR_SAVE");
	//	CheckError(ret, __LINE__);

	//	//_util->Wait_Sec(On_Delay_s);

	//	if (Debug_Enable == true)
	//	{
	//		sb->AppendLine("-----------------------------------------------------------------------");
	//		sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
	//		sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
	//		sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("On_Delay_s=" + On_Delay_s);
	//	}


	//	ret = RunVectorFile("write_default_digfunc");
	//	CheckError(ret, __LINE__);

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		Vector_File [i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	//	}

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

	//		if (isCurrentTPBypassed == false)
	//		{
	//			if (Debug_Enable == true)
	//			{
	//				sb->AppendLine("-----------------------------------------------------------------------");
	//				sb->AppendLine("// " + TPDispName[i]);
	//			}

	//			if(Vector_File[i] == "all")
	//			{
	//				int temp = 0;
	//				for(int j=1; j<total_tp; j++)
	//				{
	//					if (Vector_File[j] == "digfunc_modes_ext_0" || Vector_File[j] == "digfunc_modes_ext_1")
	//					{
	//						_Input_Channel_Delay_s = 0;
	//					}
	//					else
	//					{
	//						_Input_Channel_Delay_s = Input_Channel_Delay_s;
	//					}

	//					ret = dm->ConfigureInputChannelDelay("SPD", _Input_Channel_Delay_s);
	//					CheckError(ret, __LINE__);
	//	
	//					ret = RunVectorFile(Vector_File[j]);
	//					CheckError(ret, __LINE__);
	//					ret = dm->AcquireVectorFailCount("DM_2", temp);
	//					CheckError(ret, __LINE__);
	//					if (Debug_Enable == true)
	//					{
	//						sb->AppendLine("Vector: " + Vector_File[j] + "\t\tAcquireVectorFailCount= "+ temp );
	//					}

	//					result += temp;
	//				}
	//			}
	//			else
	//			{
	//				ret = RunVectorFile(Vector_File[i]);	
	//				//ret = ReadVector("read_p2_reg48", data);
	//				//ret = ReadVector("read_p2_reg49", data);
	//				//pg1
	//				/*ret = ReadVector("read_p1_reg0", data_pg1[0]);
	//				ret = ReadVector("read_p1_reg1", data_pg1[1]);
	//				ret = ReadVector("read_p1_reg2", data_pg1[2]);
	//				ret = ReadVector("read_p1_reg3", data_pg1[3]);
	//				ret = ReadVector("read_p1_reg4", data_pg1[4]);
	//				ret = ReadVector("read_p1_reg5", data_pg1[5]);
	//				ret = ReadVector("read_p1_reg6", data_pg1[6]);
	//				ret = ReadVector("read_p1_reg7", data_pg1[7]);
	//				ret = ReadVector("read_p1_reg8", data_pg1[8]);
	//				ret = ReadVector("read_p1_reg9", data_pg1[9]);
	//				ret = ReadVector("read_p1_reg10", data_pg1[10]);
	//				ret = ReadVector("read_p1_reg11", data_pg1[11]);
	//				ret = ReadVector("read_p1_reg12", data_pg1[12]);
	//				ret = ReadVector("read_p1_reg13", data_pg1[13]);
	//				ret = ReadVector("read_p1_reg14", data_pg1[14]);
	//				ret = ReadVector("read_p1_reg15", data_pg1[15]);
	//				ret = ReadVector("read_p1_reg16", data_pg1[16]);
	//				ret = ReadVector("read_p1_reg17", data_pg1[17]);
	//				ret = ReadVector("read_p1_reg18", data_pg1[18]);
	//				ret = ReadVector("read_p1_reg19", data_pg1[19]);
	//				ret = ReadVector("read_p1_reg20", data_pg1[20]);
	//				ret = ReadVector("read_p1_reg21", data_pg1[21]);
	//				ret = ReadVector("read_p1_reg22", data_pg1[22]);
	//				ret = ReadVector("read_p1_reg23", data_pg1[23]);
	//				ret = ReadVector("read_p1_reg24", data_pg1[24]);
	//				ret = ReadVector("read_p1_reg25", data_pg1[25]);
	//				ret = ReadVector("read_p1_reg26", data_pg1[26]);
	//				ret = ReadVector("read_p1_reg27", data_pg1[27]);
	//				ret = ReadVector("read_p1_reg28", data_pg1[28]);
	//				ret = ReadVector("read_p1_reg29", data_pg1[29]);
	//				ret = ReadVector("read_p1_reg30", data_pg1[30]);
	//				ret = ReadVector("read_p1_reg31", data_pg1[31]);*/
	//				////pg2
	//				//ret = ReadVector("read_p2_reg32", data_pg2[0]);
	//				//ret = ReadVector("read_p2_reg33", data_pg2[1]);
	//				//ret = ReadVector("read_p2_reg34", data_pg2[2]);
	//				//ret = ReadVector("read_p2_reg38", data_pg2[6]);
	//				//ret = ReadVector("read_p2_reg39", data_pg2[7]);
	//				//ret = ReadVector("read_p2_reg40", data_pg2[8]);
	//				//ret = ReadVector("read_p2_reg54", data_pg2[22]);
	//				//ret = ReadVector("read_p2_reg56", data_pg2[24]);
	//				//ret = ReadVector("read_p2_reg57", data_pg2[25]);
	//				//ret = ReadVector("read_p2_reg58", data_pg2[26]);
	//				//ret = ReadVector("read_p2_reg59", data_pg2[27]);
	//				//ret = ReadVector("read_p2_reg60", data_pg2[28]);
	//				//ret = ReadVector("read_p2_reg61", data_pg2[29]);
	//				//ret = ReadVector("read_p2_reg62", data_pg2[30]);
	//				//ret = ReadVector("read_p2_reg63", data_pg2[31]);
	//				//////pg4
	//				//ret = RunVectorFile("write_p2_reg63_extregsp_enable_h");
	//				//ret = ReadVector("read_p4_reg16", data_pg4[16]);
	//				//ret = ReadVector("read_p4_reg17", data_pg4[17]);
	//				//ret = ReadVector("read_p4_reg18", data_pg4[18]);
	//				//ret = ReadVector("read_p4_reg26", data_pg4[26]);


	//				CheckError(ret, __LINE__);

	//				ret = dm->AcquireVectorFailCount("DM_2", result);
	//				CheckError(ret, __LINE__);
	//			}

	//			if (Debug_Enable == true)
	//			{
	//				sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
	//				sb->AppendLine("AcquireVectorFailCount=" + result.ToString());

	//				int First_Fail_Vector_Count = 0;
	//				if (result > 0)
	//				{
	//					ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
	//					CheckError(ret, __LINE__);
	//					sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
	//				}
	//			}

	//			if (Debug_Enable == true)
	//			{
	//				sb->AppendLine("Total fail count=" + result.ToString());
	//			}

	//			tf_SetResult(TPName[i], result + (int)GetOffset(TPDispName[i]));
	//		
	//		}
	//	}

	//	ret = ResetDMPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);

	//	//Power down supplies
	//	ret = smu->DriveVoltage("VEE", 0);
	//	CheckError(ret, __LINE__);
	//	ret = smu->DriveVoltage("VCC", 0);
	//	CheckError(ret, __LINE__);
	//	
	//	//IO setting
	//	//ret = ResetDIOPin(TPDispName[0]);
	//	//CheckError(ret, __LINE__);
	//	ret = ResetCBit();
	//	CheckError(ret, __LINE__);
	//	ret = ResetMuxIO();
	//	CheckError(ret, __LINE__);

	//	if (Debug_Enable == true)
	//	{
	//		sw->Write(sb);	
	//		sb = nullptr;
	//		sw->Close();
	//		sw = nullptr;

	//		Debug_Enable = false;
	//	}

	//	return ret;
	//}
//int TestProgram::seq_digfunc(Site ^ site)
//	{
//		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}
//
//		int ret = 0;
//
//		//Get test name from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ Vector_File = gcnew array<String ^>(total_tp);
//		array<int> ^ data_pg1 = gcnew array<int>(32);
//		array<int> ^ data_pg2 = gcnew array<int>(32);
//		array<int> ^ data_pg4 = gcnew array<int>(32);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//		double Input_Channel_Delay_s = 0;
//		bool isCurrentTPBypassed = false;
//
//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
//
//		int result				= 0;
//
//		if (Debug_Enable == true)
//		{
//			sb = gcnew StringBuilder();
//			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
//		}
//				
//		double vih;
//        double vil;
//        double voh; 
//        double vol;
//        double ioh;
//		double iol;
//        double vch;
//        double vcl;
//		double vt;
//		
//		int vector_engine_status = 0;
//
//		Stopwatch swatch;
//
//		//IO setting
//		ret = SetupDigital(site);
//		CheckError(ret, __LINE__);
//		ret = DriveDIOPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = DriveCBit(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = DriveMuxIO(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		
//		//Setup Power supplies
//		//ret = smu->SetBandwidth("VCC", Bandwidth);
//		//CheckError(ret, __LINE__);
//		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//		//CheckError(ret, __LINE__);
//		//ret = smu->DriveVoltage("VCC", 0);
//		//CheckError(ret, __LINE__);
//		//ret = smu->OnSmuPin("VCC", true, false);
//		//CheckError(ret, __LINE__);
//
//		//ret = smu->SetBandwidth("VEE", Bandwidth);
//		//CheckError(ret, __LINE__);
//		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
//		//CheckError(ret, __LINE__);
//		//ret = smu->DriveVoltage("VEE", 0);
//		//CheckError(ret, __LINE__);
//		//ret = smu->OnSmuPin("VEE", true, false);
//		//CheckError(ret, __LINE__);
//		//_util->Wait_Sec(0.001);
//
//		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
//		CheckError(ret, __LINE__);
//		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
//		CheckError(ret, __LINE__);
//		//_util->Wait_Sec(On_Delay_s);
//
//		vih = 2.5;
//        vil = 0.00;
//        voh = 0.75; 
//        vol = 0.75;
//        ioh = 0.002;
//		iol = 0.002;
//        vch = 6;
//        vcl = -0.1;
//		vt = 0;
//
//		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPE");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPD");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPC");
//		CheckError(ret, __LINE__);
//
//		ret = DriveDMPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("RWN");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("PWR_SAVE", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("PWR_SAVE", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("PWR_SAVE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("PWR_SAVE");
//		CheckError(ret, __LINE__);
//
//		//_util->Wait_Sec(On_Delay_s);
//
//		if (Debug_Enable == true)
//		{
//			sb->AppendLine("-----------------------------------------------------------------------");
//			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("On_Delay_s=" + On_Delay_s);
//		}
//
//		ret = RunVectorFile("write_default_digfunc");
//		CheckError(ret, __LINE__);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			Vector_File [i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
//		}
//
//		for (int i=0; i<total_tp; i++)
//		{
//			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
//
//			if (isCurrentTPBypassed == false)
//			{
//				if (Debug_Enable == true)
//				{
//					sb->AppendLine("-----------------------------------------------------------------------");
//					sb->AppendLine("// " + TPDispName[i]);
//				}
//
//				if (Debug_Enable == true)
//				{
//					if(0)  // find optimum in put channel delay
//					{	
//						double ICD = 0; 
//						int a = 0;
//						double start = -2e-7;
//						double end = 2e-7;
//						int step = 100;
//						double stepsize = abs(start - end) / step;
//						int failCount = 0;
//						ICD = start;
//						sb->AppendLine("=============================");
//						sb->AppendLine("Vector: " + Vector_File[1]);
//
//						for( a = 0; a < 100; a++)
//						{
//							ICD += stepsize ;
//							ret = dm->ConfigureInputChannelDelay("SPD", ICD);
//							CheckError(ret, __LINE__);
//							ret = RunVectorFile(Vector_File[1]);
//							CheckError(ret, __LINE__);
//							ret = dm->AcquireVectorFailCount("DM_2", failCount);
//							CheckError(ret, __LINE__);
//							sb->AppendLine("ICD: " + + ICD  + "\t\tAcquireVectorFailCount= "+ failCount );
//						}
//
//						sb->AppendLine("=============================");
//					}
//					
//					ret = RunVectorFile("write_default_digfunc");
//					CheckError(ret, __LINE__);
//
//				}
//
//				if(Vector_File[i] == "all")
//				{
//					int temp = 0;
//					ret = dm->ConfigureInputChannelDelay("SPD", -2e-7);
//					
//					ret = RunVectorFile("write_default_digfunc");
//					for(int j=1; j<3; j++)
//					{
//						ret = RunVectorFile(Vector_File[j]);
//						CheckError(ret, __LINE__);
//						ret = dm->AcquireVectorFailCount("DM_2", temp);
//						CheckError(ret, __LINE__);
//						result += temp;
//						if (Debug_Enable == true)
//						{
//						sb->AppendLine("Vector: " + Vector_File[j] + "\t\tAcquireVectorFailCount= "+ temp );
//		
//						}
//					}
//						
//					ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//
//					for(int j=3; j<total_tp; j++)
//					{
//						ret = RunVectorFile(Vector_File[j]);
//						CheckError(ret, __LINE__);
//						ret = dm->AcquireVectorFailCount("DM_2", temp);
//						CheckError(ret, __LINE__);
//						result += temp;
//						if (Debug_Enable == true)
//						{
//							sb->AppendLine("Vector: " + Vector_File[j] + "\t\tAcquireVectorFailCount= "+ temp );
//			
//						}
//					}
//				}
//				else
//				{
//					ret = RunVectorFile(Vector_File[i]);	
//					/*ret = ReadVector("read_p2_reg48", data);
//					ret = ReadVector("read_p2_reg49", data);*/
//					//pg1
//					//ret = ReadVector("read_p1_reg0", data_pg1[0]);
//					//ret = ReadVector("read_p1_reg1", data_pg1[1]);
//					//ret = ReadVector("read_p1_reg2", data_pg1[2]);
//					//ret = ReadVector("read_p1_reg3", data_pg1[3]);
//					//ret = ReadVector("read_p1_reg4", data_pg1[4]);
//					//ret = ReadVector("read_p1_reg5", data_pg1[5]);
//					//ret = ReadVector("read_p1_reg6", data_pg1[6]);
//					//ret = ReadVector("read_p1_reg7", data_pg1[7]);
//					//ret = ReadVector("read_p1_reg8", data_pg1[8]);
//					//ret = ReadVector("read_p1_reg9", data_pg1[9]);
//					//ret = ReadVector("read_p1_reg10", data_pg1[10]);
//					//ret = ReadVector("read_p1_reg11", data_pg1[11]);
//					//ret = ReadVector("read_p1_reg12", data_pg1[12]);
//					//ret = ReadVector("read_p1_reg13", data_pg1[13]);
//					//ret = ReadVector("read_p1_reg14", data_pg1[14]);
//					//ret = ReadVector("read_p1_reg15", data_pg1[15]);
//					//ret = ReadVector("read_p1_reg16", data_pg1[16]);
//					//ret = ReadVector("read_p1_reg17", data_pg1[17]);
//					//ret = ReadVector("read_p1_reg18", data_pg1[18]);
//					//ret = ReadVector("read_p1_reg19", data_pg1[19]);
//					//ret = ReadVector("read_p1_reg20", data_pg1[20]);
//					//ret = ReadVector("read_p1_reg21", data_pg1[21]);
//					//ret = ReadVector("read_p1_reg22", data_pg1[22]);
//					//ret = ReadVector("read_p1_reg23", data_pg1[23]);
//					//ret = ReadVector("read_p1_reg24", data_pg1[24]);
//					//ret = ReadVector("read_p1_reg25", data_pg1[25]);
//					//ret = ReadVector("read_p1_reg26", data_pg1[26]);
//					//ret = ReadVector("read_p1_reg27", data_pg1[27]);
//					//ret = ReadVector("read_p1_reg28", data_pg1[28]);
//					//ret = ReadVector("read_p1_reg29", data_pg1[29]);
//					//ret = ReadVector("read_p1_reg30", data_pg1[30]);
//					//ret = ReadVector("read_p1_reg31", data_pg1[31]);
//					////pg2
//					//ret = ReadVector("read_p2_reg32", data_pg2[0]);
//					//ret = ReadVector("read_p2_reg33", data_pg2[1]);
//					//ret = ReadVector("read_p2_reg34", data_pg2[2]);
//					//ret = ReadVector("read_p2_reg38", data_pg2[6]);
//					//ret = ReadVector("read_p2_reg39", data_pg2[7]);
//					//ret = ReadVector("read_p2_reg40", data_pg2[8]);
//					//ret = ReadVector("read_p2_reg54", data_pg2[22]);
//					//ret = ReadVector("read_p2_reg56", data_pg2[24]);
//					//ret = ReadVector("read_p2_reg57", data_pg2[25]);
//					//ret = ReadVector("read_p2_reg58", data_pg2[26]);
//					//ret = ReadVector("read_p2_reg59", data_pg2[27]);
//					//ret = ReadVector("read_p2_reg60", data_pg2[28]);
//					//ret = ReadVector("read_p2_reg61", data_pg2[29]);
//					//ret = ReadVector("read_p2_reg62", data_pg2[30]);
//					//ret = ReadVector("read_p2_reg63", data_pg2[31]);
//					//////pg4
//					//ret = RunVectorFile("write_p2_reg63_extregsp_enable_h");
//					//ret = ReadVector("read_p4_reg16", data_pg4[16]);
//					//ret = ReadVector("read_p4_reg17", data_pg4[17]);
//					//ret = ReadVector("read_p4_reg18", data_pg4[18]);
//					//ret = ReadVector("read_p4_reg26", data_pg4[26]);
//
//
//					CheckError(ret, __LINE__);
//
//					ret = dm->AcquireVectorFailCount("DM_2", result);
//					CheckError(ret, __LINE__);
//				}
//
//				if (Debug_Enable == true)
//				{
//					sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
//					sb->AppendLine("AcquireVectorFailCount=" + result.ToString());
//
//					int First_Fail_Vector_Count = 0;
//					if (result > 0)
//					{
//						ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
//						CheckError(ret, __LINE__);
//						sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
//					}
//				}
//
//				if (Debug_Enable == true)
//				{
//					sb->AppendLine("Total fail count=" + result.ToString());
//				}
//
//				/*if (result == 0)
//					result = 0;
//				else
//					result = 1;*/
//
//				tf_SetResult(TPName[i], result + (int)GetOffset(TPDispName[i]));
//			
//			}
//		}
//
//		ret = ResetDMPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//
//		//Power down supplies
//		ret = smu->DriveVoltage("VEE", 0);
//		CheckError(ret, __LINE__);
//		ret = smu->DriveVoltage("VCC", 0);
//		CheckError(ret, __LINE__);
//		
//		//IO setting
//		ret = ResetDIOPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = ResetCBit();
//		CheckError(ret, __LINE__);
//		ret = ResetMuxIO();
//		CheckError(ret, __LINE__);
//
//		if (Debug_Enable == true)
//		{
//			sw->Write(sb);	
//			sb = nullptr;
//			sw->Close();
//			sw = nullptr;
//
//			Debug_Enable = false;
//		}
//
//		return ret;
//	}
int TestProgram::seq_digfunc(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<String ^> ^ Vector_File = gcnew array<String ^>(total_tp);
		array<int> ^ data_pg1 = gcnew array<int>(32);
		array<int> ^ data_pg2 = gcnew array<int>(32);
		array<int> ^ data_pg4 = gcnew array<int>(32);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Input_Channel_Delay_norm_s = 0;
		bool isCurrentTPBypassed = false;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][testSite];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_norm_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double _Input_Channel_Delay_s = 0;

		int result				= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("PWR_SAVE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("PWR_SAVE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("PWR_SAVE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("PWR_SAVE");
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_digfunc");
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			Vector_File [i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
		}

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if(Vector_File[i] == "all")
				{
					int temp = 0;
					for(int j=1; j<total_tp; j++)
					{
						if (Vector_File[j] == "digfunc_modes_ext_0" || Vector_File[j] == "digfunc_modes_ext_1")
						{
							_Input_Channel_Delay_s = -2e-7;
						}
						else
						{
							_Input_Channel_Delay_s = 0;
						}

						ret = dm->ConfigureInputChannelDelay("SPD", _Input_Channel_Delay_s);
						CheckError(ret, __LINE__);
		
						ret = RunVectorFile(Vector_File[j]);
						CheckError(ret, __LINE__);
						ret = dm->AcquireVectorFailCount("DM_2", temp);
						CheckError(ret, __LINE__);
						result += temp;
					}
				}
				else
				{
					ret = RunVectorFile(Vector_File[i]);	
					//ret = ReadVector("read_p2_reg48", data);
					//ret = ReadVector("read_p2_reg49", data);
					//pg1
					/*ret = ReadVector("read_p1_reg0", data_pg1[0]);
					ret = ReadVector("read_p1_reg1", data_pg1[1]);
					ret = ReadVector("read_p1_reg2", data_pg1[2]);
					ret = ReadVector("read_p1_reg3", data_pg1[3]);
					ret = ReadVector("read_p1_reg4", data_pg1[4]);
					ret = ReadVector("read_p1_reg5", data_pg1[5]);
					ret = ReadVector("read_p1_reg6", data_pg1[6]);
					ret = ReadVector("read_p1_reg7", data_pg1[7]);
					ret = ReadVector("read_p1_reg8", data_pg1[8]);
					ret = ReadVector("read_p1_reg9", data_pg1[9]);
					ret = ReadVector("read_p1_reg10", data_pg1[10]);
					ret = ReadVector("read_p1_reg11", data_pg1[11]);
					ret = ReadVector("read_p1_reg12", data_pg1[12]);
					ret = ReadVector("read_p1_reg13", data_pg1[13]);
					ret = ReadVector("read_p1_reg14", data_pg1[14]);
					ret = ReadVector("read_p1_reg15", data_pg1[15]);
					ret = ReadVector("read_p1_reg16", data_pg1[16]);
					ret = ReadVector("read_p1_reg17", data_pg1[17]);
					ret = ReadVector("read_p1_reg18", data_pg1[18]);
					ret = ReadVector("read_p1_reg19", data_pg1[19]);
					ret = ReadVector("read_p1_reg20", data_pg1[20]);
					ret = ReadVector("read_p1_reg21", data_pg1[21]);
					ret = ReadVector("read_p1_reg22", data_pg1[22]);
					ret = ReadVector("read_p1_reg23", data_pg1[23]);
					ret = ReadVector("read_p1_reg24", data_pg1[24]);
					ret = ReadVector("read_p1_reg25", data_pg1[25]);
					ret = ReadVector("read_p1_reg26", data_pg1[26]);
					ret = ReadVector("read_p1_reg27", data_pg1[27]);
					ret = ReadVector("read_p1_reg28", data_pg1[28]);
					ret = ReadVector("read_p1_reg29", data_pg1[29]);
					ret = ReadVector("read_p1_reg30", data_pg1[30]);
					ret = ReadVector("read_p1_reg31", data_pg1[31]);*/
					////pg2
					//ret = ReadVector("read_p2_reg32", data_pg2[0]);
					//ret = ReadVector("read_p2_reg33", data_pg2[1]);
					//ret = ReadVector("read_p2_reg34", data_pg2[2]);
					//ret = ReadVector("read_p2_reg38", data_pg2[6]);
					//ret = ReadVector("read_p2_reg39", data_pg2[7]);
					//ret = ReadVector("read_p2_reg40", data_pg2[8]);
					//ret = ReadVector("read_p2_reg54", data_pg2[22]);
					//ret = ReadVector("read_p2_reg56", data_pg2[24]);
					//ret = ReadVector("read_p2_reg57", data_pg2[25]);
					//ret = ReadVector("read_p2_reg58", data_pg2[26]);
					//ret = ReadVector("read_p2_reg59", data_pg2[27]);
					//ret = ReadVector("read_p2_reg60", data_pg2[28]);
					//ret = ReadVector("read_p2_reg61", data_pg2[29]);
					//ret = ReadVector("read_p2_reg62", data_pg2[30]);
					//ret = ReadVector("read_p2_reg63", data_pg2[31]);
					//////pg4
					//ret = RunVectorFile("write_p2_reg63_extregsp_enable_h");
					//ret = ReadVector("read_p4_reg16", data_pg4[16]);
					//ret = ReadVector("read_p4_reg17", data_pg4[17]);
					//ret = ReadVector("read_p4_reg18", data_pg4[18]);
					//ret = ReadVector("read_p4_reg26", data_pg4[26]);


					CheckError(ret, __LINE__);

					ret = dm->AcquireVectorFailCount("DM_2", result);
					CheckError(ret, __LINE__);
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
					sb->AppendLine("AcquireVectorFailCount=" + result.ToString());

					int First_Fail_Vector_Count = 0;
					if (result > 0)
					{
						ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
						CheckError(ret, __LINE__);
						sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
					}
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("Total fail count=" + result.ToString());
				}

				tf_SetResult(TPName[i], result + (int)GetOffset(TPDispName[i]));
			
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		
		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}


	//int TestProgram::seq_digfunc(Site ^ site)
	//{
	//	if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

	//	int ret = 0;

	//	//Get test name from techFlow
	//	int total_tp = (int)tf_TPCount();
	//	array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//	array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//	array<String ^> ^ Vector_File = gcnew array<String ^>(total_tp);
	//	array<int> ^ data_pg1 = gcnew array<int>(32);
	//	array<int> ^ data_pg2 = gcnew array<int>(32);
	//	array<int> ^ data_pg4 = gcnew array<int>(32);

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		TPDispName[i] = tf_TestParameter_DisplayName(i);
	//		TPName[i] = tf_TestParameter_Name(i);
	//	}

	//	String ^ TIDispName = tf_TestItem_DisplayName();

	//	//Get test condition from techFlow
	//	int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//	double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//	double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//	double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//	double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//	double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//	Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//	double Input_Channel_Delay_s = 0;
	//	bool isCurrentTPBypassed = false;

	//	if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//		Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

	//	int result				= 0;

	//	if (Debug_Enable == true)
	//	{
	//		sb = gcnew StringBuilder();
	//		sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
	//	}
	//			
	//	double vih;
 //       double vil;
 //       double voh; 
 //       double vol;
 //       double ioh;
	//	double iol;
 //       double vch;
 //       double vcl;
	//	double vt;
	//	
	//	int vector_engine_status = 0;

	//	Stopwatch swatch;

	//	//IO setting
	//	ret = SetupDigital(site);
	//	CheckError(ret, __LINE__);
	//	ret = DriveDIOPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = DriveCBit(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = DriveMuxIO(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	
	//	//Setup Power supplies
	//	//ret = smu->SetBandwidth("VCC", Bandwidth);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->DriveVoltage("VCC", 0);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->OnSmuPin("VCC", true, false);
	//	//CheckError(ret, __LINE__);

	//	//ret = smu->SetBandwidth("VEE", Bandwidth);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->DriveVoltage("VEE", 0);
	//	//CheckError(ret, __LINE__);
	//	//ret = smu->OnSmuPin("VEE", true, false);
	//	//CheckError(ret, __LINE__);
	//	//_util->Wait_Sec(0.001);

	//	ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
	//	CheckError(ret, __LINE__);
	//	ret = smu->DriveVoltage("VEE", Drive_Vee_V);
	//	CheckError(ret, __LINE__);
	//	//_util->Wait_Sec(On_Delay_s);

	//	vih = 2.5;
 //       vil = 0.00;
 //       voh = 0.75; 
 //       vol = 0.75;
 //       ioh = 0.002;
	//	iol = 0.002;
 //       vch = 6;
 //       vcl = -0.1;
	//	vt = 0;

	//	ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPE");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPD");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPC");
	//	CheckError(ret, __LINE__);

	//	ret = DriveDMPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("RWN");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("PWR_SAVE", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("PWR_SAVE", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("PWR_SAVE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("PWR_SAVE");
	//	CheckError(ret, __LINE__);

	//	//_util->Wait_Sec(On_Delay_s);

	//	if (Debug_Enable == true)
	//	{
	//		sb->AppendLine("-----------------------------------------------------------------------");
	//		sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
	//		sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
	//		sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("On_Delay_s=" + On_Delay_s);
	//	}

	//	ret = RunVectorFile("write_default_digfunc");
	//	CheckError(ret, __LINE__);

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		Vector_File [i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	//	}

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

	//		if (isCurrentTPBypassed == false)
	//		{
	//			if (Debug_Enable == true)
	//			{
	//				sb->AppendLine("-----------------------------------------------------------------------");
	//				sb->AppendLine("// " + TPDispName[i]);
	//			}

	//			if (1)
	//			{
	//				if(1)  // find optimum in put channel delay
	//				{	
	//					double ICD = 0; 
	//					int a = 0;
	//					double start = -3e-9;
	//					double end = 3e-9;
	//					int step = 100;
	//					double stepsize = abs(start - end) / step;
	//					int failCount = 0;
	//					ICD = start;
	//					sb->AppendLine("=============================");
	//					sb->AppendLine("Vector: " + Vector_File[1]);

	//					for( a = 0; a < 100; a++)
	//					{
	//						ICD += stepsize ;
	//						ret = dm->ConfigureInputChannelDelay("SPD", ICD);
	//						CheckError(ret, __LINE__);
	//						ret = RunVectorFile(Vector_File[1]);
	//						CheckError(ret, __LINE__);
	//						ret = dm->AcquireVectorFailCount("DM_2", failCount);
	//						CheckError(ret, __LINE__);
	//						sb->AppendLine("ICD: " + + ICD  + "\t\tAcquireVectorFailCount= "+ failCount );
	//					}

	//					sb->AppendLine("=============================");
	//				}
	//				
	//				//ret = RunVectorFile("write_default_digfunc");
	//				//CheckError(ret, __LINE__);

	//			}

	//			if(Vector_File[i] == "all")
	//			{
	//				int temp = 0;
	//				ret = dm->ConfigureInputChannelDelay("SPD", -2e-7);
	//				ret = dm->ConfigureInputChannelDelay("SPD", 1e-9);
	//				_util->Wait_Sec(0.1);

	//				for(int j=1; j<3; j++)
	//				{
	//					ret = RunVectorFile(Vector_File[j]);
	//					CheckError(ret, __LINE__);
	//					ret = dm->AcquireVectorFailCount("DM_2", temp);
	//					CheckError(ret, __LINE__);
	//					result += temp;
	//					if (Debug_Enable == true)
	//					{
	//					sb->AppendLine("Vector: " + Vector_File[j] + "\t\tAcquireVectorFailCount= "+ temp );
	//	
	//					}
	//				}
	//					
	//				ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);

	//				for(int j=3; j<total_tp; j++)
	//				{
	//					ret = RunVectorFile(Vector_File[j]);
	//					CheckError(ret, __LINE__);
	//					ret = dm->AcquireVectorFailCount("DM_2", temp);
	//					CheckError(ret, __LINE__);
	//					result += temp;
	//					if (Debug_Enable == true)
	//					{
	//						sb->AppendLine("Vector: " + Vector_File[j] + "\t\tAcquireVectorFailCount= "+ temp );
	//		
	//					}
	//				}
	//			}
	//			else
	//			{
	//				ret = RunVectorFile(Vector_File[i]);	
	//				/*ret = ReadVector("read_p2_reg48", data);
	//				ret = ReadVector("read_p2_reg49", data);*/
	//				//pg1
	//				//ret = ReadVector("read_p1_reg0", data_pg1[0]);
	//				//ret = ReadVector("read_p1_reg1", data_pg1[1]);
	//				//ret = ReadVector("read_p1_reg2", data_pg1[2]);
	//				//ret = ReadVector("read_p1_reg3", data_pg1[3]);
	//				//ret = ReadVector("read_p1_reg4", data_pg1[4]);
	//				//ret = ReadVector("read_p1_reg5", data_pg1[5]);
	//				//ret = ReadVector("read_p1_reg6", data_pg1[6]);
	//				//ret = ReadVector("read_p1_reg7", data_pg1[7]);
	//				//ret = ReadVector("read_p1_reg8", data_pg1[8]);
	//				//ret = ReadVector("read_p1_reg9", data_pg1[9]);
	//				//ret = ReadVector("read_p1_reg10", data_pg1[10]);
	//				//ret = ReadVector("read_p1_reg11", data_pg1[11]);
	//				//ret = ReadVector("read_p1_reg12", data_pg1[12]);
	//				//ret = ReadVector("read_p1_reg13", data_pg1[13]);
	//				//ret = ReadVector("read_p1_reg14", data_pg1[14]);
	//				//ret = ReadVector("read_p1_reg15", data_pg1[15]);
	//				//ret = ReadVector("read_p1_reg16", data_pg1[16]);
	//				//ret = ReadVector("read_p1_reg17", data_pg1[17]);
	//				//ret = ReadVector("read_p1_reg18", data_pg1[18]);
	//				//ret = ReadVector("read_p1_reg19", data_pg1[19]);
	//				//ret = ReadVector("read_p1_reg20", data_pg1[20]);
	//				//ret = ReadVector("read_p1_reg21", data_pg1[21]);
	//				//ret = ReadVector("read_p1_reg22", data_pg1[22]);
	//				//ret = ReadVector("read_p1_reg23", data_pg1[23]);
	//				//ret = ReadVector("read_p1_reg24", data_pg1[24]);
	//				//ret = ReadVector("read_p1_reg25", data_pg1[25]);
	//				//ret = ReadVector("read_p1_reg26", data_pg1[26]);
	//				//ret = ReadVector("read_p1_reg27", data_pg1[27]);
	//				//ret = ReadVector("read_p1_reg28", data_pg1[28]);
	//				//ret = ReadVector("read_p1_reg29", data_pg1[29]);
	//				//ret = ReadVector("read_p1_reg30", data_pg1[30]);
	//				//ret = ReadVector("read_p1_reg31", data_pg1[31]);
	//				////pg2
	//				//ret = ReadVector("read_p2_reg32", data_pg2[0]);
	//				//ret = ReadVector("read_p2_reg33", data_pg2[1]);
	//				//ret = ReadVector("read_p2_reg34", data_pg2[2]);
	//				//ret = ReadVector("read_p2_reg38", data_pg2[6]);
	//				//ret = ReadVector("read_p2_reg39", data_pg2[7]);
	//				//ret = ReadVector("read_p2_reg40", data_pg2[8]);
	//				//ret = ReadVector("read_p2_reg54", data_pg2[22]);
	//				//ret = ReadVector("read_p2_reg56", data_pg2[24]);
	//				//ret = ReadVector("read_p2_reg57", data_pg2[25]);
	//				//ret = ReadVector("read_p2_reg58", data_pg2[26]);
	//				//ret = ReadVector("read_p2_reg59", data_pg2[27]);
	//				//ret = ReadVector("read_p2_reg60", data_pg2[28]);
	//				//ret = ReadVector("read_p2_reg61", data_pg2[29]);
	//				//ret = ReadVector("read_p2_reg62", data_pg2[30]);
	//				//ret = ReadVector("read_p2_reg63", data_pg2[31]);
	//				//////pg4
	//				//ret = RunVectorFile("write_p2_reg63_extregsp_enable_h");
	//				//ret = ReadVector("read_p4_reg16", data_pg4[16]);
	//				//ret = ReadVector("read_p4_reg17", data_pg4[17]);
	//				//ret = ReadVector("read_p4_reg18", data_pg4[18]);
	//				//ret = ReadVector("read_p4_reg26", data_pg4[26]);


	//				CheckError(ret, __LINE__);

	//				ret = dm->AcquireVectorFailCount("DM_2", result);
	//				CheckError(ret, __LINE__);
	//			}

	//			if (Debug_Enable == true)
	//			{
	//				sb->AppendLine("AcquireVectorFailCount return=" + ret.ToString());
	//				sb->AppendLine("AcquireVectorFailCount=" + result.ToString());

	//				int First_Fail_Vector_Count = 0;
	//				if (result > 0)
	//				{
	//					ret = dm->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
	//					CheckError(ret, __LINE__);
	//					sb->AppendLine("AcquireChannelFirstFailVectorCount=" + First_Fail_Vector_Count.ToString());
	//				}
	//			}

	//			if (Debug_Enable == true)
	//			{
	//				sb->AppendLine("Total fail count=" + result.ToString());
	//			}

	//			if (result == 0)
	//				result = 0;
	//			else
	//				result = 1;

	//			tf_SetResult(TPName[i], result + (int)GetOffset(TPDispName[i]));
	//		
	//		}
	//	}

	//	ret = ResetDMPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);

	//	//Power down supplies
	//	ret = smu->DriveVoltage("VEE", 0);
	//	CheckError(ret, __LINE__);
	//	ret = smu->DriveVoltage("VCC", 0);
	//	CheckError(ret, __LINE__);
	//	
	//	//IO setting
	//	ret = ResetDIOPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = ResetCBit();
	//	CheckError(ret, __LINE__);
	//	ret = ResetMuxIO();
	//	CheckError(ret, __LINE__);

	//	if (Debug_Enable == true)
	//	{
	//		sw->Write(sb);	
	//		sb = nullptr;
	//		sw->Close();
	//		sw = nullptr;

	//		Debug_Enable = false;
	//	}

	//	return ret;
	//}
	//
	int TestProgram::seq_input_current(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File1	= String::Empty;
		double Clamp_Io_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Io_Current_A"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Test_Pin		= String::Empty;
		double Drive_Io_V		= 0;
		int Drive_WRN_V			= 0;

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Must use vector for ion_current to set last level to VOL
		//Write DEFAULT registers 

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		
		//init_sif_tool
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		
		if (tf_TestItemCondition_exist("Vector_File1"))
		{
			Vector_File1 = (String ^)(tf_TestItemCondition_Cast("Vector_File1"));
			ret = RunVectorFile(Vector_File1);
		}

		if (tf_TestItemCondition_exist("Drive_WRN_V"))
		{
			Drive_WRN_V = (int)(tf_TestItemCondition_Cast("Drive_WRN_V"));
			ret = dm->DrivePin("RWN", Drive_WRN_V);
			CheckError(ret, __LINE__);
		}

		Dictionary <String ^, int> ^ Test_Pin_Configured = gcnew Dictionary <String ^ , int>; // key is Test Pin

		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File"))
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);

				}

				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
				Drive_Io_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_V"));

				if (Test_Pin_Configured->ContainsKey(Test_Pin) == false)
				{
					ret = dm->DPINOff(Test_Pin);
					CheckError(ret, __LINE__);
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);

					Test_Pin_Configured->Add(Test_Pin, 1);
				}

				#ifdef USE_GNDS
				double volt = 0;
				ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				CheckError(ret, __LINE__);
				Drive_Io_V = Drive_Io_V + volt + 0.11; //0.11V is the IR dropped along SPD path as measured using DMM.
				#endif


				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Io_V);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_input_voltage(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File1	= String::Empty;
		double Clamp_Vo_Voltage_V = (double)(tf_TestItemCondition_Cast("Clamp_Vo_Voltage_V"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Test_Pin		= String::Empty;
		double Drive_Io_V		= 0;

		double result			= 0;
		double Drive_Io_A		= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		
		//init_sif_tool
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		
		if (tf_TestItemCondition_exist("Vector_File1"))
		{
			Vector_File1 = (String ^)(tf_TestItemCondition_Cast("Vector_File1"));
			ret = RunVectorFile(Vector_File1);
			CheckError(ret, __LINE__);
		}

		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		if (tf_TestItemCondition_exist("Vector_File1"))
		{
			Vector_File1 = (String ^)(tf_TestItemCondition_Cast("Vector_File1"));
			ret = RunSPI(Vector_File1);
			CheckError(ret, __LINE__);
		}
		#endif

		Dictionary <String ^, int> ^ Test_Pin_Configured = gcnew Dictionary <String ^ , int>; // key is Test Pin
		
		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
				Drive_Io_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_A"));

				if (Test_Pin_Configured->ContainsKey(Test_Pin) == false)
				{
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					
					if (Clamp_Vo_Voltage_V < 0)
						ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Vo_Voltage_V);
					else 
						ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_Voltage_V, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);

					Test_Pin_Configured->Add(Test_Pin, 1);
				}

				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				#ifdef USE_GNDS
				double volt = 0;
				ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				CheckError(ret, __LINE__);
				result = result - volt;
				#endif

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_writer_in(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));

		double Drive_WDX_V		= (double)(tf_TestItemCondition_Cast("Drive_WDX_V"));
		double Drive_WDY_V		= (double)(tf_TestItemCondition_Cast("Drive_WDY_V"));
		double Clamp_WDX_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_WDX_Current_A"));
		double Clamp_WDY_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_WDY_Current_A"));

		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("write_p1_reg9_mode_sleep");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI("write_p1_reg9_mode_sleep");
		CheckError(ret, __LINE__);
		#endif

		ret = dm->Force("WDX", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->Force("WDY", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("WDX", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("WDY", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("WDX", DM_CONST_DVCI);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("WDY", DM_CONST_DVCI);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLimitRange("WDX", Clamp_WDX_Current_A);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLimitRange("WDY", Clamp_WDY_Current_A);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDY", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDX");
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDY");
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		ret = dm->ConfigurePMUVoltageLevel("WDX", Drive_WDX_V);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDY", Drive_WDY_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(Measure_Delay_s);
		ret = dm->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, result);
		CheckError(ret, __LINE__);

		tf_SetResult(TPName[0], result + GetOffset(TPDispName[0]));

		//Rwd_in^Rd!WD!S
		#ifndef USE_SPI
		ret = RunVectorFile("write_p1_reg9_mode_active");
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI("write_p1_reg9_mode_active");
		CheckError(ret, __LINE__);
		#endif
		_util->Wait_Sec(Measure_Delay_s);
		ret = dm->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, result);
		CheckError(ret, __LINE__);

		tf_SetResult(TPName[1], result + GetOffset(TPDispName[1]));

		//Rwd_in^Wt!WD!S

		ret = dm->DrivePin("RWN", 1);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(Measure_Delay_s);

		double Current_WDY = 0;
		double Voltage_WDY = 0;
		double Voltage_WDX = 0;

		ret = dm->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, Current_WDY);
		CheckError(ret, __LINE__);
		ret = dm->PMUMeasure("WDY", DM_CONST_MEASUREVOLTAGE, Voltage_WDY);
		CheckError(ret, __LINE__);
		ret = dm->PMUMeasure("WDX", DM_CONST_MEASUREVOLTAGE, Voltage_WDX);
		CheckError(ret, __LINE__);
		result = (Voltage_WDY - Voltage_WDX)/Current_WDY;

		tf_SetResult(TPName[2], result + GetOffset(TPDispName[2]));	

		ret = dm->ConfigurePMUVoltageLevel("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDY", 0);
		CheckError(ret, __LINE__);
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_writer_in2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));

		double Drive_WDX_V		= (double)(tf_TestItemCondition_Cast("Drive_WDX_V"));
		double Drive_WDY_V		= (double)(tf_TestItemCondition_Cast("Drive_WDY_V"));
		double Clamp_WDX_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_WDX_Current_A"));
		double Clamp_WDY_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_WDY_Current_A"));

		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("write_p1_reg9_mode_sleep");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI("write_p1_reg9_mode_sleep");
		CheckError(ret, __LINE__);
		#endif

		ret = dm->Force("WDX", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->Force("WDY", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("WDX", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("WDY", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("WDX", DM_CONST_DVCI);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("WDY", DM_CONST_DVCI);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLimitRange("WDX", Clamp_WDX_Current_A);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLimitRange("WDY", Clamp_WDY_Current_A);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDY", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDX");
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDY");
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		ret = dm->ConfigurePMUVoltageLevel("WDX", Drive_WDX_V);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDY", Drive_WDY_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(Measure_Delay_s);
		ret = dm->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, result);
		CheckError(ret, __LINE__);

		tf_SetResult(TPName[0], result + GetOffset(TPDispName[0]));

		//Rwd_in^Rd!WD!S
		#ifndef USE_SPI
		ret = RunVectorFile("write_p1_reg9_mode_active");
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI("write_p1_reg9_mode_active");
		CheckError(ret, __LINE__);
		#endif
		_util->Wait_Sec(Measure_Delay_s);
		ret = dm->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, result);
		CheckError(ret, __LINE__);

		tf_SetResult(TPName[1], result + GetOffset(TPDispName[1]));

		//Rwd_in^Wt!WD!S

		ret = dm->DrivePin("RWN", 1);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(Measure_Delay_s);

		double Current_WDY = 0;
		double Voltage_WDY = 0;
		double Voltage_WDX = 0;

		ret = dm->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, Current_WDY);
		CheckError(ret, __LINE__);

		//
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 5);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", false, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//double val = 0;
		//#ifdef USE_GNDS 
		//ret = Configure_GNDS_Mux(site, NPLC);
		//CheckError(ret, __LINE__);
		//ret = smu->ReadVoltage("GND_MUX_SENSE", val);
		//CheckError(ret, __LINE__);
		//#endif

		ret = smu->ReadVoltage("MTX_SMU", Voltage_WDY);
		CheckError(ret, __LINE__);

		ret = DriveCBit(TPDispName[0], 1);
		CheckError(ret, __LINE__); 
		_util->Wait_Sec(On_Delay_s);

		ret = smu->ReadVoltage("MTX_SMU", Voltage_WDX);
		CheckError(ret, __LINE__);

		//ret = dm->PMUMeasure("WDY", DM_CONST_MEASUREVOLTAGE, Voltage_WDY);
		//CheckError(ret, __LINE__);
		//ret = dm->PMUMeasure("WDX", DM_CONST_MEASUREVOLTAGE, Voltage_WDX);
		//CheckError(ret, __LINE__);

		result = (Voltage_WDY - Voltage_WDX)/Current_WDY;

		tf_SetResult(TPName[2], result + GetOffset(TPDispName[2]));	

		ret = dm->ConfigurePMUVoltageLevel("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLevel("WDY", 0);
		CheckError(ret, __LINE__);
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	//
	int TestProgram::seq_gain_sup(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double DAC				= (double)(tf_TestItemCondition_Cast("DAC"));
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (DAC >= 0 && DAC <=5)
		{
			Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
		}
		else if (DAC >= 6 && DAC <=15)
		{
			Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;
		}
		else
		{
			Vswg = 5 * CONST_Rdr_Av_div * 1e-3;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		if(Test != TEST_IF4600_PKG)
		{
			ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			CheckError(ret, __LINE__);
			ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(ret, __LINE__);
			ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
			CheckError(ret, __LINE__);
		}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;
		
		//Calibration of Vpp

		int max_loop = 50;
		
		if (Vswg_calibrated->ContainsKey(DAC) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);
				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//Off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//Off K3, K4 
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			Vswg_calibrated->Add(DAC, Vswg_cal);
			Vswg_at_dut->Add(DAC, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}

		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double Gmax = 0;
		double Gmin = 0;
		double vin = Vswg_at_dut[DAC];
		//double vin_r1 = vin * ((CONST_Rdr_Av_div + 1000)/(CONST_Rdr_Av_div + 1000 + 1000)) - vin * (1000/(CONST_Rdr_Av_div + 1000 + 1000));
		double vin_r1 = vin / CONST_Rdr_Av_div;

		for (int i=0; i<total_tp; i++)
		{
			if (i == 0)
			{
				tf_SetResult(TPName[i], DAC + GetOffset(TPDispName[i]));
			}
			else if (i == total_tp-1)
			{
				tf_SetResult(TPName[i], Gmax - Gmin + GetOffset(TPDispName[i]));
			}
			else
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);
				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}

				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata2.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int j=0; j<dataArrayP->Length; j++)
					{
						dataArrayP[j] = dataArrayP[j] - dataArrayN[j]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				result = 20 * Math::Log10(vout_pp / vin_r1);

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (i == 1)
				{
					Gmax = result;
					Gmin = result;
				}
				else
				{
					if (result > Gmax)
						Gmax = result;
		
					if (result < Gmin)
						Gmin = result;
				}
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_gain_sup2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double DAC				= (double)(tf_TestItemCondition_Cast("DAC"));
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (DAC >= 0 && DAC <=5)
		{
			Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
		}
		else if (DAC >= 6 && DAC <=15)
		{
			Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;
		}
		else
		{
			Vswg = 5 * CONST_Rdr_Av_div * 1e-3;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 4096; //512; //1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	
		int Decimation_Factor = 1;

		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;
		
		//Calibration of Vpp

		int max_loop = 50;
		
		if (Vswg_calibrated->ContainsKey(DAC) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					ret = DigitizerFFT_Configure(digitizer_setting);
					CheckError(ret, __LINE__);
					
					do_once = 1;
				}

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//Off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//Off K3, K4 
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			Vswg_calibrated->Add(DAC, Vswg_cal);
			Vswg_at_dut->Add(DAC, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = DigitizerFFT_Configure(digitizer_setting);
			CheckError(ret, __LINE__);
		}

		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double Gmax = 0;
		double Gmin = 0;
		double vin = Vswg_at_dut[DAC];
		double vin_r1 = vin / CONST_Rdr_Av_div;

		for (int i=0; i<total_tp; i++)
		{
			if (i == 0)
			{
				tf_SetResult(TPName[i], DAC + GetOffset(TPDispName[i]));
			}
			else if (i == total_tp-1)
			{
				tf_SetResult(TPName[i], Gmax - Gmin + GetOffset(TPDispName[i]));
			}
			else
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
				
				if (ret)
				{
					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				result = 20 * Math::Log10(vout_pp / vin_r1);

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (i == 1)
				{
					Gmax = result;
					Gmin = result;
				}
				else
				{
					if (result > Gmax)
						Gmax = result;
		
					if (result < Gmin)
						Gmin = result;
				}
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
	
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_gain_hds(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed = false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		int DAC					= 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		//double result = 0;

		int Global_Result_Index = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		if(Test != TEST_IF4600_PKG)
		{
			ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			CheckError(ret, __LINE__);
			ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(ret, __LINE__);
			ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
			CheckError(ret, __LINE__);
		}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

				//Write DEFAULT registers 
		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 10;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;
		int max_loop = 50;

		//Test
		double vin_r1 = 0;

		array<double> ^ result = gcnew array<double>(total_tp);
		array<int> ^ dac = gcnew array<int>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (TPName[i]->StartsWith("Av_DAC_Mono"))
				{
					double slope = 0;
					double offset = 0;

					_util->line_fit(dac, result, total_tp-1, slope, offset);
					double mono = 0;
					double mono_step = _util->monotonicity(result, total_tp-1, 0, mono);
					mono /= slope;

					result[i] = mono;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
				else
				{
					DAC = (int)(tf_TPCondition_Cast(TPName[i], "DAC"));
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					dac[i] = DAC;

					if (DAC >= 0 && DAC <=5)
					{
						Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
						//fullScale = 2.0;
					}
					else if (DAC >= 6 && DAC <=15)
					{
						Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;
						//fullScale = 2.0;
					}
					else
					{
						Vswg = 5 * CONST_Rdr_Av_div * 1e-3; 
						//fullScale = 2.0;
					}

					///////////////////////////////
					//Program device (HSEL, IBIAS, GAIN)
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
					///////////////////////////////
					//Calibration of Vpp

					if (Vswg_calibrated->ContainsKey(DAC) == false)
					{
						double Vswg_cal = 0;
						int loop_count = 0;

						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_1", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_2", 0);
							CheckError(ret, __LINE__);

							ret = dio->DrivePin("DIO_3", 1);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 1);
							CheckError(ret, __LINE__);
						}
						else
						{
							//On K3, K4
							ret = DriveCBit(TPDispName[0], 1);
							CheckError(ret, __LINE__);
						}

						Vswg_cal = Vswg;

						ret = acm->ResetChannel("ACM_CH");
						CheckError(ret, __LINE__);
						ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
						CheckError(ret, __LINE__);
						ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						CheckError(ret, __LINE__);
						ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(1e-3);
						ret = acm->RunFG("ACM_CH", 0, true);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);

						int do_once = 0;
						while(loop_count <= max_loop)
						{
							if (do_once == 0)
							{
								ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
								CheckError(ret, __LINE__);
								ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
								CheckError(ret, __LINE__);
								ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
								CheckError(ret, __LINE__);
								ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
								CheckError(ret, __LINE__);
								if (Test == TEST_IF4600_PKG)
								{
									ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
									CheckError(ret, __LINE__);
								}
								ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
								CheckError(ret, __LINE__);
								ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
								CheckError(ret, __LINE__);
								do_once = 1;
							}

							ret = digitizer->StartAcquire("DIGITIZER");
							CheckError(ret, __LINE__);
							ret = digitizer->ForceTrigger("DIGITIZER");
							if (ret == -1074116410) //ERROR: Instrument already stopped
								ret = 0;
							CheckError(ret, __LINE__);

							ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
							if (ret == -1074116410) //ERROR: Instrument already stopped
								ret = 0;
							CheckError(ret, __LINE__);

							if (ret)
							{
								if (Debug_Enable == true)
								{
									StringBuilder ^ sa = gcnew StringBuilder();
									ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

									sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
									sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
								}

								//for (int i=0; i<total_tp; i++)
								//{
									tf_SetResult(TPName[i], (double)(-999));
								//}

								goto test_end;
							}

							ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
							CheckError(ret, __LINE__);
							if (Test == TEST_IF4600_PKG)
							{
								ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
								CheckError(ret, __LINE__);
							}
					
							if (Debug_Enable == true)
							{
								ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
								for (int i = 0; i < nbrSamples; i++) 
								{
									outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
								}
								outFile.close();
							}

							if (Test == TEST_IF4600_PKG)
							{
								for (int i=0; i<dataArrayP->Length; i++)
								{
									dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
								}
							}

							vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

							vout_pp = vout_pp * diff2se_digitizer_factor;

							//if (Math::Abs(Vswg - vout_pp) < (Vswg * 0.1))
							if (Math::Abs(Vswg - vout_pp) < 4e-3)
							{
								break;
							}
							else
							{
								Vswg_cal = Vswg_cal + (Vswg - vout_pp);

								ret = acm->StopFG("ACM_CH"); 
								CheckError(ret, __LINE__);
								ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
								if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
								{
									CheckError(ret, __LINE__);	
								}

								if (ret != 0)
								{
									ret = 0;

									ret = digitizer->StopAcquire("DIGITIZER");
									CheckError(ret, __LINE__);
									ret = acm->StopFG("ACM_CH"); 
									CheckError(ret, __LINE__);
									
									if(Test == TEST_IF4600_PKG)
									{
										ret = dio->DrivePin("DIO_3", 0);
										CheckError(ret, __LINE__);
										ret = dio->DrivePin("DIO_4", 0);
										CheckError(ret, __LINE__);
									}
									else
									{
										//Off K3, K4 
										ret = DriveCBit(TPDispName[0], 0);
										CheckError(ret, __LINE__);
									}

									for (int i=0; i<total_tp; i++)
									{
										tf_SetResult(TPName[i], (double)(-999));
									}

									goto test_end;
								}

								ret = acm->RunFG("ACM_CH", 0, true);
								CheckError(ret, __LINE__);
								_util->Wait_Sec(Measure_Delay_s);
							}
				
							loop_count++;
						}

						if (loop_count > max_loop)
						{
							ret = digitizer->StopAcquire("DIGITIZER");
							CheckError(ret, __LINE__);
							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);
							
							if(Test == TEST_IF4600_PKG)
							{
								ret = dio->DrivePin("DIO_3", 0);
								CheckError(ret, __LINE__);
								ret = dio->DrivePin("DIO_4", 0);
								CheckError(ret, __LINE__);
							}
							else
							{
								//Off K3, K4 
								ret = DriveCBit(TPDispName[0], 0);
								CheckError(ret, __LINE__);
							}

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult(TPName[i], (double)(-999));
							}

							goto test_end;
						}
									
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//Off K3, K4 
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						Vswg_calibrated->Add(DAC, Vswg_cal);
						Vswg_at_dut->Add(DAC, vout_pp);
					}
					else
					{
						if (i == 0)
						{
							ret = acm->ResetChannel("ACM_CH");
							CheckError(ret, __LINE__);
							ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
							CheckError(ret, __LINE__);
							ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
							CheckError(ret, __LINE__);

							ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
							CheckError(ret, __LINE__);
							if (Test == TEST_IF4600_PKG)
							{
								ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
								CheckError(ret, __LINE__);
							}
							ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
							CheckError(ret, __LINE__);
						}
					}

					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_1", 1);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_2", 1);
						CheckError(ret, __LINE__);
					}
					else
					{
						//On K1, K2
						ret = DriveCBit(TPDispName[0], 2);
						CheckError(ret, __LINE__);
					}

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
					CheckError(ret, __LINE__);
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					
					_util->Wait_Sec(Measure_Delay_s);

					ret = digitizer->StartAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ForceTrigger("DIGITIZER");
					if (ret == -1074116410) //ERROR: Instrument already stopped
						ret = 0;
					CheckError(ret, __LINE__);

					ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
					if (ret == -1074116410) //ERROR: Instrument already stopped
						ret = 0;
					CheckError(ret, __LINE__);

					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);

						for (int j=0; j<dataArrayP->Length; j++)
						{
							dataArrayP[j] = dataArrayP[j] - dataArrayN[j]; //get the differential values
						}
					}

					vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

					vout_pp = vout_pp * diff2se_digitizer_factor;

					vin_r1 = Vswg_at_dut[DAC] / CONST_Rdr_Av_div;

					result[i] = 20 * Math::Log10(vout_pp / vin_r1);

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));		

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

						_glob->Global_Result[Global_Result_Index] = result[i];
					}
				}
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_gain_hds2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed = false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		int DAC					= 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		//double result = 0;

		int Global_Result_Index = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		//#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		//#else
		//ret = OnOffSPI(1);
		//CheckError(ret, __LINE__);
		//ret = RunSPI("write_default_reg");
		//CheckError(ret, __LINE__);
		//ret = RunSPI(Vector_File);
		//CheckError(ret, __LINE__);
		//#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 4096; //1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;
		int max_loop = 50;

		//Test
		double vin_r1 = 0;

		array<double> ^ result = gcnew array<double>(total_tp);
		array<int> ^ dac = gcnew array<int>(total_tp);

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	
		int Decimation_Factor = 1;

		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (TPName[i]->StartsWith("Av_DAC_Mono"))
				{
					double slope = 0;
					double offset = 0;

					_util->line_fit(dac, result, total_tp-1, slope, offset);
					double mono = 0;
					double mono_step = _util->monotonicity(result, total_tp-1, 0, mono);
					mono /= slope;

					result[i] = mono;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
				else
				{
					DAC = (int)(tf_TPCondition_Cast(TPName[i], "DAC"));
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					dac[i] = DAC;

					if (DAC >= 0 && DAC <=5)
					{
						Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
						fullScale = 2.0;
					}
					else if (DAC >= 6 && DAC <=15)
					{
						Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;
						fullScale = 2.0;
					}
					else
					{
						Vswg = 5 * CONST_Rdr_Av_div * 1e-3; 
						fullScale = 2.0;
					}

					///////////////////////////////
					//Program device (HSEL, IBIAS, GAIN)

					//#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					//#else
					//ret = RunSPI(Vector_File);
					//CheckError(ret, __LINE__);
					//#endif

					///////////////////////////////
					//Calibration of Vpp

					if (Vswg_calibrated->ContainsKey(DAC) == false)
					{
						double Vswg_cal = 0;
						int loop_count = 0;

						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_1", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_2", 0);
							CheckError(ret, __LINE__);

							ret = dio->DrivePin("DIO_3", 1);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 1);
							CheckError(ret, __LINE__);
						}
						else
						{
							//On K3, K4
							ret = DriveCBit(TPDispName[0], 1);
							CheckError(ret, __LINE__);
						}

						Vswg_cal = Vswg;

						ret = acm->ResetChannel("ACM_CH");
						CheckError(ret, __LINE__);
						ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
						CheckError(ret, __LINE__);
						ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						CheckError(ret, __LINE__);
						ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(1e-3);
						ret = acm->RunFG("ACM_CH", 0, true);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);

						int do_once = 0;
						while(loop_count <= max_loop)
						{
							if (do_once == 0)
							{
								ret = DigitizerFFT_Configure(digitizer_setting);
								do_once = 1;
							}

							//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
							ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

							if (ret)
							{
								ret = digitizer->StopAcquire("DIGITIZER");
								CheckError(ret, __LINE__);

								ret = acm->StopFG("ACM_CH"); 
								CheckError(ret, __LINE__);

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult(TPName[i], (double)(-999));
								}

								goto test_end;
							}
	
							if (Math::Abs(Vswg - vout_pp) < 4e-3)
							{
								break;
							}
							else
							{
								Vswg_cal = Vswg_cal + (Vswg - vout_pp);

								ret = acm->StopFG("ACM_CH"); 
								CheckError(ret, __LINE__);
								ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
								if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
								{
									CheckError(ret, __LINE__);	
								}

								if (ret != 0)
								{
									ret = 0;

									ret = digitizer->StopAcquire("DIGITIZER");
									CheckError(ret, __LINE__);
									ret = acm->StopFG("ACM_CH"); 
									CheckError(ret, __LINE__);
									
									if(Test == TEST_IF4600_PKG)
									{
										ret = dio->DrivePin("DIO_3", 0);
										CheckError(ret, __LINE__);
										ret = dio->DrivePin("DIO_4", 0);
										CheckError(ret, __LINE__);
									}
									else
									{
										//Off K3, K4 
										ret = DriveCBit(TPDispName[0], 0);
										CheckError(ret, __LINE__);
									}

									for (int i=0; i<total_tp; i++)
									{
										tf_SetResult(TPName[i], (double)(-999));
									}

									goto test_end;
								}

								ret = acm->RunFG("ACM_CH", 0, true);
								CheckError(ret, __LINE__);
								_util->Wait_Sec(Measure_Delay_s);
							}
				
							loop_count++;
						}

						if (loop_count > max_loop)
						{
							ret = digitizer->StopAcquire("DIGITIZER");
							CheckError(ret, __LINE__);
							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);
							
							if(Test == TEST_IF4600_PKG)
							{
								ret = dio->DrivePin("DIO_3", 0);
								CheckError(ret, __LINE__);
								ret = dio->DrivePin("DIO_4", 0);
								CheckError(ret, __LINE__);
							}
							else
							{
								//Off K3, K4 
								ret = DriveCBit(TPDispName[0], 0);
								CheckError(ret, __LINE__);
							}

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult(TPName[i], (double)(-999));
							}

							goto test_end;
						}
									
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//Off K3, K4 
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						Vswg_calibrated->Add(DAC, Vswg_cal);
						Vswg_at_dut->Add(DAC, vout_pp);
					}
					else
					{
						if (i == 0)
						{
							ret = acm->ResetChannel("ACM_CH");
							CheckError(ret, __LINE__);
							ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
							CheckError(ret, __LINE__);
							ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
							CheckError(ret, __LINE__);

							ret = DigitizerFFT_Configure(digitizer_setting);
							CheckError(ret, __LINE__);
						}
					}

					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_1", 1);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_2", 1);
						CheckError(ret, __LINE__);
					}
					else
					{
						//On K1, K2
						ret = DriveCBit(TPDispName[0], 2);
						CheckError(ret, __LINE__);
					}

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
					CheckError(ret, __LINE__);
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					
					_util->Wait_Sec(Measure_Delay_s);

					//if (DAC == 8 || DAC == 12)
					//{
					//	nbrSamples = 2048;
					//	digitizer_setting[2] = (double)nbrSamples;
					//}

					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
					ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
					CheckError(ret, __LINE__);

					vin_r1 = Vswg_at_dut[DAC] / CONST_Rdr_Av_div;

					result[i] = 20 * Math::Log10(vout_pp / vin_r1);

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));		

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

						_glob->Global_Result[Global_Result_Index] = result[i];
					}
				}
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:

		//#ifdef USE_SPI
		//ret = OnOffSPI(0);
		//CheckError(ret, __LINE__);
		//#endif	

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_gain_hds_zdin(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		int DAC					= 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		int Total_Zdin			= (int)(tf_TestItemCondition_Cast("Total_Zdin"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		int Global_Result_Index = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		if(Test != TEST_IF4600_PKG)
		{
			ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			CheckError(ret, __LINE__);
			ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(ret, __LINE__);
			ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
			CheckError(ret, __LINE__);
		}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;
		int max_loop = 50;

		//Test
		array<double> ^ result		= gcnew array<double>(total_tp);

		array<double> ^ icc			= gcnew array<double>(Total_Zdin);
		array<double> ^ av_div_rin	= gcnew array<double>(Total_Zdin);
		array<double> ^ gain		= gcnew array<double>(Total_Zdin);
		array<double> ^ rdzin_r		= gcnew array<double>(Total_Zdin);
		array<double> ^ vout_meas	= gcnew array<double>(Total_Zdin);
		array<int> ^ rdzin_k		= gcnew array<int>(Total_Zdin);

		double rdzin = 0;
		double rdz_vin = 0;
		double r1_divider = 0;

		int k = 0;
		double current = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPDispName[i]->StartsWith("Zdin^Func"))
			{
				double slope = 0;
				double offset = 0;

				_util->line_fit(rdzin_k, vout_meas, k, slope, offset);
				double mono = 0;
				double mono_step = _util->monotonicity(vout_meas, k, 0, mono);
				mono /= slope;

				if (mono > 0.10) 
					result[i] = 1;
				else
					result[i] = 0;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("Delta")) //minus
			{
				result[i] = icc[1] - icc[0];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("-")) //minus
			{
				String ^ Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
				String ^ Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));
				String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

				int A = 0;
				int B = 0;

				A = _util->StrToInt(Global_Result_Index_A);
				B = _util->StrToInt(Global_Result_Index_B);

				if (Operation == "A-B")
					result[i] = _glob->Global_Result[A] - _glob->Global_Result[B];
				else
					result[i] = _glob->Global_Result[B] - _glob->Global_Result[A];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("ForceFastRec"))
			{
				String ^ Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
				String ^ Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));
				String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));
				double Threshold = (double)(tf_TPCondition_Cast(TPName[i], "Threshold")); 

				int A = 0;
				int B = 0;

				A = _util->StrToInt(Global_Result_Index_A);
				B = _util->StrToInt(Global_Result_Index_B);

				if (Operation == "A-B")
				{
					if (_glob->Global_Result[A] - _glob->Global_Result[B] > Threshold)
						result[i] = 1;
					else
						result[i] = 0;
				}
				else
				{
					if (_glob->Global_Result[B] - _glob->Global_Result[A] > Threshold)
						result[i] = 1;
					else
						result[i] = 0;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (! (i%2))
			{
				DAC = 8;
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;

				switch(k)
				{
					case 0:  rdzin=30.0;	break; //catalyst program use this but incorrect
					case 1:  rdzin=55.0;	break;
					case 2:  rdzin=75.0;	break;
					case 3:  rdzin=100.0;	break;
					//case 0:  rdzin=100.0;	break; //should be this instead
					//case 1:  rdzin=75.0;	break;
					//case 2:  rdzin=55.0;	break;
					//case 3:  rdzin=30.0;	break;
					default:  rdzin=75.0;  break;
				}

				r1_divider = CONST_R1 * ((CONST_Rr1 - CONST_R1 + rdzin) / (CONST_Rr1 + rdzin));
				av_div_rin[k] = ((2 * CONST_R4) + r1_divider) / r1_divider;
				rdzin_k[k] = k;

				///////////////////////////////
				//Program device (HSEL, IBIAS, GAIN)

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif

				///////////////////////////////
				//Calibration of Vpp

				if (Vswg_calibrated->ContainsKey(DAC) == false)
				{
					double Vswg_cal = 0;
					int loop_count = 0;

					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_1", 0);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_2", 0);
						CheckError(ret, __LINE__);

						ret = dio->DrivePin("DIO_3", 1);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 1);
						CheckError(ret, __LINE__);
					}
					else
					{
						//On K3, K4
						ret = DriveCBit(TPDispName[0], 1);
						CheckError(ret, __LINE__);
					}

					Vswg_cal = Vswg;

					ret = acm->ResetChannel("ACM_CH");
					CheckError(ret, __LINE__);
					ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					CheckError(ret, __LINE__);
					ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(1e-3);
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);

					int do_once = 0;
					while(loop_count <= max_loop)
					{
						if (do_once == 0)
						{
							ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
							CheckError(ret, __LINE__);
							if (Test == TEST_IF4600_PKG)
							{
								ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
								CheckError(ret, __LINE__);
							}
							ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
							CheckError(ret, __LINE__);
							ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
							CheckError(ret, __LINE__);
							do_once = 1;
						}

						ret = digitizer->StartAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = digitizer->ForceTrigger("DIGITIZER");
						if (ret == -1074116410) //ERROR: Instrument already stopped
							ret = 0;
						CheckError(ret, __LINE__);

						ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
						if (ret == -1074116410) //ERROR: Instrument already stopped
							ret = 0;
						CheckError(ret, __LINE__);

						if (ret)
						{
							if (Debug_Enable == true)
							{
								StringBuilder ^ sa = gcnew StringBuilder();
								ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

								sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
								sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
							}

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult(TPName[i], (double)(-999));
							}

							goto test_end;
						}

						ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
						CheckError(ret, __LINE__);
						if (Test == TEST_IF4600_PKG)
						{
							ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
							CheckError(ret, __LINE__);
						}
				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
							for (int i = 0; i < nbrSamples; i++) 
							{
								outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
							}
							outFile.close();
						}

						if (Test == TEST_IF4600_PKG)
						{
							for (int i=0; i<dataArrayP->Length; i++)
							{
								dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
							}
						}

						vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

						vout_pp = vout_pp * diff2se_digitizer_factor;

						if (Math::Abs(Vswg - vout_pp) < 4e-3)
						{
							break;
						}
						else
						{
							Vswg_cal = Vswg_cal + (Vswg - vout_pp);

							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);
							ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
							{
								CheckError(ret, __LINE__);	
							}

							if (ret != 0)
							{
								ret = 0;

								ret = digitizer->StopAcquire("DIGITIZER");
								CheckError(ret, __LINE__);
								ret = acm->StopFG("ACM_CH"); 
								CheckError(ret, __LINE__);
								
								if(Test == TEST_IF4600_PKG)
								{
									ret = dio->DrivePin("DIO_3", 0);
									CheckError(ret, __LINE__);
									ret = dio->DrivePin("DIO_4", 0);
									CheckError(ret, __LINE__);
								}
								else
								{
									//Off K3, K4 
									ret = DriveCBit(TPDispName[0], 0);
									CheckError(ret, __LINE__);
								}

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult(TPName[i], (double)(-999));
								}

								goto test_end;
							}

							ret = acm->RunFG("ACM_CH", 0, true);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);
						}
			
						loop_count++;
					}

					if (loop_count > max_loop)
					{
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//Off K3, K4 
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
								
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					
					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_3", 0);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 0);
						CheckError(ret, __LINE__);
					}
					else
					{
						//Off K3, K4 
						ret = DriveCBit(TPDispName[0], 0);
						CheckError(ret, __LINE__);
					}

					Vswg_calibrated->Add(DAC, Vswg_cal);
					Vswg_at_dut->Add(DAC, vout_pp);
				}
				else
				{
					if (i == 0)
					{
						ret = acm->ResetChannel("ACM_CH");
						CheckError(ret, __LINE__);
						ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
						CheckError(ret, __LINE__);
						double tmp = Vswg_calibrated[DAC];
						ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
						CheckError(ret, __LINE__);
						ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
						CheckError(ret, __LINE__);

						ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
						CheckError(ret, __LINE__);
						ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
						CheckError(ret, __LINE__);
						ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
						CheckError(ret, __LINE__);
						ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
						if (Test == TEST_IF4600_PKG)
						{
							ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
							CheckError(ret, __LINE__);
						}
						ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
						CheckError(ret, __LINE__);
						ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
						CheckError(ret, __LINE__);
					}
				}

				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_1", 1);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_2", 1);
					CheckError(ret, __LINE__);
				}
				else
				{
					//On K1, K2
					ret = DriveCBit(TPDispName[0], 2);
					CheckError(ret, __LINE__);
				}

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
				CheckError(ret, __LINE__);
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
				
				_util->Wait_Sec(Measure_Delay_s);

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);
				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
									
					for (int j=0; j<dataArrayP->Length; j++)
					{
						dataArrayP[j] = dataArrayP[j] - dataArrayN[j]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				vout_meas[k] = vout_pp;

				rdz_vin = (Vswg_at_dut[DAC]/CONST_Rdr_Av_div) * (av_div_rin[k] / CONST_Rdr_Av_div); 

				gain[k] = (vout_pp / rdz_vin) / 6.3096; //20log(6.3096)=16dB for gain dac=8
				
				rdzin_r[k] = (1886.0-(gain[k] * CONST_Rr1))/gain[k];

				ret = smu->ReadCurrent("VCC", current);
				CheckError(ret, __LINE__);

				icc[k] = current;

				result[i] = vout_pp;
				result[i+1] = rdzin_r[k];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));	
				tf_SetResult(TPName[i+1], result[i+1] + GetOffset(TPDispName[i+1]));	

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

					_glob->Global_Result[Global_Result_Index] = icc[k];
				}

				k++;
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
			{
				Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_gain_hds_zdin2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		int DAC					= 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		int Total_Zdin			= (int)(tf_TestItemCondition_Cast("Total_Zdin"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		int Global_Result_Index = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 
		//#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		//#else
		//ret = OnOffSPI(1);
		//CheckError(ret, __LINE__);
		//ret = RunSPI("write_default_reg");
		//CheckError(ret, __LINE__);
		//ret = RunSPI(Vector_File);
		//CheckError(ret, __LINE__);
		//#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 4096; //512; //1024; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;
		int max_loop = 50;

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	
		int Decimation_Factor = 1;

		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		//Test
		array<double> ^ result		= gcnew array<double>(total_tp);

		array<double> ^ icc			= gcnew array<double>(Total_Zdin);
		array<double> ^ av_div_rin	= gcnew array<double>(Total_Zdin);
		array<double> ^ gain		= gcnew array<double>(Total_Zdin);
		array<double> ^ rdzin_r		= gcnew array<double>(Total_Zdin);
		array<double> ^ vout_meas	= gcnew array<double>(Total_Zdin);
		array<int> ^ rdzin_k		= gcnew array<int>(Total_Zdin);

		double rdzin = 0;
		double rdz_vin = 0;
		double r1_divider = 0;

		int k = 0;
		double current = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPDispName[i]->StartsWith("Zdin^Func"))
			{
				double slope = 0;
				double offset = 0;

				_util->line_fit(rdzin_k, vout_meas, k, slope, offset);
				double mono = 0;
				double mono_step = _util->monotonicity(vout_meas, k, 0, mono);
				mono /= slope;

				if (mono > 0.10) 
					result[i] = 1;
				else
					result[i] = 0;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("Delta")) //minus
			{
				result[i] = icc[1] - icc[0];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("-")) //minus
			{
				String ^ Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
				String ^ Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));
				String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

				int A = 0;
				int B = 0;

				A = _util->StrToInt(Global_Result_Index_A);
				B = _util->StrToInt(Global_Result_Index_B);

				if (Operation == "A-B")
					result[i] = _glob->Global_Result[A] - _glob->Global_Result[B];
				else
					result[i] = _glob->Global_Result[B] - _glob->Global_Result[A];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("ForceFastRec"))
			{
				String ^ Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
				String ^ Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));
				String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));
				double Threshold = (double)(tf_TPCondition_Cast(TPName[i], "Threshold")); 

				int A = 0;
				int B = 0;

				A = _util->StrToInt(Global_Result_Index_A);
				B = _util->StrToInt(Global_Result_Index_B);

				if (Operation == "A-B")
				{
					if (_glob->Global_Result[A] - _glob->Global_Result[B] > Threshold)
						result[i] = 1;
					else
						result[i] = 0;
				}
				else
				{
					if (_glob->Global_Result[B] - _glob->Global_Result[A] > Threshold)
						result[i] = 1;
					else
						result[i] = 0;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (! (i%2))
			{
				DAC = 8;
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;

				switch(k)
				{
					case 0:  rdzin=100.0;	break; 
					case 1:  rdzin=75.0;	break;
					case 2:  rdzin=55.0;	break;
					case 3:  rdzin=30.0;	break;
					default:  rdzin=75.0;  break;
				}

				r1_divider = CONST_R1 * ((CONST_Rr1 - CONST_R1 + rdzin) / (CONST_Rr1 + rdzin));
				av_div_rin[k] = ((2 * CONST_R4) + r1_divider) / r1_divider;
				rdzin_k[k] = k;

				///////////////////////////////
				//Program device (HSEL, IBIAS, GAIN)

				//#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				//#else
				//ret = RunSPI(Vector_File);
				//CheckError(ret, __LINE__);
				//#endif

				///////////////////////////////
				//Calibration of Vpp

				#pragma region "Calibration of Vpp"
				if (Vswg_calibrated->ContainsKey(DAC) == false)
				{
					double Vswg_cal = 0;
					int loop_count = 0;

					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_1", 0);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_2", 0);
						CheckError(ret, __LINE__);

						ret = dio->DrivePin("DIO_3", 1);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 1);
						CheckError(ret, __LINE__);
					}
					else
					{
						//On K3, K4
						ret = DriveCBit(TPDispName[0], 1);
						CheckError(ret, __LINE__);
					}

					Vswg_cal = Vswg;

					ret = acm->ResetChannel("ACM_CH");
					CheckError(ret, __LINE__);
					ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					CheckError(ret, __LINE__);
					ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(1e-3);
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);

					int do_once = 0;
					while(loop_count <= max_loop)
					{
						if (do_once == 0)
						{
							ret = DigitizerFFT_Configure(digitizer_setting);
							CheckError(ret, __LINE__);
							do_once = 1;
						}

						//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
						ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

						if (ret)
						{
							ret = digitizer->StopAcquire("DIGITIZER");
							CheckError(ret, __LINE__);

							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult(TPName[i], (double)(-999));
							}

							goto test_end;
						}

						if (Math::Abs(Vswg - vout_pp) < 4e-3)
						{
							break;
						}
						else
						{
							Vswg_cal = Vswg_cal + (Vswg - vout_pp);

							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);
							ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
							{
								CheckError(ret, __LINE__);	
							}

							if (ret != 0)
							{
								ret = 0;

								ret = digitizer->StopAcquire("DIGITIZER");
								CheckError(ret, __LINE__);
								ret = acm->StopFG("ACM_CH"); 
								CheckError(ret, __LINE__);
								
								if(Test == TEST_IF4600_PKG)
								{
									ret = dio->DrivePin("DIO_3", 0);
									CheckError(ret, __LINE__);
									ret = dio->DrivePin("DIO_4", 0);
									CheckError(ret, __LINE__);
								}
								else
								{
									//Off K3, K4 
									ret = DriveCBit(TPDispName[0], 0);
									CheckError(ret, __LINE__);
								}

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult(TPName[i], (double)(-999));
								}

								goto test_end;
							}

							ret = acm->RunFG("ACM_CH", 0, true);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);
						}
			
						loop_count++;
					}

					if (loop_count > max_loop)
					{
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//Off K3, K4 
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
								
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					
					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_3", 0);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 0);
						CheckError(ret, __LINE__);
					}
					else
					{
						//Off K3, K4 
						ret = DriveCBit(TPDispName[0], 0);
						CheckError(ret, __LINE__);
					}

					Vswg_calibrated->Add(DAC, Vswg_cal);
					Vswg_at_dut->Add(DAC, vout_pp);
				}
				else
				{
					if (i == 0)
					{
						ret = acm->ResetChannel("ACM_CH");
						CheckError(ret, __LINE__);

						ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
						CheckError(ret, __LINE__);

						ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
						CheckError(ret, __LINE__);

						ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
						CheckError(ret, __LINE__);

						ret = DigitizerFFT_Configure(digitizer_setting);
						CheckError(ret, __LINE__);
					}
				}
				#pragma endregion "Calibration of Vpp"

				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_1", 1);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_2", 1);
					CheckError(ret, __LINE__);
				}
				else
				{
					//On K1, K2
					ret = DriveCBit(TPDispName[0], 2);
					CheckError(ret, __LINE__);
				}

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[DAC]/2, -1 * Vswg_calibrated[DAC]/2, Fswg, 0);
				CheckError(ret, __LINE__);
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
				
				_util->Wait_Sec(Measure_Delay_s);

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				vout_meas[k] = vout_pp;

				rdz_vin = (Vswg_at_dut[DAC]/CONST_Rdr_Av_div) * (av_div_rin[k] / CONST_Rdr_Av_div); 

				gain[k] = (vout_pp / rdz_vin) / 6.3096; //20log(6.3096)=16dB for gain dac=8
				
				rdzin_r[k] = (1886.0-(gain[k] * CONST_Rr1))/gain[k];

				ret = smu->ReadCurrent("VCC", current);
				CheckError(ret, __LINE__);

				icc[k] = current;

				result[i] = vout_pp;
				result[i+1] = rdzin_r[k];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));	
				tf_SetResult(TPName[i+1], result[i+1] + GetOffset(TPDispName[i+1]));	

				k++;
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
			{
				Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		//#ifdef USE_SPI
		//ret = OnOffSPI(0);
		//CheckError(ret, __LINE__);
		//#endif		
		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_gain_hds_vir_vor(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		int Global_Result_Index_av_odr = (int)(tf_TestItemCondition_Cast("Global_Result_Index_av_odr"));
		int Global_Result_Index_av_idr = (int)(tf_TestItemCondition_Cast("Global_Result_Index_av_idr"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		///////////////////////////////////////////////////////////////////////////////////////////
		//Pre-requisite is gain_hds_hr0 test
		///////////////////////////////////////////////////////////////////////////////////////////
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		if(Test != TEST_IF4600_PKG)
		{
			ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			CheckError(ret, __LINE__);
			ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(ret, __LINE__);
			ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
			CheckError(ret, __LINE__);
		}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;
		int max_loop = 50;

		//Test
		array<double> ^ result		= gcnew array<double>(total_tp);

		double idr_l = 20e-3; //20mVpp
		double odr_l = 400e-3; //400mVpp
		double vin_idr = (idr_l * 1.5) * CONST_Rdr_Av_div;   /* Target spec +30% for margin */
		double vout_odr = odr_l * 1.5; /* Target spec +30% for margin */  

		double vin_odr_highest = 0.0;
		double vin_odr = 0;
		double vin_odr_i = 0;

		double compute_av_odr = 0;
		double compute_av_idr = 0;
		
		double vout_idr = 0;
		double vin_idr_meas = 0;
		double vout_odr_meas = 0;

		double dac_odr = 8;

		{
			///////////////////////
			// Capture idr output

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_1", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_2", 1);
				CheckError(ret, __LINE__);
			}
			else
			{	
				//On K1, K2
				ret = DriveCBit(TPDispName[0], 2);
				CheckError(ret, __LINE__);
			}	

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", vin_idr/2, -1 * vin_idr/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = digitizer->ForceTrigger("DIGITIZER");
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			if (ret)
			{
				if (Debug_Enable == true)
				{
					StringBuilder ^ sa = gcnew StringBuilder();
					ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);
					CheckError(ret, __LINE__);

					sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
					sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
				CheckError(ret, __LINE__);
			}
	
			if (Debug_Enable == true)
			{
				ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
				for (int i = 0; i < nbrSamples; i++) 
				{
					outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
				}
				outFile.close();
			}

			if (Test == TEST_IF4600_PKG)
			{
				for (int i=0; i<dataArrayP->Length; i++)
				{
					dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
				}
			}

			vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

			vout_pp = vout_pp * diff2se_digitizer_factor;

			vout_idr = vout_pp;

			ret = acm->StopFG("ACM_CH");
			CheckError(ret, __LINE__);

			if (Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_1", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_2", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//Off K1, K2 
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			///////////////////////
			// Capture idr output

			if (Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = digitizer->ForceTrigger("DIGITIZER");
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			if (ret)
			{
				if (Debug_Enable == true)
				{
					StringBuilder ^ sa = gcnew StringBuilder();
					ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

					sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
					sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
				CheckError(ret, __LINE__);
			}
	
			if (Debug_Enable == true)
			{
				ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
				for (int i = 0; i < nbrSamples; i++) 
				{
					outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
				}
				outFile.close();
			}

			if (Test == TEST_IF4600_PKG)
			{
				for (int i=0; i<dataArrayP->Length; i++)
				{
					dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
				}
			}

			vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

			vout_pp = vout_pp * diff2se_digitizer_factor;

			vin_idr_meas = vout_pp;

			///////////////////////
			// Capture odr input

			vout_odr		= odr_l * 1.5;

			compute_av_odr	= Math::Pow(10, _glob->Global_Result[Global_Result_Index_av_odr]/20);
			vin_odr			= (vout_odr / compute_av_odr * CONST_Rdr_Av_div);
			vin_odr_i		= vin_odr * 1000;
			vin_odr			= vin_odr_i / 1000.0;

			if (vin_odr_highest < 1.5)
			{
				ret = acm->StopFG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = acm->ConfigureFGSineWaveform("ACM_CH", (vin_odr)/2, -1 * (vin_odr)/2, Fswg, 0);
				CheckError(ret, __LINE__);
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
			}

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_1);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File_1);
			CheckError(ret, __LINE__);
			#endif

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = digitizer->ForceTrigger("DIGITIZER");
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			if (ret)
			{
				if (Debug_Enable == true)
				{
					StringBuilder ^ sa = gcnew StringBuilder();
					ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);
					CheckError(ret, __LINE__);

					sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
					sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
				CheckError(ret, __LINE__);
			}
	
			if (Debug_Enable == true)
			{
				ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
				for (int i = 0; i < nbrSamples; i++) 
				{
					outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
				}
				outFile.close();
			}

			if (Test == TEST_IF4600_PKG)
			{
				for (int i=0; i<dataArrayP->Length; i++)
				{
					dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
				}
			}

			vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

			vout_pp = vout_pp * diff2se_digitizer_factor;

			vin_odr = vout_pp;

			///////////////////////
			// Capture odr input

			ret = acm->StopFG("ACM_CH");
			CheckError(ret, __LINE__);

			if (Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
				
				ret = dio->DrivePin("DIO_1", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_2", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K1, K2
				ret = DriveCBit(TPDispName[0], 2);
				CheckError(ret, __LINE__);
			}

			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(Measure_Delay_s);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = digitizer->ForceTrigger("DIGITIZER");
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret == -1074116410) //ERROR: Instrument already stopped
				ret = 0;
			CheckError(ret, __LINE__);

			ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
			CheckError(ret, __LINE__);

			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
				CheckError(ret, __LINE__);
						
				for (int j=0; j<dataArrayP->Length; j++)
				{
					dataArrayP[j] = dataArrayP[j] - dataArrayN[j]; //get the differential values
				}
			}

			vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

			vout_pp = vout_pp * diff2se_digitizer_factor;
			
			vout_odr_meas = vout_pp;

			compute_av_idr = Math::Pow(10, _glob->Global_Result[Global_Result_Index_av_idr]/20);

			double idr_ref = compute_av_idr;
			double odr_ref = compute_av_odr;

			double idr = (vout_idr / (vin_idr_meas / CONST_Rdr_Av_div)) / idr_ref;
			double odr = (vout_odr_meas / (vin_odr / CONST_Rdr_Av_div)) / odr_ref;

			tf_SetResult(TPName[0], idr * 100 + GetOffset(TPDispName[0]));

			if (idr < 0.9)
				tf_SetResult(TPName[1], (double)(-1e-3) + GetOffset(TPDispName[1]));
		    else if (idr > 1.1)
				tf_SetResult(TPName[1], (double)(1e-3) + GetOffset(TPDispName[1]));
			else
				tf_SetResult(TPName[1], (double)(vin_idr_meas / CONST_Rdr_Av_div) + GetOffset(TPDispName[1]));
      
			tf_SetResult(TPName[2], dac_odr + GetOffset(TPDispName[2]));

			tf_SetResult(TPName[3], odr * 100 + GetOffset(TPDispName[3]));
			
			if (odr < 0.9)
				tf_SetResult(TPName[4], (double)(-1e-3) + GetOffset(TPDispName[4]));
			else if (odr > 1.1)
				tf_SetResult(TPName[4], (double)(1e-3) + GetOffset(TPDispName[4]));
			else
				tf_SetResult(TPName[4], vout_odr_meas + GetOffset(TPDispName[4]));
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_gain_hds_vir_vor2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		int Global_Result_Index_av_odr = (int)(tf_TestItemCondition_Cast("Global_Result_Index_av_odr"));
		int Global_Result_Index_av_idr = (int)(tf_TestItemCondition_Cast("Global_Result_Index_av_idr"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		///////////////////////////////////////////////////////////////////////////////////////////
		//Pre-requisite is gain_hds_hr0 test
		///////////////////////////////////////////////////////////////////////////////////////////
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 4096; //1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;
		int max_loop = 50;

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	
		int Decimation_Factor = 1;

		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		//Test
		array<double> ^ result		= gcnew array<double>(total_tp);

		double idr_l = 20e-3; //20mVpp
		double odr_l = 400e-3; //400mVpp
		double vin_idr = (idr_l * 1.5) * CONST_Rdr_Av_div;   
		double vout_odr = odr_l * 1.5;  

		double vin_odr_highest = 0.0;
		double vin_odr = 0;
		double vin_odr_i = 0;

		double compute_av_odr = 0;
		double compute_av_idr = 0;
		
		double vout_idr = 0;
		double vin_idr_meas = 0;
		double vout_odr_meas = 0;

		double dac_odr = 8;

		{
			///////////////////////
			// Capture idr output

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_1", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_2", 1);
				CheckError(ret, __LINE__);
			}
			else
			{	
				//On K1, K2
				ret = DriveCBit(TPDispName[0], 2);
				CheckError(ret, __LINE__);
			}	

			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", vin_idr/2, -1 * vin_idr/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			CheckError(ret, __LINE__);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			ret = DigitizerFFT_Configure(digitizer_setting);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
			ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

			if (ret)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			vout_idr = vout_pp;

			ret = acm->StopFG("ACM_CH");
			CheckError(ret, __LINE__);

			if (Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_1", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_2", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//Off K1, K2 
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			///////////////////////
			// Capture idr output

			if (Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
			ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

			if (ret)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			vin_idr_meas = vout_pp;

			///////////////////////
			// Capture odr input

			vout_odr		= odr_l * 1.5;

			compute_av_odr	= Math::Pow(10, _glob->Global_Result[Global_Result_Index_av_odr]/20);
			vin_odr			= (vout_odr / compute_av_odr * CONST_Rdr_Av_div);
			vin_odr_i		= vin_odr * 1000;
			vin_odr			= vin_odr_i / 1000.0;

			if (vin_odr_highest < 1.5)
			{
				ret = acm->StopFG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = acm->ConfigureFGSineWaveform("ACM_CH", (vin_odr)/2, -1 * (vin_odr)/2, Fswg, 0);
				CheckError(ret, __LINE__);
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
			}

			ret = RunVectorFile(Vector_File_1);
			CheckError(ret, __LINE__);

			//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
			ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

			if (ret)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			vin_odr = vout_pp;

			///////////////////////
			// Capture odr input

			ret = acm->StopFG("ACM_CH");
			CheckError(ret, __LINE__);

			if (Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
				
				ret = dio->DrivePin("DIO_1", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_2", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K1, K2
				ret = DriveCBit(TPDispName[0], 2);
				CheckError(ret, __LINE__);
			}

			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(Measure_Delay_s);

			//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
			ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

			if (ret)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
			
			vout_odr_meas = vout_pp;

			compute_av_idr = Math::Pow(10, _glob->Global_Result[Global_Result_Index_av_idr]/20);

			double idr_ref = compute_av_idr;
			double odr_ref = compute_av_odr;

			double idr = (vout_idr / (vin_idr_meas / CONST_Rdr_Av_div)) / idr_ref;
			double odr = (vout_odr_meas / (vin_odr / CONST_Rdr_Av_div)) / odr_ref;

			tf_SetResult(TPName[0], idr * 100 + GetOffset(TPDispName[0]));

			if (idr < 0.9)
				tf_SetResult(TPName[1], (double)(-1e-3) + GetOffset(TPDispName[1]));
		    else if (idr > 1.1)
				tf_SetResult(TPName[1], (double)(1e-3) + GetOffset(TPDispName[1]));
			else
				tf_SetResult(TPName[1], (double)(vin_idr_meas / CONST_Rdr_Av_div) + GetOffset(TPDispName[1]));
      
			tf_SetResult(TPName[2], dac_odr + GetOffset(TPDispName[2]));

			tf_SetResult(TPName[3], odr * 100 + GetOffset(TPDispName[3]));
			
			if (odr < 0.9)
				tf_SetResult(TPName[4], (double)(-1e-3) + GetOffset(TPDispName[4]));
			else if (odr > 1.1)
				tf_SetResult(TPName[4], (double)(1e-3) + GetOffset(TPDispName[4]));
			else
				tf_SetResult(TPName[4], vout_odr_meas + GetOffset(TPDispName[4]));
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif			

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	//
	int TestProgram::seq_power(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ result2 = gcnew array<double>(total_tp);
		array<double> ^ result3 = gcnew array<double>(total_tp);
		array<double> ^ result4 = gcnew array<double>(total_tp);
		array<int> ^ Drive_WRN_V = gcnew array<int>(total_tp);
		array<int> ^ Drive_PWR_SAVE = gcnew array<int>(total_tp);
		array<int> ^ data_pg1 = gcnew array<int>(32);
		array<int> ^ data_pg2 = gcnew array<int>(32);
		array<int> ^ data_pg4 = gcnew array<int>(32);


		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			result2[i] = 0;
			result3[i] = 0;
			result4[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double Clamp_Vee_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vee_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= 0;
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		bool isCurrentTPBypassed = false;

		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File	= String::Empty;
		String ^ Vector_File_1	= String::Empty;
		String ^ Measure_Pin	= String::Empty;
		String ^ Measure_Pin_1	= String::Empty;
		int Global_Result_Index = 0;
		int Global_Result_Index_1 = 0;
		String ^ Operation		= String::Empty; 

		double Drive_Vcc2_V		= 0;
		double Drive_Vee2_V		= 0;
		int On_SPI_Once			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", 0.5);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", 0.5);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		//ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		//ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		//ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=	" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
		ret = dm->DPINOff("FLTMUX");
		ret = dm->DPINOff("PWR_SAVE");
		ret = dm->DPINOff("WDX");
		ret = dm->DPINOff("WDY");
		ret = dm->DPINOff("RWN");
		ret = dm->DPINOff("SPD");
		ret = dm->DPINOff("SPC");
		ret = dm->DPINOff("SPE");

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
				{
					NPLC	= (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));

					//ret = smu->ConfigurePLF("VEE", Power_Line_Freq);
					//CheckError(ret, __LINE__);
					ret = smu->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);

					//ret = smu->ConfigurePLF("VCC", Power_Line_Freq);
					//CheckError(ret, __LINE__);
					ret = smu->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					ret = dm->DPINOn("SPE");
					ret = dm->DPINOn("SPD");
					ret = dm->DPINOn("SPC");

					if(On_SPI_Once == 0)
					{
						#ifdef USE_SPI
						ret = OnOffSPI(1);
						CheckError(ret, __LINE__);
						#endif

						ret = DriveDMPin2(TPDispName[0]);
						CheckError(ret, __LINE__);
						On_SPI_Once = 1;
					}

					if((TPDispName[i]->Contains("3p3") == true) || (TPDispName[i]->Contains("Icc_i^") == true) || (TPDispName[i]->Contains("Iee_i^") == true) ||
						(TPDispName[i]->Contains("Icc_s^") == true) || (TPDispName[i]->Contains("Icc_s^") == true)) //follow Catalyst to remove pin loading for icc_s_3p3 & iee_s_3p3
					{
						ret = dm->DPINOn("SPE");
						ret = dm->DPINOn("SPD");
						ret = dm->DPINOn("SPC");
						ret = dm->DPINOn("RWN");
						ret = dm->DPINOn("WDX");
						ret = dm->DPINOn("WDY");
						ret = dm->DPINOff("FLTMUX");
						ret = dm->DPINOff("PWR_SAVE");
					}
					else 
					{
						ret = dm->DPINOn("SPE");
						ret = dm->DPINOn("SPD");
						ret = dm->DPINOn("SPC");
						ret = dm->DPINOn("RWN");
						ret = dm->DPINOn("WDX");
						ret = dm->DPINOn("WDY");
						ret = dm->DPINOff("FLTMUX");//Follow Catalyst's code
						ret = dm->DPINOn("PWR_SAVE");
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_WRN_V") == true)
					{
						Drive_WRN_V[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_WRN_V");
						ret = dm->DrivePin("RWN", Drive_WRN_V[i]);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_PWR_SAVE") == true)
					{
						Drive_PWR_SAVE[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_PWR_SAVE");
						ret = dm->DrivePin("PWR_SAVE", Drive_PWR_SAVE[i]);
					}

					//if (i == 0 || i == 2)
					//{
						//Set Icmpl to 0.5A before any register changes
					//	ret = smu->ClampCurrent("VCC", 0.01);
					//	CheckError(ret, __LINE__);
						//_util->Wait_Sec(0.001);

						//Set Icmpl to 0.5A before any register changes
					//	ret = smu->ClampCurrent("VEE", 0.01);
					//	CheckError(ret, __LINE__);
					//	_util->Wait_Sec(0.001);

						//array<double> ^ tmpI = gcnew array<double>(4096);
						//array<double> ^ tmpV = gcnew array<double>(4096);
						//ret = smu->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);

						//for (int z=0; z<4096; z++)
						//{
						//	_util->Wait_Sec(100e-6);
						//	ret = smu->ReadCurrent("VEE", tmpI[z]);
						//	ret = smu->ReadVoltage("VEE", tmpV[z]);
						//}

						//ret = smu->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
					//}
					//else
					{
						//Set Icmpl to 0.5A before any register changes
						ret = smu->ClampCurrent("VCC", 0.5);
						CheckError(ret, __LINE__);
						//_util->Wait_Sec(0.001);

						//Set Icmpl to 0.5A before any register changes
						ret = smu->ClampCurrent("VEE", 0.5);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(0.001);
					}

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

					/*ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);*/
				}

				////pg1
				//ret = ReadVector("read_p1_reg0", data_pg1[0]);
				//ret = ReadVector("read_p1_reg1", data_pg1[1]);
				//ret = ReadVector("read_p1_reg2", data_pg1[2]);
				//ret = ReadVector("read_p1_reg3", data_pg1[3]);
				//ret = ReadVector("read_p1_reg4", data_pg1[4]);
				//ret = ReadVector("read_p1_reg5", data_pg1[5]);
				//ret = ReadVector("read_p1_reg6", data_pg1[6]);
				//ret = ReadVector("read_p1_reg7", data_pg1[7]);
				//ret = ReadVector("read_p1_reg8", data_pg1[8]);
				//ret = ReadVector("read_p1_reg9", data_pg1[9]);
				//ret = ReadVector("read_p1_reg10", data_pg1[10]);
				//ret = ReadVector("read_p1_reg11", data_pg1[11]);
				//ret = ReadVector("read_p1_reg12", data_pg1[12]);
				//ret = ReadVector("read_p1_reg13", data_pg1[13]);
				//ret = ReadVector("read_p1_reg14", data_pg1[14]);
				//ret = ReadVector("read_p1_reg15", data_pg1[15]);
				//ret = ReadVector("read_p1_reg16", data_pg1[16]);
				//ret = ReadVector("read_p1_reg17", data_pg1[17]);
				//ret = ReadVector("read_p1_reg18", data_pg1[18]);
				//ret = ReadVector("read_p1_reg19", data_pg1[19]);
				//ret = ReadVector("read_p1_reg20", data_pg1[20]);
				//ret = ReadVector("read_p1_reg21", data_pg1[21]);
				//ret = ReadVector("read_p1_reg22", data_pg1[22]);
				//ret = ReadVector("read_p1_reg23", data_pg1[23]);
				//ret = ReadVector("read_p1_reg24", data_pg1[24]);
				//ret = ReadVector("read_p1_reg25", data_pg1[25]);
				//ret = ReadVector("read_p1_reg26", data_pg1[26]);
				//ret = ReadVector("read_p1_reg27", data_pg1[27]);
				//ret = ReadVector("read_p1_reg28", data_pg1[28]);
				//ret = ReadVector("read_p1_reg29", data_pg1[29]);
				//ret = ReadVector("read_p1_reg30", data_pg1[30]);
				//ret = ReadVector("read_p1_reg31", data_pg1[31]);
				////pg2
				//ret = ReadVector("read_p2_reg32", data_pg2[0]);
				//ret = ReadVector("read_p2_reg33", data_pg2[1]);
				//ret = ReadVector("read_p2_reg34", data_pg2[2]);
				//ret = ReadVector("read_p2_reg38", data_pg2[6]);
				//ret = ReadVector("read_p2_reg39", data_pg2[7]);
				//ret = ReadVector("read_p2_reg40", data_pg2[8]);
				//ret = ReadVector("read_p2_reg54", data_pg2[22]);
				//ret = ReadVector("read_p2_reg56", data_pg2[24]);
				//ret = ReadVector("read_p2_reg57", data_pg2[25]);
				//ret = ReadVector("read_p2_reg58", data_pg2[26]);
				//ret = ReadVector("read_p2_reg59", data_pg2[27]);
				//ret = ReadVector("read_p2_reg60", data_pg2[28]);
				//ret = ReadVector("read_p2_reg61", data_pg2[29]);
				//ret = ReadVector("read_p2_reg62", data_pg2[30]);
				//ret = ReadVector("read_p2_reg63", data_pg2[31]);
				////pg4
				//ret = RunVectorFile("write_p2_reg63_extregsp_enable_h");
				//ret = ReadVector("read_p4_reg16", data_pg4[16]);
				//ret = ReadVector("read_p4_reg17", data_pg4[17]);
				//ret = ReadVector("read_p4_reg18", data_pg4[18]);
				//ret = ReadVector("read_p4_reg25", data_pg4[25]);
				//ret = ReadVector("read_p4_reg26", data_pg4[26]);
				//ret = ReadVector("read_p4_reg27", data_pg4[27]);
				//ret = ReadVector("read_p4_reg28", data_pg4[28]);
				//ret = ReadVector("read_p4_reg29", data_pg4[29]);
				//ret = ReadVector("read_p4_reg30", data_pg4[30]);

				if (tf_TPCondition_exist(TPName[i], "Clamp_Vcc_Current_A") == true)
				{
					////Set Icmpl to 0.5A before any register changes
					//ret = smu->ClampCurrent("VCC", 0.5);
					//CheckError(ret, __LINE__);
					//_util->Wait_Sec(0.001);

					Clamp_Vcc_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vcc_Current_A"));
					ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Clamp_Vee_Current_A") == true)
				{
					////Set Icmpl to 0.5A before any register changes
					//ret = smu->ClampCurrent("VEE", 0.5);
					//CheckError(ret, __LINE__);
					//_util->Wait_Sec(0.001);

					Clamp_Vee_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vee_Current_A"));
					ret = smu->ClampCurrent("VEE", Clamp_Vee_Current_A);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc2_V") == true)
				{
					Drive_Vcc2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc2_V"));
					ret = smu->DriveVoltage("VCC", Drive_Vcc2_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee2_V") == true)
				{
					Drive_Vee2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee2_V"));
					ret = smu->DriveVoltage("VEE", Drive_Vee2_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
				{
					Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
					_util->Wait_Sec(Measure_Delay_s);
				}

				if (tf_TPCondition_exist(TPName[i], "Measure_Pin") == true)
				{
					Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));

					//array<double> ^ tmpI = gcnew array<double>(1024);
					//array<double> ^ tmpV = gcnew array<double>(1024);
					//ret = smu->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);

					//for (int z=0; z<1024; z++)
					//{
					//	_util->Wait_Sec(10e-6);
					//	ret = smu->ReadCurrent("VEE", tmpI[z]);
					//	ret = smu->ReadVoltage("VEE", tmpV[z]);
					//}

					//ret = smu->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
					
					if (Measure_Pin == "VCC")
					{
						ret = smu->ReadCurrent("VCC", result[i]);
						CheckError(ret, __LINE__);
					}

					if (Measure_Pin == "VEE")
					{
						if (tf_TPCondition_exist(TPName[i], "Barrier_Index") == true)
						{
							ret = OnOffFETGnd(0);
							CheckError(ret, __LINE__);

							int idx = (int)(tf_TPCondition_Cast(TPName[i], "Barrier_Index"));

							Barrier(idx);

							if (true)
							{
								msclr::lock enter(__gndIsolateLock);

								ret = OnOffFETGnd(1);
								CheckError(ret, __LINE__);

								_util->Wait_Sec(Measure_Delay_s);

								ret = smu->ReadCurrent("VEE", result[i]);
								CheckError(ret, __LINE__);

								ret = OnOffFETGnd(0);
								CheckError(ret, __LINE__);
							}

							Barrier(idx+1);

							ret = OnOffFETGnd(1);
							CheckError(ret, __LINE__);
						}
						else
						{	
							if (i == 1 || i == 3)
							{
								//ret = smu->ConfigureOutputEnabled("VEE", false);
								//ret = smu->ConfigureSamplingTime("VEE", 1, AM_CONST_PLC);
								//CheckError(ret, __LINE__);

								_util->Wait_Sec(0.2);

								//int data = 0;
								//ret = OnOffSPI(0);
								//ret = ReadVector("read_p1_reg9", data);
								//CheckError(ret, __LINE__); 
								//ret = OnOffSPI(1);
							}

							ret = smu->ReadCurrent("VEE", result[i]);
							CheckError(ret, __LINE__);
							
							//if (i == 1 || i == 3)
							//{
							//	array<double> ^ tmpI = gcnew array<double>(4096);
							//	array<double> ^ tmpV = gcnew array<double>(4096);
							//	ret = smu->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);

							//	for (int z=0; z<4096; z++)
							//	{
							//		_util->Wait_Sec(100e-6);
							//		ret = smu->ReadCurrent("VEE", tmpI[z]);
							//		ret = smu->ReadVoltage("VEE", tmpV[z]);
							//	}

							//	ret = smu->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
							//}

							//double volt = 0;
							//ret = smu->ReadVoltage("VEE", volt);
							//CheckError(ret, __LINE__);

							//if (i == 1 || i == 3)
							//{
								//ret = smu->ConfigureOutputEnabled("VEE", true);
								//ret = smu->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
								//CheckError(ret, __LINE__);
							//}
						}
					}

					if (Debug_Enable == true)
					{
						double volt_vcc = 0;
						double volt_vee = 0;
						ret = smu->ReadVoltage("VCC", volt_vcc);
						CheckError(ret, __LINE__);
						ret = smu->ReadVoltage("VEE", volt_vee);
						CheckError(ret, __LINE__);
					}
				}

				if (tf_TPCondition_exist(TPName[i], "Measure_Pin_1") == true)
				{
					Measure_Pin_1	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_1"));
					
					if (Measure_Pin_1 == "VCC")
					{
						ret = smu->ReadCurrent("VCC", result2[i]);
						CheckError(ret, __LINE__);
					}

					if (Measure_Pin_1 == "VEE")
					{
						ret = smu->ReadCurrent("VEE", result2[i]);
						CheckError(ret, __LINE__);
					}
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
				{
					Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File_1);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File_1);
					CheckError(ret, __LINE__);
					#endif

					_util->Wait_Sec(Measure_Delay_s);

					if (Measure_Pin == "VCC")
					{
						ret = smu->ReadCurrent("VCC", result3[i]);
						CheckError(ret, __LINE__);
					}

					if (Measure_Pin == "VEE")
					{
						ret = smu->ReadCurrent("VEE", result3[i]);
						CheckError(ret, __LINE__);
					}

					if (Measure_Pin_1 == "VCC")
					{
						ret = smu->ReadCurrent("VCC", result4[i]);
						CheckError(ret, __LINE__);
					}

					if (Measure_Pin_1 == "VEE")
					{
						ret = smu->ReadCurrent("VEE", result4[i]);
						CheckError(ret, __LINE__);
					}

					result[i] = result[i] - result3[i];

					result2[i] = result2[i] - result4[i];
				}

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
					
					_glob->Global_Result[Global_Result_Index] = result[i];
				}	

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_1") == true)
				{
					Global_Result_Index_1 = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_1"));
					
					_glob->Global_Result[Global_Result_Index_1] = result2[i];
				}	

				if (tf_TPCondition_exist(TPName[i], "Operation") == true)
				{
					String ^ Global_Result_Index_A = String::Empty;
					String ^ Global_Result_Index_B = String::Empty;

					int A = 0;
					int B = 0;

					Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_A") == true)
					{
						Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A")); 
					}

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_B") == true)
					{
						Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));			
					}				

					if (Operation == "-A")
					{
						A = _util->StrToInt(Global_Result_Index_A);

						result[i] = result[i] - _glob->Global_Result[A];
					}

					if (Operation == "=")
					{
						A = _util->StrToInt(Global_Result_Index_A);

						result[i] = _glob->Global_Result[A];
					}
					
					if (Operation == "A-B")
					{
						A = _util->StrToInt(Global_Result_Index_A);
						B = _util->StrToInt(Global_Result_Index_B);

						if (TPDispName[i]->StartsWith("Pd"))
						{
							result[i] = _glob->Global_Result[A]*Drive_Vcc_V - _glob->Global_Result[B]*-Drive_Vee_V;
						}
						else
						{
							result[i] = _glob->Global_Result[A] - _glob->Global_Result[B];
						}
					}

					if (Operation == "ABS(A-B)")
					{
						A = _util->StrToInt(Global_Result_Index_A);
						B = _util->StrToInt(Global_Result_Index_B);

						result[i] = Math::Abs(_glob->Global_Result[A] - _glob->Global_Result[B]);
					}

					if (Operation == "MAX[A]-MIN[B]")
					{
						double max = 0;
						double min = 0;

						array<String ^> ^ ArrStr = gcnew array<String ^>(0);
						array<String ^> ^ Separator = gcnew array<String ^>(1);
						Separator[0] = ",";

						ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

						for (int j=0; j<ArrStr->Length; j++)
						{
							if (j == 0)
							{
								max = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
							}
							else
							{
								if (max < _glob->Global_Result[_util->StrToInt(ArrStr[j])])
									max = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
							}
						}

						ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);

						for (int j=0; j<ArrStr->Length; j++)
						{
							if (j == 0)
							{
								min = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
							}
							else
							{
								if (min > _glob->Global_Result[_util->StrToInt(ArrStr[j])])
									min = _glob->Global_Result[_util->StrToInt(ArrStr[j])];
							}
						}

						result[i] = max - min;
					}
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->ClampCurrent("VCC", 0.5);
		CheckError(ret, __LINE__);

		ret = smu->ClampCurrent("VEE", 0.5);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(5e-3);

		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(5e-3); //discharge cap

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_src_curr_meas_volt(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= String::Empty;
		double Clamp_Vo_Voltage_V = 0;
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Test_Pin		= String::Empty;

		double result			= 0;
		double Drive_Io_A		= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 ChX via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 ChX via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 ChX via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 ChX via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					Drive_Io_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_A"));
					Clamp_Vo_Voltage_V = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vo_Voltage_V"));
				
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(ret, __LINE__);
				
					if (Clamp_Vo_Voltage_V < 0)
							ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Vo_Voltage_V);
					else 
						ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_Voltage_V, 0);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
				{
					NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Io_A") == true)
				{
					Drive_Io_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_A"));

					ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);

				/*if (TPName[i]->Contains("VINPBias") == true)
				{*/
					#ifdef USE_GNDS
					double volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
					CheckError(ret, __LINE__);
					result = result - volt;
					#endif
				//}

				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				if (tf_TPCondition_exist(TPName[i], "Operation") == true)
				{
					String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

					if (Operation == "ABS")
					{
						result = Math::Abs(result);
					}
				}

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_src_volt_meas_curr(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= String::Empty;
		double Clamp_Io_Current_A = 0;
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Test_Pin		= String::Empty;
		double Drive_Vo_V		= 0;

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}
		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));
					Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));
				
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					//ret = dm->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
					//CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
					CheckError(ret, __LINE__);
					////ret = dm->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
					////CheckError(ret, __LINE__);
				
					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
				}

				if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
				{
					NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Clamp_Io_Current_A") == true)
				{
					Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));

					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vo_V") == true)
				{
					Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));

					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				if (tf_TPCondition_exist(TPName[i], "Operation") == true)
				{
					String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

					if (Operation == "ABS")
					{
						result = Math::Abs(result);
					}
					else if (Operation == "CUSTOM")
					{
						result = Math::Abs(0.0003 / result) - 1;
					}
				}


				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_amux_current(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= String::Empty;
		double Clamp_Io_Current_A = 0;
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		String ^ Test_Pin		= String::Empty;
		double Drive_Vo_V		= 0;

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg/2, -1 * Vswg/2, Fswg, 0);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(1e-3);
		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));
					Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));
				
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
					CheckError(ret, __LINE__);
				
					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);

					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);
				}

				if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
				{
					NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Clamp_Io_Current_A") == true)
				{
					Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));

					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vo_V") == true)
				{
					Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));

					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				if (tf_TPCondition_exist(TPName[i], "Operation") == true)
				{
					String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

					if (Operation == "ABS")
					{
						result = Math::Abs(result);
					}
					else if (Operation == "CUSTOM")
					{
						result = Math::Abs(0.0003 / result) - 1;
					}
				}

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_amux_current1(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		String ^ Vector_File	= String::Empty;
		double Clamp_Io_Current_A = 0;
		double Input_Channel_Delay_s = 0;
		bool isCurrentTPBypassed = false;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		String ^ Test_Pin		= String::Empty;
		double Drive_Vo_V		= 0;

		double result			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)	

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg/2, -1 * Vswg/2, Fswg, 0);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(1e-3);
		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif

		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (Debug_Enable == true)
				{
					sb->AppendLine("-----------------------------------------------------------------------");
					sb->AppendLine("// " + TPDispName[i]);
				}

				if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));
					Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));
				
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
					CheckError(ret, __LINE__);
				
					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);

					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);
				}

				if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
				{
					NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Clamp_Io_Current_A") == true)
				{
					Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));

					ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vo_V") == true)
				{
					Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));

					ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
					CheckError(ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				if (tf_TPCondition_exist(TPName[i], "Operation") == true)
				{
					String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

					if (Operation == "ABS")
					{
						result = Math::Abs(result);
					}
					else if (Operation == "CUSTOM")
					{
						result = Math::Abs(0.0003 / result) - 1;
					}
				}

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_dietemp_i(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(8192);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		{
			if (Debug_Enable == true)
			{
				sb->AppendLine("-----------------------------------------------------------------------");
				sb->AppendLine("// Vendor ID:");
			}

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(0.000008);//8us delay as stated in datasheet pg65

			#ifndef USE_SPI
			ret = ReadVector(Vector_File_1, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File_1, data);
			CheckError(ret, __LINE__);
			#endif
			
			result = 0.92 * data - 40.45;

			tf_SetResult(TPName[0], result + GetOffset(TPDispName[0]));
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_dgf(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//StreamWriter ^ sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\testtime.txt");
		//StringBuilder ^ sb = gcnew StringBuilder();
		//LARGE_INTEGER t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
		//LARGE_INTEGER t11, t12, t13, t14, t15, t16, t17, t18, t19, t20;
		//LARGE_INTEGER t21, t22, t23, t24, t25, t26;
		//LARGE_INTEGER sysFreq;
		//
		//QueryPerformanceFrequency(&sysFreq);
		//QueryPerformanceCounter(&t1);

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		String ^ Vector_File	= String::Empty;
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//QueryPerformanceCounter(&t2);

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t3);

		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t4);

		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t5);

		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t6);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		//QueryPerformanceCounter(&t7);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t8);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t9);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		//QueryPerformanceCounter(&t10);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Write DEFAULT registers 
		
		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t17);

		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		#endif

		//QueryPerformanceCounter(&t18);

		array<double> ^ Target = gcnew array<double>(total_tp);
		array<double> ^ Actual = gcnew array<double>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			Target[i] = 0;
			Actual[i] = 0;
			result[i] = 0;
		}

		tmu_start_threshold = 0.5;
		tmu_stop_threshold = 0.5;
		tmu_start_hysteresis = 0.02;//0.2;
		tmu_stop_hysteresis = 0.02;//0.2;
		number_of_samples = 10;
		tmu_timeout = 10e-3;

		double res_tmp = 0;

		sampled_result = gcnew array<double>(number_of_samples);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Target"))
			{
				Target[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));

				result[i] = Target[i];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Min") == true ||
				TPName[i]->Contains("Max") == true)
			{
				Target[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
							
				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				CheckError(ret, __LINE__);
				ret = tm->ArmSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, number_of_samples, TM_CONST_SOFTWARE_ARM, TM_CONST_SLOPE_POSITIVE, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, tmu_timeout, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
				ret = tm->RetrieveResultsSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, 0, returned_sample_count, sampled_result);

				if (ret)
				{
					result[i] = 999;
					ret = 0;
				}
				else
				{
					int count = returned_sample_count;
					double temp = 0;
					res_tmp = 0;
					for (int k=0; k<returned_sample_count; k++)
					{
						if (sampled_result[k] > 0)
						{
							temp = (1 / sampled_result[k]) * 256;
							if (Math::Abs(Target[i] - temp)/Target[i] < 0.1) 
								res_tmp += sampled_result[k];
							else
								count--;
						}
						else
							count--;
					}

					if (count > 0)
					{
						res_tmp = res_tmp / count;

						//res_tmp = 1 / (res_tmp * 2); //convert to freq, 50% DC
						res_tmp = 1 / (res_tmp); //convert to freq, 50% DC

						result[i] = res_tmp * 256;
					}
					else
					{
						result[i] = 999;
					}					
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			}
			else if (TPName[i]->StartsWith("dFdg") == true)
			{
				if (result[i-1] != 999)
				{
					result[i] = (result[i-1] / result[i-2] - 1) * 100;
				}
				else
				{
					result[i] = 999;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif

				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				CheckError(ret, __LINE__);
				ret = tm->ArmSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, number_of_samples, TM_CONST_SOFTWARE_ARM, TM_CONST_SLOPE_POSITIVE, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, tmu_timeout, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);
				ret = tm->RetrieveResultsSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, 0, returned_sample_count, sampled_result);

 				if (ret)
				{
					result[i] = 999;
					ret = 0;
				}
				else
				{
					int count = returned_sample_count;
					double temp = 0;
					res_tmp = 0;
					for (int k=0; k<returned_sample_count; k++)
					{
						if (sampled_result[k] > 0)
						{
							temp = (1 / sampled_result[k]) * 256;
							if (Math::Abs(result[i-1] - temp)/result[i-1] < 0.1) 
								res_tmp += sampled_result[k];
							else
								count--;
						}
						else
							count--;
					}

					if (count > 0)
					{
						res_tmp = res_tmp / count;

						//res_tmp = 1 / (res_tmp * 2); //convert to freq, 50% DC
						res_tmp = 1 / (res_tmp); //convert to freq, 50% DC

						result[i] = res_tmp * 256;
					}
					else
					{
						result[i] = 999;
					}	
				}
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				
			}
		}	

		//QueryPerformanceCounter(&t19);
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//QueryPerformanceCounter(&t11);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t12);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t13);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t14);

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t15);

		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		//QueryPerformanceCounter(&t16);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		//sb->AppendLine("Variable setup Time:\t" + ((double)(t2.QuadPart - t1.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("SetupDigital Time:\t" + ((double)(t3.QuadPart - t2.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("DriveDIOPin Time:\t" + ((double)(t4.QuadPart - t3.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("DriveCBit Time:\t" + ((double)(t5.QuadPart - t4.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("DriveMuxIO Time:\t" + ((double)(t6.QuadPart - t5.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Setup Power supplies Time:\t" + ((double)(t7.QuadPart - t6.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Digital pin config Time:\t" + ((double)(t8.QuadPart - t7.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("DriveDMPin Time:\t" + ((double)(t9.QuadPart - t8.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("ConfigureInputChannelDelay Time:\t" + ((double)(t10.QuadPart - t9.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Test Time:\t" + ((double)(t19.QuadPart - t18.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("ResetDMPin Time:\t" + ((double)(t12.QuadPart - t11.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Power down supplies Time:\t" + ((double)(t13.QuadPart - t12.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("ResetDIOPin Time:\t" + ((double)(t14.QuadPart - t13.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("ResetCBit Time:\t" + ((double)(t15.QuadPart - t14.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("ResetMuxIO Time:\t" + ((double)(t16.QuadPart - t15.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Reset SPI Time:\t" + ((double)(t11.QuadPart - t19.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Config SPI Time:\t" + ((double)(t18.QuadPart - t17.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Write default reg (SPI) Time:\t" + ((double)(t17.QuadPart - t10.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//sb->AppendLine("Total Time:\t" + ((double)(t16.QuadPart - t1.QuadPart) / (double)sysFreq.QuadPart).ToString());
		//
		//sw->Write(sb->ToString());
		//sw->Close();
		//sw = nullptr;

		return ret;
	}

	int TestProgram::seq_dgt(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		String ^ Vector_File	= String::Empty;
		double Measure_Deay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		ret = DriveDIOPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Must use vector method as write_dgt is required
		//Write DEFAULT registers 

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(1e-3);

		array<double> ^ Target = gcnew array<double>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			Target[i] = 0;
			result[i] = 0;
		}

		tmu_start_hysteresis = 0.02;
		tmu_stop_hysteresis = 0.02;
		number_of_samples = 1;
		tmu_timeout = 5e-3;

		double voh_flt = 0.6;

		if (Test != TEST_IF4600_PKG)
			voh_flt = 0.45; //0.4;

		double res_tmp = 0;

		int retest_count = 0;
		int retest_count2 = 0;

		sampled_result = gcnew array<double>(number_of_samples);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Target"))
			{
				Target[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));

				result[i] = Target[i];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Oscilator") == true) //rise time
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				tmu_start_threshold = voh_flt * 0.2;
				tmu_stop_threshold = voh_flt * 0.8;

				retest_count = 0;

DGT_RETEST1:
				
				ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
				CheckError(ret, __LINE__);
				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);

				ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
				CheckError(ret, __LINE__);

				//_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile("write_dgt");
				CheckError(ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
				
				if (ret)
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						ret = 0;
						retest_count++;
						goto DGT_RETEST1;
					}
					else
					{
						result[i] = 999;
						ret = 0;
					}
				}
				else
				{
					int count = returned_sample_count;
					res_tmp = 0;
					for (int k=0; k<returned_sample_count; k++)
					{
						if (sampled_result[k] > 0)
						{
							if (sampled_result[k] < 40e-9) //set 40ns as retest check for rise time measurement
							{
								res_tmp += sampled_result[0];
							}
							else
							{
								if (retest_count < TIMING_RESET_COUNT)
								{
									retest_count++; 
									goto DGT_RETEST1;
								}	
							}
							
						}
						else
							count--;
					}

					if (count > 0)
						res_tmp = res_tmp / count;
					else
						res_tmp = 999;

					result[i] = res_tmp;
				}

				result[i] = result[i] + 6e-9;
				 
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			}
			else if (TPName[i]->StartsWith("dTdg") == true)
			{
				if (result[i-1] != 999)
				{
					result[i] = (result[i-1] / result[i-2] - 1) * 100;
				}
				else
				{
					result[i] = 999;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				tmu_start_threshold = voh_flt / 2;
				tmu_stop_threshold = voh_flt / 2;

				if (TPName[i]->StartsWith("Tdg0") == true)
				{
					tmu_start_threshold = voh_flt * 0.2;
					tmu_stop_threshold = voh_flt * 0.8;
				}
				else
					tmu_stop_threshold = voh_flt * 0.8;

				retest_count = 0;
DGT_RETEST2:

				ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
				CheckError(ret, __LINE__);
				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
				CheckError(ret, __LINE__);
				
				ret = RunVectorFile("write_dgt");
				CheckError(ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

				if (ret)
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						ret = 0;
						retest_count++;
						goto DGT_RETEST2;
					}
					else
					{
						result[i] = 999;
						ret = 0;
					}
				}
				else
				{
					int count = returned_sample_count;
					res_tmp = 0;
					for (int k=0; k<returned_sample_count; k++)
					{
						if (sampled_result[k] > 0)
						{
							if (Math::Abs(result[i-1] - sampled_result[0])/result[i-1] < 0.1) 
							{
								res_tmp += sampled_result[0];
							}
							else
							{
								if (retest_count < TIMING_RESET_COUNT)
								{
									retest_count++; 
									goto DGT_RETEST2;									
								}	
							}
							
						}
						else
							count--;
					}

					if (count > 0)
						res_tmp = res_tmp / count;
					else
						res_tmp = 999;

					result[i] = res_tmp;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				
			}
		}	

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		ret = ResetDIOPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_dgt2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		String ^ Vector_File	= String::Empty;
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Must use vector method as write_dgt is required
		//Write DEFAULT registers 

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(1e-3);

		array<double> ^ Target = gcnew array<double>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			Target[i] = 0;
			result[i] = 0;
		}

		tmu_start_hysteresis = 0.02;
		tmu_stop_hysteresis = 0.02;
		number_of_samples = 1;
		tmu_timeout = 5e-3;

		double voh_flt = 0.6;

		double res_tmp = 0;

		int retest_count = 0;
		int retest_count2 = 0;

		sampled_result = gcnew array<double>(number_of_samples);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Target"))
			{
				Target[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));

				result[i] = Target[i];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Oscilator") == true) //rise time
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				tmu_start_threshold = voh_flt * 0.2;
				tmu_stop_threshold = voh_flt * 0.8;

				retest_count = 0;

DGT_RETEST1:
				
				ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
				CheckError(ret, __LINE__);
				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);

				ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile("write_dgt");
				CheckError(ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
				
				if (ret)
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						ret = 0;
						retest_count++;
						goto DGT_RETEST1;
					}
					else
					{
						result[i] = 999;
						ret = 0;
					}
				}
				else
				{
					int count = returned_sample_count;
					res_tmp = 0;
					for (int k=0; k<returned_sample_count; k++)
					{
						if (sampled_result[k] > 0)
						{
							if (sampled_result[k] < 40e-9) //set 40ns as retest check for rise time measurement
							{
								res_tmp += sampled_result[0];
							}
							else
							{
								if (retest_count < TIMING_RESET_COUNT)
								{
									retest_count++; 
									goto DGT_RETEST1;
								}	
							}
							
						}
						else
							count--;
					}

					if (count > 0)
						res_tmp = res_tmp / count;
					else
						res_tmp = 999;

					result[i] = res_tmp;
				}

				//result[i] = result[i] + 6e-9;
				 
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			}
			else if (TPName[i]->StartsWith("dTdg") == true)
			{
				if (result[i-1] != 999)
				{
					result[i] = (result[i-1] / result[i-2] - 1) * 100;
				}
				else
				{
					result[i] = 999;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				//tmu_start_threshold = voh_flt / 2;
				//tmu_stop_threshold = voh_flt / 2;

				//if (TPName[i]->StartsWith("Tdg0") == true)
				//{
				//	tmu_start_threshold = voh_flt * 0.2;
				//	tmu_stop_threshold = voh_flt * 0.8;
				//}
				//else
				//	tmu_stop_threshold = voh_flt * 0.8;

				tmu_start_threshold = voh_flt * 0.5;
				tmu_stop_threshold = voh_flt * 0.5;

				retest_count = 0;
DGT_RETEST2:

				ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
				CheckError(ret, __LINE__);
				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				
				ret = RunVectorFile("write_dgt");
				CheckError(ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

				if (ret)
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						ret = 0;
						retest_count++;
						goto DGT_RETEST2;
					}
					else
					{
						result[i] = 999;
						ret = 0;
					}
				}
				else
				{
					int count = returned_sample_count;
					res_tmp = 0;
					for (int k=0; k<returned_sample_count; k++)
					{
						if (sampled_result[k] > 0)
						{
							sampled_result[k] = sampled_result[k] + GetOffset(TPDispName[i]);
							if (TPName[i]->StartsWith("Tdg0") == false) //no need to check for Tdg0 as it doesn't have limtis
							{
								if (Math::Abs(result[i-1] - sampled_result[0])/result[i-1] < 0.23) 
								{
									res_tmp += sampled_result[0];
								}
								else
								{
									if (retest_count < TIMING_RESET_COUNT)
									{
										retest_count++; 
										goto DGT_RETEST2;									
									}	
								}
							}		
							else
							{
								res_tmp += sampled_result[0];
							}
						}
						else
							count--;
					}

					if (count > 0)
						res_tmp = res_tmp / count;
					else
						res_tmp = 999;

					result[i] = res_tmp;
				}

				//tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				tf_SetResult(TPName[i], result[i]);
				
			}
		}	

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_awg_input_meas(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		int result = 1;

		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		tf_SetResult(TPName[0], result + (int)GetOffset(TPDispName[0]));

		return ret;
	}

	int TestProgram::seq_ir_sup(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
				#ifndef USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
				{
					ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					}

					ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					CheckError(ret, __LINE__);
					result[i] = (data >> 7) & 0x1;

					if (Debug_Enable == true)
					{
						sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					}
				}
				else
				{
					result[i] = -999;
				}

				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result[i] = (data >> 7) & 0x1;
				#endif

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 1)
			{
				result[i] = data & 0x7F;
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 2)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 7)
			{
				double ir_min = 0;
				double ir_max = 0;

				for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
				{
					if(k == 3)
					{
						ir_min = ir_max = result[k]; 
					}
					else
					{
						if(result[k] > ir_max)
							ir_max = result[k];

						if(result[k] < ir_min)
							ir_min = result[k];
					}		
				}

				result[i] = ir_max - ir_min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				double diffp_V = 0;
				double diffn_V = 0;

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				
				result[i] = Math::Abs(diffp_V - diffn_V) / CONST_Rr1;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ir_sup2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0], 1);//MUX to DiffAmp
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}


		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
				#ifndef USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
				{
					ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					}

					ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					CheckError(ret, __LINE__);
					result[i] = (data >> 7) & 0x1;

					if (Debug_Enable == true)
					{
						sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					}
				}
				else
				{
					result[i] = -999;
				}

				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result[i] = (data >> 7) & 0x1;
				#endif

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 1)
			{
				result[i] = data & 0x7F;
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 2)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 7)
			{
				double ir_min = 0;
				double ir_max = 0;

				for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
				{
					if(k == 3)
					{
						ir_min = ir_max = result[k]; 
					}
					else
					{
						if(result[k] > ir_max)
							ir_max = result[k];

						if(result[k] < ir_min)
							ir_min = result[k];
					}		
				}

				result[i] = ir_max - ir_min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				double diffpn_V = 0;

				if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
					CheckError(ret, __LINE__);
				}
				
				result[i] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ir_sup3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0], 1);//MUX to DiffAmp
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}


		// Configure PN
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, 6, -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
				#ifndef USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
				{
					ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					}

					ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					CheckError(ret, __LINE__);
					result[i] = (data >> 7) & 0x1;

					if (Debug_Enable == true)
					{
						sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					}
				}
				else
				{
					result[i] = -999;
				}

				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result[i] = (data >> 7) & 0x1;
				#endif

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 1)
			{
				result[i] = data & 0x7F;
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 2)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 7)
			{
				double ir_min = 0;
				double ir_max = 0;

				for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
				{
					if(k == 3)
					{
						ir_min = ir_max = result[k]; 
					}
					else
					{
						if(result[k] > ir_max)
							ir_max = result[k];

						if(result[k] < ir_min)
							ir_min = result[k];
					}		
				}

				result[i] = ir_max - ir_min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				double diffpn_V = 0;

				//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//	CheckError(ret, __LINE__);
				//}

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);
				
				result[i] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ir_hds(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		array<String ^> ^ Vector_File_Zin;
		array<double> ^ result_irz; 

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);	
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);	
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		int irz_worst = 0;

		double volt = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Ibias") == true)
			{
				int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

				result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Zin_K") == true)
			{
				int READERINPUTZ = (int)(tf_TPCondition_Cast(TPName[i], "READERINPUTZ"));
				Vector_File_Zin = gcnew array<String ^>(READERINPUTZ); 
				result_irz = gcnew array<double>(READERINPUTZ);

				double h0_lim_max = (double)(tf_TPHighLimit_Cast(TPName[i-1])); //Acquire previous test's high limit
				double h0_lim_min = (double)(tf_TPLowLimit_Cast(TPName[i-1])); //Acquire previous test's low limit
				double h0_lim_mid = (h0_lim_max + h0_lim_min) / 2;

				for (int k=0; k<READERINPUTZ; k++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_" + k));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);

						ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
						CheckError(ret, __LINE__);
						ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
						CheckError(ret, __LINE__);
					}

					if (i==0 || i==9)
					{
						#ifdef USE_GNDS
						ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
						CheckError(ret, __LINE__);
						#endif
					}
					
					resultp[i] = diffp_V - volt;
					resultn[i] = diffn_V - volt;

					result_irz[k] = Math::Abs(diffp_V - diffn_V) / CONST_Rr1;
				}

				for(int k=1; k<READERINPUTZ; k++) 
				{
					if(Math::Abs(result_irz[k]-h0_lim_mid) > Math::Abs(result_irz[irz_worst]-h0_lim_mid))
						irz_worst = k;
				}
				
				result[i] = irz_worst; //display the worst index

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Zin") == true)
			{
				result[i] = result_irz[irz_worst];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				
				result[i] = Math::Abs(diffp_V - diffn_V) / CONST_Rr1;

				if (i==0 || i==9)
				{
					#ifdef USE_GNDS
					ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					CheckError(ret, __LINE__);
					#endif
				}

				resultp[i] = diffp_V - volt;
				resultn[i] = diffn_V - volt;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ir_hds3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		array<String ^> ^ Vector_File_Zin;
		array<double> ^ result_irz; 

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		
		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);


			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);	
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);	
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;
		int irz_worst = 0;

		double volt = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Ibias") == true)
			{
				int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

				result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Zin_K") == true)
			{
				int READERINPUTZ = (int)(tf_TPCondition_Cast(TPName[i], "READERINPUTZ"));
				Vector_File_Zin = gcnew array<String ^>(READERINPUTZ); 
				result_irz = gcnew array<double>(READERINPUTZ);

				double h0_lim_max = (double)(tf_TPHighLimit_Cast(TPName[i-1])); //Acquire previous test's high limit
				double h0_lim_min = (double)(tf_TPLowLimit_Cast(TPName[i-1])); //Acquire previous test's low limit
				double h0_lim_mid = (h0_lim_max + h0_lim_min) / 2;

				for (int k=0; k<READERINPUTZ; k++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_" + k));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);

						ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
						CheckError(ret, __LINE__);
						ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
						CheckError(ret, __LINE__);
					}

					if (i==0 || i==9)
					{
						#ifdef USE_GNDS
						ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
						CheckError(ret, __LINE__);
						#endif
					}
					
					resultp[i] = diffp_V - volt;
					resultn[i] = diffn_V - volt;

					//differential
					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					ret = DriveMuxIO(TPDispName[0],1);
					CheckError(ret, __LINE__);

					ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(ret, __LINE__);

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					ret = DriveMuxIO(TPDispName[0],0);
					CheckError(ret, __LINE__);

					result_irz[k] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;
				}

				for(int k=1; k<READERINPUTZ; k++) 
				{
					if(Math::Abs(result_irz[k]-h0_lim_mid) > Math::Abs(result_irz[irz_worst]-h0_lim_mid))
						irz_worst = k;
				}
				
				result[i] = irz_worst; //display the worst index

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Zin") == true)
			{
				result[i] = result_irz[irz_worst];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],1);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],0);
				CheckError(ret, __LINE__);

				
				result[i] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;

				if (i==0 || i==9)
				{
					#ifdef USE_GNDS
					ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					CheckError(ret, __LINE__);
					#endif
				}

				resultp[i] = diffp_V - volt;
				resultn[i] = diffn_V - volt;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ir_hds4(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);
		array<double> ^ resultpn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
			resultpn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		array<String ^> ^ Vector_File_Zin;
		array<double> ^ result_irz; 

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		//// Check whether resource is SMU or DM
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeP = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypePN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		//}

		//// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		
		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);	
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);	
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;
		int irz_worst = 0;

		double volt = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Ibias") == true)
			{
				int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

				//result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;
				result[i] = resultp[Result_Index] - (resultpn[Result_Index])/2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Zin_K") == true)
			{
				int READERINPUTZ = (int)(tf_TPCondition_Cast(TPName[i], "READERINPUTZ"));
				Vector_File_Zin = gcnew array<String ^>(READERINPUTZ); 
				result_irz = gcnew array<double>(READERINPUTZ);

				double h0_lim_max = (double)(tf_TPHighLimit_Cast(TPName[i-1])); //Acquire previous test's high limit
				double h0_lim_min = (double)(tf_TPLowLimit_Cast(TPName[i-1])); //Acquire previous test's low limit
				double h0_lim_mid = (h0_lim_max + h0_lim_min) / 2;

				for (int k=0; k<READERINPUTZ; k++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_" + k));

					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

					_util->Wait_Sec(Measure_Delay_s);

					//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					//{
					//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					//	CheckError(ret, __LINE__);

					//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					//	CheckError(ret, __LINE__);
					//}
					//else
					//{
					//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					//	CheckError(ret, __LINE__);
					//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					//	CheckError(ret, __LINE__);
					//}

					//if (i==0 || i==9)
					//{
					//	#ifdef USE_GNDS
					//	ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					//	CheckError(ret, __LINE__);
					//	#endif
					//}
					
					//resultp[i] = diffp_V - volt;
					//resultn[i] = diffn_V - volt;

					//differential
					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					ret = DriveMuxIO(TPDispName[0], 1);
					CheckError(ret, __LINE__);

					ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(ret, __LINE__);

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					ret = DriveMuxIO(TPDispName[0], 0);
					CheckError(ret, __LINE__);

					result_irz[k] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;
				}

				for(int k=1; k<READERINPUTZ; k++) 
				{
					if(Math::Abs(result_irz[k]-h0_lim_mid) > Math::Abs(result_irz[irz_worst]-h0_lim_mid))
						irz_worst = k;
				}
				
				result[i] = irz_worst; //display the worst index

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Zin") == true)
			{
				result[i] = result_irz[irz_worst];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);

				//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	CheckError(ret, __LINE__);
				//}
				//else
				//{
				//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				//	CheckError(ret, __LINE__);
				//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//	CheckError(ret, __LINE__);
				//}

				//measure p-GNDS 
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0], 2);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);

				if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT))
				{
					diffp_V = -1 * diffp_V;
				}
				else if (TPName[i]->Contains("HR1"))
				{
					diffp_V = -1 * diffp_V;
				}

				resultp[i] = (diffp_V-c)/m;

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0], 1);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0], 0);
				CheckError(ret, __LINE__);
				
				result[i] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;

				//if (i==0 || i==9)
				//{
				//	#ifdef USE_GNDS
				//	ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//	CheckError(ret, __LINE__);
				//	#endif
				//}

				//resultp[i] = diffp_V - volt;
				//resultn[i] = diffn_V - volt;

				if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT))
				{
					diffpn_V = -1 * diffpn_V;
				}
				else if (TPName[i]->Contains("HR1"))
				{
					diffpn_V = -1 * diffpn_V;
				}
				resultpn[i] = (diffpn_V-c)/m;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_v_sup(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
				{
					ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					}

					ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					CheckError(ret, __LINE__);
					result[i] = data & 0x3F;

					if (Debug_Enable == true)
					{
						sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					}
				}
				else
				{
					result[i] = -999;
				}
				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result[i] = data & 0x3F;
				#endif

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 5)
			{
				double vr_min = 0;
				double vr_max = 0;

				for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
				{
					if(k == 3)
					{
						vr_min = vr_max = result[k]; 
					}
					else
					{
						if(result[k] > vr_max)
							vr_max = result[k];

						if(result[k] < vr_min)
							vr_min = result[k];
					}		
				}

				result[i] = vr_max - vr_min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				double diffp_V = 0;
				double diffn_V = 0;

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				
				result[i] = Math::Abs(diffp_V - diffn_V);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_v_sup2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0], 1);//MUX to DiffAmp
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		/*#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif*/

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
				{
					ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					}

					ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					CheckError(ret, __LINE__);
					result[i] = data & 0x3F;

					if (Debug_Enable == true)
					{
						sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					}
				}
				else
				{
					result[i] = -999;
				}
				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result[i] = data & 0x3F;
				#endif

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 5)
			{
				double vr_min = 0;
				double vr_max = 0;

				for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
				{
					if(k == 3)
					{
						vr_min = vr_max = result[k]; 
					}
					else
					{
						if(result[k] > vr_max)
							vr_max = result[k];

						if(result[k] < vr_min)
							vr_min = result[k];
					}		
				}

				result[i] = vr_max - vr_min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				double diffpn_V = 0;
				ret = DriveMuxIO(TPDispName[0], 1);//change to differential circuit
				CheckError(ret, __LINE__);

				if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
					CheckError(ret, __LINE__);
				}
				
				result[i] = Math::Abs((diffpn_V-c)/m);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_v_sup3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0], 1);//MUX to DiffAmp
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure PN
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		/*#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif*/

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
				{
					ret = dm->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					}

					ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					CheckError(ret, __LINE__);
					result[i] = data & 0x3F;

					if (Debug_Enable == true)
					{
						sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					}
				}
				else
				{
					result[i] = -999;
				}
				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);

				result[i] = data & 0x3F;
				#endif

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 5)
			{
				double vr_min = 0;
				double vr_max = 0;

				for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
				{
					if(k == 3)
					{
						vr_min = vr_max = result[k]; 
					}
					else
					{
						if(result[k] > vr_max)
							vr_max = result[k];

						if(result[k] < vr_min)
							vr_min = result[k];
					}		
				}

				result[i] = vr_max - vr_min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				double diffpn_V = 0;

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0], 1);//change to differential circuit
				CheckError(ret, __LINE__);

				//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//	CheckError(ret, __LINE__);
				//}

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);
				
				result[i] = Math::Abs((diffpn_V-c)/m);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_vr_hds(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Vbias") == true)
			{
				int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

				result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				if (i==0 || i==4)
				{
					#ifdef USE_GNDS
					double volt = 0;
					ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V - volt;
					diffn_V = diffn_V - volt;
					#endif
				}
				
				result[i] = Math::Abs(diffp_V - diffn_V);

				resultp[i] = diffp_V;
				resultn[i] = diffn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vr_hds3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Vbias") == true)
			{
				int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

				result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				if (i==0 || i==4)
				{
					#ifdef USE_GNDS
					double volt = 0;
					ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V - volt;
					diffn_V = diffn_V - volt;
					#endif
				}

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],1);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],0);
				CheckError(ret, __LINE__);
	
				result[i] = Math::Abs((diffpn_V-c)/m);

				resultp[i] = diffp_V;
				resultn[i] = diffn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vr_hds4(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);
		array<double> ^ resultpn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
			resultpn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		//// Check whether resource is SMU or DM
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeP = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypePN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		//}

		//// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Vbias") == true)
			{
				int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

				//result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;
				result[i] = resultp[Result_Index] - (resultpn[Result_Index])/2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);

				//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	CheckError(ret, __LINE__);
				//}
				//else
				//{
				//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				//	CheckError(ret, __LINE__);
				//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//	CheckError(ret, __LINE__);
				//}

				//if (i==0 || i==4)
				//{
				//	#ifdef USE_GNDS
				//	double volt = 0;
				//	ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//	CheckError(ret, __LINE__);
				//	diffp_V = diffp_V - volt;
				//	diffn_V = diffn_V - volt;
				//	#endif
				//}

				//measure p-GNDS
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],2);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],1);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],0);
				CheckError(ret, __LINE__);
	
				result[i] = Math::Abs((diffpn_V-c)/m);

				if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT))
				{
					diffp_V = -1 * diffp_V;
					diffpn_V = -1 * diffpn_V;
				}
				else if (TPName[i]->Contains("HR1"))
				{
					diffp_V = -1 * diffp_V;
					diffpn_V = -1 * diffpn_V;
				}

				resultp[i] = (diffp_V-c)/m;

				resultpn[i] = (diffpn_V-c)/m;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_mrhv(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//Must use vector method due to special vectors
		//init

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		double diffp_V = 0;
		double diffn_V = 0;

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("VMR") == true)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					
					_util->Wait_Sec(Measure_Delay_s);

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
						ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
						CheckError(ret, __LINE__);
						ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
						CheckError(ret, __LINE__);
					}

					#ifdef USE_GNDS
					double volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V - volt;
					diffn_V = diffn_V - volt;
					#endif
					
					result[i] = diffp_V - Math::Abs(diffp_V - diffn_V)/2;

					resultp[i] = diffp_V;
					resultn[i] = diffn_V;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				}
				else
				{
					int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

					result[i] = resultp[Result_Index] - (resultp[Result_Index] - resultn[Result_Index])/2;		

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
			}
			else if (TPName[i]->Contains("IMR") == true)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - volt;
				diffn_V = diffn_V - volt;
				#endif
				
				result[i] = Math::Abs(diffp_V - diffn_V) / CONST_Rr1;

				resultp[i] = diffp_V;
				resultn[i] = diffn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_mrhv2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);
		array<double> ^ resultpn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;//differential

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//Must use vector method due to special vectors
		//init

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;//differential

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("VMR") == true)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					
					_util->Wait_Sec(Measure_Delay_s);

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
						ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
						CheckError(ret, __LINE__);
						ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
						CheckError(ret, __LINE__);
					}

					////differential
					//ret = DriveMuxIO(TPDispName[0],1);
					//CheckError(ret, __LINE__);
					//ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
					//CheckError(ret, __LINE__);
					//ret = DriveMuxIO(TPDispName[0],0);
					//CheckError(ret, __LINE__);

					#ifdef USE_GNDS
					double volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V - volt;
					diffn_V = diffn_V - volt;
					#endif
					
					result[i] = diffp_V - Math::Abs(diffp_V - diffn_V)/2;

					resultp[i] = diffp_V;
					resultn[i] = diffn_V;
					//resultpn[i] = diffpn_V;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				}
				else
				{
					int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

					result[i] = resultp[Result_Index] - (resultpn[Result_Index])/2;		

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
			}
			else if (TPName[i]->Contains("IMR") == true)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					/*ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);*/
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],1);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				CheckError(ret, __LINE__);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],0);
				CheckError(ret, __LINE__);

				#ifdef USE_GNDS
				double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - volt;
				diffn_V = diffn_V - volt;
				#endif
				
				result[i] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;

				resultp[i] = diffp_V;
				//resultn[i] = diffn_V;
				resultpn[i] = diffpn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_mrhv3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//Use AM430e (MTX_SMU) to measure diff amp output

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);
		array<double> ^ resultpn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;//differential

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			//ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			//CheckError(ret, __LINE__);
			//ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			//CheckError(ret, __LINE__);
			//ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			//CheckError(ret, __LINE__);
			//ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			//CheckError(ret, __LINE__);
			//ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			//CheckError(ret, __LINE__);
			//ret = dm->DPINOn(Test_Pin_PN);
			//CheckError(ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
			//ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			//CheckError(ret, __LINE__);
		}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//Must use vector method due to special vectors
		//init

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;//differential

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("VMR") == true)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					
					_util->Wait_Sec(Measure_Delay_s);

					//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					//{
					//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					//	CheckError(ret, __LINE__);
					//	//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					//	//CheckError(ret, __LINE__);
					//}
					//else
					//{
						ret = smu->ReadVoltage("MTX_SMU", diffp_V);
						CheckError(ret, __LINE__);
						//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
						//CheckError(ret, __LINE__);
					//}

					//differential
					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					ret = DriveMuxIO(TPDispName[0],1);
					CheckError(ret, __LINE__);

					//ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
					//CheckError(ret, __LINE__);
					ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(ret, __LINE__);

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					ret = DriveMuxIO(TPDispName[0],0);
					CheckError(ret, __LINE__);

					//#ifdef USE_GNDS
					//double volt = 0;
					////ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					//ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
					//CheckError(ret, __LINE__);
					//diffp_V = diffp_V - volt;
					//diffn_V = diffn_V - volt;
					//#endif
					
					//result[i] = diffp_V - Math::Abs(diffp_V - diffn_V)/2;
					//resultn[i] = diffn_V;
					//resultpn[i] = diffpn_V;

					if((TIDispName->Contains("hr0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) || (TIDispName->Contains("hr1") == true))
						diffp_V = -1*diffp_V;

					result[i] = diffp_V - (Math::Abs((diffpn_V-c)/m))/2;
					resultp[i] = (diffp_V-c)/m;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				}
				else
				{
					int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

					result[i] = resultp[Result_Index] - (resultpn[Result_Index])/2;		

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
			}
			else if (TPName[i]->Contains("IMR") == true)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],0);
				CheckError(ret, __LINE__);

				//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);
				//	/*ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	CheckError(ret, __LINE__);*/
				//}
				//else
				//{
					ret = smu->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(ret, __LINE__);
					//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					//CheckError(ret, __LINE__);
				//}

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],1);
				CheckError(ret, __LINE__);

				//ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//CheckError(ret, __LINE__);
				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(TPDispName[0],0);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				////ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
				//CheckError(ret, __LINE__);

				//diffp_V = diffp_V - volt;
				//diffn_V = diffn_V - volt;
				//#endif
				
				if((TIDispName->Contains("hr0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) || (TIDispName->Contains("hr1") == true))
						diffp_V = -1*diffp_V;

				result[i] = Math::Abs((diffpn_V-c)/m) / CONST_Rr1;
				resultp[i] = (diffp_V-c)/m;
				resultpn[i] = diffpn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_reader_vos_spd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			//_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = DriveCBit(TPDispName[0], 1); //for RDP
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDP
				//CheckError(ret, __LINE__);

				ret = DriveCBit(TPDispName[0], 2); //for RDN
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDN
				//CheckError(ret, __LINE__);
			}
			else
			{
				ret = DriveCBit(TPDispName[0], 1); //for RDP
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDP
				//CheckError(ret, __LINE__);

				ret = DriveCBit(TPDispName[0], 2); //for RDN
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDN
				//CheckError(ret, __LINE__);
			}
			
			result[i] = diffp_V - diffn_V;

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_reader_vocm(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int Drive_RWn			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_RWn") == true)
			{
				Drive_RWn = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWn"));

				ret = ret = dm->DrivePin("RWN", Drive_RWn);
				CheckError(ret, __LINE__);
			}

			//_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = DriveCBit(TPDispName[0], 1); //for RDP
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDP
				//CheckError(ret, __LINE__);

				ret = DriveCBit(TPDispName[0], 2); //for RDN
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDN
				//CheckError(ret, __LINE__);
			}
			else
			{
				ret = DriveCBit(TPDispName[0], 1); //for RDP
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDP
				//CheckError(ret, __LINE__);

				ret = DriveCBit(TPDispName[0], 2); //for RDN
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);

				//ret = DriveCBit(TPDispName[0], 0); //for RDN
				//CheckError(ret, __LINE__);
			}

			#ifdef USE_GNDS
			double volt = 0;
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
			ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
			CheckError(ret, __LINE__);

			diffp_V = diffp_V - volt;
			diffn_V = diffn_V - volt;
			#endif
			
			resultp[i] = diffp_V;
			resultn[i] = diffn_V;

			if (i == 0 || i == 1)
			{	
				//vocm_rd = (active_rd_p + active_rd_n)/2;
				//vocm_wr = (active_wr_p + active_wr_n)/2;
				result[i] = (resultp[i] + resultn[i]) / 2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 2)
			{
				//dvocm = vocm_rd - vocm_wr;
				result[i] = result[0] - result[1];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 3)
			{
				//dvocm_ts = vocm_rd - ((sleep_rd_p + sleep_rd_n)/2);
				result[i] = result[0] - ((resultp[i] + resultn[i]) / 2);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 4)
			{
				tf_SetResult(TPName[i], resultp[i] + GetOffset(TPDispName[i]));
				tf_SetResult(TPName[i + 1], resultn[i] + GetOffset(TPDispName[i]));

				break;
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_reader_vocm2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//Use diff amp method
		//Hardcode CBIT and MUX setting here as RDP/N pin assignments for all quadrants and DUT/probe cards are the same
		//reader_vocm_ibias
		//Vocm^Rd_Ibias!RDPN!S,0 (connect p only. connect n to GNDS)
		//Vocm^Rd_Ibias!RDPN!S,1 (connect n only. connect p to GNDS)

		//reader_vocm_vbias
		//Vocm^Rd_Vbias!RDPN!V,0 (connect p only. connect n to GNDS)
		//Vocm^Rd_Vbias!RDPN!V,1 (connect n only. connect p to GNDS)

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int Drive_RWn			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = DriveCBit(TPDispName[0]);
		//CheckError(ret, __LINE__);
		//ret = DriveMuxIO(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		//// Check whether resource is SMU or DM
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeP = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		//// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, true, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, true, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 5);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//query for DiffAmp gain

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_RLY_GRP1_IA_SEL, 1); 
			CheckError(ret, __LINE__);

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_RLY_GRP2_IA_SEL, 1); 
			CheckError(ret, __LINE__);

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//#ifdef USE_GNDS
		//ret = Configure_GNDS_Mux(site, NPLC);
		//CheckError(ret, __LINE__);
		//#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_RWn") == true)
			{
				Drive_RWn = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWn"));

				ret = ret = dm->DrivePin("RWN", Drive_RWn);
				CheckError(ret, __LINE__);
			}

			//_util->Wait_Sec(Measure_Delay_s);

			{
				//RDP
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				
				ret = DriveMuxIO(TPDispName[0], 0);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);

				//RDN
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
				
				ret = DriveMuxIO(TPDispName[0], 1);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu->ReadVoltage("MTX_SMU", diffn_V);
				CheckError(ret, __LINE__);
			}

			diffp_V = -1 * diffp_V;
			//diffn_V = -1 * diffn_V;

			diffp_V =  (diffp_V-c)/m;
			diffn_V =  (diffn_V-c)/m;
			
			resultp[i] = diffp_V;
			resultn[i] = diffn_V;

			if (i == 0 || i == 1)
			{	
				//vocm_rd = (active_rd_p + active_rd_n)/2;
				//vocm_wr = (active_wr_p + active_wr_n)/2;
				result[i] = (resultp[i] + resultn[i]) / 2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 2)
			{
				//dvocm = vocm_rd - vocm_wr;
				result[i] = result[0] - result[1];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 3)
			{
				//dvocm_ts = vocm_rd - ((sleep_rd_p + sleep_rd_n)/2);
				result[i] = result[0] - ((resultp[i] + resultn[i]) / 2);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (i == 4)
			{
				tf_SetResult(TPName[i], resultp[i] + GetOffset(TPDispName[i]));
				tf_SetResult(TPName[i + 1], resultn[i] + GetOffset(TPDispName[i]));

				break;
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_rout(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Meas_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Meas_Pin_P"));
		String ^ Meas_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Meas_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = DriveMuxIO(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = dm->DrivePin("GND_MUX_RST_N", 0); //reset SPI MUX as we need MTX_SMU2 for this test (no need GNDS)
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleType_MeasureP = 0;
		unsigned int moduleType_MeasureN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Meas_Pin_P, moduleType_MeasureP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_MeasureP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Meas_Pin_P module type=" + moduleType_MeasureP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Meas_Pin_N, moduleType_MeasureN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_MeasureN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Meas_Pin_N module type=" + moduleType_MeasureN.ToString("X"));
		}

		int differential_measure = 0;
		if (Meas_Pin_P->Contains("DIFF_SENSE"))
		{
			differential_measure = 1;
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
		}

		if (moduleType_MeasureP != moduleTypeP)
		{
			if (moduleType_MeasureP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Meas_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Meas_Pin_P, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Meas_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Meas_Pin_P, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Meas_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Meas_Pin_P);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Meas_Pin_P, 0);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Meas_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Meas_Pin_P, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Meas_Pin_P, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Meas_Pin_P, true, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_P, 0);
				CheckError(ret, __LINE__);
			}
		}

		if (differential_measure == 0)
		{
			if (moduleType_MeasureN != moduleTypeN)
			{
				if (moduleType_MeasureN == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Meas_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Meas_Pin_N, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUVoltageLimit(Meas_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUCurrentLevel(Meas_Pin_N, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Meas_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Meas_Pin_N);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm->ConfigurePMUCurrentLevel(Meas_Pin_N, 0);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					ret = smu->ConfigureSamplingTime(Meas_Pin_N, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Meas_Pin_N, Math::Abs(Clamp_Vo_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Meas_Pin_N, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Meas_Pin_N, true, false);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = smu->DriveCurrent(Meas_Pin_N, 0);
					CheckError(ret, __LINE__);
				}
			}
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		{
			//SE voltage wrt GNDS
			double diffp_V1 = 0; //RDP @ -500uA 
			double diffn_V1 = 0; //RDN @ -500uA
			double diffp_V2 = 0; //RDP @ +500uA
			double diffn_V2 = 0; //RDN @ +500uA

			//diff voltage between RDP wrt RDN
			double diffpn_V1 = 0; //@ -500uA
			double diffpn_V2 = 0; //@ +500uA

			//Imbalance current due to external 100-ohm resistor btw RDP and RDN
			double ip1 = 0; // real current into RDP (test current @ -500uA)
			double in1 = 0; // real current into RDN (test current @ -500uA)
			double ip2 = 0; // real current out from RDP (test current @ +500uA)
			double in2 = 0; // real current out from RDP (test current @ +500uA)

			//////////////////////////////////////////////////
			//Drive -I
			//////////////////////////////////////////////////

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, -1 * Drive_Io_A);
			else
				ret = smu->DriveCurrent(Test_Pin_P, -1 * Drive_Io_A);
			CheckError(ret, __LINE__);

			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, -1 * Drive_Io_A);
			else
				ret = smu->DriveCurrent(Test_Pin_N, -1 * Drive_Io_A);
			CheckError(ret, __LINE__);

			if (Debug_Enable)
			{	
				double curr = 0;
				double volt = 0;

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASURECURRENT, curr);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadCurrent(Test_Pin_P, curr);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_P, volt);
					CheckError(ret, __LINE__);
				}

				if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
				{
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASURECURRENT, curr);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadCurrent(Test_Pin_N, curr); 
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, volt);
					CheckError(ret, __LINE__);
				}
			}

			if (differential_measure == 1)
			{
				//meas Hi wrt Lo
	
				ret = DriveMuxIO(TPDispName[0], 0);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V1);
				else
					ret = smu->ReadVoltage(Meas_Pin_P, diffpn_V1);
				CheckError(ret, __LINE__);

				diffpn_V1 = diffpn_V1 / 3; // There is a x3 gain at the SE-to-DIFF converter

				diffpn_V1 = -1 * diffpn_V1;

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				//meas Lo wrt GNDS
				
				ret = DriveMuxIO(TPDispName[0], 1);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffn_V1);
				else
					ret = smu->ReadVoltage(Meas_Pin_P, diffn_V1);
				CheckError(ret, __LINE__);

				diffn_V1 = diffn_V1 / 3; // There is a x3 gain at the SE-to-DIFF converter

				diffp_V1 = diffn_V1 + diffpn_V1;

				ip1 = -Drive_Io_A - diffpn_V1 / 100;
				in1 = -Drive_Io_A + diffpn_V1 / 100;
				
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
			}
			else
			{
				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V1);
				else
					ret = smu->ReadVoltage(Meas_Pin_P, diffp_V1);
				CheckError(ret, __LINE__);
				
				if (moduleType_MeasureN == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V1);
				else
					ret = smu->ReadVoltage(Meas_Pin_N, diffn_V1);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//CheckError(ret, __LINE__);
				//diffp_V1 = diffp_V1 - volt;
				//diffn_V1 = diffn_V1 - volt;
				//#endif
			}
			
			//////////////////////////////////////////////////
			//Drive +I
			//////////////////////////////////////////////////

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			else
				ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);

			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			else
				ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);

			if (Debug_Enable)
			{	
				double curr = 0;
				double volt = 0;

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASURECURRENT, curr);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadCurrent(Test_Pin_P, curr);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_P, volt);
					CheckError(ret, __LINE__);
				}

				if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
				{
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASURECURRENT, curr);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadCurrent(Test_Pin_N, curr); 
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, volt);
					CheckError(ret, __LINE__);
				}
			}

			if (differential_measure == 1)
			{
				//meas Hi wrt Lo

				ret = DriveMuxIO(TPDispName[0], 0);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V2);
				else
					ret = smu->ReadVoltage(Meas_Pin_P, diffpn_V2);
				CheckError(ret, __LINE__);

				diffpn_V2 = diffpn_V2 / 3; // There is a x3 gain at the SE-to-DIFF converter

				diffpn_V2 = -1 * diffpn_V2;

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				//meas Lo wrt GNDS

				ret = DriveMuxIO(TPDispName[0], 1);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffn_V2);
				else
					ret = smu->ReadVoltage(Meas_Pin_P, diffn_V2);
				CheckError(ret, __LINE__);

				diffn_V2 = diffn_V2 / 3; // There is a x3 gain at the SE-to-DIFF converter

				diffp_V2 = diffn_V2 + diffpn_V2;
				
				ip2 = Drive_Io_A - diffpn_V2 / 100;
				in2 = Drive_Io_A + diffpn_V2 / 100;

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
			}
			else
			{
				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V2);
				else
					ret = smu->ReadVoltage(Meas_Pin_P, diffp_V2);
				CheckError(ret, __LINE__);
				
				if (moduleType_MeasureN == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Meas_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V2);
				else
					ret = smu->ReadVoltage(Meas_Pin_N, diffn_V2);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//CheckError(ret, __LINE__);
				//diffp_V2 = diffp_V2 - volt;
				//diffn_V2 = diffn_V2 - volt;
				//#endif
			}

			//////////////////////////////////////////////////
			//Drive 0
			//////////////////////////////////////////////////

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			else
				ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);

			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			else
				ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);

			double routp = (diffp_V2 - diffp_V1) / (Math::Abs(ip1 - ip2));
			double routn = (diffn_V2 - diffn_V1) / (Math::Abs(in1 - in2));

			tf_SetResult(TPName[0], routp + GetOffset(TPDispName[0]));

			tf_SetResult(TPName[1], routn + GetOffset(TPDispName[1]));
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("GND_MUX_RST_N", 1);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_supply(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int Drive_WDX			= 0;
		int Drive_WDY			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_WDX") == true)
			{
				Drive_WDX = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDX"));

				ret = dm->DrivePin("WDX", Drive_WDX);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_WDY") == true)
			{
				Drive_WDY = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDY"));

				ret = dm->DrivePin("WDY", Drive_WDY);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
		
				#ifndef USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);
				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);
				#endif	
						
				if (ret == 0)
				{
					result[i] = (data >> 4) & 0x0F;
				}
				else
				{
					result[i] = -999;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("Y_Sply_Dev")) //TP1-4
			{
				double max = 0;
				double min = 0;

				for (int k=1; k<=4; k++)
				{
					if (k == 1)
					{
						min = max = result[k];
						min = max = result[k];
					}	
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("X_Sply_Dev")) //TP5-8
			{
				double max = 0;
				double min = 0;

				for (int k=5; k<=8; k++)
				{
					if (k == 5)
					{
						min = max = result[k];
						min = max = result[k];
					}	
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				_util->Wait_Sec(Measure_Delay_s);

				double diffp_V = 0;
				double diffn_V = 0;

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				
				result[i] = (diffp_V - diffn_V) / CONST_Rw;

				if (TPDispName[i]->Contains("X"))
					result[i] = result[i] * (1 - 0.09 * result[i] / 0.07);
				else //Y
					result[i] = result[i] * (1 + 0.09 * result[i] / 0.07);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_supply2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		Test_Pin_P = "GRP1_DIFF_SENSE";

		int Drive_WDX			= 0;
		int Drive_WDY			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_WDX") == true)
			{
				Drive_WDX = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDX"));

				ret = dm->DrivePin("WDX", Drive_WDX);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_WDY") == true)
			{
				Drive_WDY = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDY"));

				ret = dm->DrivePin("WDY", Drive_WDY);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
		
				#ifndef USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);
				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);
				#endif	
						
				if (ret == 0)
				{
					result[i] = (data >> 4) & 0x0F;
				}
				else
				{
					result[i] = -999;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("Y_Sply_Dev")) //TP1-4
			{
				double max = 0;
				double min = 0;

				for (int k=1; k<=4; k++)
				{
					if (k == 1)
					{
						min = max = result[k];
						min = max = result[k];
					}	
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("X_Sply_Dev")) //TP5-8
			{
				double max = 0;
				double min = 0;

				for (int k=5; k<=8; k++)
				{
					if (k == 5)
					{
						min = max = result[k];
						min = max = result[k];
					}	
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				_util->Wait_Sec(Measure_Delay_s);

				double diffp_V = 0;
				double diffn_V = 0;

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);

					//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					//CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					//CheckError(ret, __LINE__);
				}

				diffp_V = (diffp_V-c)/m;

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
				
				result[i] = (diffp_V - diffn_V) / CONST_Rw;

				if (TPDispName[i]->Contains("X"))
					result[i] = result[i] * (1 - 0.09 * result[i] / 0.07);
				else //Y
					result[i] = result[i] * (1 + 0.09 * result[i] / 0.07);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_supply3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		Test_Pin_P = "GRP1_DIFF_SENSE";

		int Drive_WDX			= 0;
		int Drive_WDY			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_WDX") == true)
			{
				Drive_WDX = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDX"));

				ret = dm->DrivePin("WDX", Drive_WDX);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_WDY") == true)
			{
				Drive_WDY = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDY"));

				ret = dm->DrivePin("WDY", Drive_WDY);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(On_Delay_s);

			if (i == 0)
			{
		
				#ifndef USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);
				#else
				ret = ReadSPI(Vector_File, data);
				CheckError(ret, __LINE__);
				#endif	
						
				if (ret == 0)
				{
					result[i] = (data >> 4) & 0x0F;
				}
				else
				{
					result[i] = -999;
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("Y_Sply_Dev")) //TP1-4
			{
				double max = 0;
				double min = 0;

				for (int k=1; k<=4; k++)
				{
					if (k == 1)
					{
						min = max = result[k];
						min = max = result[k];
					}	
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else if (TPDispName[i]->Contains("X_Sply_Dev")) //TP5-8
			{
				double max = 0;
				double min = 0;

				for (int k=5; k<=8; k++)
				{
					if (k == 5)
					{
						min = max = result[k];
						min = max = result[k];
					}	
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				_util->Wait_Sec(Measure_Delay_s);

				double diffp_V = 0;
				double diffn_V = 0;

				//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);

				//	//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	//CheckError(ret, __LINE__);
				//}
				//else
				//{
				//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				//	CheckError(ret, __LINE__);
				//	//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//	//CheckError(ret, __LINE__);
				//}

				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);

				diffp_V = (diffp_V-c)/m;

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
				
				result[i] = (diffp_V - diffn_V) / CONST_Rw;

				if (TPDispName[i]->Contains("X"))
					result[i] = result[i] * (1 - 0.09 * result[i] / 0.07);
				else //Y
					result[i] = result[i] * (1 + 0.09 * result[i] / 0.07);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_step(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double iw_dac_dc_cm = 0;

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

			if (i == step - 1)
			{
				iw_dac_dc_cm = diffp_V - (result_iwx[i] / 2);
			}
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			result[i] = result_iwx[i];

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};
		array<double> ^ result_iwx_tmp = gcnew array<double> (step);
		for (int k=0; k<step; k++)
		{
			//if (k == 0) result_iwx_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
			//else
			{
				result_iwx_tmp[k] = result_iwx[k];
			}
		}

		_util->line_fit(asym_iwx, result_iwx_tmp, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		smallest_delta_index_iwx = _util->monotonicity(result_iwx_tmp, step, 0, smallest_delta_iwx); //type = 0 (ascending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};
		array<double> ^ result_iwy_tmp = gcnew array<double> (step);
		for (int k=0; k<step; k++)
		{
			//if (k == 0) result_iwy_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
			//else
			{
				result_iwy_tmp[k] = result_iwy[k];
			}
		}

		_util->line_fit(asym_iwy, result_iwy_tmp, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[10], slope_iwy + GetOffset(TPDispName[10]));
		tf_SetResult(TPName[11], offset_iwy + GetOffset(TPDispName[11]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		smallest_delta_index_iwy = _util->monotonicity(result_iwy_tmp, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[12], smallest_delta_index_iwy + (int)GetOffset(TPDispName[12]));
		tf_SetResult(TPName[13], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[13]));		

		/////////////////////////////////

		array<double> ^ iw_dac_asy= gcnew array<double>(step);
		double iw_dac_asy_fabs = 0;
		double iw_asy_max = 0;
		int iw_asy_max_dac = 0;
		
		for(int k=0; k<step; k++)
		{	
			if(Math::Abs(result_iwx[k]) == Math::Abs(result_iwy[k]))
				iw_dac_asy[k] = 0;
			else 
				iw_dac_asy[k] = (Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k])) / ((Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]))/2);
		}
			
		for(int k=5; k<step; k++)
		{
			iw_dac_asy_fabs = Math::Abs(iw_dac_asy[k]);

			if(iw_dac_asy_fabs > iw_asy_max)
			{
				iw_asy_max = iw_dac_asy_fabs;
				iw_asy_max_dac = k;
			}
		}

		tf_SetResult(TPName[14], iw_asy_max_dac + (int)GetOffset(TPDispName[14]));
		tf_SetResult(TPName[15], iw_dac_asy[iw_asy_max_dac] + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], iw_dac_dc_cm + GetOffset(TPDispName[16]));

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_step2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double iw_dac_dc_cm = 0;

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				ret = DriveMuxIO(TPDispName[0], 0);

				if (moduleTypeP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				else
					ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				else 
					diffpn_V = (diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter

				if (i == step - 1)
				{
					//meas P wrt GNDS
					ret = DriveMuxIO(TPDispName[0], 1);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleTypeP == DM_CONST_MODULE_TYPE)
						ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					else
						ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
				
					diffp_V = (diffp_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				}

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = (diffpn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

			if (i == step - 1)
			{
				iw_dac_dc_cm = diffp_V - (result_iwx[i] / 2);
			}
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				ret = DriveMuxIO(TPDispName[0], 0);

				if (moduleTypeP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				else
					ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				else 
					diffpn_V = (diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = (diffpn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			result[i] = result_iwx[i];

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};
		array<double> ^ result_iwx_tmp = gcnew array<double> (step);
		for (int k=0; k<step; k++)
		{
			//if (k == 0) result_iwx_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
			//else
			{
				result_iwx_tmp[k] = result_iwx[k];
			}
		}

		_util->line_fit(asym_iwx, result_iwx_tmp, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		smallest_delta_index_iwx = _util->monotonicity(result_iwx_tmp, step, 0, smallest_delta_iwx); //type = 0 (ascending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};
		array<double> ^ result_iwy_tmp = gcnew array<double> (step);
		for (int k=0; k<step; k++)
		{
			//if (k == 0) result_iwy_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
			//else
			{
				result_iwy_tmp[k] = result_iwy[k];
			}
		}

		_util->line_fit(asym_iwy, result_iwy_tmp, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[10], slope_iwy + GetOffset(TPDispName[10]));
		tf_SetResult(TPName[11], offset_iwy + GetOffset(TPDispName[11]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		smallest_delta_index_iwy = _util->monotonicity(result_iwy_tmp, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[12], smallest_delta_index_iwy + (int)GetOffset(TPDispName[12]));
		tf_SetResult(TPName[13], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[13]));		

		/////////////////////////////////

		array<double> ^ iw_dac_asy= gcnew array<double>(step);
		double iw_dac_asy_fabs = 0;
		double iw_asy_max = 0;
		int iw_asy_max_dac = 0;
		
		for(int k=0; k<step; k++)
		{	
			if(Math::Abs(result_iwx[k]) == Math::Abs(result_iwy[k]))
				iw_dac_asy[k] = 0;
			else 
				iw_dac_asy[k] = (Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k])) / ((Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]))/2);
		}
			
		for(int k=5; k<step; k++)
		{
			iw_dac_asy_fabs = Math::Abs(iw_dac_asy[k]);

			if(iw_dac_asy_fabs > iw_asy_max)
			{
				iw_asy_max = iw_dac_asy_fabs;
				iw_asy_max_dac = k;
			}
		}

		tf_SetResult(TPName[14], iw_asy_max_dac + (int)GetOffset(TPDispName[14]));
		tf_SetResult(TPName[15], iw_dac_asy[iw_asy_max_dac] + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], iw_dac_dc_cm + GetOffset(TPDispName[16]));

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_iw_step3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 3);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double iw_dac_dc_cm = 0;

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			//_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0], 0);

				_util->Wait_Sec(Measure_Delay_s);

				//if (moduleTypeP == DM_CONST_MODULE_TYPE)
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//else
				//	ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				else 
					diffpn_V = (diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter

				if (i == step - 1)
				{
					ret = ResetMuxIO();
					CheckError(ret, __LINE__);

					//meas P wrt GNDS
					ret = DriveMuxIO(TPDispName[0], 1);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					//if (moduleTypeP == DM_CONST_MODULE_TYPE)
					//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					//else
					//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					//CheckError(ret, __LINE__);

					ret = smu->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(ret, __LINE__);
				
					diffp_V = (diffp_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				}

				//ret = ResetMuxIO();
				//CheckError(ret, __LINE__);

			}
			else
			{
				//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				//CheckError(ret, __LINE__);
				//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = (diffpn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

			if (i == step - 1)
			{
				iw_dac_dc_cm = diffp_V - (result_iwx[i] / 2);
			}
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			//_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0], 0);

				_util->Wait_Sec(Measure_Delay_s);

				//if (moduleTypeP == DM_CONST_MODULE_TYPE)
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//else
				//	ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				else 
					diffpn_V = (diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter

				//ret = ResetMuxIO();
				//CheckError(ret, __LINE__);
			}
			else
			{
				//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				//CheckError(ret, __LINE__);
				//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = (diffpn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			result[i] = result_iwx[i];

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};
		array<double> ^ result_iwx_tmp = gcnew array<double> (step);
		for (int k=0; k<step; k++)
		{
			//if (k == 0) result_iwx_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
			//else
			{
				result_iwx_tmp[k] = result_iwx[k];
			}
		}

		_util->line_fit(asym_iwx, result_iwx_tmp, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		smallest_delta_index_iwx = _util->monotonicity(result_iwx_tmp, step, 0, smallest_delta_iwx); //type = 0 (ascending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};
		array<double> ^ result_iwy_tmp = gcnew array<double> (step);
		for (int k=0; k<step; k++)
		{
			//if (k == 0) result_iwy_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
			//else
			{
				result_iwy_tmp[k] = result_iwy[k];
			}
		}

		_util->line_fit(asym_iwy, result_iwy_tmp, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[10], slope_iwy + GetOffset(TPDispName[10]));
		tf_SetResult(TPName[11], offset_iwy + GetOffset(TPDispName[11]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		smallest_delta_index_iwy = _util->monotonicity(result_iwy_tmp, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[12], smallest_delta_index_iwy + (int)GetOffset(TPDispName[12]));
		tf_SetResult(TPName[13], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[13]));		

		/////////////////////////////////

		array<double> ^ iw_dac_asy= gcnew array<double>(step);
		double iw_dac_asy_fabs = 0;
		double iw_asy_max = 0;
		int iw_asy_max_dac = 0;
		
		for(int k=0; k<step; k++)
		{	
			if(Math::Abs(result_iwx[k]) == Math::Abs(result_iwy[k]))
				iw_dac_asy[k] = 0;
			else 
				iw_dac_asy[k] = (Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k])) / ((Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]))/2);
		}
			
		for(int k=5; k<step; k++)
		{
			iw_dac_asy_fabs = Math::Abs(iw_dac_asy[k]);

			if(iw_dac_asy_fabs > iw_asy_max)
			{
				iw_asy_max = iw_dac_asy_fabs;
				iw_asy_max_dac = k;
			}
		}

		tf_SetResult(TPName[14], iw_asy_max_dac + (int)GetOffset(TPDispName[14]));
		tf_SetResult(TPName[15], iw_dac_asy[iw_asy_max_dac] + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], iw_dac_dc_cm + GetOffset(TPDispName[16]));

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_iw_asym_step(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			tf_SetResult(TPName[i], result_iwx[i] + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i + 10], result_iwy[i] + GetOffset(TPDispName[i+10]));
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 1, smallest_delta_iwx); //type = 1 (decending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[16], slope_iwy + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], offset_iwy + GetOffset(TPDispName[17]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 0, smallest_delta_iwy); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[18], smallest_delta_index_iwy + (int)GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[19]));		

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_asym_step2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;
			double diffpn_V = 0;
			
			//query for DiffAmp gain
			double m = 3;
			double c = 0;
			if (Test_Pin_P == "GRP1_DIFF_SENSE")
			{
				m = _glob->DA_GainError[0];
				c = _glob->DA_OffsetError[0];
			}
			else if (Test_Pin_P == "GRP2_DIFF_SENSE")
			{
				m = _glob->DA_GainError[1];
				c = _glob->DA_OffsetError[1];
			}

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				if (moduleTypeP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				else
					ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				else 
					diffpn_V = (diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = diffpn_V / CONST_Rw;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				if (moduleTypeP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				else
					ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m;
				else 
					diffpn_V = (diffpn_V-c)/m; 
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = diffpn_V / CONST_Rw;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			tf_SetResult(TPName[i], result_iwx[i] + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i + 10], result_iwy[i] + GetOffset(TPDispName[i+10]));
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 1, smallest_delta_iwx); //type = 1 (decending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[16], slope_iwy + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], offset_iwy + GetOffset(TPDispName[17]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 0, smallest_delta_iwy); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[18], smallest_delta_index_iwy + (int)GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[19]));		

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_iw_asym_step3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;
			double diffpn_V = 0;
			
			//query for DiffAmp gain
			double m = 3;
			double c = 0;
			if (Test_Pin_P == "GRP1_DIFF_SENSE")
			{
				m = _glob->DA_GainError[0];
				c = _glob->DA_OffsetError[0];

				ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
				CheckError(ret, __LINE__);
			}
			else if (Test_Pin_P == "GRP2_DIFF_SENSE")
			{
				m = _glob->DA_GainError[1];
				c = _glob->DA_OffsetError[1];

				ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
				CheckError(ret, __LINE__);
			}

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				//if (moduleTypeP == DM_CONST_MODULE_TYPE)
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//else
				//	ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
				else 
					diffpn_V = (diffpn_V-c)/m; // There is a x3 gain at the SE-to-DIFF converter
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = diffpn_V / CONST_Rw;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm differential
			{
				//if (moduleTypeP == DM_CONST_MODULE_TYPE)
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//else
				//	ret = smu->ReadVoltage(Test_Pin_P, diffpn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				if((TIDispName->Contains("hw0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card writer pin is inversed with probe card
					diffpn_V = -1*(diffpn_V-c)/m;
				else 
					diffpn_V = (diffpn_V-c)/m; 
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = diffpn_V / CONST_Rw;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			tf_SetResult(TPName[i], result_iwx[i] + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i + 10], result_iwy[i] + GetOffset(TPDispName[i+10]));
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 1, smallest_delta_iwx); //type = 1 (decending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[16], slope_iwy + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], offset_iwy + GetOffset(TPDispName[17]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 0, smallest_delta_iwy); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[18], smallest_delta_index_iwy + (int)GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[19]));		

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_osa_step(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File_1	= String::Empty;

		double iosmax_x		= 0; 
		double iosmax_y		= 0;
		double reference_x	= 0;
		double reference_y	= 0;

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		int differential_measure = 0;
		if (Test_Pin_P->Contains("DIFF_SENSE"))
		{
			differential_measure = 1;
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		if (differential_measure == 0)
		{
			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_N);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_N, false, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(On_Delay_s);

			// X

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				if (differential_measure == 0)
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V / 3; 
				}
			}
			else
			{
				if (differential_measure == 0)
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V / 3; 
				}
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;

			if (i == 0)
			{
				reference_x = result_iwx[i];

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_X"));
					_glob->Global_Result[Global_Result_Index] = reference_x;
			}
			
			result_iwx[i] = result_iwx[i] - reference_x;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

			// Y

			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				if (differential_measure == 0)
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V / 3; 
				}
			}
			else
			{
				if (differential_measure == 0)
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V / 3; 
				}
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;

			if (i == 0)
			{
				reference_y = result_iwy[i];

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Y"));
					_glob->Global_Result[Global_Result_Index] = reference_y;
			}
			
			result_iwy[i] = result_iwy[i] - reference_y;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			result[i] = result_iwx[i];

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[10], slope_iwy + GetOffset(TPDispName[10]));
		tf_SetResult(TPName[11], offset_iwy + GetOffset(TPDispName[11]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[12], smallest_delta_index_iwy + (int)GetOffset(TPDispName[12]));
		tf_SetResult(TPName[13], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[13]));		

		/////////////////////////////////

		array<double> ^ iw_dac_asy= gcnew array<double>(step);
		double iw_dac_asy_fabs = 0;
		double iw_asy_max = 0;
		int iw_asy_max_dac = 0;
		
		for(int k=0; k<step; k++)
		{	
			iw_dac_asy[k] = Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]);
		}

		//for(int k=5; k<step; k++)
		//{
		//	iw_dac_asy_fabs = abs(iw_dac_asy[k]);

		//	if(iw_dac_asy_fabs > iw_asy_max)
		//	{
		//		iw_asy_max = iw_dac_asy_fabs;
		//		iw_asy_max_dac = k;
		//	}
		//}

		tf_SetResult(TPName[14], iw_dac_asy[step-1] + GetOffset(TPDispName[14]));

		/////////////////////////////////
		// Ios
		/////////////////////////////////

		Vector_File = (String ^)(tf_TPCondition_Cast(TPName[15], "Vector_File"));
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(On_Delay_s);

		//Measure reference_x & reference_y

		// X
		ret = dm->DrivePin("WDX", 1);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}

		reference_x = (diffp_V - diffn_V) / CONST_Rw;

		// Y
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}

		reference_y = (diffp_V - diffn_V) / CONST_Rw;

		//Measure iosmax_x & iosmax_y

		Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[15], "Vector_File_1"));
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(On_Delay_s);

		// X
		ret = dm->DrivePin("WDX", 1);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}

		iosmax_x = (diffp_V - diffn_V) / CONST_Rw;
		iosmax_x = iosmax_x - reference_x;
		iosmax_x = iosmax_x * (1 - 0.09 * iosmax_x / 0.07);

		// Y
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 
			}
		}

		iosmax_y = (diffp_V - diffn_V) / CONST_Rw;
		iosmax_y = iosmax_y - reference_y;
		iosmax_y = iosmax_y * (1 + 0.09 * iosmax_y/ 0.07);

		tf_SetResult(TPName[15], iosmax_x + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], iosmax_y + GetOffset(TPDispName[16]));

		/////////////////////////////////
		// End
		/////////////////////////////////

		Vector_File = "write_p1_reg4_iss_15_ios_rampdown";

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_osa_step2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File_1	= String::Empty;

		double iosmax_x		= 0; 
		double iosmax_y		= 0;
		double reference_x	= 0;
		double reference_y	= 0;

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		int differential_measure = 0;
		if (Test_Pin_P->Contains("DIFF_SENSE"))
		{
			differential_measure = 1;
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		if (differential_measure == 0)
		{
			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_N);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_N, false, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(On_Delay_s);

			// X

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				if (differential_measure == 0)
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = (diffp_V-c)/m; 

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
					{
						diffp_V = -1 * diffp_V;
					}
				}
			}
			else
			{
				if (differential_measure == 0)
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = (diffp_V-c)/m; 

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
					{
						diffp_V = -1 * diffp_V;
					}
				}
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;

			if (i == 0)
			{
				reference_x = result_iwx[i];

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_X"));
					_glob->Global_Result[Global_Result_Index] = reference_x;
			}
			
			result_iwx[i] = result_iwx[i] - reference_x;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

			// Y

			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				if (differential_measure == 0)
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = (diffp_V-c)/m; 

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
					{
						diffp_V = -1 * diffp_V;
					}
				}
			}
			else
			{
				if (differential_measure == 0)
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = (diffp_V-c)/m; 

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
					{
						diffp_V = -1 * diffp_V;
					}
				}
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;

			if (i == 0)
			{
				reference_y = result_iwy[i];

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Y"));
					_glob->Global_Result[Global_Result_Index] = reference_y;
			}
			
			result_iwy[i] = result_iwy[i] - reference_y;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			result[i] = result_iwx[i];

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[10], slope_iwy + GetOffset(TPDispName[10]));
		tf_SetResult(TPName[11], offset_iwy + GetOffset(TPDispName[11]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[12], smallest_delta_index_iwy + (int)GetOffset(TPDispName[12]));
		tf_SetResult(TPName[13], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[13]));		

		/////////////////////////////////

		array<double> ^ iw_dac_asy= gcnew array<double>(step);
		double iw_dac_asy_fabs = 0;
		double iw_asy_max = 0;
		int iw_asy_max_dac = 0;
		
		for(int k=0; k<step; k++)
		{	
			iw_dac_asy[k] = Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]);
		}

		//for(int k=5; k<step; k++)
		//{
		//	iw_dac_asy_fabs = abs(iw_dac_asy[k]);

		//	if(iw_dac_asy_fabs > iw_asy_max)
		//	{
		//		iw_asy_max = iw_dac_asy_fabs;
		//		iw_asy_max_dac = k;
		//	}
		//}

		tf_SetResult(TPName[14], iw_dac_asy[step-1] + GetOffset(TPDispName[14]));

		/////////////////////////////////
		// Ios
		/////////////////////////////////

		Vector_File = (String ^)(tf_TPCondition_Cast(TPName[15], "Vector_File"));
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(On_Delay_s);

		//Measure reference_x & reference_y

		// X
		ret = dm->DrivePin("WDX", 1);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}

		reference_x = (diffp_V - diffn_V) / CONST_Rw;

		// Y
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}

		reference_y = (diffp_V - diffn_V) / CONST_Rw;

		//Measure iosmax_x & iosmax_y

		Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[15], "Vector_File_1"));
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(On_Delay_s);

		// X
		ret = dm->DrivePin("WDX", 1);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}

		iosmax_x = (diffp_V - diffn_V) / CONST_Rw;
		iosmax_x = iosmax_x - reference_x;
		iosmax_x = iosmax_x * (1 - 0.09 * iosmax_x / 0.07);

		// Y
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			if (differential_measure == 0)
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		else
		{
			if (differential_measure == 0)
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V / 3; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}

		iosmax_y = (diffp_V - diffn_V) / CONST_Rw;
		iosmax_y = iosmax_y - reference_y;
		iosmax_y = iosmax_y * (1 + 0.09 * iosmax_y/ 0.07);

		tf_SetResult(TPName[15], iosmax_x + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], iosmax_y + GetOffset(TPDispName[16]));

		/////////////////////////////////
		// End
		/////////////////////////////////

		Vector_File = "write_p1_reg4_iss_15_ios_rampdown";

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_osa_step3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File_1	= String::Empty;

		double iosmax_x		= 0; 
		double iosmax_y		= 0;
		double reference_x	= 0;
		double reference_y	= 0;

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		int differential_measure = 0;
		if (Test_Pin_P->Contains("DIFF_SENSE"))
		{
			differential_measure = 1;
		}

		// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//if (differential_measure == 0)
		//{
		//	// Configure N
		//	if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//	{
		//		ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//		CheckError(ret, __LINE__);
		//		ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//		CheckError(ret, __LINE__);
		//		ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//		CheckError(ret, __LINE__);
		//		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//		CheckError(ret, __LINE__);
		//		ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//		CheckError(ret, __LINE__);
		//		ret = dm->DPINOn(Test_Pin_N);
		//		CheckError(ret, __LINE__);
		//		_util->Wait_Sec(On_Delay_s);
		//		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//		CheckError(ret, __LINE__);
		//	}
		//	else //smu
		//	{
		//		ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//		CheckError(ret, __LINE__);
		//		ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//		CheckError(ret, __LINE__);
		//		ret = smu->DriveCurrent(Test_Pin_N, 0);
		//		CheckError(ret, __LINE__);
		//		ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//		CheckError(ret, __LINE__);
		//		_util->Wait_Sec(On_Delay_s);
		//		ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//		CheckError(ret, __LINE__);
		//	}
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(On_Delay_s);

			// X

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				//if (differential_measure == 0)
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);
				//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	CheckError(ret, __LINE__);
				//}
				//else
				{
					//ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					ret = smu->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = (diffp_V-c)/m; 

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
					{
						diffp_V = -1 * diffp_V;
					}
				}
			}
			//else
			//{
			//	if (differential_measure == 0)
			//	{
			//		ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//		CheckError(ret, __LINE__);
			//		ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//		CheckError(ret, __LINE__);
			//	}
			//	else
			//	{
			//		//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//		ret = smu->ReadVoltage("MTX_SMU", diffp_V);
			//		CheckError(ret, __LINE__);
			//		diffp_V = (diffp_V-c)/m; 

			//		if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
			//		{
			//			diffp_V = -1 * diffp_V;
			//		}
			//	}
			//}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;

			if (i == 0)
			{
				reference_x = result_iwx[i];

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_X"));
					_glob->Global_Result[Global_Result_Index] = reference_x;
			}
			
			result_iwx[i] = result_iwx[i] - reference_x;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

			// Y

			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				//if (differential_measure == 0)
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);
				//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	CheckError(ret, __LINE__);
				//}
				//else
				{
					//ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					ret = smu->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(ret, __LINE__);
					diffp_V = (diffp_V-c)/m; 

					if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
					{
						diffp_V = -1 * diffp_V;
					}
				}
			}
			//else
			//{
			//	if (differential_measure == 0)
			//	{
			//		ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//		CheckError(ret, __LINE__);
			//		ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//		CheckError(ret, __LINE__);
			//	}
			//	else
			//	{
			//		//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//		ret = smu->ReadVoltage("MTX_SMU", diffp_V);
			//		CheckError(ret, __LINE__);
			//		diffp_V = (diffp_V-c)/m; 

			//		if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
			//		{
			//			diffp_V = -1 * diffp_V;
			//		}
			//	}
			//}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;

			if (i == 0)
			{
				reference_y = result_iwy[i];

				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Y"));
					_glob->Global_Result[Global_Result_Index] = reference_y;
			}
			
			result_iwy[i] = result_iwy[i] - reference_y;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			result[i] = result_iwx[i];

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[10], slope_iwy + GetOffset(TPDispName[10]));
		tf_SetResult(TPName[11], offset_iwy + GetOffset(TPDispName[11]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[12], smallest_delta_index_iwy + (int)GetOffset(TPDispName[12]));
		tf_SetResult(TPName[13], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[13]));		

		/////////////////////////////////

		array<double> ^ iw_dac_asy= gcnew array<double>(step);
		double iw_dac_asy_fabs = 0;
		double iw_asy_max = 0;
		int iw_asy_max_dac = 0;
		
		for(int k=0; k<step; k++)
		{	
			iw_dac_asy[k] = Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]);
		}

		//for(int k=5; k<step; k++)
		//{
		//	iw_dac_asy_fabs = abs(iw_dac_asy[k]);

		//	if(iw_dac_asy_fabs > iw_asy_max)
		//	{
		//		iw_asy_max = iw_dac_asy_fabs;
		//		iw_asy_max_dac = k;
		//	}
		//}

		tf_SetResult(TPName[14], iw_dac_asy[step-1] + GetOffset(TPDispName[14]));

		/////////////////////////////////
		// Ios
		/////////////////////////////////

		Vector_File = (String ^)(tf_TPCondition_Cast(TPName[15], "Vector_File"));
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(On_Delay_s);

		//Measure reference_x & reference_y

		// X
		ret = dm->DrivePin("WDX", 1);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			//if (differential_measure == 0)
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			{
				//ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m;  

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		//else
		//{
		//	if (differential_measure == 0)
		//	{
		//		ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		CheckError(ret, __LINE__);
		//		ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
		//		CheckError(ret, __LINE__);
		//	}
		//	else
		//	{
		//		//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		ret = smu->ReadVoltage("MTX_SMU", diffp_V);
		//		CheckError(ret, __LINE__);
		//		diffp_V = (diffp_V-c)/m; 

		//		if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
		//		{
		//			diffp_V = -1 * diffp_V;
		//		}
		//	}
		//}

		reference_x = (diffp_V - diffn_V) / CONST_Rw;

		// Y
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			//if (differential_measure == 0)
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			{
				//ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		//else
		//{
		//	//if (differential_measure == 0)
		//	//{
		//	//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//	//	CheckError(ret, __LINE__);
		//	//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
		//	//	CheckError(ret, __LINE__);
		//	//}
		//	//else
		//	{
		//		//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		ret = smu->ReadVoltage("MTX_SMU", diffp_V);
		//		CheckError(ret, __LINE__);
		//		diffp_V = (diffp_V-c)/m; 

		//		if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
		//		{
		//			diffp_V = -1 * diffp_V;
		//		}
		//	}
		//}

		reference_y = (diffp_V - diffn_V) / CONST_Rw;

		//Measure iosmax_x & iosmax_y

		Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[15], "Vector_File_1"));
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(On_Delay_s);

		// X
		ret = dm->DrivePin("WDX", 1);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			//if (differential_measure == 0)
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			{
				//ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		//else
		//{
		//	if (differential_measure == 0)
		//	{
		//		ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		CheckError(ret, __LINE__);
		//		ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
		//		CheckError(ret, __LINE__);
		//	}
		//	else
		//	{
		//		//ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		ret = smu->ReadVoltage("MTX_SMU", diffp_V);
		//		CheckError(ret, __LINE__);
		//		diffp_V = (diffp_V-c)/m; 

		//		if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
		//		{
		//			diffp_V = -1 * diffp_V;
		//		}
		//	}
		//}

		iosmax_x = (diffp_V - diffn_V) / CONST_Rw;
		iosmax_x = iosmax_x - reference_x;
		iosmax_x = iosmax_x * (1 - 0.09 * iosmax_x / 0.07);

		// Y
		ret = dm->DrivePin("WDX", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("WDY", 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			//if (differential_measure == 0)
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			{
				//ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);
				diffp_V = (diffp_V-c)/m; 

				if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
				{
					diffp_V = -1 * diffp_V;
				}
			}
		}
		//else
		//{
		//	if (differential_measure == 0)
		//	{
		//		ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		CheckError(ret, __LINE__);
		//		ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
		//		CheckError(ret, __LINE__);
		//	}
		//	else
		//	{
		//		ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
		//		CheckError(ret, __LINE__);
		//		diffp_V = diffp_V / 3; 

		//		if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[15]->Contains("HW0")))
		//		{
		//			diffp_V = -1 * diffp_V;
		//		}
		//	}
		//}

		iosmax_y = (diffp_V - diffn_V) / CONST_Rw;
		iosmax_y = iosmax_y - reference_y;
		iosmax_y = iosmax_y * (1 + 0.09 * iosmax_y/ 0.07);

		tf_SetResult(TPName[15], iosmax_x + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], iosmax_y + GetOffset(TPDispName[16]));

		/////////////////////////////////
		// End
		/////////////////////////////////

		Vector_File = "write_p1_reg4_iss_15_ios_rampdown";

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_osa3_asym_step(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		int Global_Result_Index_X = (int)(tf_TestItemCondition_Cast("Global_Result_Index_X"));
		int Global_Result_Index_Y = (int)(tf_TestItemCondition_Cast("Global_Result_Index_Y"));

		double global_reference_x = _glob->Global_Result[Global_Result_Index_X];
		double global_reference_y = _glob->Global_Result[Global_Result_Index_Y];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] - global_reference_x;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] - global_reference_y;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			tf_SetResult(TPName[i], result_iwx[i] + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i + 10], result_iwy[i] + GetOffset(TPDispName[i+10]));
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 1, smallest_delta_iwx); //type = 1 (decending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[16], slope_iwy + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], offset_iwy + GetOffset(TPDispName[17]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 0, smallest_delta_iwy); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[18], smallest_delta_index_iwy + (int)GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[19]));		

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
	
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_osa3_asym_step2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		Test_Pin_P = "GRP1_DIFF_SENSE";

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		int Global_Result_Index_X = (int)(tf_TestItemCondition_Cast("Global_Result_Index_X"));
		int Global_Result_Index_Y = (int)(tf_TestItemCondition_Cast("Global_Result_Index_Y"));

		double global_reference_x = _glob->Global_Result[Global_Result_Index_X];
		double global_reference_y = _glob->Global_Result[Global_Result_Index_Y];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			//query for DiffAmp gain
			double m = 3;
			double c = 0;
			if (Test_Pin_P == "GRP1_DIFF_SENSE")
			{
				m = _glob->DA_GainError[0];
				c = _glob->DA_OffsetError[0];
			}
			else if (Test_Pin_P == "GRP2_DIFF_SENSE")
			{
				m = _glob->DA_GainError[1];
				c = _glob->DA_OffsetError[1];
			}

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//CheckError(ret, __LINE__);
			}

			diffp_V = (diffp_V-c)/m;

			if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
			{
				diffp_V = -1 * diffp_V;
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] - global_reference_x;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//CheckError(ret, __LINE__);
			}

			diffp_V = (diffp_V-c)/m;

			if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
			{
				diffp_V = -1 * diffp_V;
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] - global_reference_y;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			tf_SetResult(TPName[i], result_iwx[i] + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i + 10], result_iwy[i] + GetOffset(TPDispName[i+10]));
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 1, smallest_delta_iwx); //type = 1 (decending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[16], slope_iwy + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], offset_iwy + GetOffset(TPDispName[17]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 0, smallest_delta_iwy); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[18], smallest_delta_index_iwy + (int)GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[19]));		

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
	
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_osa3_asym_step3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		Test_Pin_P = "GRP1_DIFF_SENSE";

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx = gcnew array<double>(step);
		array<double> ^ result_iwy = gcnew array<double>(step);

		int Global_Result_Index_X = (int)(tf_TestItemCondition_Cast("Global_Result_Index_X"));
		int Global_Result_Index_Y = (int)(tf_TestItemCondition_Cast("Global_Result_Index_Y"));

		double global_reference_x = _glob->Global_Result[Global_Result_Index_X];
		double global_reference_y = _glob->Global_Result[Global_Result_Index_Y];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_iwy[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			//query for DiffAmp gain
			double m = 3;
			double c = 0;
			if (Test_Pin_P == "GRP1_DIFF_SENSE")
			{
				m = _glob->DA_GainError[0];
				c = _glob->DA_OffsetError[0];

				ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
				CheckError(ret, __LINE__);
			}
			else if (Test_Pin_P == "GRP2_DIFF_SENSE")
			{
				m = _glob->DA_GainError[1];
				c = _glob->DA_OffsetError[1];

				ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
				CheckError(ret, __LINE__);
			}

			ret = dm->DrivePin("WDX", 1);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = smu->ReadVoltage("MTX_SMU", diffp_V);
			CheckError(ret, __LINE__);

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);

			//	//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	//CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//	CheckError(ret, __LINE__);
			//	//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//	//CheckError(ret, __LINE__);
			//}

			diffp_V = (diffp_V-c)/m;

			if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
			{
				diffp_V = -1 * diffp_V;
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwx[i] = result_iwx[i] - global_reference_x;
			result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);
			
			ret = dm->DrivePin("WDX", 0);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("WDY", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);

			//	//ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	//CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//	CheckError(ret, __LINE__);
			//	//ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//	//CheckError(ret, __LINE__);
			//}

			ret = smu->ReadVoltage("MTX_SMU", diffp_V);
			CheckError(ret, __LINE__);

			diffp_V = (diffp_V-c)/m;

			if ((Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2) && (TPName[i]->Contains("HW0")))
			{
				diffp_V = -1 * diffp_V;
			}

			result_iwy[i] = (diffp_V - diffn_V) / CONST_Rw;
			result_iwy[i] = result_iwy[i] - global_reference_y;
			result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

			tf_SetResult(TPName[i], result_iwx[i] + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i + 10], result_iwy[i] + GetOffset(TPDispName[i+10]));
		}

		/////////////////////////////////
		// X
		/////////////////////////////////

		double slope_iwx = 0;
		double offset_iwx = 0;
		array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

		tf_SetResult(TPName[6], slope_iwx + GetOffset(TPDispName[6]));
		tf_SetResult(TPName[7], offset_iwx + GetOffset(TPDispName[7]));

		int smallest_delta_index_iwx = 0;
		double smallest_delta_iwx = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 1, smallest_delta_iwx); //type = 1 (decending)

		tf_SetResult(TPName[8], smallest_delta_index_iwx + (int)GetOffset(TPDispName[8]));
		tf_SetResult(TPName[9], smallest_delta_iwx / slope_iwx + GetOffset(TPDispName[9]));
		
		/////////////////////////////////
		// Y
		/////////////////////////////////

		double slope_iwy = 0;
		double offset_iwy = 0;
		array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

		_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

		tf_SetResult(TPName[16], slope_iwy + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], offset_iwy + GetOffset(TPDispName[17]));

		int smallest_delta_index_iwy = 0;
		double smallest_delta_iwy = 0;

		if (TIDispName->Contains("p"))
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 0, smallest_delta_iwy); //type = 0 (ascending)
		else //"n"
			smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

		tf_SetResult(TPName[18], smallest_delta_index_iwy + (int)GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], smallest_delta_iwy / slope_iwy + GetOffset(TPDispName[19]));		

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
	
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ro(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		array<double> ^ result_iwx		= gcnew array<double>(step);
		array<double> ^ result_Viw_open = gcnew array<double>(step);

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_Viw_open[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
		}

		//ret = dm->DrivePin("HW_FETS", 0);
		//CheckError(ret, __LINE__);

		int idx = (int)(tf_TestItemCondition_Cast("Barrier_Index_Start"));
		ret = Probe_Card_FET_Control(idx, 0, 0, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			double diffp_V = 0;
			double diffn_V = 0;

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_Viw_open[i] = (diffp_V - diffn_V);
		}

		array<double> ^ result_Rout = gcnew array<double>(step);
		array<double> ^ result_I1k  = gcnew array<double>(step);
		double Rt = 50;
		double I3 = result_iwx[1]; //use I3 value for WZ1 (50 Ohm)
		double Is = I3 / (1 - (CONST_Rw/(CONST_Rw+Rt))); 

		for (int i=0; i<step; i++)
		{
			result_I1k[i] = result_Viw_open[i] / (CONST_Rw + 1000);
			result_Rout[i] = result_Viw_open[i] / (Is - result_I1k[i]);

			tf_SetResult(TPName[i], result_Rout[i] + GetOffset(TPDispName[i]));
		}

		/////////////////////////////////
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//ret = dm->DrivePin("HW_FETS", 1);
		//CheckError(ret, __LINE__);

		idx = (int)(tf_TestItemCondition_Cast("Barrier_Index_End"));
		ret = Probe_Card_FET_Control(idx, 1, 0, 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_osd_spd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveVoltage(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent(Test_Pin, result[i]);
				CheckError(ret, __LINE__);
			}

			result[i] = Math::Abs(result[i]);

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}

		/////////////////////////////////

		double slope = 0;
		double offset = 0;
		array<int> ^ x = gcnew array<int> {0,1,2,3,4,8,15};

		_util->line_fit(x, result, step, slope, offset);

		int smallest_delta_index_x = 0;
		double smallest_delta_x = 0;

		smallest_delta_index_x = _util->monotonicity(result, step, 1, smallest_delta_x); //type = 1 (decending)

		tf_SetResult(TPName[7], smallest_delta_index_x + (int)GetOffset(TPDispName[7]));
		tf_SetResult(TPName[8], smallest_delta_x / slope + GetOffset(TPDispName[8]));

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_unsel(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int hd					= (int)(tf_TestItemCondition_Cast("hd"));

		int Measure_Mode		= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double RWOpen			= CONST_Rw + CONST_Rwo;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//ret = dm->DrivePin("HW_FETS", 0);
		//CheckError(ret, __LINE__);
		//ret = dm->DrivePin("FHCR_FETS", 1);
		//CheckError(ret, __LINE__);

		int idx = (int)(tf_TestItemCondition_Cast("Barrier_Index_Start"));
		ret = Probe_Card_FET_Control(idx, 0, 1, 0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->StartsWith("WHST"))
			{
				//ret = dm->DrivePin("HW_FETS", 1);
				//CheckError(ret, __LINE__);

				idx = (int)(tf_TPCondition_Cast(TPName[i], "Barrier_Index"));
				ret = Probe_Card_FET_Control(idx, 1, 1, 0);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			ret = DriveDMPin(TPDispName[i]);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			double diffp_V = 0;
			double diffn_V = 0;

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			#ifdef USE_GNDS
			double volt = 0;
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
			ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
			CheckError(ret, __LINE__);
			diffp_V = diffp_V - volt;
			diffn_V = diffn_V - volt;
			#endif

			if (tf_TPCondition_exist(TPName[i], "Measure_Mode") == true)
			{
				Measure_Mode = (int)(tf_TPCondition_Cast(TPName[i], "Measure_Mode"));

				if (Measure_Mode == AM_CONST_MEASURECURRENT || Measure_Mode == DM_CONST_MEASURECURRENT)
				{
					//iw_unsel
					//iw_rd_unsel
					//iw_off
					//who_i

					result[i] = (diffp_V - diffn_V) / RWOpen;
				}
				else
				{
					//wxv_unsel
					//wyv_unsel
					//wxv_rd_unsel
					//wxv_rd_unsel
					//who_v

					result[i] = diffp_V;
				}
			}

			if (i == 7) //who_i
			{
				_glob->global_who_i[hd] = result[i];
			}

			if (i == 8) //who_v
			{
				_glob->global_who_v[hd] = result[i];
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[total_tp-1]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//ret = dm->DrivePin("HW_FETS", 1);
		//CheckError(ret, __LINE__);
		//ret = dm->DrivePin("FHCR_FETS", 0);
		//CheckError(ret, __LINE__);
		
		idx = (int)(tf_TestItemCondition_Cast("Barrier_Index_End"));
		ret = Probe_Card_FET_Control(idx, 1, 0, 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_iw_unsel2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int hd					= (int)(tf_TestItemCondition_Cast("hd"));

		int Measure_Mode		= 0;

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double RWOpen			= CONST_Rw + CONST_Rwo;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = DriveMuxIO(TPDispName[0], 1); //MUX to DiffAmp
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//ret = dm->DrivePin("HW_FETS", 0);
		//CheckError(ret, __LINE__);
		//ret = dm->DrivePin("FHCR_FETS", 1);
		//CheckError(ret, __LINE__);

		int idx = (int)(tf_TestItemCondition_Cast("Barrier_Index_Start"));
		ret = Probe_Card_FET_Control(idx, 0, 1, 0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, true, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		// Configure PN
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->StartsWith("WHST"))
			{
				//ret = dm->DrivePin("HW_FETS", 1);
				//CheckError(ret, __LINE__);

				idx = (int)(tf_TPCondition_Cast(TPName[i], "Barrier_Index"));
				ret = Probe_Card_FET_Control(idx, 1, 1, 0);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			ret = DriveDMPin(TPDispName[i]);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			double diffp_V = 0;
			double diffn_V = 0;
			double diffpn_V = 0;

			//query for DiffAmp gain
			double m = 3;
			double c = 0;
			if (Test_Pin_PN == "GRP1_DIFF_SENSE")
			{
				m = _glob->DA_GainError[0];
				c = _glob->DA_OffsetError[0];
			}
			else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
			{
				m = _glob->DA_GainError[1];
				c = _glob->DA_OffsetError[1];
			}

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				/*ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);*/
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				/*ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);*/
			}

			#ifdef USE_GNDS
			double volt = 0;
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
			ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
			CheckError(ret, __LINE__);
			diffp_V = diffp_V - volt;
			//diffn_V = diffn_V - volt;
			#endif

			if (tf_TPCondition_exist(TPName[i], "Measure_Mode") == true)
			{
				Measure_Mode = (int)(tf_TPCondition_Cast(TPName[i], "Measure_Mode"));

				if (Measure_Mode == AM_CONST_MEASURECURRENT || Measure_Mode == DM_CONST_MEASURECURRENT)
				{
					//iw_unsel
					//iw_rd_unsel
					//iw_off
					//who_i

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);

					ret = DriveMuxIO(TPDispName[0], 1);//MUX to DiffAmp
					CheckError(ret, __LINE__);

					if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
						CheckError(ret, __LINE__);
					}

					diffpn_V = (diffpn_V-c)/m;
					result[i] = (diffpn_V) / RWOpen;

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);

					ret = DriveMuxIO(TPDispName[0], 0);//MUX back to SE
					CheckError(ret, __LINE__);
				}
				else
				{
					//wxv_unsel
					//wyv_unsel
					//wxv_rd_unsel
					//wxv_rd_unsel
					//who_v

					result[i] = diffp_V;
				}
			}

			if (i == 7) //who_i
			{
				_glob->global_who_i[hd] = result[i];
			}

			if (i == 8) //who_v
			{
				_glob->global_who_v[hd] = result[i];
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[total_tp-1]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//ret = dm->DrivePin("HW_FETS", 1);
		//CheckError(ret, __LINE__);
		//ret = dm->DrivePin("FHCR_FETS", 0);
		//CheckError(ret, __LINE__);
		
		idx = (int)(tf_TestItemCondition_Cast("Barrier_Index_End"));
		ret = Probe_Card_FET_Control(idx, 1, 0, 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_heater_sup(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int Range				= (int)(tf_TestItemCondition_Cast("Range"));
		int DAC					= (int)(tf_TestItemCondition_Cast("DAC"));

		int Drive_RWN			= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		tf_SetResult(TPName[0], Range + (int)GetOffset(TPDispName[0]));
		tf_SetResult(TPName[1], DAC + (int)GetOffset(TPDispName[1]));

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=2; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
			{
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Drive_RWN") == true)
			{
				Drive_RWN = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWN"));

				ret = dm->DrivePin("RWN", Drive_RWN);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(Measure_Delay_s);
			
			if (TPName[i]->Contains("Dev"))
			{
				double min = 0;
				double max = 0;

				int start = 0;
				int stop = 0;

				if (TPName[i]->Contains("Rd"))
				{
					start = 2;
					stop = 5;
				}
				else //Wt
				{
					start = 7;
					stop = 10;
				}

				for(int k=start; k<=stop; k++) // start from the 4th until 7th parameter only
				{
					if(k == start)
					{
						min = max = result[k]; 
					}
					else
					{
						if(result[k] > max)
							max = result[k];

						if(result[k] < min)
							min = result[k];
					}		
				}

				result[i] = max - min;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				double volt = 0;

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin, volt);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double val = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
				volt = volt - val;
				#endif
				
				result[i] = (volt * volt) / CONST_RhNom;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_heater_rng(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1  = String::Empty;

		int Drive_RWN			= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
	
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Drive_RWN") == true)
			{
				Drive_RWN = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWN"));

				ret = dm->DrivePin("RWN", Drive_RWN);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
			{
				Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
						
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File_1);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File_1);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(Measure_Delay_s);
			
			{
				double volt = 0;

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin, volt);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double val = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
				volt = volt - val;
				#endif
				
				result[i] = (volt * volt) / CONST_RhNom;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_heater_hds(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		double val = 0;
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(On_Delay_s);
			
			{
				double volt = 0;

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin, volt);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double val = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
				volt = volt - val;
				#endif
				
				result[i] = (volt * volt) / CONST_RhNom;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

				_glob->Global_Result[Global_Result_Index] = result[i];
			}
		}

		/////////////////////////////////
		//Find valid pht steps
		/////////////////////////////////
		array<double> ^ pht_steps= gcnew array<double>{0,1,2,4,8,16,32,64,96,127,128,160,192,224,255};
		int valid_step_size	= 15; //initially set as similar to step size
		int first, last	= 0;
		double max			= Drive_Vcc_V - 0.7; //follow catalyst
		double pht, vht		= 0;

		for(int k=0; k<step; k++)
		{
			if(pht_steps[k] >= 64)	
			{
				first = k;
				break;	
			}
		}
		
		for(int k=first; k<step; k++)
		{
			pht = 4e-3 + (0.708e-3 * pht_steps[k]);
			vht = sqrt(pht * CONST_RhNom);
			last = k;
			if(vht>max)
				break;	
			
		}	

		valid_step_size = last - first + 1;

		/////////////////////////////////
		//Processing delta
		/////////////////////////////////
		double delta		= 0;
		int K_min, K_max	= -1;
		double delta_min	= 1000;
		double delta_max	= -1000;
		
		for(int k=first; k<step; k++)//process only within the valid pht steps
		{
			if((pht_steps[k] - pht_steps[k-1]) == 1)
			{
				delta = result[k] - result[k-1];

				if(k == first)
				{
					K_min = K_max = k;
					delta_min = delta_max = delta;
				}

				else //ascending 
				{
					if(delta < delta_min)
					{
						K_min = k;
						delta_min = delta;
					}
					if(delta > delta_max)
					{
						K_max = k;
						delta_max = delta;
					}
				}
			}
		}

		/////////////////////////////////
		//Processing slope & offset - pht_steps VS phs
		/////////////////////////////////
		double slope = 0;
		double offset = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=first; k<step; k++)
		{
			sum_x	+= pht_steps[k];
			sum_y	+= result[k];
			mult_xy += pht_steps[k] * result[k];
			exp_x	+= pht_steps[k] * pht_steps[k];
		}

		slope = ((valid_step_size*mult_xy) - (sum_x*sum_y)) / ((valid_step_size*exp_x) - (sum_x*sum_x));
		offset = (sum_y/valid_step_size) - (slope*(sum_x/valid_step_size));

		/////////////////////////////////
		//Extra processing
		/////////////////////////////////
		double slope_b	= 0;
		double dnl_min	= 0;
		double dnl_max	= 0;

		slope_b = ((slope - 0.708e-3) / 0.708e-3) * 100; //follow Catalyst's formula and show in percentage
		dnl_min = (delta_min - slope) / slope;
		dnl_max = (delta_max - slope) / slope;

		tf_SetResult(TPName[15], slope + GetOffset(TPDispName[15]));
		tf_SetResult(TPName[16], offset + GetOffset(TPDispName[16]));
		tf_SetResult(TPName[17], slope_b + GetOffset(TPDispName[17]));
		tf_SetResult(TPName[18], pht_steps[K_min] + GetOffset(TPDispName[18]));
		tf_SetResult(TPName[19], dnl_min + GetOffset(TPDispName[19]));
		tf_SetResult(TPName[20], pht_steps[K_max] + GetOffset(TPDispName[20]));
		tf_SetResult(TPName[21], dnl_max + GetOffset(TPDispName[21]));

		/////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_ht_w_max(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= String::Empty;
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("FHCW_FETS", 0);
		CheckError(ret, __LINE__);
		ret = dm->DrivePin("FHCR_FETS", 0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//ret = DriveDMPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;
			
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
			{
				Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				// Check whether resource is SMU or DM
				try
				{
					ret = smu->QueryModuleType(Test_Pin, moduleType);
					CheckError(ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType = DM_CONST_MODULE_TYPE;
				}

				if (Debug_Enable == true)
				{
					sb->AppendLine("QueryModuleType returns " + ret.ToString());
					sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
				}

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(ret, __LINE__);
					//ret = dm->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
					//CheckError(ret, __LINE__);
					//ret = dm->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
					//CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Test_Pin);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
					CheckError(ret, __LINE__);
				}
				else //smu
				{
					//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
					//CheckError(ret, __LINE__);
					ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Test_Pin, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Test_Pin, false, false);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
					CheckError(ret, __LINE__);
				}
			}
						
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			ret = DriveMuxIO(TPDispName[i]);
			CheckError(ret, __LINE__);
			ret = DriveDMPin(TPDispName[i]);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			{
				double volt = 0;

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin, volt);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				if (Test != TEST_IF4600_PKG)
				{
					double val = 0;
					ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
					CheckError(ret, __LINE__);
					volt = volt - val;
				}
				#endif
				
				result[i] = volt / CONST_RhAlt;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_heater_slew(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int Global_Result_Index	= 0;
		double PHi = 0;
		double PLo = 0;
		double Vdiff = 0;
		double P90 = 0;
		double P10 = 0;

		int tmu_start_range = 0;
		int tmu_stop_range = 0;
		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		double tm_heater_fast_slew_factor = 0;

		if (calfactor->ContainsKey("TM_HEATER_FAST_SLEW"))
			tm_heater_fast_slew_factor = calfactor["TM_HEATER_FAST_SLEW"][testSite];

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//When CBIT is turned on, TMU is connected. From previous TMU tests (DGF/DGT), 50-ohm range is selected, so DM measurement will be incorrect. Reset TMU range here first.
		ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_2_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(ret, __LINE__);
		ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_2_1MOHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			if (TPName[i]->StartsWith("SRHV"))
			{
				if (TPName[i]->Contains("Vlo"))
				{
					ret = dm->DrivePin("RWN", 1);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = dm->DrivePin("RWN", 0);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(On_Delay_s);

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result[i]);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin, result[i]);
					CheckError(ret, __LINE__);
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
					_glob->Global_Result[Global_Result_Index] = result[i];
				}

				if (TPName[i]->Contains("Vlo"))
				{
					PLo = result[i];
				}
				else //Vhi
				{
					PHi = result[i];
				}
			}
			else
			{
				ret = dm->DrivePin("RWN", 1); //Lo
				CheckError(ret, __LINE__);

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->DPINOff(Test_Pin);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->OffSmuPin(Test_Pin);
					CheckError(ret, __LINE__);
				}

				Vdiff = PHi - PLo;
				P90 = PHi - 0.1*Vdiff; 
				P10 = PLo + 0.1*Vdiff;

				if(P90>5)
				{
					P90 = 5;
				}
				if(P10<0)
				{
					P10 = 0;
				}

				if (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_DUT)
				{
					//For TMU range2 
					tmu_start_threshold = 0.396 * P10 + 0.030;
					tmu_stop_threshold = 0.396 * P90 + 0.030;

					tmu_start_threshold = 58.255 * tmu_start_threshold + (-14.817);
					tmu_stop_threshold = 61.255 * tmu_stop_threshold + (-14.817);
					
					tmu_start_hysteresis = 38 * 0.01; //max for 5V is 20mV
					tmu_stop_hysteresis = 38 * 0.01;

					tmu_start_range = TM_CONST_RANGE_2_1MOHM;
					tmu_stop_range = TM_CONST_RANGE_2_1MOHM;
				}
				else
				{
					tmu_start_threshold = P10;
					tmu_stop_threshold = P90;
					tmu_start_hysteresis = 0.02;
					tmu_stop_hysteresis = 0.02;

					tmu_start_range = TM_CONST_RANGE_0_50OHM;
					tmu_stop_range = TM_CONST_RANGE_0_50OHM;
				}

				tmu_timeout = 10e-3;

				number_of_samples = 1;

				sampled_result = gcnew array<double>(number_of_samples);

				int retest_count = 0;

RETEST:

				ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_start_range, tmu_start_threshold, tmu_start_hysteresis, 0);
				if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
				{
					for (int z=0; z<total_tp; z++)
					{	
						result[i] = 999;
					}
					ret = 0;
					goto TEST_END;
				}

				CheckError(ret, __LINE__);

				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_stop_range, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
				{
					for (int z=0; z<total_tp; z++)
					{	
						result[i] = 999;
					}
					ret = 0;
					goto TEST_END;
				}

				CheckError(ret, __LINE__);
				//_util->Wait_Sec(On_Delay_s);

				ret = dm->DrivePin("RWN", 1); //Lo
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);

				ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
	
				ret = dm->DrivePin("RWN", 0); //Hi
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);

				ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

				if (ret)
				{
					result[i] = 999;
					ret = 0;
				}
				else
				{
					//result[i] = Vdiff / (sampled_result[0] * 1e6); //V/us
					result[i] = (P90-P10) / (sampled_result[0] * 1e6); //V/us
				}

				if (TPName[i]->Contains("K3"))
				{
					result[i] = result[i] + tm_heater_fast_slew_factor;
				}

				double max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
				double min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));

				if ((result[i] < min_limit) || (result[i] > max_limit))
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						retest_count++;
						goto RETEST;
					}
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
					_glob->Global_Result[Global_Result_Index] = result[i];
				}
			}
		}

		/////////////////////////////////

TEST_END:

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_heater_blank_power(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//heater_slew must run prior to blanking tests to get PHi, PLo and PSlew

		//TMU START: RWN
		//TMU STOP: HEATER
		
		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int PLo_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PLo_Global_Result_Index"));
		int PHi_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PHi_Global_Result_Index"));
		int PSlew_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PSlew_Global_Result_Index"));

		int step = (int)(tf_TestItemCondition_Cast("step"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double PHi = _glob->Global_Result[PHi_Global_Result_Index];
		double PLo = _glob->Global_Result[PLo_Global_Result_Index];
		double PSlew = _glob->Global_Result[PSlew_Global_Result_Index];
		double Vdiff = PHi - PLo;
		double P90 = 0;
		double P10 = 0;

		int tmu_start_range = 0;
		int tmu_stop_range = 0;
		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		double tm_heater_dig_delay_factor = 0;

		if (calfactor->ContainsKey("TM_HEATER_DIG_DELAY"))
			tm_heater_dig_delay_factor = calfactor["TM_HEATER_DIG_DELAY"][testSite];

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}
			
			if (TPName[i]->StartsWith("t_htr"))
			{
				ret = dm->DrivePin("RWN", 1); //Lo
				CheckError(ret, __LINE__);

				Vdiff = PHi - PLo;
				P90 = 2.5 * 0.9; //RWN
				P10 = PLo + 0.1*Vdiff; //Heater

				if(P90>5)
				{
					P90 = 5;
				}
				if(P10<0)
				{
					P10 = 0;
				}

				if (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_DUT)
				{
					tmu_start_threshold = P90; //50-ohm termination

					tmu_stop_threshold = 0.396 * P10 + 0.030;
					tmu_stop_threshold = 61.255 * tmu_stop_threshold + (-14.817);

					tmu_start_hysteresis = 0.02;//0.2;
					//tmu_stop_hysteresis = 0.02;//0.2;

					tmu_stop_hysteresis = 38 * 0.01;

					tmu_start_range = TM_CONST_RANGE_1_1MOHM;
					tmu_stop_range = TM_CONST_RANGE_2_1MOHM;
				}
				else
				{
					tmu_start_threshold = P90;
					tmu_stop_threshold = P10;
					tmu_start_hysteresis = 0.02;
					tmu_stop_hysteresis = 0.02;

					tmu_start_range = TM_CONST_RANGE_1_1MOHM;
					tmu_stop_range = TM_CONST_RANGE_0_50OHM;
				}

				tmu_timeout = 10e-3;

				number_of_samples = 1;

				sampled_result = gcnew array<double>(number_of_samples);

				int retest_count = 0;

RETEST:

				ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, tmu_start_range, tmu_start_threshold, tmu_start_hysteresis, 0);
				if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
				{
					for (int z=0; z<total_tp; z++)
					{	
						result[i] = 999;
					}
					ret = 0;
					goto TEST_END;
				}

				CheckError(ret, __LINE__);
				ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_stop_range, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
				{
					for (int z=0; z<total_tp; z++)
					{	
						result[i] = 999;
					}
					ret = 0;
					goto TEST_END;
				}

				CheckError(ret, __LINE__);
				//_util->Wait_Sec(On_Delay_s);

				ret = dm->DrivePin("RWN", 1); //Lo
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);

				ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
	
				ret = dm->DrivePin("RWN", 0); //Hi
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);

				ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

				if (ret)
				{
					result[i] = 999;
					ret = 0;
				}
				else
				{
					if (PSlew != 0)
					{
						result[i] = sampled_result[0] - 0.75e-6 - ((P10 - PLo) / (PSlew * 1e6));
						//0.75u is voltage and power in HBT shift factor

						result[i] = result[i] + tm_heater_dig_delay_factor;
					}
					else
					{
						result[i] = 999;
						ret = 0;
					}
				}

				double max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
				double min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));

				if ((result[i] < min_limit) || (result[i] > max_limit))
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						retest_count++;
						goto RETEST;
					}
				}

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				double mono_meas = 0; 
				int smallest_delta_index = 0;
				smallest_delta_index = _util->monotonicity(result, step, 0, mono_meas);

				tf_SetResult(TPName[i], smallest_delta_index + (int)GetOffset(TPDispName[i]));
			}
		}

		/////////////////////////////////
TEST_END:
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_heater_blank_head(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//heater_slew must run prior to blanking tests to get PHi, PLo and PSlew

		//TMU START: SPE
		//TMU STOP: HEATER HEAD
		
		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		int PLo_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PLo_Global_Result_Index"));
		int PHi_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PHi_Global_Result_Index"));
		int PSlew_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PSlew_Global_Result_Index"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double PHi = _glob->Global_Result[PHi_Global_Result_Index];
		double PLo = _glob->Global_Result[PLo_Global_Result_Index];
		double PSlew = _glob->Global_Result[PSlew_Global_Result_Index];
		double Vdiff = PHi - PLo;
		double P90 = 0;
		double P10 = 0;

		int tmu_start_range = 0;
		int tmu_stop_range = 0;
		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		double tm_heater_dig_delay_factor = 0;

		if (calfactor->ContainsKey("TM_HEATER_DIG_DELAY"))
			tm_heater_dig_delay_factor = calfactor["TM_HEATER_DIG_DELAY"][testSite];

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Use vector method 

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			ret = dm->DrivePin("RWN", 0); //Lo
			CheckError(ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

			Vdiff = PHi - PLo;
			P90 = 2.5 * 0.9; //SPE
			P10 = PLo + 0.1*Vdiff; //Heater

			if(P90>5)
			{
				P90 = 5;
			}
			if(P10<0)
			{
				P10 = 0;
			}

			if (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_DUT)
			{
				tmu_start_threshold = P90; 

				tmu_stop_threshold = 0.396 * P90 + 0.030;
				tmu_stop_threshold = 58.255 * tmu_stop_threshold + (-14.817);

				tmu_start_hysteresis = 0.02;

				tmu_stop_hysteresis = 38 * 0.01;

				tmu_start_range = TM_CONST_RANGE_1_1MOHM;
				tmu_stop_range = TM_CONST_RANGE_2_1MOHM;
			}
			else
			{
				tmu_start_threshold = P90; 
				tmu_stop_threshold = P10;
				tmu_start_hysteresis = 0.02;
				tmu_stop_hysteresis = 0.02;

				tmu_start_range = TM_CONST_RANGE_1_1MOHM;
				tmu_stop_range = TM_CONST_RANGE_1_1MOHM;
			}

			tmu_timeout = 10e-3;

			number_of_samples = 1;

			sampled_result = gcnew array<double>(number_of_samples);

			int retest_count = 0;

RETEST:

			ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, tmu_start_range, tmu_start_threshold, tmu_start_hysteresis, 0);
			if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
			{
				for (int z=0; z<total_tp; z++)
				{	
					result[i] = 999;
				}
				ret = 0;
				goto TEST_END;
			}

			CheckError(ret, __LINE__);
			ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_stop_range, tmu_stop_threshold, tmu_stop_hysteresis, 0);
			if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
			{
				for (int z=0; z<total_tp; z++)
				{	
					result[i] = 999;
				}
				ret = 0;
				goto TEST_END;
			}
			CheckError(ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);

			ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

			if (ret)
			{
				result[0] = 999;
				ret = 0;
			}
			else
			{
				result[i] = sampled_result[0];

				result[i] = result[i] + tm_heater_dig_delay_factor;
			}

			double max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
			double min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));

			if ((result[i] < min_limit) || (result[i] > max_limit))
			{
				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto RETEST;
				}
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}

		/////////////////////////////////
TEST_END:

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_wr_timing(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing = 0;

		if (calfactor->ContainsKey("SYNC_RWN_DELAY"))
			sync_rwn_timing = calfactor["SYNC_RWN_DELAY"][testSite];

		int sync_rwn_timing_index = (int)(sync_rwn_timing / 1e-9); //digitizer sampling interval is 1ns

		String ^ Vector_File	= String::Empty;
		String ^ Vector_File_1  = String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_timing_at_dut->Add(TIDispName, vout_pp);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting up digitizer, ACM and DM"

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//AWG setting
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ChannelWaveShape("ACM_CH", ACM_CONST_SINE); //sine
		CheckError(ret, __LINE__);
		ret = acm->ChannelFrequency("ACM_CH", Fswg);
		CheckError(ret, __LINE__);
		ret = acm->ChannelPhase("ACM_CH", 0);
		CheckError(ret, __LINE__);
		ret = acm->ChannelOffset("ACM_CH", 0);
		CheckError(ret, __LINE__);
		ret = acm->ChannelAmplitude("ACM_CH", 0);
		CheckError(ret, __LINE__);
		ret = acm->ModulationAmplitudeConfig("ACM_CH", 1, Vswg_timing_calibrated[TIDispName]/2);
		CheckError(ret, __LINE__);
		ret = acm->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
		CheckError(ret, __LINE__);

		array<double> ^ waveAmplitude = gcnew array<double>(100);
		for (int i = 0; i < 100; i++) waveAmplitude[i] = (int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform

		ret = acm->AWGWaveformFlush("ACM");
		CheckError(ret, __LINE__);
		ret = acm->AWGWaveformLoad("ACM_CH", 0, waveAmplitude->Length, 0, waveAmplitude); //The waveform is transfered to the onboard RAM. Waveform number is 0
		CheckError(ret, __LINE__);
		ret = acm->AWGQueueWaveform("ACM_CH", 0, ACM_CONST_EXTTRIG, 0, 2, 0); //Waveform is queued. AWG 0, Waveform 0, 1 cycle, and external trigger=2; auto-trigger=0
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);
		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
		}
		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);


		#pragma endregion "Setting up digitizer, ACM and DM"

		#pragma region "Looking for SigGen trigger delay"

		int trigger_delay_index = 0;

		if (wr_timing_siggen_del_index->ContainsKey(TIDispName) == false)
		{
			ret = dm->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
			CheckError(ret, __LINE__);

			////AWG setting
			//ret = acm->ResetChannel("ACM_CH");
			//CheckError(ret, __LINE__);
			//ret = acm->ChannelWaveShape("ACM_CH", ACM_CONST_SINE); //sine
			//CheckError(ret, __LINE__);
			//ret = acm->ChannelFrequency("ACM_CH", Fswg);
			//CheckError(ret, __LINE__);
			//ret = acm->ChannelPhase("ACM_CH", 0);
			//CheckError(ret, __LINE__);
			//ret = acm->ChannelOffset("ACM_CH", 0);
			//CheckError(ret, __LINE__);
			//ret = acm->ChannelAmplitude("ACM_CH", 0);
			//CheckError(ret, __LINE__);
			//ret = acm->ModulationAmplitudeConfig("ACM_CH", 1, Vswg_timing_calibrated[TIDispName]/2);
			//CheckError(ret, __LINE__);
			//ret = acm->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
			//CheckError(ret, __LINE__);

			//array<double> ^ waveAmplitude = gcnew array<double>(100);
			//for (int i = 0; i < 100; i++) waveAmplitude[i] = (int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform

			//ret = acm->AWGWaveformFlush("ACM");
			//CheckError(ret, __LINE__);
			//ret = acm->AWGWaveformLoad("ACM_CH", 0, waveAmplitude->Length, 0, waveAmplitude); //The waveform is transfered to the onboard RAM. Waveform number is 0
			//CheckError(ret, __LINE__);
			//ret = acm->AWGQueueWaveform("ACM_CH", 0, ACM_CONST_EXTTRIG, 0, 2, 0); //Waveform is queued. AWG 0, Waveform 0, 1 cycle, and external trigger=2; auto-trigger=0
			//CheckError(ret, __LINE__);

			//Digitizer setting
			//try
			//{
			//	resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			//	Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			//	if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			//	{
			//		sourcePattern = 0x80000000;
			//	}
			//	else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			//	{
			//		sourcePattern = 0x40000000;
			//	}

			//	if (resourceManager)
			//		delete resourceManager;
			//}
			//catch (Exception ^ e)
			//{
			//	throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			//}

			//trigLevel = 300;	//% of FS, or mV if external trigger is used
			//					//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

			//trigSlope = 1; //negative

			//timeOut_ms = 100;

			//ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			//CheckError(ret, __LINE__);
			//ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			//CheckError(ret, __LINE__);
			//ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			//CheckError(ret, __LINE__);
			//ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			//CheckError(ret, __LINE__);
			//if (Test == TEST_IF4600_PKG)
			//{
			//	ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			//	CheckError(ret, __LINE__);
			//}
			//ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			//CheckError(ret, __LINE__);
			//ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			//CheckError(ret, __LINE__);

			ret = acm->ChannelPhase("ACM_CH", 0);
			CheckError(ret, __LINE__);
			ret = acm->StartAWG("ACM_CH");
			CheckError(ret, __LINE__);
			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(0.5e-3);
			ret = RunVectorFile("wr_timing_ext_trigger");
			CheckError(ret, __LINE__);
			//ret = dm->RunVector("DM_2", VectorSetNo["wr_timing_ext_trigger"]);
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}
			}
			else
			{
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			for (int i=0; i<dataArrayP->Length; i++)
			{
				if (dataArrayP[i] > 0.01)
				{
					trigger_delay_index = i;
					break;
				}
			}

			wr_timing_siggen_del_index->Add(TIDispName, trigger_delay_index);
		}

		trigger_delay_index = wr_timing_siggen_del_index[TIDispName];

		#pragma endregion "Looking for SigGen trigger delay"

		#pragma region "Setting up WRn vector"

		int vector_set_no = _glob->VectorArrSetNo;

		//if (wr_timing_vset->ContainsKey(TIDispName) == false)
		{
			//Ensure trigger_delay_index is a multiple of 5ns (digitizer sampling rate = 1ns), if not reduce it till it is
			while (trigger_delay_index % 5)
			{
				trigger_delay_index--;
				
				if (trigger_delay_index % 5 == 0)
					break;
			}

			//Check WRN and SYNC pin numbers
			int WRN_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("RWN")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					WRN_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					WRN_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					WRN_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					WRN_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					WRN_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					WRN_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					WRN_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					WRN_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					WRN_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					WRN_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					WRN_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					WRN_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector
			int vector_size = 0;
			int h_size = 0;
			int l_size = 10; //padd 10x "0" each, at beginning and end of vectors
			if (trigger_delay_index > 10) 
			{
				//divide by 5 because trigger_delay_index is per 1ns, but vector_size is per 5ns vector rate
				h_size = (trigger_delay_index - 10) / 5;
			}
			else
			{
				h_size = trigger_delay_index / 5;
			}
			vector_size = (2 * l_size + h_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int WRN = 0;
			if (WRN_Channel > 5)
				WRN = ((WRN_Channel-6) * 3 + 1);
			else
				WRN = WRN_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < l_size)
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
				else if (i >= (h_size + l_size))
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
				else
				{
					if (WRN_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != WRN_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (WRN_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<WRN;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= WRN_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 5e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}

			//wr_timing_vset->Add(TIDispName, vector_set_no);
		}
		
		#pragma endregion "Setting up WRn vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int retest_count = 0;

DIG_TRG_DEL_RETEST:

		int digitizer_trigger_delay_index = 0;

		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//if (wr_timing_dig_del_index->ContainsKey(TIDispName) == false)
		{
			double vThreshold = 0.1;

			//CBIT13 (Connect SWG to DM_TO_ACM)
			ret = DriveCBit(TPDispName[0], 3);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}

			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				//CheckError(ret, __LINE__);

				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] < vThreshold)
					{
						digitizer_trigger_delay_index = k;

						if (digitizer_trigger_delay_index > 40)
						{
							retest_count++;

							if (retest_count < TIMING_RESET_COUNT)
							{
								goto DIG_TRG_DEL_RETEST;
							}
						}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			//wr_timing_dig_del_index->Add(TIDispName, digitizer_trigger_delay_index);
		}

		//digitizer_trigger_delay_index = wr_timing_dig_del_index[TIDispName];

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		//Trigger:
		//	Digitizer - Falling edge
		//	AWG - Rising edge

		ret = acm->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_RISE);
		CheckError(ret, __LINE__);

		double vpp = 0;
		double ac_timing = 0;
		double dc_timing = 0;

		array<double> ^ dataArray_0deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_90deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_180deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_270deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_dc = gcnew array<double>(nbrSamples);
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArray_0deg[i] = 0;
			dataArray_90deg[i] = 0;
			dataArray_180deg[i] = 0;
			dataArray_270deg[i] = 0;
			dataArray_dc[i] = 0;
		}

		double vThres = 0.5/2;
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			if ((TPName[i]->Contains("DC") == true)) //start test here
			{
				//////////////////////////////////
				//DC (no waveform)
				//////////////////////////////////

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_dc[j] = dataArrayP[k];
						j++;
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArray_dc[k]) > vThres)
					{
						index = k;
						break;
					}
				}

				if (index != -1)
				{
					dc_timing = index * sampInterval;
				}
				else
				{
					dc_timing = 0;
				}

				result[i] = dc_timing;

				//////////////////////////////////
				//AC
				//////////////////////////////////

				//0 deg
				ret = acm->ChannelPhase("ACM_CH", 0);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_0deg[j] = dataArrayP[k];
						j++;
					}
				}

				//90 deg
				ret = acm->ChannelPhase("ACM_CH", 90);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata2.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_90deg[j] = dataArrayP[k];
						j++;
					}
				}

				//180 deg
				ret = acm->ChannelPhase("ACM_CH", 180);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata3.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_180deg[j] = dataArrayP[k];
						j++;
					}
				}

				//270deg
				ret = acm->ChannelPhase("ACM_CH", 270);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata4.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_270deg[j] = dataArrayP[k];
						j++;
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArray_0deg[k] * diff2se_digitizer_factor) > vThres ||
						Math::Abs(dataArray_90deg[k] * diff2se_digitizer_factor) > vThres ||
						Math::Abs(dataArray_180deg[k] * diff2se_digitizer_factor) > vThres ||
						Math::Abs(dataArray_270deg[k] * diff2se_digitizer_factor) > vThres)
					{
						index = k;

						if (index > 50)
						{
 							int here = 0;
						}

						break;
					}
				}

				if (index != -1)
				{
					ac_timing = index * sampInterval;
				}
				else
				{
					ac_timing = 999;
				}

				//Calculate vpp

				if (ac_timing != 999)
				{
					array<double> ^ dataArray_vpp = gcnew array<double>(128);
					int j = 0;
					for (int k=200; k<328; k++)
					{
						dataArray_vpp[j] = dataArray_0deg[k];
						j++;
					}

					vpp = _fft->GetVpp(dataArray_vpp, sampInterval, NONE, false);

					vpp = vpp * diff2se_digitizer_factor;
				}
				else
				{
					vpp = 999;
				}
			}

			if (TPName[i]->Contains("AC") == true)
			{
				result[i] = ac_timing;
			}
			
			if (TPName[i]->Contains("hsd_sync") == true)
			{
				result[i] = Math::Abs(sync_rwn_timing);
			}
			
			if (TPName[i]->Contains("vpp") == true)
			{
				result[i] = vpp;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_wr_timing2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;

		if (calfactor->ContainsKey("SYNC_RWN_DELAY"))
			sync_rwn_timing = calfactor["SYNC_RWN_DELAY"][testSite];

		int sync_rwn_timing_index = (int)(sync_rwn_timing / 1e-9); //digitizer sampling interval is 1ns

		String ^ Vector_File	= String::Empty;
		String ^ Vector_File_1  = String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_timing_at_dut->Add(TIDispName, vout_pp);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting up digitizer, ACM and DM"

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//AWG setting
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ChannelWaveShape("ACM_CH", ACM_CONST_SINE); //sine
		CheckError(ret, __LINE__);
		ret = acm->ChannelFrequency("ACM_CH", Fswg);
		CheckError(ret, __LINE__);
		ret = acm->ChannelPhase("ACM_CH", 0);
		CheckError(ret, __LINE__);
		ret = acm->ChannelOffset("ACM_CH", 0);
		CheckError(ret, __LINE__);
		ret = acm->ChannelAmplitude("ACM_CH", 0);
		CheckError(ret, __LINE__);
		ret = acm->ModulationAmplitudeConfig("ACM_CH", 1, Vswg_timing_calibrated[TIDispName]/2);
		CheckError(ret, __LINE__);
		ret = acm->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
		CheckError(ret, __LINE__);

		array<double> ^ waveAmplitude = gcnew array<double>(100);
		for (int i = 0; i < 100; i++) waveAmplitude[i] = (int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform

		ret = acm->AWGWaveformFlush("ACM");
		CheckError(ret, __LINE__);
		ret = acm->AWGWaveformLoad("ACM_CH", 0, waveAmplitude->Length, 0, waveAmplitude); //The waveform is transfered to the onboard RAM. Waveform number is 0
		CheckError(ret, __LINE__);
		ret = acm->AWGQueueWaveform("ACM_CH", 0, ACM_CONST_EXTTRIG, 0, 2, 0); //Waveform is queued. AWG 0, Waveform 0, 1 cycle, and external trigger=2; auto-trigger=0
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);
		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
		}
		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting up digitizer, ACM and DM"

		#pragma region "Looking for SigGen trigger delay"

		int trigger_delay_index = 0;

		if (wr_timing_siggen_del_index->ContainsKey(TIDispName) == false)
		{
			ret = dm->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
			CheckError(ret, __LINE__);

			ret = acm->ChannelPhase("ACM_CH", 0);
			CheckError(ret, __LINE__);
			ret = acm->StartAWG("ACM_CH");
			CheckError(ret, __LINE__);
			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(0.5e-3);
			ret = RunVectorFile("wr_timing_ext_trigger");
			CheckError(ret, __LINE__);
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}
			}
			else
			{
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			for (int i=0; i<dataArrayP->Length; i++)
			{
				if (dataArrayP[i] > 0.01)
				{
					trigger_delay_index = i;
					break;
				}
			}

			wr_timing_siggen_del_index->Add(TIDispName, trigger_delay_index);
		}

		trigger_delay_index = wr_timing_siggen_del_index[TIDispName];

		#pragma endregion "Looking for SigGen trigger delay"

		#pragma region "Setting up WRn vector"

		int vector_set_no = _glob->VectorArrSetNo;

		//if (wr_timing_vset->ContainsKey(TIDispName) == false)
		{
			//Ensure trigger_delay_index is a multiple of 100ns (digitizer sampling rate = 1ns), if not increase it till it is
			while (trigger_delay_index % 100)
			{
				trigger_delay_index++;
				
				if (trigger_delay_index % 100 == 0)
					break;
			}

			//Check WRN and SYNC pin numbers
			int WRN_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("RWN")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					WRN_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					WRN_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					WRN_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					WRN_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					WRN_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					WRN_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					WRN_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					WRN_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					WRN_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					WRN_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					WRN_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					WRN_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector
			int vector_size = 0;
			int h_size = 0;
			int l_size = 10; //padd 10x "0" each, at beginning and end of vectors
			//if (trigger_delay_index > 10) 
			//{
				//divide by 5 because trigger_delay_index is per 1ns, but vector_size is per 5ns vector rate
			//	h_size = (trigger_delay_index - 10) / 5;
			//}
			//else
			{
				h_size = trigger_delay_index / 100;
			}
			vector_size = (2 * l_size + h_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int WRN = 0;
			if (WRN_Channel > 5)
				WRN = ((WRN_Channel-6) * 3 + 1);
			else
				WRN = WRN_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < l_size)
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
				else if (i >= (h_size + l_size))
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
				else
				{
					if (WRN_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != WRN_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (WRN_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<WRN;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= WRN_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 100e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}

			//wr_timing_vset->Add(TIDispName, vector_set_no);
		}
		
		#pragma endregion "Setting up WRn vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int retest_count = 0;

//DIG_TRG_DEL_RETEST:

		int digitizer_trigger_delay_index = 0;

		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//if (wr_timing_dig_del_index->ContainsKey(TIDispName) == false)
		{
			double vThreshold = 0.1;

			//CBIT13 (Connect SWG to DM_TO_ACM)
			ret = DriveCBit(TPDispName[0], 3);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}

			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				//CheckError(ret, __LINE__);

				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] < vThreshold)
					{
						digitizer_trigger_delay_index = k;

						//if (digitizer_trigger_delay_index > 40)
						//{
						//	retest_count++;

						//	if (retest_count < TIMING_RESET_COUNT)
						//	{
						//		goto DIG_TRG_DEL_RETEST;
						//	}
						//}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			//wr_timing_dig_del_index->Add(TIDispName, digitizer_trigger_delay_index);
		}

		//digitizer_trigger_delay_index = wr_timing_dig_del_index[TIDispName];

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		//Trigger:
		//	Digitizer - Falling edge
		//	AWG - Rising edge

		ret = acm->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_RISE);
		CheckError(ret, __LINE__);

		double vpp = 0;
		double ac_timing = 0;
		double dc_timing = 0;

		array<double> ^ dataArray_0deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_90deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_180deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_270deg = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray_dc = gcnew array<double>(nbrSamples);
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArray_0deg[i] = 0;
			dataArray_90deg[i] = 0;
			dataArray_180deg[i] = 0;
			dataArray_270deg[i] = 0;
			dataArray_dc[i] = 0;
		}

		double vThres = 0.5/2;
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			if ((TPName[i]->Contains("DC") == true)) //start test here
			{
				//////////////////////////////////
				//DC (no waveform)
				//////////////////////////////////

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_dc[j] = dataArrayP[k];
						j++;
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArray_dc[k]) > vThres)
					{
						index = k;
						break;
					}
				}

				if (index != -1)
				{
					dc_timing = index * sampInterval;
				}
				else
				{
					dc_timing = 0;
				}

				result[i] = dc_timing;

				//////////////////////////////////
				//AC
				//////////////////////////////////

				//0 deg
				ret = acm->ChannelPhase("ACM_CH", 0);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_0deg[j] = dataArrayP[k];
						j++;
					}
				}

				//90 deg
				ret = acm->ChannelPhase("ACM_CH", 90);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata2.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_90deg[j] = dataArrayP[k];
						j++;
					}
				}

				//180 deg
				ret = acm->ChannelPhase("ACM_CH", 180);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata3.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_180deg[j] = dataArrayP[k];
						j++;
					}
				}

				//270deg
				ret = acm->ChannelPhase("ACM_CH", 270);
				CheckError(ret, __LINE__);
				ret = acm->StartAWG("ACM_CH");
				CheckError(ret, __LINE__);
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata4.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray_270deg[j] = dataArrayP[k];
						j++;
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArray_0deg[k] * diff2se_digitizer_factor) > vThres ||
						Math::Abs(dataArray_90deg[k] * diff2se_digitizer_factor) > vThres ||
						Math::Abs(dataArray_180deg[k] * diff2se_digitizer_factor) > vThres ||
						Math::Abs(dataArray_270deg[k] * diff2se_digitizer_factor) > vThres)
					{
						index = k;

						if (index > 50)
						{
 							int here = 0;
						}

						break;
					}
				}

				if (index != -1)
				{
					ac_timing = index * sampInterval;
				}
				else
				{
					ac_timing = 999;
				}

				//Calculate vpp

				if (ac_timing != 999)
				{
					array<double> ^ dataArray_vpp = gcnew array<double>(128);
					int j = 0;
					for (int k=200; k<328; k++)
					{
						dataArray_vpp[j] = dataArray_0deg[k];
						j++;
					}

					vpp = _fft->GetVpp(dataArray_vpp, sampInterval, NONE, false);

					vpp = vpp * diff2se_digitizer_factor;
				}
				else
				{
					vpp = 999;
				}
			}

			if (TPName[i]->Contains("AC") == true)
			{
				result[i] = ac_timing;
			}
			
			if (TPName[i]->Contains("hsd_sync") == true)
			{
				result[i] = Math::Abs(sync_rwn_timing);
			}
			
			if (TPName[i]->Contains("vpp") == true)
			{
				result[i] = vpp;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	//
	int TestProgram::seq_vfhs_bias_hds(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Pin			= (String ^)(tf_TestItemCondition_Cast("Pin"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		int differential_measure = 0;
		if (Test_Pin_P->Contains("DIFF_SENSE"))
		{
			differential_measure = 1;
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		if (differential_measure == 0)
		{
			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_N);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_N, false, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
		}		

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(Measure_Delay_s);

			if (differential_measure == 1)
			{
				
				//Gnds

				//meas P
				
				//G1-FH = 0
				//G1-SH = 1
				//G1-SL = 2
				//G1-FL = 3
				//G2-FH = 4
				//G2-SH = 5
				//G2-SL = 6
				//G2-FL = 7

				if (testSite == QUADRANTA)
				{
					if (Pin == "TA1")
					{
						// Group1, SH8, to GNDS
						// Group1, SL10, to DUT
						ret = OnMux(GROUP1_SH, SWITCH_S8);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S10);
						CheckError(ret, __LINE__);
					}

					if (Pin == "TA0")
					{
						// Group1, SH6, to DUT
						// Group1, SL7, to GNDS
						ret = OnMux(GROUP1_SH, SWITCH_S6);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S7);
						CheckError(ret, __LINE__);
					}
				}
				else if (testSite == QUADRANTB)
				{
					if (Pin == "TA1")
					{
						// Group1, SH8, to GNDS
						// Group1, SL4, to DUT
						ret = OnMux(GROUP1_SH, SWITCH_S8);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S4);
						CheckError(ret, __LINE__);
					}

					if (Pin == "TA0")
					{
						// Group1, SH14, to DUT
						// Group1, SL7, to GNDS
						ret = OnMux(GROUP1_SH, SWITCH_S14);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S7);
						CheckError(ret, __LINE__);
					}
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				else
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);

				diffp_V = diffp_V / 3; // There is a x3 gain at the SE-to-DIFF converter

				/////////////////////////////////
				//meas N
				
				if (testSite == QUADRANTA)
				{
					if (Pin == "TA1")
					{
						// Group1, SH10, to DUT
						// Group1, SL7, to GNDS
						ret = OnMux(GROUP1_SH, SWITCH_S10);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S7);
						CheckError(ret, __LINE__);
					}

					if (Pin == "TA0")
					{
						// Group1, SH8, to GNDS
						// Group1, SL6, to DUT
						ret = OnMux(GROUP1_SH, SWITCH_S8);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S6);
						CheckError(ret, __LINE__);
					}
				}
				else if (testSite == QUADRANTB)
				{
					if (Pin == "TA1")
					{
						// Group1, SH4, to DUT
						// Group1, SL7, to GNDS
						ret = OnMux(GROUP1_SH, SWITCH_S4);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S7);
						CheckError(ret, __LINE__);
					}

					if (Pin == "TA0")
					{
						// Group1, SH8, to GNDS
						// Group1, SL14, to DUT
						ret = OnMux(GROUP1_SH, SWITCH_S8);
						CheckError(ret, __LINE__);
						ret = OnMux(GROUP1_SL, SWITCH_S14);
						CheckError(ret, __LINE__);
					}
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE)
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffn_V);
				else
					ret = smu->ReadVoltage(Test_Pin_P, diffn_V);
				CheckError(ret, __LINE__);
				
				diffn_V = diffn_V / 3; // There is a x3 gain at the SE-to-DIFF converter

				result[i] = Math::Abs(diffp_V) - Math::Abs(diffn_V);

				resultp[i] = diffp_V;
				resultn[i] = diffn_V;
			}
			else
			{
				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				if (Test != TEST_IF4600_PKG)
				{
					double val = 0;
					ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
					CheckError(ret, __LINE__);
					diffp_V = diffp_V - val;
					diffn_V = diffn_V - val;
				}
				#endif

				result[i] = Math::Abs(diffp_V - diffn_V);

				resultp[i] = diffp_V;
				resultn[i] = diffn_V;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_Vcm") == true)
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));
				_glob->Global_Result[Global_Result_Index_Vcm] = (diffp_V + diffn_V) / 2;
			}
		}

		double slope = 0;
		double offset = 0;
		array<int> ^ x = gcnew array<int> {1,16,31};

		_util->line_fit(x, result, step, slope, offset);

		if (total_tp > step)
		{
			tf_SetResult(TPName[step], slope + GetOffset(TPDispName[step]));
			tf_SetResult(TPName[step+1], offset + GetOffset(TPDispName[step+1]));
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhs_bias_hds2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Pin			= (String ^)(tf_TestItemCondition_Cast("Pin"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}


		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
	
		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(Measure_Delay_s);
		
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			#ifdef USE_GNDS
			if (Test != TEST_IF4600_PKG)
			{
				double val = 0;
				ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - val;
				diffn_V = diffn_V - val;
			}
			#endif

			//differential
			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],1); //MUX to DiffAmp
			CheckError(ret, __LINE__);

			if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				CheckError(ret, __LINE__);
			}

			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],0); //MUX back to SE
			CheckError(ret, __LINE__);

			result[i] = Math::Abs((diffpn_V-c)/m);

			resultp[i] = diffp_V;
			resultn[i] = diffn_V;

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_Vcm") == true)
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));
				_glob->Global_Result[Global_Result_Index_Vcm] = (diffp_V + diffn_V) / 2;
			}
		}

		double slope = 0;
		double offset = 0;
		array<int> ^ x = gcnew array<int> {1,16,31};

		_util->line_fit(x, result, step, slope, offset);

		if (total_tp > step)
		{
			tf_SetResult(TPName[step], slope + GetOffset(TPDispName[step]));
			tf_SetResult(TPName[step+1], offset + GetOffset(TPDispName[step+1]));
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhs_bias_hds3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Pin			= (String ^)(tf_TestItemCondition_Cast("Pin"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
	
		// Configure PN
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			_util->Wait_Sec(Measure_Delay_s);
		
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			#ifdef USE_GNDS
			if (Test != TEST_IF4600_PKG)
			{
				double val = 0;
				ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - val;
				diffn_V = diffn_V - val;
			}
			#endif

			//differential
			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],1); //MUX to DiffAmp
			CheckError(ret, __LINE__);

			//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
			//	CheckError(ret, __LINE__);
			//}

			ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
			CheckError(ret, __LINE__);

			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],0); //MUX back to SE
			CheckError(ret, __LINE__);

			result[i] = Math::Abs((diffpn_V-c)/m);

			resultp[i] = diffp_V;
			resultn[i] = diffn_V;

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_Vcm") == true)
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));
				_glob->Global_Result[Global_Result_Index_Vcm] = (diffp_V + diffn_V) / 2;
			}
		}

		double slope = 0;
		double offset = 0;
		array<int> ^ x = gcnew array<int> {1,16,31};

		_util->line_fit(x, result, step, slope, offset);

		if (total_tp > step)
		{
			tf_SetResult(TPName[step], slope + GetOffset(TPDispName[step]));
			tf_SetResult(TPName[step+1], offset + GetOffset(TPDispName[step+1]));
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhs_bias_hds4(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Pin			= (String ^)(tf_TestItemCondition_Cast("Pin"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		int data = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;

		//// Check whether resource is SMU or DM
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeP = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_PN, moduleTypeP);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypePN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		//}

		//// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
	
		// Configure PN
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 1.99);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<step; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			//_util->Wait_Sec(Measure_Delay_s);
		
			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//	CheckError(ret, __LINE__);
			//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//	CheckError(ret, __LINE__);
			//}

			//#ifdef USE_GNDS
			//if (Test != TEST_IF4600_PKG)
			//{
			//	double val = 0;
			//	ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			//	CheckError(ret, __LINE__);
			//	diffp_V = diffp_V - val;
			//	diffn_V = diffn_V - val;
			//}
			//#endif

			//Measure p-GNDS

			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],2); 
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = smu->ReadVoltage("MTX_SMU", diffp_V);
			CheckError(ret, __LINE__);

			if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS0")))
			{
				diffp_V = -1 * diffp_V;
			}
			else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS1")))
			{
				diffp_V = -1 * diffp_V;
			}

			diffp_V = (diffp_V-c)/m;

			//Measure n-GNDS

			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],3); 
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = smu->ReadVoltage("MTX_SMU", diffn_V);
			CheckError(ret, __LINE__);

			if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS1")))
			{
				diffn_V = -1 * diffn_V;
			}
			else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS0")))
			{
				diffn_V = -1 * diffn_V;
			}

			diffn_V = (diffn_V-c)/m;

			//differential
			ret = ResetMuxIO();
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0],1); //MUX to DiffAmp
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
			CheckError(ret, __LINE__);

			result[i] = Math::Abs((diffpn_V-c)/m);

			resultp[i] = diffp_V;
			resultn[i] = diffn_V;

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				_glob->Global_Result[Global_Result_Index] = result[i];
			}

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_Vcm") == true)
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));
				_glob->Global_Result[Global_Result_Index_Vcm] = (diffp_V + diffn_V) / 2;
			}
		}

		double slope = 0;
		double offset = 0;
		array<int> ^ x = gcnew array<int> {1,16,31};

		_util->line_fit(x, result, step, slope, offset);

		if (total_tp > step)
		{
			tf_SetResult(TPName[step], slope + GetOffset(TPDispName[step]));
			tf_SetResult(TPName[step+1], offset + GetOffset(TPDispName[step+1]));
		}

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhsv(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("sel"))
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));

				result[i] = _glob->Global_Result[Global_Result_Index_Vcm];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
											
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double val = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - val;
				diffn_V = diffn_V - val;
				#endif
				
				result[i] = (diffp_V + diffn_V) / 2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				i++;

				result[i] = diffp_V - diffn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhsv2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;//differential

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure PN (differential)
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;//DiffAmp

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("sel"))
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));

				result[i] = _glob->Global_Result[Global_Result_Index_Vcm];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
											
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);
		
				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double val = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - val;
				diffn_V = diffn_V - val;
				#endif
				
				result[i] = (diffp_V + diffn_V) / 2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				i++;

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0],1);//MUX to DiffAmp
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				CheckError(ret, __LINE__);

				diffpn_V = Math::Abs((diffpn_V-c)/m) ;
				result[i] = diffpn_V;

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0],0);//MUX back to SE
				CheckError(ret, __LINE__);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhsv3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;//differential

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure PN (differential)
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;//DiffAmp

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("sel"))
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));

				result[i] = _glob->Global_Result[Global_Result_Index_Vcm];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
											
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);
		
				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(ret, __LINE__);
					ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(ret, __LINE__);
				}

				#ifdef USE_GNDS
				double val = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
				diffp_V = diffp_V - val;
				diffn_V = diffn_V - val;
				#endif
				
				result[i] = (diffp_V + diffn_V) / 2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				i++;

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0],1);//MUX to DiffAmp
				CheckError(ret, __LINE__);

				//ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				//CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				diffpn_V = Math::Abs((diffpn_V-c)/m) ;
				result[i] = diffpn_V;

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0],0);//MUX back to SE
				CheckError(ret, __LINE__);

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_vfhsv4(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ resultp = gcnew array<double>(total_tp);
		array<double> ^ resultn = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			resultp[i] = 0;
			resultn[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0],0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;
		unsigned int moduleTypePN = 0;//differential

		//// Check whether resource is SMU or DM
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeP = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypePN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		//}

		//// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		// Configure PN (differential)
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;//DiffAmp

		//query for DiffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		//#ifdef USE_GNDS
		//ret = Configure_GNDS_Mux(site, NPLC);
		//CheckError(ret, __LINE__);
		//#endif

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("sel"))
			{
				int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));

				result[i] = _glob->Global_Result[Global_Result_Index_Vcm];

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
			else
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
											
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
				}

				_util->Wait_Sec(Measure_Delay_s);
		
				//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				//{
				//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				//	CheckError(ret, __LINE__);
				//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				//	CheckError(ret, __LINE__);
				//}
				//else
				//{
				//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				//	CheckError(ret, __LINE__);
				//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				//	CheckError(ret, __LINE__);
				//}

				//#ifdef USE_GNDS
				//double val = 0;
				////ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				//ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				//CheckError(ret, __LINE__);
				//diffp_V = diffp_V - val;
				//diffn_V = diffn_V - val;
				//#endif

				//Measure P-GNDS

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0], 2);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(ret, __LINE__);

				if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS0")))
				{
					diffp_V = -1 * diffp_V;
				}
				else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS1")))
				{
					diffp_V = -1 * diffp_V;
				}

				diffp_V = (diffp_V-c)/m;

				//Measure N-GNDS

				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0], 3);
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffn_V);
				CheckError(ret, __LINE__);

				if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS1")))
				{
					diffn_V = -1 * diffn_V;
				}
				else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS0")))
				{
					diffn_V = -1 * diffn_V;
				}

				diffn_V = (diffn_V-c)/m;
				
				result[i] = (diffp_V + diffn_V) / 2;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));

				i++;

				//differential
				ret = ResetMuxIO();
				CheckError(ret, __LINE__);

				ret = DriveMuxIO(TPDispName[0],1);//MUX to DiffAmp
				CheckError(ret, __LINE__);

				ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(ret, __LINE__);

				diffpn_V = Math::Abs((diffpn_V-c)/m) ;
				result[i] = diffpn_V;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_fhsgain_sup(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File_0	= String::Empty;
		String ^ Vector_File_1	= String::Empty;
		String ^ Vector_File_2  = String::Empty;

		Vswg = 0.6 * 1 * CONST_FSAv_div * 1e-3;
		
		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		if(Test != TEST_IF4600_PKG)
		{
			ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			CheckError(ret, __LINE__);
			ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(ret, __LINE__);
			ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 1);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
			CheckError(ret, __LINE__);
		}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;

		//if (Fswg < 10e6)
		//	sampInterval = 20e-9;

		double delayTime = 0.0;
		int nbrSamples = 1024;//8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 100;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;

		int max_loop = 50;

		//Calibration of Vpp
		
		if (Vswg_fhsgain_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);
				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0)
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//off K3, K4
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			Vswg_fhsgain_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_fhsgain_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_fhsgain_calibrated[TIDispName]/2, -1 * Vswg_fhsgain_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}

		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double Gmax = 0;
		double Gmin = 0;
		double vin = Vswg_fhsgain_at_dut[TIDispName];
		double vin_r1 = vin * CONST_Rf;

		int step = 3;
		array<double> ^ res_sum = gcnew array<double>(step);
		for (int i=0; i<step; i++)
			res_sum[i] = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Dev"))
			{
				tf_SetResult(TPName[i], Gmax - Gmin + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Sum"))
			{
				Vector_File_0 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_0"));
				Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
				Vector_File_2 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_2"));

				for (int k=0; k<step; k++)
				{
					Vector_File = "Vector_File_" + k;
					
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = OnOffSPI(1);
					CheckError(ret, __LINE__);
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

					_util->Wait_Sec(Measure_Delay_s);

					ret = digitizer->StartAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ForceTrigger("DIGITIZER");
					if (ret == -1074116410) //ERROR: Instrument already stopped
						ret = 0;
					CheckError(ret, __LINE__);

					ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
					if (ret == -1074116410) //ERROR: Instrument already stopped
						ret = 0;
					CheckError(ret, __LINE__);

					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
					//ret = digitizer->StopAcquire("DIGITIZER");
					//CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata2.txt");
						for (int l = 0; l < nbrSamples; l++) 
						{
							outFile << dataArrayP[l] << "," << dataArrayN[l] << "," << dataArrayP[l]-dataArrayN[l] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int j=0; j<dataArrayP->Length; j++)
						{
							dataArrayP[j] = dataArrayP[j] - dataArrayN[j]; //get the differential values
						}
					}

					vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

					vout_pp = vout_pp * diff2se_digitizer_factor;

					res_sum[k] = vout_pp;
				}	

				result = (res_sum[2] - (res_sum[0] + res_sum[1])) / ((res_sum[0] + res_sum[1])); //(SUM-(FHS+RDR)/(FHS+RDR))

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
			else
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);
				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
				//ret = digitizer->StopAcquire("DIGITIZER");
				//CheckError(ret, __LINE__);

				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata2.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int j=0; j<dataArrayP->Length; j++)
					{
						dataArrayP[j] = dataArrayP[j] - dataArrayN[j]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				result = 20 * Math::Log10(vout_pp / vin_r1);

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (i == 0)
				{
					Gmax = result;
					Gmin = result;
				}
				else
				{
					if (result > Gmax)
						Gmax = result;
		
					if (result < Gmin)
						Gmin = result;
				}
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_fhsgain_sup2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File_0	= String::Empty;
		String ^ Vector_File_1	= String::Empty;
		String ^ Vector_File_2  = String::Empty;

		Vswg = 0.6 * 1 * CONST_FSAv_div * 1e-3;
		
		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]); 
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}
	
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 4096;//1024; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 1.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 100;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;

		int max_loop = 50;

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	
		int Decimation_Factor = 1;

		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		//Calibration of Vpp
		
		if (Vswg_fhsgain_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					ret = DigitizerFFT_Configure(digitizer_setting);
					CheckError(ret, __LINE__);

					do_once = 1;
				}

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0)
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);

						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//off K3, K4
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			Vswg_fhsgain_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_fhsgain_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_fhsgain_calibrated[TIDispName]/2, -1 * Vswg_fhsgain_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = DigitizerFFT_Configure(digitizer_setting);
			CheckError(ret, __LINE__);
		}

		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double Gmax = 0;
		double Gmin = 0;
		double vin = Vswg_fhsgain_at_dut[TIDispName];
		double vin_r1 = vin * CONST_Rf;

		int step = 3;
		array<double> ^ res_sum = gcnew array<double>(step);
		for (int i=0; i<step; i++)
			res_sum[i] = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Dev"))
			{
				//double G_vpv = Math::Pow(10, (Gmax-Gmin)/20);
				double G_vpv = Math::Pow(10, (Gmax)/20) - Math::Pow(10, (Gmin)/20);

				tf_SetResult(TPName[i], G_vpv + GetOffset(TPDispName[i]));
			}
			else if (TPName[i]->Contains("Sum"))
			{
				Vector_File_0 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_0"));
				Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
				Vector_File_2 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_2"));

				for (int k=0; k<step; k++)
				{
					//Vector_File = "Vector_File_" + k;
					if (k==0) 
						Vector_File = "write_p1_reg10_hsel_0";
					else if (k==1)
						Vector_File = "write_fhsgain_sup_rdr";
					else
						Vector_File = "write_reg39_fhsgain_sup";
				
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif
	
					_util->Wait_Sec(Measure_Delay_s);

					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
					ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
					if (ret)
					{
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);

						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					res_sum[k] = vout_pp;
				}	

				result = 100 * (res_sum[2] - (res_sum[0] + res_sum[1])) / ((res_sum[0] + res_sum[1])); //(SUM-(FHS+RDR)/(FHS+RDR))

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
			else
			{
				Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
				Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				result = 20 * Math::Log10(vout_pp / vin_r1);

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));

				if (i == 0)
				{
					Gmax = result;
					Gmin = result;
				}
				else
				{
					if (result > Gmax)
						Gmax = result;
		
					if (result < Gmin)
						Gmin = result;
				}
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_fhsgain_spd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Vswg				= 0;
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		Vswg = 120e-3; //1 * CONST_FSAv_div * 1e-3;  
		
		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_DC"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 4096; //1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 1.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 100;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;

		int max_loop = 50;

		int Decimation_Factor = 1; //1GS/s
		if (Fswg < 10e6)
		{
			Decimation_Factor = 4; //250MS/s
		}

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		#pragma region "Calibration of Vpp"
		
		if (Vswg_fhsgain_spd_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					ret = DigitizerFFT_Configure(digitizer_setting);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
				
				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0)
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//off K3, K4
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			Vswg_fhsgain_spd_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_fhsgain_spd_at_dut->Add(TIDispName, vout_pp);
		}
		#pragma endregion "Calibration of Vpp"
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_fhsgain_spd_calibrated[TIDispName]/2, -1 * Vswg_fhsgain_spd_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = DigitizerFFT_Configure(digitizer_setting);
			CheckError(ret, __LINE__);
		}

		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double Gmax = 0;
		double Gmin = 0;
		double vin = Vswg_fhsgain_spd_at_dut[TIDispName];
		double vin_r1 = vin / CONST_FSAv_div; //vin * CONST_Rf;

		int Global_Result_Index = 0;

		array<double> ^ res_temp = gcnew array<double>(TOTAL_GLOBAL_VARIABLE);

		for (int i=0; i<total_tp; i++)
		{
			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
			ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
			
			if (ret)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			result = 20 * Math::Log10(vout_pp / vin_r1);

			if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
			{
				Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
				res_temp[Global_Result_Index] = result;
				_glob->Global_Result[Global_Result_Index] = Math::Pow(10, result/20);
			}

			if (TPName[i]->Contains("db"))
			{
				result = result - res_temp[Global_Result_Index];

				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
			else
			{
				tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
			}
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	//
	int TestProgram::seq_filter(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= 0;
		double Fswg_Ref			= (double)(tf_TestItemCondition_Cast("Fswg_Ref"));
		double Gain_Ref			= (double)(tf_TestItemCondition_Cast("Gain_Ref")); //3dB
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	//1. Manually connect FLTMUX to DM_1 Ch0 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 ChX via J36.2 (PC3_2A/B)
		//	//3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	//4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	//5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)
		//  6. Manually connect AWG differential signals to J20 and J16
		//  7. Manually connect 2x digitizer channels to J13 and J9
		//	   (For PKG test, we need 2 digitizer channels, but we only need one for WAF as diff-to-se conversion is done on adaptor board

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		
		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		int Decimation_Factor = 1; //1GS/s
		if (Fswg_Ref < 0.5e6)
		{
			Decimation_Factor = 16; //31.25MS/s
			nbrSamples = 4096;
		}

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double vout_pp = 0.0;
		double fftBIN = 0;
		int magn_peak_index = 0;

		int max_loop = 50;

		double Vswg_cal = 0;
		int loop_count = 0;
		int do_once = 0;

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		/////////////////////////////////////////////
		//Calibration of Vpp for Fswg_Ref
		/////////////////////////////////////////////
		Fswg = Fswg_Ref;

		if (Vswg_filter_calibrated->ContainsKey(Fswg) == false)
		{
			Vswg_cal = 0;
			loop_count = 0;
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 1);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 1);
				CheckError(ret, __LINE__);
			}
			else
			{
				//On K3, K4
				ret = DriveCBit(TPDispName[0], 1);
				CheckError(ret, __LINE__);
			}

			Vswg_cal = Vswg;

			ret = SWG_Configure();
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					ret = DigitizerFFT_Configure(digitizer_setting);
					CheckError(ret, __LINE__);

					do_once = 1;
				}

				//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
				ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}
	
				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);

					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);

						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);

						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}

					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);
			
			if(Test == TEST_IF4600_PKG)
			{
				ret = dio->DrivePin("DIO_3", 0);
				CheckError(ret, __LINE__);
				ret = dio->DrivePin("DIO_4", 0);
				CheckError(ret, __LINE__);
			}
			else
			{
				//off K3, K4
				ret = DriveCBit(TPDispName[0], 0);
				CheckError(ret, __LINE__);
			}

			Vswg_filter_calibrated->Add(Fswg, Vswg_cal);
			Vswg_filter_at_dut->Add(Fswg, vout_pp);
		}
		else
		{
			ret = SWG_Configure();
			CheckError(ret, __LINE__);

			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_filter_calibrated[Fswg]/2, -1 * Vswg_filter_calibrated[Fswg]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			
			ret = Digitizer_Configure(digitizer_setting);
			CheckError(ret, __LINE__);
		}

		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
		ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
		if (ret)
		{
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				tf_SetResult(TPName[i], (double)(-999));
			}

			goto test_end;
		}

		double Vin_Ref = vout_pp / CONST_FSAv_div;
		
		/////////////////////////////////////////////////////

		for (int i=0; i<total_tp; i++)
		{
			{//Calibration of Vpp

				Fswg = (double)(tf_TPCondition_Cast(TPName[i], "Fswg"));

				if (Vswg_filter_calibrated->ContainsKey(Fswg) == false)
				{
					Vswg_cal = 0;
					loop_count = 0;

					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_3", 1);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 1);
						CheckError(ret, __LINE__);
					}
					else
					{
						//On K3, K4
						ret = DriveCBit(TPDispName[0], 1);
						CheckError(ret, __LINE__);
					}

					Vswg_cal = Vswg;

					ret = SWG_Configure();
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					CheckError(ret, __LINE__);
					
					_util->Wait_Sec(1e-3);
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					while(loop_count <= max_loop)
					{
						//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
						ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
						if (ret)
						{
							ret = digitizer->StopAcquire("DIGITIZER");
							CheckError(ret, __LINE__);

							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);

							for (int k=0; k<total_tp; k++)
							{
								tf_SetResult(TPName[k], (double)(-999));
							}

							goto test_end;
						}
	
						if (Math::Abs(Vswg - vout_pp) < (4e-3))
						{
							break;
						}
						else
						{
							Vswg_cal = Vswg_cal + (Vswg - vout_pp);

							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);

							ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
							{
								CheckError(ret, __LINE__);	
							}

							if (ret != 0) 
							{
								ret = 0;

								ret = digitizer->StopAcquire("DIGITIZER");
								CheckError(ret, __LINE__);

								ret = acm->StopFG("ACM_CH"); 
								CheckError(ret, __LINE__);

								if(Test == TEST_IF4600_PKG)
								{
									ret = dio->DrivePin("DIO_3", 0);
									CheckError(ret, __LINE__);
									ret = dio->DrivePin("DIO_4", 0);
									CheckError(ret, __LINE__);
								}
								else
								{
									//off K3, K4
									ret = DriveCBit(TPDispName[0], 0);
									CheckError(ret, __LINE__);
								}

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult(TPName[i], (double)(-999));
								}

								goto test_end;
							}

							ret = acm->RunFG("ACM_CH", 0, true);
							CheckError(ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);
						}
			
						loop_count++;
					}

					if (loop_count > max_loop)
					{
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int k=0; k<total_tp; k++)
						{
							tf_SetResult(TPName[k], (double)(-999));
						}

						goto test_end;
					}
								
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					
					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_3", 0);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 0);
						CheckError(ret, __LINE__);
					}
					else
					{
						//off K3, K4
						ret = DriveCBit(TPDispName[0], 0);
						CheckError(ret, __LINE__);
					}

					Vswg_filter_calibrated->Add(Fswg, Vswg_cal);
					Vswg_filter_at_dut->Add(Fswg, vout_pp);
				}
				else
				{
					ret = SWG_Configure();
					CheckError(ret, __LINE__);

					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_filter_calibrated[Fswg]/2, -1 * Vswg_filter_calibrated[Fswg]/2, Fswg, 0);
					CheckError(ret, __LINE__);
	
					ret = Digitizer_Configure(digitizer_setting);
					CheckError(ret, __LINE__);
				}
			
				//Test
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_1", 1);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_2", 1);
					CheckError(ret, __LINE__);
				}
				else
				{
					//On K1, K2
					ret = DriveCBit(TPDispName[0], 2);
					CheckError(ret, __LINE__);
				}

				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
			}

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
			ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
			if (ret)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);

				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}

			double gain = 20 * Math::Log10(vout_pp / Vin_Ref);

			double temp = 0;
			temp = Gain_Ref - gain;
			temp = temp / 10;
			temp = Math::Pow(10, temp) - 1;
			temp = Math::Sqrt(temp);
			temp = Math::Pow(temp, (double)1/(double)3);
			temp = 1 / temp;

			if (_util->IsInf(temp) == false)
				result = Fswg * temp;
			else
				result = 0;

			tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
		}	

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		
test_end:
		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_rbhv(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rbhv = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rbhv[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		double Vos_Target		= (double)(tf_TestItemCondition_Cast("Vos_Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		int step = 0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (TPName[i]->Contains("Target"))
				{
					result[i] = Vos_Target;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
				else
				{
					if (TPName[i]->Contains("mV"))
					{
						ret = dm->DrivePin("RWN", 0);
						CheckError(ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File	= (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

						#ifndef USE_SPI
						ret = RunVectorFile(Vector_File);
						CheckError(ret, __LINE__);
						#else
						ret = RunSPI(Vector_File);
						CheckError(ret, __LINE__);
						#endif
					}

					_util->Wait_Sec(Measure_Delay_s);

					double val = 0;
					#ifdef USE_GNDS
					if (Test != TEST_IF4600_PKG)
					{
						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
						ret = smu->ReadVoltage("GND_MUX_SENSE", val);
						CheckError(ret, __LINE__);
					}
					#endif

 					if (TPName[i]->Contains("mV"))
					{
						if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
						{
							ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
							CheckError(ret, __LINE__);
							ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
							CheckError(ret, __LINE__);
						}
						else
						{
							ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
							CheckError(ret, __LINE__);
							ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
							CheckError(ret, __LINE__);
						}

						result_mrhv[i] = Math::Abs(diffp_V - diffn_V);
					}

					if (moduleType == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result[i]);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin, result[i]);
						CheckError(ret, __LINE__);
					}

					result[i] = result[i] - val;

					if (TPName[i]->Contains("mV"))
					{
						result_rbhv[i] = Math::Abs(result[i]);

						step++;
					}
					else
					{
						tf_SetResult(TPName[i], result[i] - Vos_Target + GetOffset(TPDispName[i]));
					}
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(total_tp);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;

		if (step > 1)
		{
			for(int k=0; k<step; k++)
			{
				sum_x	+= result_mrhv[k+1];
				sum_y	+= result_rbhv[k+1]; 
				mult_xy += result_mrhv[k+1] * result_rbhv[k+1];
				exp_x	+= result_mrhv[k+1] * result_mrhv[k+1];
			}

			slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
			offset = (sum_y/step) - (slope*(sum_x/step));
		}
		
		for (int i=0; i<step; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i+1]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (offset > 0)
				{
					gain[i+1]	= (result_rbhv[i+1] - offset) / result_mrhv[i+1];
				}
				else
				{
					gain[i+1]	= (result_rbhv[i+1] - result[0]) / result_mrhv[i+1];
				}

				if (_util->IsInf(gain[i+1]) == false)
					tf_SetResult(TPName[i+1], gain[i+1] + GetOffset(TPDispName[i+1]));
				else
					tf_SetResult(TPName[i+1], 999.0);

				if (tf_TPCondition_exist(TPName[i+1], "Global_Result_Index") == true)
				{
					int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i+1], "Global_Result_Index"));

					_glob->Global_Result[Global_Result_Index] = gain[i+1];
				}
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rbhv2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rbhv = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rbhv[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		double Vos_Target		= (double)(tf_TestItemCondition_Cast("Vos_Target"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_PN, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_PN, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_PN, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		int step = 0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (TPName[i]->Contains("Target"))
				{
					result[i] = Vos_Target;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
				else
				{
					if (TPName[i]->Contains("mV"))
					{
						ret = dm->DrivePin("RWN", 0);
						CheckError(ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File	= (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

						#ifndef USE_SPI
						ret = RunVectorFile(Vector_File);
						CheckError(ret, __LINE__);
						#else
						ret = RunSPI(Vector_File);
						CheckError(ret, __LINE__);
						#endif
					}

					_util->Wait_Sec(Measure_Delay_s);

					double val = 0;
					#ifdef USE_GNDS
					if (Test != TEST_IF4600_PKG)
					{
						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
						ret = smu->ReadVoltage("GND_MUX_SENSE", val);
						CheckError(ret, __LINE__);
					}
					#endif

 					if (TPName[i]->Contains("mV"))
					{
						if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
						{
							ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
							CheckError(ret, __LINE__);
						}
						else
						{
							ret = smu->ReadVoltage(Test_Pin_PN, diffpn_V);
							CheckError(ret, __LINE__);
						}

						diffpn_V = (diffpn_V-c)/m;

						result_mrhv[i] = Math::Abs(diffpn_V);
					}

					if (moduleType == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result[i]);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin, result[i]);
						CheckError(ret, __LINE__);
					}

					result[i] = result[i] - val;

					if (TPName[i]->Contains("mV"))
					{
						result_rbhv[i] = Math::Abs(result[i]);

						step++;
					}
					else
					{
						tf_SetResult(TPName[i], result[i] - Vos_Target + GetOffset(TPDispName[i]));
					}
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(total_tp);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;

		if (step > 1)
		{
			for(int k=0; k<step; k++)
			{
				sum_x	+= result_mrhv[k+1];
				sum_y	+= result_rbhv[k+1]; 
				mult_xy += result_mrhv[k+1] * result_rbhv[k+1];
				exp_x	+= result_mrhv[k+1] * result_mrhv[k+1];
			}

			slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
			offset = (sum_y/step) - (slope*(sum_x/step));
		}
		
		for (int i=0; i<step; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i+1]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (offset > 0)
				{
					gain[i+1]	= (result_rbhv[i+1] - offset) / result_mrhv[i+1];
				}
				else
				{
					gain[i+1]	= (result_rbhv[i+1] - result[0]) / result_mrhv[i+1];
				}

				if (_util->IsInf(gain[i+1]) == false)
					tf_SetResult(TPName[i+1], gain[i+1] + GetOffset(TPDispName[i+1]));
				else
					tf_SetResult(TPName[i+1], 999.0);

				if (tf_TPCondition_exist(TPName[i+1], "Global_Result_Index") == true)
				{
					int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i+1], "Global_Result_Index"));

					_glob->Global_Result[Global_Result_Index] = gain[i+1];
				}
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rbhv3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rbhv = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rbhv[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		double Vos_Target		= (double)(tf_TestItemCondition_Cast("Vos_Target"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure PN
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_PN, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_PN, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_PN, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		int step = 0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (TPName[i]->Contains("Target"))
				{
					result[i] = Vos_Target;

					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				}
				else
				{
					if (TPName[i]->Contains("mV"))
					{
						ret = dm->DrivePin("RWN", 0);
						CheckError(ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File	= (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

						#ifndef USE_SPI
						ret = RunVectorFile(Vector_File);
						CheckError(ret, __LINE__);
						#else
						ret = RunSPI(Vector_File);
						CheckError(ret, __LINE__);
						#endif
					}

					_util->Wait_Sec(Measure_Delay_s);

					double val = 0;
					#ifdef USE_GNDS
					if (Test != TEST_IF4600_PKG)
					{
						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
						ret = smu->ReadVoltage("GND_MUX_SENSE", val);
						CheckError(ret, __LINE__);
					}
					#endif

 					if (TPName[i]->Contains("mV"))
					{
						//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
						//{
						//	ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
						//	CheckError(ret, __LINE__);
						//}
						//else
						//{
						//	ret = smu->ReadVoltage(Test_Pin_PN, diffpn_V);
						//	CheckError(ret, __LINE__);
						//}

						ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
						CheckError(ret, __LINE__);

						diffpn_V = (diffpn_V-c)/m;

						result_mrhv[i] = Math::Abs(diffpn_V);
					}

					if (moduleType == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result[i]);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin, result[i]);
						CheckError(ret, __LINE__);
					}

					result[i] = result[i] - val;

					if (TPName[i]->Contains("mV"))
					{
						result_rbhv[i] = Math::Abs(result[i]);

						step++;
					}
					else
					{
						tf_SetResult(TPName[i], result[i] - Vos_Target + GetOffset(TPDispName[i]));
					}
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(total_tp);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;

		if (step > 1)
		{
			for(int k=0; k<step; k++)
			{
				sum_x	+= result_mrhv[k+1];
				sum_y	+= result_rbhv[k+1]; 
				mult_xy += result_mrhv[k+1] * result_rbhv[k+1];
				exp_x	+= result_mrhv[k+1] * result_mrhv[k+1];
			}

			slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
			offset = (sum_y/step) - (slope*(sum_x/step));
		}
		
		for (int i=0; i<step; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i+1]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (offset > 0)
				{
					gain[i+1]	= (result_rbhv[i+1] - offset) / result_mrhv[i+1];
				}
				else
				{
					gain[i+1]	= (result_rbhv[i+1] - result[0]) / result_mrhv[i+1];
				}

				if (_util->IsInf(gain[i+1]) == false)
					tf_SetResult(TPName[i+1], gain[i+1] + GetOffset(TPDispName[i+1]));
				else
					tf_SetResult(TPName[i+1], 999.0);

				if (tf_TPCondition_exist(TPName[i+1], "Global_Result_Index") == true)
				{
					int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i+1], "Global_Result_Index"));

					_glob->Global_Result[Global_Result_Index] = gain[i+1];
				}
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rhbuff(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//use MTX_SMU_2 for Test_Pin_Nout

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rhbuff = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rhbuff[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_Pin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pin"));
		String ^ Test_Pin_Nin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nin"));
		String ^ Test_Pin_Pout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pout"));
		String ^ Test_Pin_Nout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nout"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("GND_MUX_RST_N", 0);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePout  = 0;
		unsigned int moduleTypeNout = 0;
		unsigned int moduleTypePin = 0;
		unsigned int moduleTypeNin = 0;

		// Check whether resource is SMU or DM

		try
		{
			ret = smu->QueryModuleType(Test_Pin_Pin, moduleTypePin);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePin = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_Pin module type=" + moduleTypePin.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_Nin, moduleTypeNin);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeNin = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_Nin module type=" + moduleTypeNin.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_Pout, moduleTypePout);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePout = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_Pout module type=" + moduleTypePout.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_Nout, moduleTypeNout);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeNout = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_Nout module type=" + moduleTypeNout.ToString("X"));
		}

		// Configure Pin
		if (moduleTypePin == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Pin,6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure Nin
		if (moduleTypeNin == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Nin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Nin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Nin, 6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Nin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Nin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Nin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Nin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Nin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Nin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Nin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure Pout
		if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Pout, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Pout, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Pout, 6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Pout, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Pout);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Pout, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Pout, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Pout, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure Nout
		if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Nout, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Nout, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Nout,6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Nout, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Nout);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Nout, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Nout, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Nout, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Nout, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Nout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;
		double result_vcm = 0;

		int step = 0;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
									
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

				}

				if (TPName[i]->Contains("mV"))
				{
					_util->Wait_Sec(Measure_Delay_s);

					double val = 0;
					#ifdef USE_GNDS //Do not use GNDS for this test as SMU_SITEx_CH3 is used to measure RDP
					//if (Test == TEST_QS_BLKDGN_PROBE)
					//{
					//	ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
					//	CheckError(ret, __LINE__);
					//}
					#endif

					if (moduleTypePin == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Pin, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Pin, diffp_V);
						CheckError(ret, __LINE__);
					}

					diffp_V = diffp_V - val;

					if (moduleTypeNin == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Nin, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Nin, diffn_V);
						CheckError(ret, __LINE__);
					}

					diffn_V = diffn_V - val;

					result_mrhv[step] = Math::Abs(diffp_V - diffn_V);

					if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Pout, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Pout, diffp_V);
						CheckError(ret, __LINE__);
					}

					diffp_V = diffp_V - val;

					if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Nout, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Nout, diffn_V);
						CheckError(ret, __LINE__);
					}

					diffn_V = diffn_V - val;

					result_rhbuff[step] = Math::Abs(diffp_V - diffn_V);

					if (tf_TPCondition_exist(TPName[i], "Measure_Vcm") == true)
					{
						bool Measure_Vcm = (bool)(tf_TPCondition_Cast(TPName[i], "Measure_Vcm"));
						
						if (Measure_Vcm == true)
						{	
							result_vcm = (diffp_V + diffn_V) / 2;
						}
					}

					step++;
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mrhv[k];
			sum_y	+= result_rhbuff[k]; 
			mult_xy += result_mrhv[k] * result_rhbuff[k];
			exp_x	+= result_mrhv[k] * result_mrhv[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		for(int k=0; k<step; k++)
		{
			gain[k] = (result_rhbuff[k] - offset) / result_mrhv[k];
		}

		tf_SetResult(TPName[0], offset + GetOffset(TPDispName[0]));
		for(int k=1; k<=step; k++)
		{
			if (_util->IsInf(gain[k-1]) == false)
				tf_SetResult(TPName[k], gain[k-1] + GetOffset(TPDispName[k]));
			else
				tf_SetResult(TPName[k], (double)999);
		}
		tf_SetResult(TPName[4], result_vcm + GetOffset(TPDispName[4]));

		//////////////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("GND_MUX_RST_N", 1);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rhbuff2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//use MTX_SMU for Test_Pin_Nout

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rhbuff = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rhbuff[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_Pin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pin"));
		String ^ Test_Pin_Nin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nin"));
		String ^ Test_Pin_Pout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pout"));
		String ^ Test_Pin_Nout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nout"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin		= "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePout  = 0;
		unsigned int moduleTypeNout = 0;
		unsigned int moduleTypePin = 0;
		unsigned int moduleTypeNin = 0;

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM

		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleTypePin);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		// Configure
		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure Pout
		if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Pout, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Pout, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Pout, 6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Pout, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Pout);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Pout, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Pout, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Pout, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		if (Test_Pin_Nout != Test_Pin_Pout)
		{
			// Configure Nout
			if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_Nout, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_Nout, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Nout,6, -2);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_Nout, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_Nout);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_Nout, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_Nout, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_Nout, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_Nout, false, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_Nout, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
		}

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffpn_V = 0;
		double diffp_V = 0;
		double diffn_V = 0;
		double result_vcm = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		int step = 0;

		#ifdef USE_GNDS 
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
									
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

				}

				if (TPName[i]->Contains("mV"))
				{
					_util->Wait_Sec(Measure_Delay_s);

					double val = 0;
					#ifdef USE_GNDS 
					ret = smu->ReadVoltage("GND_MUX_SENSE", val);
					CheckError(ret, __LINE__);
					#endif

					if (moduleType == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, diffpn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin, diffpn_V);
						CheckError(ret, __LINE__);
					}

					diffpn_V = (diffpn_V-c)/m;

					result_mrhv[step] = Math::Abs(diffpn_V);
					
					///

					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__); 

					_util->Wait_Sec(On_Delay_s);

					if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Pout, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Pout, diffp_V);
						CheckError(ret, __LINE__);
					}

					diffp_V = diffp_V - val;

					ret = DriveCBit(TPDispName[0], 1);
					CheckError(ret, __LINE__); 

					_util->Wait_Sec(On_Delay_s);

					if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Nout, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Nout, diffn_V);
						CheckError(ret, __LINE__);
					}

					diffn_V = diffn_V - val;

					result_rhbuff[step] = Math::Abs(diffp_V - diffn_V);

					if (tf_TPCondition_exist(TPName[i], "Measure_Vcm") == true)
					{
						bool Measure_Vcm = (bool)(tf_TPCondition_Cast(TPName[i], "Measure_Vcm"));
						
						if (Measure_Vcm == true)
						{	
							result_vcm = (diffp_V + diffn_V) / 2;
						}
					}

					step++;
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mrhv[k];
			sum_y	+= result_rhbuff[k]; 
			mult_xy += result_mrhv[k] * result_rhbuff[k];
			exp_x	+= result_mrhv[k] * result_mrhv[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		for(int k=0; k<step; k++)
		{
			gain[k] = (result_rhbuff[k] - offset) / result_mrhv[k];
		}

		tf_SetResult(TPName[0], offset + GetOffset(TPDispName[0]));

		for(int k=1; k<=step; k++)
		{
			if (_util->IsInf(gain[k-1]) == false)
				tf_SetResult(TPName[k], gain[k-1] + GetOffset(TPDispName[k]));
			else
				tf_SetResult(TPName[k], (double)999);
		}
		tf_SetResult(TPName[4], result_vcm + GetOffset(TPDispName[4]));

		//////////////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rhbuff3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//use MTX_SMU for Test_Pin_Nout
		//use MTX_SMU_2 to measure RDxP/N via diff measurement

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rhbuff = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rhbuff[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_Pin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pin"));
		String ^ Test_Pin_Nin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nin"));
		String ^ Test_Pin_Pout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pout"));
		String ^ Test_Pin_Nout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nout"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin		= "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePout  = 0;
		unsigned int moduleTypeNout = 0;
		unsigned int moduleTypePin = 0;
		unsigned int moduleTypeNin = 0;

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM

		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleTypePin);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		// Configure
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 6, -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		// Configure Pout
		if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Pout, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Pout, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Pout, 6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Pout, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Pout);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Pout, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Pout, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Pout, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		if (Test_Pin_Nout != Test_Pin_Pout)
		{
			// Configure Nout
			if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_Nout, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_Nout, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Nout,6, -2);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_Nout, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_Nout);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_Nout, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_Nout, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_Nout, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_Nout, false, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_Nout, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
		}

		ret = smu->ConfigureSamplingTime("MTX_SMU_2", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU_2", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU_2", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU_2", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffpn_V = 0;
		double diffp_V = 0;
		double diffn_V = 0;
		double result_vcm = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		int step = 0;

		//#ifdef USE_GNDS 
		//ret = Configure_GNDS_Mux(site, NPLC);
		//CheckError(ret, __LINE__);
		//#endif

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
									
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

				}

				if (TPName[i]->Contains("mV"))
				{
					//_util->Wait_Sec(Measure_Delay_s);

					//double val = 0;
					//#ifdef USE_GNDS 
					//ret = smu->ReadVoltage("GND_MUX_SENSE", val);
					//CheckError(ret, __LINE__);
					//#endif

					ret = dm->DrivePin("GND_MUX_RST_N", 0); //reset SPI MUX as we need MTX_SMU2 
					CheckError(ret, __LINE__);

					if (Test_Pin == "GRP1_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT2, 1); //Connect to AM430e MTX_SMU2 via switch matrix
						CheckError(ret, __LINE__);
					}
					else if (Test_Pin == "GRP2_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT5, 1); //Connect to AM430e MTX_SMU2 via switch matrix
						CheckError(ret, __LINE__);
					}

					//if (moduleType == DM_CONST_MODULE_TYPE) //dm
					//{
					//	ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, diffpn_V);
					//	CheckError(ret, __LINE__);
					//}
					//else
					//{
					//	ret = smu->ReadVoltage(Test_Pin, diffpn_V);
					//	CheckError(ret, __LINE__);
					//}

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu->ReadVoltage("MTX_SMU_2", diffpn_V);
					CheckError(ret, __LINE__);

					diffpn_V = (diffpn_V-c)/m;

					result_mrhv[step] = Math::Abs(diffpn_V);

					ret = dm->DrivePin("GND_MUX_RST_N", 1); //reset SPI MUX as we need MTX_SMU2 
					CheckError(ret, __LINE__);
					
					///

					double val = 0;
					#ifdef USE_GNDS 
					ret = Configure_GNDS_Mux(site, NPLC);
					CheckError(ret, __LINE__);
					ret = smu->ReadVoltage("GND_MUX_SENSE", val);
					CheckError(ret, __LINE__);
					#endif

					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__); 

					_util->Wait_Sec(On_Delay_s);

					if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Pout, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Pout, diffp_V);
						CheckError(ret, __LINE__);
					}

					diffp_V = diffp_V - val;

					ret = DriveCBit(TPDispName[0], 1);
					CheckError(ret, __LINE__); 

					_util->Wait_Sec(On_Delay_s);

					if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm->PMUMeasure(Test_Pin_Nout, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
					}
					else
					{
						ret = smu->ReadVoltage(Test_Pin_Nout, diffn_V);
						CheckError(ret, __LINE__);
					}

					diffn_V = diffn_V - val;

					result_rhbuff[step] = Math::Abs(diffp_V - diffn_V);

					if (tf_TPCondition_exist(TPName[i], "Measure_Vcm") == true)
					{
						bool Measure_Vcm = (bool)(tf_TPCondition_Cast(TPName[i], "Measure_Vcm"));
						
						if (Measure_Vcm == true)
						{	
							result_vcm = (diffp_V + diffn_V) / 2;
						}
					}

					step++;
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mrhv[k];
			sum_y	+= result_rhbuff[k]; 
			mult_xy += result_mrhv[k] * result_rhbuff[k];
			exp_x	+= result_mrhv[k] * result_mrhv[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		for(int k=0; k<step; k++)
		{
			gain[k] = (result_rhbuff[k] - offset) / result_mrhv[k];
		}

		tf_SetResult(TPName[0], offset + GetOffset(TPDispName[0]));

		for(int k=1; k<=step; k++)
		{
			if (_util->IsInf(gain[k-1]) == false)
				tf_SetResult(TPName[k], gain[k-1] + GetOffset(TPDispName[k]));
			else
				tf_SetResult(TPName[k], (double)999);
		}
		tf_SetResult(TPName[4], result_vcm + GetOffset(TPDispName[4]));

		//////////////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rhbuff4(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		//use MTX_SMU to measure RDP/N via diff measurement
		//use MTX_SMU_2 to measure RD0P/N via diff measurement

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		array<double> ^ result_rhbuff = gcnew array<double>(total_tp); 
		array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;

			result_rhbuff[i] = 0;
			result_mrhv[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_Pin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pin"));
		String ^ Test_Pin_Nin	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nin"));
		String ^ Test_Pin_Pout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Pout"));
		String ^ Test_Pin_Nout	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_Nout"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin		= "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypePout  = 0;
		unsigned int moduleTypeNout = 0;
		unsigned int moduleTypePin = 0;
		unsigned int moduleTypeNin = 0;

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM

		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleTypePin);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		// Configure
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 6, -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		// Configure Pout
		if (moduleTypePout == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_Pout, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_Pout, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Pout, 6, -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_Pout, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_Pout);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_Pout, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_Pout, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_Pout, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_Pout, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_Pout, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		if (Test_Pin_Nout != Test_Pin_Pout)
		{
			// Configure Nout
			if (moduleTypeNout == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_Nout, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_Nout, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_Nout,6, -2);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_Nout, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_Nout);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_Nout, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_Nout, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_Nout, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_Nout, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_Nout, false, false);
				CheckError(ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu->DriveCurrent(Test_Pin_Nout, Drive_Io_A);
				CheckError(ret, __LINE__);
			}
		}

		ret = smu->ConfigureSamplingTime("MTX_SMU_2", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU_2", 1.99);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU_2", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU_2", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffpn_V = 0;
		double diffp_V = 0;
		double diffn_V = 0;
		double result_vcm = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		int step = 0;

		ret = dm->DrivePin("GND_MUX_RST_N", 0); //reset SPI MUX as we need MTX_SMU2 
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
									
					#ifndef USE_SPI
					ret = RunVectorFile(Vector_File);
					CheckError(ret, __LINE__);
					#else
					ret = RunSPI(Vector_File);
					CheckError(ret, __LINE__);
					#endif

				}

				if (TPName[i]->Contains("mV"))
				{
					//RD0P, RD0N

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					
					ret = DriveMuxIO(TPDispName[0], 0);
					CheckError(ret, __LINE__);

					if (Test_Pin == "GRP1_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT2, 1); //Connect to AM430e MTX_SMU2 via switch matrix
						CheckError(ret, __LINE__);
					}
					else if (Test_Pin == "GRP2_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT5, 1); //Connect to AM430e MTX_SMU2 via switch matrix
						CheckError(ret, __LINE__);
					}

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu->ReadVoltage("MTX_SMU_2", diffpn_V);
					CheckError(ret, __LINE__);

					diffpn_V = (diffpn_V-c)/m;

					result_mrhv[step] = Math::Abs(diffpn_V);

					if (Test_Pin == "GRP1_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT2, 0); //Disconnect to AM430e MTX_SMU2 via switch matrix
						CheckError(ret, __LINE__);
					}
					else if (Test_Pin == "GRP2_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN1_OUT5, 0); //Disconnect to AM430e MTX_SMU2 via switch matrix
						CheckError(ret, __LINE__);
					}
															
					//RDP

					if (Test_Pin == "GRP1_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e MTX_SMU via switch matrix
						CheckError(ret, __LINE__);
					}
					else if (Test_Pin == "GRP2_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e MTX_SMU via switch matrix
						CheckError(ret, __LINE__);
					}

					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					
					ret = DriveMuxIO(TPDispName[0], 1);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(ret, __LINE__);

					//RDN
					ret = ResetMuxIO();
					CheckError(ret, __LINE__);
					
					ret = DriveMuxIO(TPDispName[0], 2);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu->ReadVoltage("MTX_SMU", diffn_V);
					CheckError(ret, __LINE__);
				
					diffp_V = -1 * diffp_V;
					//diffn_V = -1 * diffn_V;

					diffp_V =  (diffp_V-c)/m;
					diffn_V =  (diffn_V-c)/m;

					if (Test_Pin == "GRP1_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 0); //Disconnect to AM430e MTX_SMU via switch matrix
						CheckError(ret, __LINE__);
					}
					else if (Test_Pin == "GRP2_DIFF_SENSE")
					{
						ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 0); //Disconnect to AM430e MTX_SMU via switch matrix
						CheckError(ret, __LINE__);
					}
					
					//

					result_rhbuff[step] = Math::Abs(diffp_V - diffn_V);

					if (tf_TPCondition_exist(TPName[i], "Measure_Vcm") == true)
					{
						bool Measure_Vcm = (bool)(tf_TPCondition_Cast(TPName[i], "Measure_Vcm"));
						
						if (Measure_Vcm == true)
						{	
							result_vcm = (diffp_V + diffn_V) / 2;
						}
					}

					step++;
				}
			}
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mrhv[k];
			sum_y	+= result_rhbuff[k]; 
			mult_xy += result_mrhv[k] * result_rhbuff[k];
			exp_x	+= result_mrhv[k] * result_mrhv[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		for(int k=0; k<step; k++)
		{
			gain[k] = (result_rhbuff[k] - offset) / result_mrhv[k];
		}

		tf_SetResult(TPName[0], offset + GetOffset(TPDispName[0]));

		for(int k=1; k<=step; k++)
		{
			if (_util->IsInf(gain[k-1]) == false)
				tf_SetResult(TPName[k], gain[k-1] + GetOffset(TPDispName[k]));
			else
				tf_SetResult(TPName[k], 999);
		}
		tf_SetResult(TPName[4], result_vcm + GetOffset(TPDispName[4]));

		//////////////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->DrivePin("GND_MUX_RST_N", 1); //reset SPI MUX as we need MTX_SMU2 
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rbhi(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
				
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		array<String ^> ^ Vector_File_Test = gcnew array<String ^>(step);
		array<double> ^ result_rbhi = gcnew array<double>(step); 
		array<double> ^ result_mr = gcnew array<double>(step); 
		array<double> ^ result = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			Vector_File_Test[i] = (String ^)(tf_TestItemCondition_Cast("Vector_File_" + (i+1).ToString()));

			result_rbhi[i] = 0;
			result_mr[i] = 0;

			result[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveVoltage(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<step; i++)
		{
			Vector_File = Vector_File_Test[i];
					
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
			}

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_mr[i] = Math::Abs(diffp_V - diffn_V) / CONST_Rr1;

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent(Test_Pin, result[i]);
				CheckError(ret, __LINE__);
			}

			result_rbhi[i] = Math::Abs(result[i]);
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mr[k];
			sum_y	+= result_rbhi[k]; 
			mult_xy += result_mr[k] * result_rbhi[k];
			exp_x	+= result_mr[k] * result_mr[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		if (_util->IsInf(slope) == false)
			tf_SetResult(TPName[0], 1/slope + GetOffset(TPDispName[0]));
		else
			tf_SetResult(TPName[0], (double)999);

		tf_SetResult(TPName[1], offset + GetOffset(TPDispName[1]));

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rbhi2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
				
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		array<String ^> ^ Vector_File_Test = gcnew array<String ^>(step);
		array<double> ^ result_rbhi = gcnew array<double>(step); 
		array<double> ^ result_mr = gcnew array<double>(step); 
		array<double> ^ result = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			Vector_File_Test[i] = (String ^)(tf_TestItemCondition_Cast("Vector_File_" + (i+1).ToString()));

			result_rbhi[i] = 0;
			result_mr[i] = 0;

			result[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		// Configure PN
		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_PN, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_PN, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_PN, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_PN, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveVoltage(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<step; i++)
		{
			Vector_File = Vector_File_Test[i];
					
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_PN, diffpn_V);
				CheckError(ret, __LINE__);
			}

			diffpn_V = (diffpn_V-c)/m;

			result_mr[i] = Math::Abs(diffpn_V) / CONST_Rr1;

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent(Test_Pin, result[i]);
				CheckError(ret, __LINE__);
			}

			result_rbhi[i] = Math::Abs(result[i]);
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mr[k];
			sum_y	+= result_rbhi[k]; 
			mult_xy += result_mr[k] * result_rbhi[k];
			exp_x	+= result_mr[k] * result_mr[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		if (_util->IsInf(slope) == false)
			tf_SetResult(TPName[0], 1/slope + GetOffset(TPDispName[0]));
		else
			tf_SetResult(TPName[0], (double)999);

		tf_SetResult(TPName[1], offset + GetOffset(TPDispName[1]));

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rbhi3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
				
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int step				= (int)(tf_TestItemCondition_Cast("step"));

		array<String ^> ^ Vector_File_Test = gcnew array<String ^>(step);
		array<double> ^ result_rbhi = gcnew array<double>(step); 
		array<double> ^ result_mr = gcnew array<double>(step); 
		array<double> ^ result = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			Vector_File_Test[i] = (String ^)(tf_TestItemCondition_Cast("Vector_File_" + (i+1).ToString()));

			result_rbhi[i] = 0;
			result_mr[i] = 0;

			result[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		unsigned int moduleTypePN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		//// Configure PN
		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Math::Abs(Clamp_Vo_V), -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_PN, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_PN, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_PN, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_PN, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 1);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveVoltage(Test_Pin, Drive_Vo_V);
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double diffpn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<step; i++)
		{
			Vector_File = Vector_File_Test[i];
					
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_PN, diffpn_V);
			//	CheckError(ret, __LINE__);
			//}

			ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
			CheckError(ret, __LINE__);

			diffpn_V = (diffpn_V-c)/m;

			result_mr[i] = Math::Abs(diffpn_V) / CONST_Rr1;

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent(Test_Pin, result[i]);
				CheckError(ret, __LINE__);
			}

			result_rbhi[i] = Math::Abs(result[i]);
		}

		//Processing slope & offset

		array<double> ^ gain = gcnew array<double>(step);
		double slope = 0;
		double offset = 0;
		double dev_hd = 0;
		double sum_x = 0;
		double sum_y = 0;
		double mult_xy = 0;
		double exp_x = 0;
		
		for(int k=0; k<step; k++)
		{
			sum_x	+= result_mr[k];
			sum_y	+= result_rbhi[k]; 
			mult_xy += result_mr[k] * result_rbhi[k];
			exp_x	+= result_mr[k] * result_mr[k];
		}

		slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
		offset = (sum_y/step) - (slope*(sum_x/step));

		if (_util->IsInf(slope) == false)
			tf_SetResult(TPName[0], 1/slope + GetOffset(TPDispName[0]));
		else
			tf_SetResult(TPName[0], (double)999);

		tf_SetResult(TPName[1], offset + GetOffset(TPDispName[1]));

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rdbhv(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_Rd	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		array<String ^> ^ Vector_File_Test = gcnew array<String ^>(step);
		array<double> ^ result_v = gcnew array<double>(step);
		array<double> ^ result_adc = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			Vector_File_Test[i] = (String ^)(tf_TestItemCondition_Cast("Vector_File_" + (i+1).ToString()));

			result_v[i] = 0;
			result_adc[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		for (int i=0; i<step; i++)
		{
			Vector_File = Vector_File_Test[i];
					
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
			}

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			result_v[i] = Math::Abs(diffp_V - diffn_V);

			// read adc
			Vector_File = Vector_File_Rd;
		
			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif
			result_adc[i] = data;
		
		}

		//Processing slope & offset

		double gain		= 0;
		double offset	= 0;
		double rmr		= 0;	
		double delta	= 0;

		delta = ((6.25e-6 * 65) + 50e-6) - ((6.25e-6 * 16) + 50e-6); //bias_i = 16 & 65. Follow the formula in datasheet page18.
		rmr = ((result_adc[1] - result_adc[0]) * 1e-3) / delta;
		offset = result_adc[1] - (1000*result_v[1]);
		gain = (result_adc[1] - result_adc[0]) / (1000*(result_v[1] - result_v[0]));
		
		result[0] = ((rmr/Target) - 1)*100;
		result[1] = offset;
		result[2] = gain;
		result[3] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}			
		}

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rdbhv2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_Rd	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		Test_Pin_P = "GRP2_DIFF_SENSE";

		array<String ^> ^ Vector_File_Test = gcnew array<String ^>(step);
		array<double> ^ result_v = gcnew array<double>(step);
		array<double> ^ result_adc = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			Vector_File_Test[i] = (String ^)(tf_TestItemCondition_Cast("Vector_File_" + (i+1).ToString()));

			result_v[i] = 0;
			result_adc[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		// Configure P
		if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		for (int i=0; i<step; i++)
		{
			Vector_File = Vector_File_Test[i];
					
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
				CheckError(ret, __LINE__);
			}

			diffp_V = (diffp_V-c)/m;

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//	CheckError(ret, __LINE__);
			//}

			result_v[i] = Math::Abs(diffp_V - diffn_V);

			// read adc
			Vector_File = Vector_File_Rd;
		
			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif
			result_adc[i] = data;
		
		}

		//Processing slope & offset

		double gain		= 0;
		double offset	= 0;
		double rmr		= 0;	
		double delta	= 0;

		delta = ((6.25e-6 * 65) + 50e-6) - ((6.25e-6 * 16) + 50e-6); //bias_i = 16 & 65. Follow the formula in datasheet page18.
		rmr = ((result_adc[1] - result_adc[0]) * 1e-3) / delta;
		offset = result_adc[1] - (1000*result_v[1]);
		gain = (result_adc[1] - result_adc[0]) / (1000*(result_v[1] - result_v[0]));
		
		result[0] = ((rmr/Target) - 1)*100;
		result[1] = offset;
		result[2] = gain;
		result[3] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}			
		}

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rdbhv3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_Rd	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		Test_Pin_P = "GRP2_DIFF_SENSE";

		array<String ^> ^ Vector_File_Test = gcnew array<String ^>(step);
		array<double> ^ result_v = gcnew array<double>(step);
		array<double> ^ result_adc = gcnew array<double>(step);

		for (int i=0; i<step; i++)
		{
			Vector_File_Test[i] = (String ^)(tf_TestItemCondition_Cast("Vector_File_" + (i+1).ToString()));

			result_v[i] = 0;
			result_adc[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleTypeP = 0;
		unsigned int moduleTypeN = 0;

		// Check whether resource is SMU or DM
		
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, moduleTypeP);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypeP = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_P module type=" + moduleTypeP.ToString("X"));
		}

		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_N, moduleTypeN);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleTypeN = DM_CONST_MODULE_TYPE;
		//}

		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("QueryModuleType returns " + ret.ToString());
		//	sb->AppendLine("Test_Pin_N module type=" + moduleTypeN.ToString("X"));
		//}

		// Configure P
		//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_P, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_P, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		// Configure N
		//if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -2);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = smu->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
		//	CheckError(ret, __LINE__);
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OnSmuPin(Test_Pin_N, false, false);
		//	CheckError(ret, __LINE__);
		//	_util->Wait_Sec(On_Delay_s);
		//	ret = smu->DriveCurrent(Test_Pin_N, Drive_Io_A);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		double diffp_V = 0;
		double diffn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_P == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_P == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		for (int i=0; i<step; i++)
		{
			Vector_File = Vector_File_Test[i];
					
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
			//	CheckError(ret, __LINE__);
			//}

			ret = smu->ReadVoltage("MTX_SMU", diffp_V);
			CheckError(ret, __LINE__);

			diffp_V = (diffp_V-c)/m;

			//if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			//	CheckError(ret, __LINE__);
			//}
			//else
			//{
			//	ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
			//	CheckError(ret, __LINE__);
			//}

			result_v[i] = Math::Abs(diffp_V - diffn_V);

			// read adc
			Vector_File = Vector_File_Rd;
		
			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif
			result_adc[i] = data;
		
		}

		//Processing slope & offset

		double gain		= 0;
		double offset	= 0;
		double rmr		= 0;	
		double delta	= 0;

		delta = ((6.25e-6 * 65) + 50e-6) - ((6.25e-6 * 16) + 50e-6); //bias_i = 16 & 65. Follow the formula in datasheet page18.
		rmr = ((result_adc[1] - result_adc[0]) * 1e-3) / delta;
		offset = result_adc[1] - (1000*result_v[1]);
		gain = (result_adc[1] - result_adc[0]) / (1000*(result_v[1] - result_v[0]));
		
		result[0] = ((rmr/Target) - 1)*100;
		result[1] = offset;
		result[2] = gain;
		result[3] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}			
		}

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rdbhvc(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}
		
		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		ret = ReadVector(Vector_File_ReadADC, data);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		ret = ReadSPI(Vector_File_ReadADC, data);
		CheckError(ret, __LINE__);
		#endif

		//Processing slope & offset

		double gain		= 0;
		double offset	= 0;
		double rmr		= 0;
		double delta	= 0;

		delta = (6.25e-6 * 52) + 50e-6; //bias_i = 52. Follow the formula in datasheet page18.
		rmr = (data * 1e-3) / delta;
		
		result[0] = ((rmr/Target) - 1)*100;
		result[1] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}			
		}

		/////////////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rdbhi(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
		String ^ Vector_File_2	= (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));
		String ^ Vector_File_Rd	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd"));

		int step				= (int)(tf_TestItemCondition_Cast("step"));
		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		array<double> ^ result_adc = gcnew array<double>(step);
		for (int i=0; i<step; i++)
		{
			result_adc[i] = 0;
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//init
		
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif
		
		String ^ Vector_str;

		for (int i=0; i<step; i++)
		{
			switch(i)
			{
				case 0:
					Vector_str = Vector_File_1;
					break;
				case 1:
					Vector_str = Vector_File_2;
					break;
			}
			
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_str);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_str);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);

			// read adc
			#ifndef USE_SPI
			ret = ReadVector(Vector_File_Rd, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File_Rd, data);
			CheckError(ret, __LINE__);
			#endif

			result_adc[i] = data;
			
		}

		//Processing slope & offset

		double MRResRng    = 2; // see pg2_reg29 bit4 to bit6, default = 2
		double gain		= 0;
		double rmr		= 0;	
		double delta	= 0;

		delta = ((2.53e-3 * 63) + 40e-3) - ((2.53e-3 * 0) + 40e-3); //bias_i = 0 & 63. Follow the formula in datasheet page18.

		gain = 2.11e-6 * pow(2,(MRResRng-1)); // see datasheet page11 for this formula 

		rmr = delta / ((result_adc[1] - result_adc[0]) * gain);
		
		result[0] = ((rmr/Target) - 1)*100;
		result[1] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}			
		}

		/////////////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_wbhv(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Drive_Pin_P	= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_P"));
		String ^ Drive_Pin_N	= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_N"));
		String ^ Measure_Pin_P	= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_P"));
		String ^ Measure_Pin_N	= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_N"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));

		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleType_Drive_P = 0;
		unsigned int moduleType_Drive_N = 0;
		unsigned int moduleType_Meas_P = 0;
		unsigned int moduleType_Meas_N = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Drive_Pin_P, moduleType_Drive_P);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Drive_P = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Drive_Pin_P module type=" + moduleType_Drive_P.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Drive_Pin_N, moduleType_Drive_N);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Drive_N = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Drive_Pin_N module type=" + moduleType_Drive_N.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}

		// Configure P
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Drive_Pin_P);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Drive_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Drive_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Drive_Pin_P, false, false);
			CheckError(ret, __LINE__);
		}

		if (Measure_Pin_P != Drive_Pin_P)
		{
			if (moduleType_Meas_P == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Measure_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Measure_Pin_P, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_P, Math::Abs(Clamp_Vo_V), -2);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_P, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Measure_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Measure_Pin_P);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ConfigureSamplingTime(Measure_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Measure_Pin_P, Math::Abs(Clamp_Vo_V));
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Measure_Pin_P, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Measure_Pin_P, false, false);
				CheckError(ret, __LINE__);
			}
		}

		// Configure N
		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Drive_Pin_N);	
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Drive_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Drive_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Drive_Pin_N, false, false);
			CheckError(ret, __LINE__);
		}

		if (Measure_Pin_N != Drive_Pin_N)
		{
			if (Measure_Pin_N != Measure_Pin_P)
			{
				if (moduleType_Meas_N == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm->Force(Measure_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUOutputFunction(Measure_Pin_N, DM_CONST_DICV);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_N, Math::Abs(Clamp_Vo_V), -2);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_N, 0);
					CheckError(ret, __LINE__);
					ret = dm->ConfigurePMUSamplingTime(Measure_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = dm->DPINOn(Measure_Pin_N);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = smu->ConfigureSamplingTime(Measure_Pin_N, NPLC, AM_CONST_PLC);
					CheckError(ret, __LINE__);
					ret = smu->ClampVoltage(Measure_Pin_N, Math::Abs(Clamp_Vo_V));
					CheckError(ret, __LINE__);
					ret = smu->DriveCurrent(Measure_Pin_N, 0);
					CheckError(ret, __LINE__);
					ret = smu->OnSmuPin(Measure_Pin_N, false, false);
					CheckError(ret, __LINE__);
				}
			}
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double result_wbhv1 = 0;
		double result_wbhv2 = 0;
		double result_whv1 = 0;
		double result_whv2 = 0;
		double result_whi = 0;
		double result_whvx = 0;

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		////////////////////////////////////////////////////////////////////////////////////
		//Drive Lo
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, -1 * Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, -1 * Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}

		//Measure Lo
		ret = DriveCBit(TPDispName[0], 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		double val = 0;
		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		if (moduleType_Meas_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_P, diffp_V);
			CheckError(ret, __LINE__);
		}

		ret = DriveCBit(TPDispName[0], 1);
		CheckError(ret, __LINE__);
		
		_util->Wait_Sec(Measure_Delay_s);

		if (moduleType_Meas_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_N, diffn_V);
			CheckError(ret, __LINE__);
		}

		result_whv1 = Math::Abs(diffp_V - diffn_V);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_wbhv1);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_wbhv1);
			CheckError(ret, __LINE__);
		}

		result_wbhv1 = result_wbhv1 - val;

		////////////////////////////////////////////////////////////////////////////////////
		//Drive Hi
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, -1 * Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, -1 * Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}

		//Measure Hi
		ret = DriveCBit(TPDispName[0], 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		if (moduleType_Meas_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_P, diffp_V);
			CheckError(ret, __LINE__);
		}

		ret = DriveCBit(TPDispName[0], 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleType_Meas_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_N, diffn_V);
			CheckError(ret, __LINE__);
		}

		result_whv2 = Math::Abs(diffp_V - diffn_V);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_wbhv2);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_wbhv2);
			CheckError(ret, __LINE__);
		}

		result_wbhv2 = result_wbhv2 - val;

		//Drive 0
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
		}

		////////////////////////////////////////////////////////////////////////////////////
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		//Measure
		ret = DriveCBit(TPDispName[0], 0);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		
		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		if (moduleType_Meas_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_P, diffp_V);
			CheckError(ret, __LINE__);
		}

		ret = DriveCBit(TPDispName[0], 1);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleType_Meas_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_N, diffn_V);
			CheckError(ret, __LINE__);
		}

		result_whi = (Math::Abs(diffp_V - diffn_V))/(CONST_Rw);

		result_whi = result_whi*(1 - 0.09*result_whi/0.07); //follow Catalyst's equation

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_whvx);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_whvx);
			CheckError(ret, __LINE__);
		}

		result_whvx = result_whvx - val;

		////////////////////////////////////////////////////////////////////////////////////

		double gain		= 0;
		double offset	= 0;
		double result_wvcm = 0;

		//1-2mV can affect gain results by 0.2-0.3!

		gain = (result_wbhv2 - result_wbhv1) / (result_whv2 - result_whv1); //Direct use DMM to measure will get better correlation.
		offset = result_wbhv2 - (gain * result_whv2); //Don't care correlation as customer's datalog also fluctuate a lot
		result_wvcm = result_whvx - (result_whi * (CONST_Rw/2));

		result[0] = gain;
		result[1] = offset - Target;
		result[2] = result_whi;
		result[3] = result_wvcm;
		result[4] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_wbhv2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Drive_Pin_P	= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_P"));
		String ^ Drive_Pin_N	= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_N"));
		String ^ Measure_Pin_P	= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_P"));
		String ^ Measure_Pin_N	= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_N"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));

		String ^ Measure_Pin_PN = "GRP1_DIFF_SENSE";

		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleType_Drive_P = 0;
		unsigned int moduleType_Drive_N = 0;
		unsigned int moduleType_Meas_P = 0;
		unsigned int moduleType_Meas_N = 0;

		unsigned int moduleType_Meas_PN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Drive_Pin_P, moduleType_Drive_P);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Drive_P = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Drive_Pin_P module type=" + moduleType_Drive_P.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Drive_Pin_N, moduleType_Drive_N);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Drive_N = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Drive_Pin_N module type=" + moduleType_Drive_N.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Measure_Pin_PN, moduleType_Meas_PN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Meas_PN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Measure_Pin_PN module type=" + moduleType_Meas_PN.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}

		// Configure P
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Drive_Pin_P);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Drive_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Drive_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Drive_Pin_P, false, false);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Measure_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Measure_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_PN, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Measure_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Measure_Pin_PN);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ConfigureSamplingTime(Measure_Pin_PN, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Measure_Pin_PN, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Measure_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Measure_Pin_PN, false, false);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Drive_Pin_N);	
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Drive_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Drive_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Drive_Pin_N, false, false);
			CheckError(ret, __LINE__);
		}

		double diffp_V = 0;
		double diffn_V = 0;
		double result_wbhv1 = 0;
		double result_wbhv2 = 0;
		double result_whv1 = 0;
		double result_whv2 = 0;
		double result_whi = 0;
		double result_whvx = 0;
		double diffpn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Measure_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Measure_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		////////////////////////////////////////////////////////////////////////////////////
		//Drive Lo
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, -1 * Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, -1 * Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}

		//Measure Lo

		_util->Wait_Sec(Measure_Delay_s);

		double val = 0;
		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_PN, diffpn_V);
			CheckError(ret, __LINE__);
		}

		diffpn_V = (diffpn_V-c)/m;

		result_whv1 = Math::Abs(diffpn_V);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_wbhv1);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_wbhv1);
			CheckError(ret, __LINE__);
		}

		result_wbhv1 = result_wbhv1 - val;

		////////////////////////////////////////////////////////////////////////////////////
		//Drive Hi
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, -1 * Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, -1 * Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}

		//Measure Hi
		
		_util->Wait_Sec(Measure_Delay_s);

		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_PN, diffpn_V);
			CheckError(ret, __LINE__);
		}

		diffpn_V = (diffpn_V-c)/m;

		result_whv2 = Math::Abs(diffpn_V);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_wbhv2);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_wbhv2);
			CheckError(ret, __LINE__);
		}

		result_wbhv2 = result_wbhv2 - val;

		//Drive 0
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
		}

		////////////////////////////////////////////////////////////////////////////////////
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		//Measure

		_util->Wait_Sec(On_Delay_s);
		
		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Measure_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Measure_Pin_PN, diffpn_V);
			CheckError(ret, __LINE__);
		}

		diffpn_V = (diffpn_V-c)/m;

		result_whi = (Math::Abs(diffpn_V))/(CONST_Rw);

		result_whi = result_whi*(1 - 0.09*result_whi/0.07); //follow Catalyst's equation

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_whvx);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_whvx);
			CheckError(ret, __LINE__);
		}

		result_whvx = result_whvx - val;

		////////////////////////////////////////////////////////////////////////////////////

		double gain		= 0;
		double offset	= 0;
		double result_wvcm = 0;

		//1-2mV can affect gain results by 0.2-0.3!

		gain = (result_wbhv2 - result_wbhv1) / (result_whv2 - result_whv1); //Direct use DMM to measure will get better correlation.
		offset = result_wbhv2 - (gain * result_whv2); //Don't care correlation as customer's datalog also fluctuate a lot
		result_wvcm = result_whvx - (result_whi * (CONST_Rw/2));

		result[0] = gain;
		result[1] = offset - Target;
		result[2] = result_whi;
		result[3] = result_wvcm;
		result[4] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_wbhv3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Drive_Pin_P	= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_P"));
		String ^ Drive_Pin_N	= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_N"));
		String ^ Measure_Pin_P	= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_P"));
		String ^ Measure_Pin_N	= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_N"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
		double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));

		String ^ Measure_Pin_PN = "GRP1_DIFF_SENSE";

		double Target			= (double)(tf_TestItemCondition_Cast("Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleType_Drive_P = 0;
		unsigned int moduleType_Drive_N = 0;
		unsigned int moduleType_Meas_P = 0;
		unsigned int moduleType_Meas_N = 0;

		unsigned int moduleType_Meas_PN = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Drive_Pin_P, moduleType_Drive_P);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Drive_P = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Drive_Pin_P module type=" + moduleType_Drive_P.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Drive_Pin_N, moduleType_Drive_N);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Drive_N = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Drive_Pin_N module type=" + moduleType_Drive_N.ToString("X"));
		}

		try
		{
			ret = smu->QueryModuleType(Measure_Pin_PN, moduleType_Meas_PN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType_Meas_PN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Measure_Pin_PN module type=" + moduleType_Meas_PN.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}

		// Configure P
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_P, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Drive_Pin_P);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Drive_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Drive_Pin_P, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Drive_Pin_P, false, false);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Measure_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Measure_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Measure_Pin_PN, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Measure_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Measure_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Measure_Pin_PN);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ConfigureSamplingTime(Measure_Pin_PN, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Measure_Pin_PN, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Measure_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Measure_Pin_PN, false, false);
			CheckError(ret, __LINE__);
		}

		// Configure N
		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Drive_Pin_N, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Drive_Pin_N);	
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Drive_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Drive_Pin_N, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Drive_Pin_N, false, false);
			CheckError(ret, __LINE__);
		}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		double diffp_V = 0;
		double diffn_V = 0;
		double result_wbhv1 = 0;
		double result_wbhv2 = 0;
		double result_whv1 = 0;
		double result_whv2 = 0;
		double result_whi = 0;
		double result_whvx = 0;
		double diffpn_V = 0;

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Measure_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Measure_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		//init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		////////////////////////////////////////////////////////////////////////////////////
		//Drive Lo
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, -1 * Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, -1 * Drive_Current_Lo_A);
			CheckError(ret, __LINE__);
		}

		//Measure Lo

		_util->Wait_Sec(Measure_Delay_s);

		double val = 0;
		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		//if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->PMUMeasure(Measure_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
		//	CheckError(ret, __LINE__);
		//}
		//else
		//{
		//	ret = smu->ReadVoltage(Measure_Pin_PN, diffpn_V);
		//	CheckError(ret, __LINE__);
		//}

		ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
		CheckError(ret, __LINE__);

		diffpn_V = (diffpn_V-c)/m;

		result_whv1 = Math::Abs(diffpn_V);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_wbhv1);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_wbhv1);
			CheckError(ret, __LINE__);
		}

		result_wbhv1 = result_wbhv1 - val;

		////////////////////////////////////////////////////////////////////////////////////
		//Drive Hi
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, -1 * Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, -1 * Drive_Current_Hi_A);
			CheckError(ret, __LINE__);
		}

		//Measure Hi
		
		_util->Wait_Sec(Measure_Delay_s);

		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		//if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->PMUMeasure(Measure_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
		//	CheckError(ret, __LINE__);
		//}
		//else
		//{
		//	ret = smu->ReadVoltage(Measure_Pin_PN, diffpn_V);
		//	CheckError(ret, __LINE__);
		//}

		ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
		CheckError(ret, __LINE__);

		diffpn_V = (diffpn_V-c)/m;

		result_whv2 = Math::Abs(diffpn_V);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_wbhv2);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_wbhv2);
			CheckError(ret, __LINE__);
		}

		result_wbhv2 = result_wbhv2 - val;

		//Drive 0
		if (moduleType_Drive_P == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_P, 0);
			CheckError(ret, __LINE__);
		}

		if (moduleType_Drive_N == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->DriveCurrent(Drive_Pin_N, 0);
			CheckError(ret, __LINE__);
		}

		////////////////////////////////////////////////////////////////////////////////////
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		//Measure

		_util->Wait_Sec(On_Delay_s);
		
		#ifdef USE_GNDS
		if ((Test != TEST_IF4600_PKG))
		{
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			ret = smu->ReadVoltage("GND_MUX_SENSE", val);
			CheckError(ret, __LINE__);
		}
		#endif

		//if (moduleType_Meas_PN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->PMUMeasure(Measure_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
		//	CheckError(ret, __LINE__);
		//}
		//else
		//{
		//	ret = smu->ReadVoltage(Measure_Pin_PN, diffpn_V);
		//	CheckError(ret, __LINE__);
		//}

		ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
		CheckError(ret, __LINE__);

		diffpn_V = (diffpn_V-c)/m;

		result_whi = (Math::Abs(diffpn_V))/(CONST_Rw);

		result_whi = result_whi*(1 - 0.09*result_whi/0.07); //follow Catalyst's equation

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_whvx);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result_whvx);
			CheckError(ret, __LINE__);
		}

		result_whvx = result_whvx - val;

		////////////////////////////////////////////////////////////////////////////////////

		double gain		= 0;
		double offset	= 0;
		double result_wvcm = 0;

		//1-2mV can affect gain results by 0.2-0.3!

		gain = (result_wbhv2 - result_wbhv1) / (result_whv2 - result_whv1); //Direct use DMM to measure will get better correlation.
		offset = result_wbhv2 - (gain * result_whv2); //Don't care correlation as customer's datalog also fluctuate a lot
		result_wvcm = result_whvx - (result_whi * (CONST_Rw/2));

		result[0] = gain;
		result[1] = offset - Target;
		result[2] = result_whi;
		result[3] = result_wvcm;
		result[4] = Target;

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_wdbhv(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// result variables
		array<int>^ result_adc		= gcnew array<int>(2);
		double RhNom	= 78.3;
		double result = 0.0;
		

		//Get test condition from techFlow
		bool isCurrentTPBypassed	= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		
		String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));	
		String ^ Vector_File_ADCLo		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADCLo"));
		String ^ Vector_File_ADCHi		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADCHi"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		int Step				= (int)(tf_TestItemCondition_Cast("Step"));
	
		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);
		#endif

		//ret = RunVectorFile(Vector_File_Hsel);
		//CheckError(ret, __LINE__);
	
		for (int i = 0 ; i < Step ; i++)
		{
			switch(i)
			{
				case 0:
					
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File_ADCLo);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File_ADCLo);
				CheckError(ret, __LINE__);
				#endif

				break;

				case 1:
										
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File_ADCHi);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File_ADCHi);
				CheckError(ret, __LINE__);
				#endif

				break;
			}	

			_util->Wait_Sec(Measure_Delay_s);

			#ifndef USE_SPI
			ret = ReadVector(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#endif

			result_adc[i] = data;
					
		}

		//processing result
		double rw		= 0;	
		double delta	= 0;

		delta = (10.24e-3 + (3.463e-3 * 6)) -  (10.24e-3 + (3.463e-3 * 0)); //ISS = 0 & 6. Follow the formula in datasheet page18. 

		result = ((result_adc[1] - result_adc[0]) * 1e-3) / delta ; 

		tf_SetResult(TPName[0], result + GetOffset(TPDispName[0]));
	
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_fhcr(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result		= gcnew array<double>(10);

		//hardware constant	
		double RhNom		= 78.3; //follow catalyst RH+RH1
		
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();
	
		// result variables
		int result_adc		= 0; 
		double result_flt		= 0; 
	
	
		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;

		String ^ Test_Pin			= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

		String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;

		// Check whether resource is SMU or DM for all Test Pin
		// DVCI pin (FLTMUX)
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, 0 );
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Clamp_Vo_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}
		
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Hsel);
		CheckError(ret, __LINE__);

		#endif

		// Measure FLTMUX pin
		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_flt);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadCurrent(Test_Pin,  result_flt);
			CheckError(ret, __LINE__);
		}

		#ifdef USE_GNDS
		if (Test != TEST_IF4600_PKG)
		{
			double val = 0;
			ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
			CheckError(ret, __LINE__);
			result_flt = result_flt - val;
		}
		#endif

		// setup to get digital reading from adc	
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_ADC);
		CheckError(ret, __LINE__);
		ret = ReadVector(Vector_File_ReadADC, result_adc);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_ADC);
		CheckError(ret, __LINE__);
		ret = ReadSPI(Vector_File_ReadADC, result_adc);
		CheckError(ret, __LINE__);
		#endif	
				
		//processing result
		double afhcr	= 0;	
		double dfhcr	= 0;

		afhcr = (result_flt * 143) - 71.4;	//follow catalyst
		dfhcr = result_adc * 0.715;			//follow catalyst
	
		tf_SetResult(TPName[0], ((afhcr/CONST_RhNom) - 1)*100 + GetOffset(TPDispName[0]));
		tf_SetResult(TPName[1], ((dfhcr/CONST_RhNom) - 1)*100 + GetOffset(TPDispName[1]));

		if (total_tp > 2)
			tf_SetResult(TPName[2], CONST_RhNom);
	
		// Power down
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}
		
		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->DPINOff(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OffSmuPin(Test_Pin);
			CheckError(ret, __LINE__);
		}
	
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_hbhi(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result		= gcnew array<double>(10);

		double RhNom		= 78.3; //follow catalyst RH+RH1
		int reading_adc		= 0; 

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
			result[i]		= 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// result variables
		array<double> ^ result_htr	= gcnew array<double>(5);
		array<double> ^ result_hbhi = gcnew array<double>(5);
		array<double> ^ result_adc	= gcnew array<double>(5);

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;

		String ^ Test_Pin_0			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_0"));
		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		String ^ Test_Pin_1			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_1"));
		double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
		
		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;

		// Check whether resource is SMU or DM for all Test Pin
		// DVCI pin (FLTMUX)
		try
		{
			ret = smu->QueryModuleType(Test_Pin_0, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_0, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_0, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin_0, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin_0, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_0, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_0);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_0, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin_0, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin_0, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_0, false, false);
			CheckError(ret, __LINE__);
		}
		
		// DICV pin (Heater)
		try
		{
			ret = smu->QueryModuleType(Test_Pin_1, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_1, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_1, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_1, Clamp_Vo_V, -2); //
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_1, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_1, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_1);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_1, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_1, Clamp_Vo_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_1, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_1, false, false);
			CheckError(ret, __LINE__);
		}
				
		_util->Wait_Sec(On_Delay_s);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#endif

		String ^ vector_file;
		// 5 steps sweep
		int steps = 5;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i = 0 ; i < steps; i++)
		{
			
			// get analog reading
			
			switch (i)
				{
				case 0:
					vector_file = Vector_File_Sweep + "1";  
					break;
				case 1:
					vector_file = Vector_File_Sweep + "35";
					break;
				case 2:
					vector_file = Vector_File_Sweep + "103";
					break;
				case 3:
					vector_file = Vector_File_Sweep + "165";
					break;
				case 4:
					vector_file = Vector_File_Sweep + "228";
					break;
				}
			
			#ifndef USE_SPI
			ret = RunVectorFile(vector_file);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(vector_file);
			CheckError(ret, __LINE__);
			#endif

			_util->Wait_Sec(Measure_Delay_s);
			
			// Measure FLTMUX pin
			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_0, DM_CONST_MEASURECURRENT, result_hbhi[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent(Test_Pin_0,  result_hbhi[i]);
				CheckError(ret, __LINE__);
			}

			double val = 0;
			#ifdef USE_GNDS
			if (Test != TEST_IF4600_PKG)
			{
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(ret, __LINE__);
			}
			#endif

			// Measure Heater pin
			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_1, DM_CONST_MEASUREVOLTAGE, result_htr[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_1,  result_htr[i]);
				CheckError(ret, __LINE__);
			}

			result_htr[i] = result_htr[i] - val;
		
			result_htr[i] = result_htr[i] / CONST_RhNom;
			result_hbhi[i] = result_hbhi[i]*-1;
		
			// setup to get digital reading from adc	

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_ADC);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File_ADC);
			CheckError(ret, __LINE__);
			#endif

			#ifndef USE_SPI
			ret = ReadVector(Vector_File_ReadADC, reading_adc);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File_ReadADC, reading_adc);
			CheckError(ret, __LINE__);
			#endif
				
			result_adc[i] = (double)reading_adc;

		}
 
		// Calculation 

		// htr VS adc
		double slope_d	= 0;
		double offset_d = 0;
		 
		_util->line_fit_d(result_htr, result_adc, 5, slope_d, offset_d);
		
		// htr VS fltmux
		double slope_a	= 0;
		double offset_a = 0;
		
		_util->line_fit_d(result_htr, result_hbhi, 5, slope_a, offset_a);
		
		// htr VS adc
		double adc_iav	= 0;
		double adc_ioff = 0;
		
		_util->line_fit_d(result_adc, result_hbhi, 5, adc_iav, adc_ioff);
	
		// min max
		double K_min, K_max		= 0;

		K_min = result_hbhi[0];
		K_max = result_hbhi[4];

		result[0] = 1/slope_a;
		result[1] = offset_a;
		result[2] = 1/slope_d;
		result[3] = offset_d;
		result[4] = K_min;
		result[5] = K_max;
		result[6] = adc_iav;
		result[7] = adc_ioff;
		
		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (_util->IsInf(result[i]) == false)
					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				else
					tf_SetResult(TPName[i], -999 + GetOffset(TPDispName[i]));
			}			
		}

		// Power down
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_0, moduleType);
		//	CheckError(ret, __LINE__);
		//}
		//
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleType = DM_CONST_MODULE_TYPE;
		//}
		//
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUVoltageLevel(Test_Pin_0, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_0);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveVoltage(Test_Pin_0, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_0);
		//	CheckError(ret, __LINE__);
		//}
		//
		//// DICV pin (Heater)
		//try
		//{
		//	ret = smu->QueryModuleType(Test_Pin_1, moduleType);
		//	CheckError(ret, __LINE__);
		//}
		//catch (Exception ^) //not a smu resource if exception occurs
		//{
		//	moduleType = DM_CONST_MODULE_TYPE;
		//}
	
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_1, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_1);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_1, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_1);
		//	CheckError(ret, __LINE__);
		//}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_idrheat(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// result variables
		double result_adc	= 0.0;
		double pht		= 0.0;	
		double vht		= 0.0;
		double idrheat	= 0.0;
		double result	= 0.0;
		double RhNom	= 78.3;
		

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		double dflt_reg_set			= (double)tf_TestItemCondition_Cast("dflt_reg_set"); // this is the key point to varies between W & R

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		
		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;

		
		//Init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);
		#endif
		
		for (int i = 1 ; i < HDS + 1; i++)
		{
			String ^ Vector_File_Hsel = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_Hsel"));

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_Hsel);
			CheckError(ret, __LINE__);
			ret = RunVectorFile(Vector_File_ADC);
			CheckError(ret, __LINE__);
			ret = ReadVector(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File_Hsel);
			CheckError(ret, __LINE__);
			ret = RunSPI(Vector_File_ADC);
			CheckError(ret, __LINE__);
			ret = ReadSPI(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#endif
	
			result_adc = data >> 0;

			// Calculation 
			pht = 4e-3 + (0.708e-3 * dflt_reg_set);		// 140 is the default value of RDHT_W in dsio_sif_map
			vht = sqrt(pht*RhNom);						
			idrheat = vht / (0.286e-3 * result_adc);	
			result = ((idrheat/RhNom) - 1)*100;

			tf_SetResult(TPName[i], result + GetOffset(TPDispName[i]));
		}

		tf_SetResult(TPName[0], RhNom + GetOffset(TPDispName[0]));

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_sbhi(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result		= gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
			result[i]		= 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// hardware constant
		double R30			= 45.3;
		double R31			= 10;
		double Rfhs			= R31 + (2*R30);
		
		// result variables
		array<double> ^ result_sbhi	= gcnew array<double>(5);
		array<double> ^ result_fhs	= gcnew array<double>(5);
		array<double> ^ result_adc	= gcnew array<double>(5);
		double diffp_V = 0.0;
		double diffn_V = 0.0;

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;

		String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	
		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
		String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int TestPin0_moduleType  = 0;
		unsigned int TestPin1_moduleType  = 0;

		// Check whether resource is SMU or DM for all Test Pin
		// DVCI pin (FLTMUX)
		String ^ Test_Pin = "FLTMUX";
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}

		// DICV pin (TAxP)
		try
		{
			ret = smu->QueryModuleType(Test_Pin_P, TestPin0_moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			TestPin0_moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + TestPin0_moduleType.ToString("X"));
		}

		if (TestPin0_moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2); //
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_P);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_P, Clamp_Vo_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_P, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_P, false, false);
			CheckError(ret, __LINE__);
		}
		
		// DICV pin (TAxN)
		try
		{
			ret = smu->QueryModuleType(Test_Pin_N, TestPin1_moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			TestPin1_moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + TestPin1_moduleType.ToString("X"));
		}

		if (TestPin1_moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2); //
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_N);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin_N, Clamp_Vo_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin_N, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin_N, false, false);
			CheckError(ret, __LINE__);
		}
		
		//_util->Wait_Sec(On_Delay_s);

		//Init

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);		
		ret = RunSPI(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#endif

		// 5 steps sweep
		int steps = 5;
		
		String ^ vector_file_str = "" ;

		for (int i = 0 ; i < steps; i++)
		{
			
			// get analog reading
			
			switch (i)
			{
				case 0:
					vector_file_str = Vector_File_Sweep + "7";  
					break;
				case 1:
					vector_file_str = Vector_File_Sweep + "12";
					break;
				case 2:
					vector_file_str = Vector_File_Sweep + "16";
					break;
				case 3:
					vector_file_str = Vector_File_Sweep + "24";
					break;
				case 4:
					vector_file_str = Vector_File_Sweep + "29";
					break;
			}
		
			#ifndef USE_SPI
			ret = RunVectorFile(vector_file_str);
			CheckError(ret, __LINE__);
			#else
		
			ret = RunSPI(vector_file_str);
			CheckError(ret, __LINE__);
			#endif

			ret = RunVectorFile(vector_file_str);
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(Measure_Delay_s);
				
			// Measure TAxP
			if (TestPin0_moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_P,  diffp_V);
				CheckError(ret, __LINE__);
			}

			// Measure TAxN
			if (TestPin1_moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
				CheckError(ret, __LINE__);
			}

			// Measure FLTMUX pin
			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, result_sbhi[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent("FLTMUX",  result_sbhi[i]);
				CheckError(ret, __LINE__);
			}

			result_fhs[i] = (Math::Abs(diffp_V - diffn_V)) / Rfhs;

			result_sbhi[i] = result_sbhi[i]*-1;
		
			// setup to get digital reading from adc	

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_ADC);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = ReadVector(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File_ADC);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = ReadSPI(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);

			#endif
			
			result_adc[i] = data;
		}
 
		// Calculation 

		// fhs VS fltmux
		double slope_a	= 0;
		double offset_a = 0;
		
		_util->line_fit_d(result_fhs, result_sbhi, 5, slope_a, offset_a);
		
		// adc vs fhs
		double slope_d	= 0;
		double offset_d = 0;
		
		_util->line_fit_d(result_adc, result_fhs, 5, slope_d, offset_d);
	
		// min max
	
		double K_min, K_mid, K_max					= 0;
		double vfhs_min, vfhs_mid, vfhs_max 		= 0;
		double dsbhi_min, dsbhi_mid, dsbhi_max		= 0;

		vfhs_min = 48.96e-3 + (12* 8.16e-3); //BIAS_V = 12. Follow Catalyst's formula
		vfhs_mid = 48.96e-3 + (16* 8.16e-3); //BIAS_V = 16. Follow Catalyst's formula
		vfhs_max = 48.96e-3 + (29* 8.16e-3); //BIAS_V = 29. Follow Catalyst's formula

		dsbhi_min = 34e-6 * result_adc[1]; //BIAS_V = 12. Follow Catalyst's formula
		dsbhi_mid = 34e-6 * result_adc[2]; //BIAS_V = 16. Follow Catalyst's formula
		dsbhi_max = 34e-6 * result_adc[4]; //BIAS_V = 29. Follow Catalyst's formula

		K_min = ((vfhs_min / dsbhi_min) / Rfhs) - 1;
		K_mid = ((vfhs_mid / dsbhi_mid) / Rfhs) - 1;
		K_max = ((vfhs_max / dsbhi_max) / Rfhs) - 1;

		result[0] = 1/slope_a;
		result[1] = offset_a;
		result[2] = slope_d;
		result[3] = offset_d * 1000;
		result[4] = K_min*100;//display in percentage
		result[5] = K_mid*100;//display in percentage
		result[6] = K_max*100;//display in percentage
		result[7] = Rfhs;
		
		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (_util->IsInf(result[i]) == false)
					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				else
					tf_SetResult(TPName[i], -999 + GetOffset(TPDispName[i]));
			}			
		}
	
		// Power down
		//{
		//	moduleType = DM_CONST_MODULE_TYPE;
		//}
		//
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveVoltage(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin);
		//	CheckError(ret, __LINE__);
		//}

		//if (TestPin0_moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//}

		//if (TestPin1_moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_sbhi2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result		= gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
			result[i]		= 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// hardware constant
		double R30			= 45.3;
		double R31			= 10;
		double Rfhs			= R31 + (2*R30);
		
		// result variables
		array<double> ^ result_sbhi	= gcnew array<double>(5);
		array<double> ^ result_fhs	= gcnew array<double>(5);
		array<double> ^ result_adc	= gcnew array<double>(5);
		double diffp_V = 0.0;
		double diffn_V = 0.0;
		double diffpn_V = 0.0;

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;

		String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	
		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
		String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0], 1); //MUX to DiffAmp
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypePN  = 0;

		// Check whether resource is SMU or DM for all Test Pin
		// DVCI pin (FLTMUX)
		String ^ Test_Pin = "FLTMUX";
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}


		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}

		// DICV pin (TAxPN)		
		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Clamp_Vo_V, -2); //
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin_PN);
			CheckError(ret, __LINE__);
		}
		
		//_util->Wait_Sec(On_Delay_s);

		//Init

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);		
		ret = RunSPI(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#endif

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];
		}

		// 5 steps sweep
		int steps = 5;
		
		String ^ vector_file_str = "" ;

		for (int i = 0 ; i < steps; i++)
		{
			
			// get analog reading
			
			switch (i)
			{
				case 0:
					vector_file_str = Vector_File_Sweep + "7";  
					break;
				case 1:
					vector_file_str = Vector_File_Sweep + "12";
					break;
				case 2:
					vector_file_str = Vector_File_Sweep + "16";
					break;
				case 3:
					vector_file_str = Vector_File_Sweep + "24";
					break;
				case 4:
					vector_file_str = Vector_File_Sweep + "29";
					break;
			}
		
			#ifndef USE_SPI
			ret = RunVectorFile(vector_file_str);
			CheckError(ret, __LINE__);
			#else
		
			ret = RunSPI(vector_file_str);
			CheckError(ret, __LINE__);
			#endif

			ret = RunVectorFile(vector_file_str);
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(Measure_Delay_s);
				
			// Measure TAxPN
			if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
				CheckError(ret, __LINE__);
			}
			
			// Measure FLTMUX pin
			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, result_sbhi[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent("FLTMUX",  result_sbhi[i]);
				CheckError(ret, __LINE__);
			}

			
			//DUT card & Probe card inversed
			if((TIDispName->Contains("hs0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card is inversed at HS0
					diffpn_V = -1*diffpn_V;
			else if((TIDispName->Contains("hs1") == true) && (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2)) //Probe card is inversed at HS1
					diffpn_V = -1*diffpn_V;

			result_fhs[i] = (Math::Abs((diffpn_V-c)/m)) / Rfhs;

			result_sbhi[i] = result_sbhi[i]*-1;
		
			// setup to get digital reading from adc	

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_ADC);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = ReadVector(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File_ADC);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = ReadSPI(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);

			#endif
			
			result_adc[i] = data;
		}
 
		// Calculation 

		// fhs VS fltmux
		double slope_a	= 0;
		double offset_a = 0;
		
		_util->line_fit_d(result_fhs, result_sbhi, 5, slope_a, offset_a);
		
		// adc vs fhs
		double slope_d	= 0;
		double offset_d = 0;
		
		_util->line_fit_d(result_adc, result_fhs, 5, slope_d, offset_d);
	
		// min max
	
		double K_min, K_mid, K_max					= 0;
		double vfhs_min, vfhs_mid, vfhs_max 		= 0;
		double dsbhi_min, dsbhi_mid, dsbhi_max		= 0;

		vfhs_min = 48.96e-3 + (12* 8.16e-3); //BIAS_V = 12. Follow Catalyst's formula
		vfhs_mid = 48.96e-3 + (16* 8.16e-3); //BIAS_V = 16. Follow Catalyst's formula
		vfhs_max = 48.96e-3 + (29* 8.16e-3); //BIAS_V = 29. Follow Catalyst's formula

		dsbhi_min = 34e-6 * result_adc[1]; //BIAS_V = 12. Follow Catalyst's formula
		dsbhi_mid = 34e-6 * result_adc[2]; //BIAS_V = 16. Follow Catalyst's formula
		dsbhi_max = 34e-6 * result_adc[4]; //BIAS_V = 29. Follow Catalyst's formula

		K_min = ((vfhs_min / dsbhi_min) / Rfhs) - 1;
		K_mid = ((vfhs_mid / dsbhi_mid) / Rfhs) - 1;
		K_max = ((vfhs_max / dsbhi_max) / Rfhs) - 1;

		result[0] = 1/slope_a;
		result[1] = offset_a;
		result[2] = slope_d;
		result[3] = offset_d * 1000;
		result[4] = K_min*100;//display in percentage
		result[5] = K_mid*100;//display in percentage
		result[6] = K_max*100;//display in percentage
		result[7] = Rfhs;
		
		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (_util->IsInf(result[i]) == false)
					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				else
					tf_SetResult(TPName[i], -999 + GetOffset(TPDispName[i]));
			}			
		}
	
		// Power down
		//{
		//	moduleType = DM_CONST_MODULE_TYPE;
		//}
		//
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveVoltage(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin);
		//	CheckError(ret, __LINE__);
		//}

		//if (TestPin0_moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//}

		//if (TestPin1_moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_sbhi3(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result		= gcnew array<double>(10);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
			result[i]		= 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// hardware constant
		double R30			= 45.3;
		double R31			= 10;
		double Rfhs			= R31 + (2*R30);
		
		// result variables
		array<double> ^ result_sbhi	= gcnew array<double>(5);
		array<double> ^ result_fhs	= gcnew array<double>(5);
		array<double> ^ result_adc	= gcnew array<double>(5);
		double diffp_V = 0.0;
		double diffn_V = 0.0;
		double diffpn_V = 0.0;

		//Get test condition from techFlow
		bool isCurrentTPBypassed= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;

		String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	
		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
		double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		
		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
		String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));

		String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0], 1); //MUX to DiffAmp
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int moduleTypePN  = 0;

		// Check whether resource is SMU or DM for all Test Pin
		// DVCI pin (FLTMUX)
		String ^ Test_Pin = "FLTMUX";
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Io_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
		}

		// DICV pin (TAxPN)		
		try
		{
			ret = smu->QueryModuleType(Test_Pin_PN, moduleTypePN);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleTypePN = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin_PN module type=" + moduleTypePN.ToString("X"));
		}

		//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->Force(Test_Pin_PN, DM_CONST_FORCE_STATE_PMU);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUOutputFunction(Test_Pin_PN, DM_CONST_DICV);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUVoltageLimit(Test_Pin_PN, Clamp_Vo_V, -2); //
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_PN, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->ConfigurePMUSamplingTime(Test_Pin_PN, NPLC, DM_CONST_PLC);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn(Test_Pin_PN);
		//	CheckError(ret, __LINE__);
		//}

		//MTX_SMU
		ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage("MTX_SMU", 2);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent("MTX_SMU", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("MTX_SMU", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		//_util->Wait_Sec(On_Delay_s);

		//Init

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);		
		ret = RunSPI(Vector_File_Hsel);
		CheckError(ret, __LINE__);
		#endif

		//query for DIffAmp gain
		double m = 3;
		double c = 0;
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			m = _glob->DA_GainError[0];
			c = _glob->DA_OffsetError[0];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			m = _glob->DA_GainError[1];
			c = _glob->DA_OffsetError[1];

			ret = OnOffCbit(CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(ret, __LINE__);
		}

		// 5 steps sweep
		int steps = 5;
		
		String ^ vector_file_str = "" ;

		for (int i = 0 ; i < steps; i++)
		{
			
			// get analog reading
			
			switch (i)
			{
				case 0:
					vector_file_str = Vector_File_Sweep + "7";  
					break;
				case 1:
					vector_file_str = Vector_File_Sweep + "12";
					break;
				case 2:
					vector_file_str = Vector_File_Sweep + "16";
					break;
				case 3:
					vector_file_str = Vector_File_Sweep + "24";
					break;
				case 4:
					vector_file_str = Vector_File_Sweep + "29";
					break;
			}
		
			#ifndef USE_SPI
			ret = RunVectorFile(vector_file_str);
			CheckError(ret, __LINE__);
			#else
		
			ret = RunSPI(vector_file_str);
			CheckError(ret, __LINE__);
			#endif

			ret = RunVectorFile(vector_file_str);
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(Measure_Delay_s);
				
			// Measure TAxPN
			//if (moduleTypePN == DM_CONST_MODULE_TYPE) //dm
			//{
			//	ret = dm->PMUMeasure(Test_Pin_PN, DM_CONST_MEASUREVOLTAGE, diffpn_V);
			//	CheckError(ret, __LINE__);
			//}

			ret = smu->ReadVoltage("MTX_SMU", diffpn_V);
			CheckError(ret, __LINE__);
			
			// Measure FLTMUX pin
			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, result_sbhi[i]);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = smu->ReadCurrent("FLTMUX",  result_sbhi[i]);
				CheckError(ret, __LINE__);
			}

			//DUT card & Probe card inversed
			if((TIDispName->Contains("hs0") == true) && (Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)) //DUT card is inversed at HS0
					diffpn_V = -1*diffpn_V;
			else if((TIDispName->Contains("hs1") == true) && (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2)) //Probe card is inversed at HS1
					diffpn_V = -1*diffpn_V;

			result_fhs[i] = (Math::Abs((diffpn_V-c)/m)) / Rfhs;

			result_sbhi[i] = result_sbhi[i]*-1;
		
			// setup to get digital reading from adc	

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_ADC);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = ReadVector(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File_ADC);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = ReadSPI(Vector_File_ReadADC, data);
			CheckError(ret, __LINE__);

			#endif
			
			result_adc[i] = data;
		}
 
		// Calculation 

		// fhs VS fltmux
		double slope_a	= 0;
		double offset_a = 0;
		
		_util->line_fit_d(result_fhs, result_sbhi, 5, slope_a, offset_a);
		
		// adc vs fhs
		double slope_d	= 0;
		double offset_d = 0;
		
		_util->line_fit_d(result_adc, result_fhs, 5, slope_d, offset_d);
	
		// min max
	
		double K_min, K_mid, K_max					= 0;
		double vfhs_min, vfhs_mid, vfhs_max 		= 0;
		double dsbhi_min, dsbhi_mid, dsbhi_max		= 0;

		vfhs_min = 48.96e-3 + (12* 8.16e-3); //BIAS_V = 12. Follow Catalyst's formula
		vfhs_mid = 48.96e-3 + (16* 8.16e-3); //BIAS_V = 16. Follow Catalyst's formula
		vfhs_max = 48.96e-3 + (29* 8.16e-3); //BIAS_V = 29. Follow Catalyst's formula

		dsbhi_min = 34e-6 * result_adc[1]; //BIAS_V = 12. Follow Catalyst's formula
		dsbhi_mid = 34e-6 * result_adc[2]; //BIAS_V = 16. Follow Catalyst's formula
		dsbhi_max = 34e-6 * result_adc[4]; //BIAS_V = 29. Follow Catalyst's formula

		K_min = ((vfhs_min / dsbhi_min) / Rfhs) - 1;
		K_mid = ((vfhs_mid / dsbhi_mid) / Rfhs) - 1;
		K_max = ((vfhs_max / dsbhi_max) / Rfhs) - 1;

		result[0] = 1/slope_a;
		result[1] = offset_a;
		result[2] = slope_d;
		result[3] = offset_d * 1000;
		result[4] = K_min*100;//display in percentage
		result[5] = K_mid*100;//display in percentage
		result[6] = K_max*100;//display in percentage
		result[7] = Rfhs;
		
		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				if (_util->IsInf(result[i]) == false)
					tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
				else
					tf_SetResult(TPName[i], -999 + GetOffset(TPDispName[i]));
			}			
		}
	
		// Power down
		//{
		//	moduleType = DM_CONST_MODULE_TYPE;
		//}
		//
		//if (moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveVoltage(Test_Pin, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin);
		//	CheckError(ret, __LINE__);
		//}

		//if (TestPin0_moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_P, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_P);
		//	CheckError(ret, __LINE__);
		//}

		//if (TestPin1_moduleType == DM_CONST_MODULE_TYPE) //dm
		//{
		//	ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOff(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//}
		//else //smu
		//{
		//	ret = smu->DriveCurrent(Test_Pin_N, 0);
		//	CheckError(ret, __LINE__);
		//	ret = smu->OffSmuPin(Test_Pin_N);
		//	CheckError(ret, __LINE__);
		//}
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_flt_wr(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp				= (int)tf_TPCount();
		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result		= gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i]	= tf_TestParameter_DisplayName(i);
			TPName[i]		= tf_TestParameter_Name(i);
			result[i]		= 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		// result variables
		double diffp_V		= 0;
		double diffn_V		= 0;

		array<double> ^ result_trip = gcnew array<double>(HDS);
		for (int i=0; i<HDS; i++)
		{
			result_trip[i] = 0;
		}

		//Get test condition from techFlow
		bool isCurrentTPBypassed	= false;
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel				= _glob->SPD_Channel_Number;

		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			
		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));

		int Start_Data				= (int)(tf_TestItemCondition_Cast("Start_Data"));
		int Stop_Data				= (int)(tf_TestItemCondition_Cast("Stop_Data"));
		int Compare_Bit				= (int)(tf_TestItemCondition_Cast("Compare_Bit"));
		int Compare_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Compare_Reg_Addr"));
		int Sweep_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

		int mask = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		array<int>^ HistoryRam = gcnew array<int>(256);	
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType  = 0;
		unsigned int TestPinP_moduleType  = 0;
		unsigned int TestPinN_moduleType  = 0;
		
		//_util->Wait_Sec(On_Delay_s);
		//Init
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Init);
		CheckError(ret, __LINE__);
		#endif
		
		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_clk_divider = (int)(200e6/spi_clk_freq - 1);
		int cpol = 0;
		int cpha = 0;
		int spi_status = 0;
		int readback = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
		//CheckError(ret, __LINE__);
		//ret = dm->SPI_NCS_ACTIVE_STATE("DM_2", spi_group, DM_CONST_SPI_NCS_ACTIVE_HIGH);
		//CheckError(ret, __LINE__);
	
		//if (Input_Channel_Delay_s == 0)
		//{
		//	ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 0);
		//	CheckError(ret, __LINE__);
		//}
		//else if (Input_Channel_Delay_s < 5e-9)
		//{
		//	ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
		//	CheckError(ret, __LINE__);
		//}
		//else
		//{
		//	ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 2);
		//	CheckError(ret, __LINE__);
		//}

		//ret = dm->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
		//CheckError(ret, __LINE__);

		//sweep register

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i = 1; i < HDS + 1 ; i++)
		{
			String ^ Vector_File_Hsel	= (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_Hsel"));
			String ^ Test_Pin_N			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin_N"));
			String ^ Test_Pin_P			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin_P"));

			ret = ResetMuxIO();
			CheckError(ret, __LINE__);
			ret = DriveMuxIO(TPDispName[i]);
			CheckError(ret, __LINE__);

			diffp_V = 0;
			diffn_V = 0;

			if (TPName[i]->Contains("wop") == true)
			{
				mask = 1 << Compare_Bit;
			}
			else
			{
				mask = Compare_Bit;
			}
	
			// DICV pin (WRxP)
			try
			{
				ret = smu->QueryModuleType(Test_Pin_P, TestPinP_moduleType);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				TestPinP_moduleType = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Test_Pin module type=" + TestPinP_moduleType.ToString("X"));
			}

			if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2); //
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_P);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_P, Clamp_Vo_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_P, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_P, false, false);
				CheckError(ret, __LINE__);
			}
			
			// DICV pin (WRxN)
			try
			{
				ret = smu->QueryModuleType(Test_Pin_N, TestPinN_moduleType);
				CheckError(ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				TestPinN_moduleType = DM_CONST_MODULE_TYPE;
			}

			if (Debug_Enable == true)
			{
				sb->AppendLine("QueryModuleType returns " + ret.ToString());
				sb->AppendLine("Test_Pin module type=" + TestPinN_moduleType.ToString("X"));
			}

			if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2); 
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin_N);
				CheckError(ret, __LINE__);
			}
			else //smu
			{
				ret = smu->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin_N, Clamp_Vo_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin_N, 0);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin_N, false, false);
				CheckError(ret, __LINE__);
			}

			//ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
			//CheckError(ret, __LINE__);

			//Set Hsel
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File_Hsel);
			CheckError(ret, __LINE__);

			ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
			CheckError(ret, __LINE__);
			#else
			//ret = OnOffSPI(1);
			//CheckError(ret, __LINE__);
			ret = RunSPI(Vector_File_Hsel);
			CheckError(ret, __LINE__);
			#endif
			
			spi_wr_byte_length = 1;

			for (int k=Start_Data; k<=Stop_Data; k++)
			{
				int datain = _util->SwapBitSequence(k, 8);

				spi_data_dir[0] = 0x0000000; 
				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
								
				ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
				CheckError(ret, __LINE__);

				spi_status = 0;

				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
					CheckError(ret, __LINE__);

					if (spi_status == 2) //0=idle, 1=busy, 2=done
						break;

					swatch.Stop();
				}

				if (spi_status == 2)
				{
					//_util->Wait_Sec(On_Delay_s);

					spi_status = 0;
					readback = 0;

					spi_data_dir[0] = 0x00000ff; 
					spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

					ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
					CheckError(ret, __LINE__);
				
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
						CheckError(ret, __LINE__);

						if (spi_status == 2) //0=idle, 1=busy, 2=done
							break;

						swatch.Stop();
					}

					ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(ret, __LINE__);

					for (int m=0; m<spi_rd_byte_length; m++)
					{
						if (spi_rd_biterror[m] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
							readback = (data & (mask & 0xff)) & 0xff;
						}
						else
						{
							readback = -999;
						}
					}

					if (readback == (mask & 0xff))
					{
						_util->Wait_Sec(Measure_Delay_s);

						// Measure WRxP
						if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
						{
							ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
							CheckError(ret, __LINE__);
						}
						else
						{
							ret = smu->ReadVoltage(Test_Pin_P, diffp_V);
							CheckError(ret, __LINE__);
						}

						if (TPName[i]->Contains("Rf_wop") == true)
						{
							// Measure WRxN
							if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
							{
								ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
								CheckError(ret, __LINE__);
							}
							else
							{
								ret = smu->ReadVoltage(Test_Pin_N, diffn_V);
								CheckError(ret, __LINE__);
							}
						}
						else
						{
							diffn_V = 0;
							#ifdef USE_GNDS
							if (Test != TEST_IF4600_PKG)
							{
								//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, diffn_V);
								ret = smu->ReadVoltage("GND_MUX_SENSE", diffn_V);
								CheckError(ret, __LINE__);
							}
							#endif
						}

						result_trip[i-1] = Math::Abs(diffp_V - diffn_V);

						break;
					}
				}
			}
			
			double result_final = 0;

			if(_glob->global_who_i[i-1] == -999 || _glob->global_who_v[i-1] == -999)
				result_final = (4000 * result_trip[i-1]) / (0.4 - result_trip[i-1]); 
			else 
				result_final = result_trip[i-1] / _glob->global_who_i[i-1];

			tf_SetResult(TPName[0], result_trip[0] + GetOffset(TPDispName[0]));
			tf_SetResult(TPName[i], result_final + GetOffset(TPDispName[i]));
		}
		
		/////////////////////////////////
		
		#ifndef USE_SPI

		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = RunVectorFile(Vector_File_End);
		CheckError(ret, __LINE__);
		#else

		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);

		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	//
	int TestProgram::seq_mux_offset(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
		String ^ Vector_File_2  = (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		double result1 = 0;
		double result2 = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		unsigned int moduleType = 0;

		// Check whether resource is SMU or DM
		try
		{
			ret = smu->QueryModuleType(Test_Pin, moduleType);
			CheckError(ret, __LINE__);
		}
		catch (Exception ^) //not a smu resource if exception occurs
		{
			moduleType = DM_CONST_MODULE_TYPE;
		}

		if (Debug_Enable == true)
		{
			sb->AppendLine("QueryModuleType returns " + ret.ToString());
			sb->AppendLine("Test_Pin module type=" + moduleType.ToString("X"));
		}

		double gnds_volt = 0.0;
		ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, gnds_volt);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}
		else //smu
		{
			OnOffCbit(11,1);
			OnOffCbit(42,1);

			ret = smu->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, 0);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = smu->DriveCurrent(Test_Pin, Drive_Io_A);
			CheckError(ret, __LINE__);
		}

		#ifndef USE_SPI
		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result1);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result1);
			CheckError(ret, __LINE__);
		}

		//Unbuffered muxoffset

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_1);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_1);
		CheckError(ret, __LINE__);
		#endif

		_util->Wait_Sec(Measure_Delay_s);

		if (moduleType == DM_CONST_MODULE_TYPE) //dm
		{
			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result2);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = smu->ReadVoltage(Test_Pin, result2);
			CheckError(ret, __LINE__);
		}

		//
		_glob->mux_offset = result1 - result2;
		tf_SetResult(TPName[0], _glob->mux_offset + GetOffset(TPDispName[0]));

		//Clean up
		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_2);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_2);
		CheckError(ret, __LINE__);
		#endif

//
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_pre_iabs_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		
		double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
		double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		
		double Input_Channel_Delay_s = 0;
		
		String ^ Vector_File	= String::Empty;
		double result			= 0;
		int result_dac			= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		array<int>^ HistoryRam = gcnew array<int>(8192);	
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
				
		// setup read iabs fuse status
		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readfuse");
		CheckError(ret, __LINE__);
		ret = ReadVector("read_p2_reg48", data);	
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_trim_readfuse");
		CheckError(ret, __LINE__);
		ret = ReadSPI("read_p2_reg48", data);
		CheckError(ret, __LINE__);
		#endif

		result_dac = (data >> 0) & 0x3F;
			
		tf_SetResult(TPName[0], result_dac + (int)GetOffset(TPDispName[0]));
		
		// setup read iabs 
		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readmux_iabs");
		CheckError(ret, __LINE__);
		#else
		//ret = OnOffSPI(1);
		//CheckError(ret, __LINE__);
		ret = RunSPI("write_trim_readmux_iabs");
		CheckError(ret, __LINE__);
		#endif
		
		if(0)
		{	// PMU measure Iabs	
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
			CheckError(ret, __LINE__);
			
			ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin,Clamp_Current_A);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Voltage_V);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
			CheckError(ret, __LINE__);
			ret = dm->DPINOff(Test_Pin);
			CheckError(ret, __LINE__);
		
		}
		else
		{
			// SMU measure Iabs
			Test_Pin = "MTX_SMU";
		
			OnOffCbit(11, 1);
			OnOffCbit(42, 1);

			Test_Pin = "MTX_SMU";
			//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
			//CheckError(ret, __LINE__);
			//ret = smu->SetBandwidth(Test_Pin, 1);
			//CheckError(ret, __LINE__);
			ret = smu->SetNPLC(Test_Pin, NPLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Current_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, Drive_Voltage_V);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);
		
			ret = smu->ReadCurrent(Test_Pin, result);
			CheckError(ret, __LINE__);
			ret = smu->OffSmuPin(Test_Pin);
			CheckError(ret, __LINE__);
		}
			
		tf_SetResult(TPName[1], -result + GetOffset(TPDispName[1])); 

		// verify result
		if (TIDispName->Contains("verify"))
		{
			int yield = _glob->iabs_fuse_toblow - _glob->iabs_blown_fuse;
			
			if ((_glob->FuseBlown) || (yield == 0))
			{
				ret = tf_SetResult(TPName[2], 0 + (int)GetOffset(TPDispName[2]));
			}
			else
			{
				ret = tf_SetResult(TPName[2], 1 + (int)GetOffset(TPDispName[2]));
			}

		}
		else 
		{
			_glob->iabs_blown_fuse = result_dac;
			_glob->iabs_pre = -result;
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		//ret = ResetMuxIO();
		//CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_pre_atemp_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		String ^ Test_Pin			= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		
		double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		_glob->Atemp_Target			= (double)(tf_TestItemCondition_Cast("Target"));	

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result	= 0;
		int result_dac	= 0;

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		int vector_engine_status = 0;
		String ^ Vector_File = String::Empty;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		// setup read atemp fuse status

		double Gnds_val = 0.0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, 0.01);
		#endif

		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readfuse");
		CheckError(ret, __LINE__);
		ret = ReadVector("read_p2_reg49", data);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_trim_readfuse");
		CheckError(ret, __LINE__);
		ret = ReadSPI("read_p2_reg49", data);
		CheckError(ret, __LINE__);
		#endif
		result_dac = (data >> 0) & 0xF;
			
		tf_SetResult(TPName[0], result_dac + (int)GetOffset(TPDispName[0]));
		
		//measure initial atemp
		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readmux_atemp");
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI("write_trim_readmux_atemp");
		CheckError(ret, __LINE__);
		#endif	

		#ifdef USE_GNDS
		ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
		#endif

		if (0)
		{
			// pmu measure
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
			CheckError(ret, __LINE__);
			
			if (Clamp_Voltage_V < 0)
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
			else 
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);
			CheckError(ret, __LINE__);
			
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
			CheckError(ret, __LINE__);
			ret = dm->DPINOff(Test_Pin);
			CheckError(ret, __LINE__);
		
		}
		else
		{
			//smu measure atemp
			ret = OnOffCbit(11, 1);
			CheckError(ret, __LINE__);
			ret = OnOffCbit(42,1);
			CheckError(ret, __LINE__);

			Test_Pin = "MTX_SMU";
			//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
			//CheckError(ret, __LINE__);
			//ret = smu->SetBandwidth(Test_Pin, 1);
			//CheckError(ret, __LINE__);
			ret = smu->SetNPLC(Test_Pin, NPLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);
			ret = smu->ReadVoltage(Test_Pin, result);
			CheckError(ret, __LINE__);
			ret = smu->OffSmuPin(Test_Pin);
			CheckError(ret, __LINE__);
		}
		
		// result and calculation
		double atemp_V  = result - Gnds_val - TRIM_COMP - _glob->mux_offset; // Compensate value
		double atemp_offset = 131.7/182.5;
		double atemp_step = 1/182.5;
		double atemp_raw = (atemp_V - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
		double atemp_target = _glob->Atemp_Target;

		tf_SetResult(TPName[1], atemp_V + GetOffset(TPDispName[1]));
		tf_SetResult(TPName[2], atemp_raw + GetOffset(TPDispName[2]));
		tf_SetResult(TPName[3], atemp_target + GetOffset(TPDispName[3]));
		tf_SetResult(TPName[4], abs(atemp_target-atemp_raw) + GetOffset(TPDispName[4]));
		tf_SetResult(TPName[4], abs(atemp_target-atemp_raw) + GetOffset(TPDispName[4]));

		// verify result
		if (TIDispName->Contains("verify"))
		{	
			int yield = _glob->atemp_fuse_toblow - _glob->atemp_blown_fuse;
			
			if ((_glob->FuseBlown) || (yield == 0))
			{ 
				tf_SetResult(TPName[5], 0 + (int)GetOffset(TPDispName[5]));
			}
			else
			{
				tf_SetResult(TPName[5], 1 + (int)GetOffset(TPDispName[5]));
			}
		}
		else 
		{
			_glob->atemp_blown_fuse = result_dac;
			_glob->atemp_pre = atemp_raw;
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_pre_vref_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result	= 0;
		int result_dac	= 0;
		double Gnds_val = 0.0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		// readlockbit
		ret = readlockbit();
		CheckError(ret, __LINE__);

		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readfuse");
		CheckError(ret, __LINE__);
		ret = ReadVector("read_p2_reg49", data);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunVectorFile("write_trim_readfuse");
		CheckError(ret, __LINE__);
		ret = ReadSPI("read_p2_reg49", data);
		CheckError(ret, __LINE__);

		#endif

		result_dac = (data >> 4) & 15;
		tf_SetResult(TPName[0], result_dac + (int)GetOffset(TPDispName[0]));

		//measure initial vref

		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readmux_vref");
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI("write_trim_readmux_vref");
		CheckError(ret, __LINE__);
		#endif

		String ^ Test_Pin = "";
		
		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, 0.01);
		ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
		#endif	
		if (0)
		{// pmu measure
			ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(ret, __LINE__);
			ret = dm->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
			CheckError(ret, __LINE__);
			
			if (Clamp_Voltage_V < 0)
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
			else 
				ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);
			CheckError(ret, __LINE__);
			
			ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
			CheckError(ret, __LINE__);
			ret = dm->DPINOn(Test_Pin);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
			CheckError(ret, __LINE__);
			ret = dm->DPINOff(Test_Pin);
			CheckError(ret, __LINE__);
		
		}else{
			//smu measure vref
			OnOffCbit(11,1);
			OnOffCbit(42,1);

			Test_Pin = "MTX_SMU";
			ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = smu->SetBandwidth(Test_Pin, 1);
			CheckError(ret, __LINE__);
			ret = smu->SetNPLC(Test_Pin, NPLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(Measure_Delay_s);
			ret = smu->ReadVoltage(Test_Pin, result);
			CheckError(ret, __LINE__);
			ret = smu->OffSmuPin(Test_Pin);
			CheckError(ret, __LINE__);
		}			
				
		
		result = result - Gnds_val - TRIM_COMP - _glob->mux_offset;
		tf_SetResult(TPName[1], result + GetOffset(TPDispName[1]));

		//yield result
		if (TIDispName->Contains("verify"))
		{
			int yield = _glob->vref_fuse_toblow - _glob->vref_blown_fuse;

			if ((_glob->FuseBlown) || (yield == 0))
			{
				ret = tf_SetResult(TPName[2], 0 + (int)GetOffset(TPDispName[2]));
				CheckError(ret, __LINE__);
			}else{
				
				ret = tf_SetResult(TPName[2], 1 + (int)GetOffset(TPDispName[2]));
				CheckError(ret, __LINE__);
			}
		}else{
			_glob->vref_blown_fuse	= result_dac;
			_glob->vref_pre			= result;
	
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_pre_whtslope_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		
		int BitMask			= 0;
		int BitShift		= 0;

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		_glob->Htslope_Target	= (double)(tf_TestItemCondition_Cast("Target"));
		//String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		
		double Input_Channel_Delay_s = 0;
		String ^ Test_Pin = "";
		String ^ Vector_File	= String::Empty;
		double result			= 0;
		int result_dac		= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		array<int>^ HistoryRam = gcnew array<int>(8192);	
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
		
		Vector_File = "write_disable_testfuse";

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif
		
		// setup read writehead fuse status
		for (int i=0; i < HDS + 1; i++)
		{
			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_W"));
			BitShift	= (int)(tf_TPCondition_Cast(TPName[i], "BitShift"));
			BitMask		= (int)(tf_TPCondition_Cast(TPName[i], "BitMask"));

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			//read whtr trim fuse status
			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_R"));

			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif

			result_dac = (data >> BitShift) & BitMask;	
			
			tf_SetResult(TPName[i], result_dac + (int)GetOffset(TPDispName[i]));
		}
		
		Test_Pin = "MTX_SMU";
		//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth(Test_Pin, 1);
		//CheckError(ret, __LINE__);
		ret = smu->SetNPLC(Test_Pin, NPLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(Test_Pin, false, false);
		CheckError(ret, __LINE__);

		// setup read slope for each head 
		String ^ Mux_Cbit_Setting = "" ;
		int trim_step_count = 2;
		
		array<int> ^ trim_step_dac = gcnew array<int>(2);
		trim_step_dac[0] = 63;
		trim_step_dac[1] = 255;
		
		array<double> ^ raw_result = gcnew array<double>(2);
		array<double> ^ slope = gcnew array<double>(2);

		double sum_slope = 0.0;
	
		double offset;
	
		for (int i = 0; i < HDS ; i++) 
		{
			for ( int j = 0 ; j < trim_step_count; j++)
			{

				Vector_File = "hw" + i + "_" + trim_step_dac[j];
				
				Mux_Cbit_Setting = "HT" + i + "W";
			
				ret = DriveCBit(Mux_Cbit_Setting);
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(Mux_Cbit_Setting);
				CheckError(ret, __LINE__);

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif

				// SMU 
				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin, result);
				CheckError(ret, __LINE__);
			
				raw_result[j] = (result*result)/78.3 ;
				
			}
			// slope calculation			

			_util->line_fit(trim_step_dac,raw_result,2, slope[i], offset);
			tf_SetResult(TPName[i+HDS+1], slope[i] + GetOffset(TPDispName[i+HDS+1]));
			sum_slope = sum_slope + slope[i];

		}
		double slope_avg = sum_slope/HDS;
		
		// Print slope average 
		if (TIDispName->StartsWith("whtslope_fuse_verify") == false)
			tf_SetResult(TPName[(HDS * 2)+1], slope_avg  + GetOffset(TPDispName[(HDS * 2)+1])); 

	//	if (_glob->trimlock == 0)
		{
			// Find best fuse comb for core trim
			double adj_core[8] = {
			0.0,	// 0: no 
			0.033,	// 1: min 
			0.066,	// 2: mid 
			0.099,	// 3: max
			0.0,	// 4: no 
			0.033,	// 5: min 
			0.066,	// 6: mid 
			0.099,	// 7: max
			};

			array<double> ^ adj_slope_core = gcnew array<double>(8);


			// calcualte adj slope core
			for (int i = 0; i < 5 ; i++)
			{	
				adj_slope_core[i] = slope_avg + (adj_core[i] * slope_avg);	
			}

			for (int i = 5; i < 8 ; i++)
			{	
				adj_slope_core[i] = slope_avg - (adj_core[i] * slope_avg);	
			}
			int fuse_dac = 0;

			fuse_dac = _util->find_closest(adj_slope_core, _glob->Htslope_Target);
			
			if(SIM)
			{
				blow_fuse(WHTRCORE, fuse_dac);
			}
		}
		// 
		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);
	
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_pre_rhtslope_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		
		int BitMask			= 0;
		int BitShift		= 0;

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		//String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		_glob->Htslope_Target			= (double)(tf_TestItemCondition_Cast("Target"));

		double Input_Channel_Delay_s = 0;
		String ^ Test_Pin = "";
		String ^ Vector_File	= String::Empty;
		double result			= 0;
		int result_dac		= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		array<int>^ HistoryRam = gcnew array<int>(8192);	
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		{
			Vector_File = "write_disable_testfuse";
		
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif
		}

		// setup read writehead fuse status
		for (int i=0; i < HDS + 1; i++)
		{
			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_W"));
			BitShift	= (int)(tf_TPCondition_Cast(TPName[i], "BitShift"));
			BitMask		= (int)(tf_TPCondition_Cast(TPName[i], "BitMask"));
		
			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			//read whtr trim fuse status
			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_R"));
						
			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif
			result_dac	= (data >> BitShift) & BitMask;	
			
			tf_SetResult(TPName[i], result_dac + (int)GetOffset(TPDispName[i]));
		}
		
		Test_Pin = "MTX_SMU";
		//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth(Test_Pin, 1);
		//CheckError(ret, __LINE__);
		ret = smu->SetNPLC(Test_Pin, NPLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(Test_Pin, false, false);
		CheckError(ret, __LINE__);

		// setup read slope for each head 
		String ^ Mux_Cbit_Setting = "" ;
		int trim_step_count = 2;
		
		array<int> ^ trim_step_dac = gcnew array<int>(2);
		trim_step_dac[0] = 63;
		trim_step_dac[1] = 255;
		
		array<double> ^ raw_result = gcnew array<double>(2);
		array<double> ^ slope = gcnew array<double>(2);

		double sum_slope = 0.0;
	
		double offset;
	
		for (int i = 0; i < HDS ; i++) 
		{
			for ( int j = 0 ; j < trim_step_count; j++)
			{

				Vector_File = "hr" + i + "_" + trim_step_dac[j];
				
				Mux_Cbit_Setting = "HT" + i + "R";
			
				ret = DriveCBit(Mux_Cbit_Setting);
				CheckError(ret, __LINE__);
				ret = DriveMuxIO(Mux_Cbit_Setting);
				CheckError(ret, __LINE__);
				
				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
		
				// SMU 

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin, result);
				CheckError(ret, __LINE__);
			
				raw_result[j] = (result*result)/78.3 ;
				
			}
			// slope calculation			

			_util->line_fit(trim_step_dac,raw_result,2, slope[i], offset);
			tf_SetResult(TPName[i+HDS+1], slope[i] + GetOffset(TPDispName[i+HDS+1]));
			sum_slope = sum_slope + slope[i];

		}
		double slope_avg = sum_slope/HDS;
		
		// Print slope average 
		if (TIDispName->StartsWith("rhtslope_fuse_verify") == false)
			tf_SetResult(TPName[(HDS * 2)+1], slope_avg + GetOffset(TPDispName[(HDS * 2)+1])); 

		// Find best fuse comb for core trim
		if (_glob->trimlock == 0)
		{
			double adj_core[8] = {
			0.0,	// 0: no 
			0.033,	// 1: min 
			0.066,	// 2: mid 
			0.099,	// 3: max
			0.0,	// 4: no 
			0.033,	// 5: min 
			0.066,	// 6: mid 
			0.099,	// 7: max
			};

			array<double> ^ adj_slope_core = gcnew array<double>(8);


			// calcualte adj slope core
			for (int i = 0; i < 5 ; i++)
			{	
				adj_slope_core[i] = slope_avg + (adj_core[i] * slope_avg);	
			}

			for (int i = 5; i < 8 ; i++)
			{	
				adj_slope_core[i] = slope_avg - (adj_core[i] * slope_avg);	
			}
			int fuse_dac = 0;

			fuse_dac = _util->find_closest(adj_slope_core, _glob->Htslope_Target);
			
			if(SIM)
			{
				blow_fuse(RHTRCORE, fuse_dac);
			}
		}
		// 
		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_post_whtslope_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		
		int BitMask			= 0;
		int BitShift		= 0;

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		//String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		
		double Input_Channel_Delay_s = 0;
		String ^ Test_Pin = "";
		String ^ Vector_File	= String::Empty;
		double result			= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		array<int>^ HistoryRam = gcnew array<int>(8192);	
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
	
		Test_Pin = "MTX_SMU";
		//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth(Test_Pin, 1);
		//CheckError(ret, __LINE__);
		ret = smu->SetNPLC(Test_Pin, NPLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(Test_Pin, false, false);
		CheckError(ret, __LINE__);

		// setup read slope for each head 
		String ^ Mux_Cbit_Setting = "" ;
		int trim_step_count = 2;
		
		array<int> ^ trim_step_dac = gcnew array<int>(2);
		trim_step_dac[0] = 63;
		trim_step_dac[1] = 255;
		
		array<double> ^ raw_result = gcnew array<double>(2);
		array<double> ^ slope = gcnew array<double>(2);

		double sum_slope = 0.0;
	
		double offset;

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif
		
		// 4 stage process

		for (int step = 0 ; step < 4; step++)
		{

			if ((step != 1) && (step != 3) )
			{ 
				for (int i = 0; i < HDS ; i++) 
				{
					for ( int j = 0 ; j < trim_step_count; j++)
					{

						Vector_File = "hw" + i + "_" + trim_step_dac[j];
						
						Mux_Cbit_Setting = "HT" + i + "W";
					
						ret = DriveCBit(Mux_Cbit_Setting);
						CheckError(ret, __LINE__);
						ret = DriveMuxIO(Mux_Cbit_Setting);
						CheckError(ret, __LINE__);
					
						#ifndef USE_SPI
						ret = RunVectorFile(Vector_File);
						CheckError(ret, __LINE__);
						#else
						ret = RunSPI(Vector_File);
						CheckError(ret, __LINE__);
						#endif
						// SMU 

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu->ReadVoltage(Test_Pin, result);
						CheckError(ret, __LINE__);
					
						raw_result[j] = (result*result)/78.3 ;
						
					}
					// slope calculation			
					_util->line_fit(trim_step_dac,raw_result,2, slope[i], offset);	
				}
			
			}
			else if(step == 1)
			{
				if(1)
				{
					// Find best fuse comb for hd trim
					double adj_hd[4] = {
						0.0,	// 0: no 
						-0.03772,	// 1: min 
						0.03976,	// 2: mid 
						0.08359,	// 3: max
					};

					int fuse_dac = 0;

					array<double> ^ adj_slope_hd = gcnew array<double>(4);

					for (int j = 0; j < HDS ; j++)
					{
						// calcualte adj slope core
						for (int i = 0; i < 4 ; i++)
						{	
							adj_slope_hd[i] = slope[j] + (adj_hd[i] * slope[j]);	
						}			
					
						fuse_dac = _util->find_closest(adj_slope_hd, _glob->Htslope_Target);
					
						if(SIM)
						{
							blow_fuse_WHD(j ,fuse_dac);
						}
					}
				}
			}
			else
			{	
				for (int j = 0; j < HDS; j++)
				{
					tf_SetResult(TPName[j], slope[j] + GetOffset(TPDispName[j]));	
				}
			}
		}

		// 
		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies

		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_post_rhtslope_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		
		int BitMask			= 0;
		int BitShift		= 0;

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		//String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		
		double Input_Channel_Delay_s = 0;
		String ^ Test_Pin = "";
		String ^ Vector_File	= String::Empty;
		double result			= 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		array<int>^ HistoryRam = gcnew array<int>(8192);	
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
	
		Test_Pin = "MTX_SMU";
		//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth(Test_Pin, 1);
		//CheckError(ret, __LINE__);
		ret = smu->SetNPLC(Test_Pin, NPLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(Test_Pin, false, false);
		CheckError(ret, __LINE__);

		// setup read slope for each head 
		String ^ Mux_Cbit_Setting = "" ;
		int trim_step_count = 2;
		
		array<int> ^ trim_step_dac = gcnew array<int>(2);
		trim_step_dac[0] = 63;
		trim_step_dac[1] = 255;
		
		array<double> ^ raw_result = gcnew array<double>(2);
		array<double> ^ slope = gcnew array<double>(2);

		double sum_slope = 0.0;
	
		double offset;
		
		// 4 stage process

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif

		for (int step = 0 ; step < 4; step++)
		{

			if ((step != 1) && (step != 3) )
			{ 
				for (int i = 0; i < HDS ; i++) 
				{
					for ( int j = 0 ; j < trim_step_count; j++)
					{

						Vector_File = "hr" + i + "_" + trim_step_dac[j];
						
						Mux_Cbit_Setting = "HT" + i + "R";
					
						ret = DriveCBit(Mux_Cbit_Setting);
						CheckError(ret, __LINE__);
						ret = DriveMuxIO(Mux_Cbit_Setting);
						CheckError(ret, __LINE__);
					
						#ifndef USE_SPI
						ret = RunVectorFile(Vector_File);
						CheckError(ret, __LINE__);
						#else
						ret = RunSPI(Vector_File);
						CheckError(ret, __LINE__);
						#endif
				
						// SMU 

						_util->Wait_Sec(Measure_Delay_s);
						ret = smu->ReadVoltage(Test_Pin, result);
						CheckError(ret, __LINE__);
					
						raw_result[j] = (result*result)/78.3 ;
						
					}
					// slope calculation			
					_util->line_fit(trim_step_dac,raw_result,2, slope[i], offset);	
				}
			
			}
			else if(step == 1)
			{
				if (_glob->trimlock == 0)
				{
					// Find best fuse comb for hd trim
					double adj_hd[4] = {
					0.0,	// 0: no 
					-0.03772,	// 1: min 
					0.03976,	// 2: mid 
					0.08359,	// 3: max
					};

					int fuse_dac = 0;

					array<double> ^ adj_slope_hd = gcnew array<double>(4);

					for (int j = 0; j < HDS ; j++)
					{
						// calcualte adj slope core
						for (int i = 0; i < 4 ; i++)
						{	
							adj_slope_hd[i] = slope[j] + (adj_hd[i] * slope[j]);	
						}			
					
						fuse_dac = _util->find_closest(adj_slope_hd, _glob->Htslope_Target);
					
						if(SIM)
						{
							blow_fuse_RHD(j ,fuse_dac);
						}
					}
				}
			}
			else
			{	
				for (int j = 0; j < HDS; j++)
				{
					tf_SetResult(TPName[j], slope[j] + GetOffset(TPDispName[j]));	
				}
			}
		}
		// 
		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies

		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = Digital_Init_State(site);
		//CheckError(ret, __LINE__);
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_wafer_id_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		int result_dac = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		int c = 0;
		
		int step = 3;

		if (TIDispName->Contains("verify"))
		{
			step = 1;
		}

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif
		
		// 3 stages procedure / check fuse -> blow fuse -> check fuse
		for (int i = 0; i < step; i++)
		{
			if (i != 1)
			{
				ret = RunVectorFile( "wafer_id_fuse" );
				CheckError(ret, __LINE__);
				
				#ifndef USE_SPI
				ret = RunVectorFile("wafer_id_fuse");
				CheckError(ret, __LINE__);
				ret = ReadVector("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI("wafer_id_fuse");
				CheckError(ret, __LINE__);
				ret = ReadSPI("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#endif

				// read testfuse
				result_dac = (data >> 3) & 0x1F;
					
				tf_SetResult(TPName[c], result_dac + (int)GetOffset(TPDispName[c]));
				c++;
					
			
			}
			else if (i == 1)
			{
				if (_glob->trimlock == 0)
				{
					//get wafer IF from scribe
					int waferID = 0; //max value = 1F, 5 bits fuse
					
					LotHierarchyVariable^ lhvar = site->FlowEngine->LotHierarchy->GetVariable("WaferID");
 
					// This will be null if techFlow’s Recipe Editor’s Sublot > Enable wafer is not enabled.
					if (lhvar != nullptr)
					{
						String ^ waferId = (String^)(lhvar->Value);
						int str_len = waferId->Length - 2;
						String ^ lastTwoChars = waferId->Substring(str_len, 2);
						waferID = _util->StrToInt(lastTwoChars);
					}

					if(SIM)
					{
						blow_fuse(WFRID, waferID); 
					}
				}
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_quadrant_id_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		int result_dac		= 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
		int c = 0;
		int step = 3;

		if (TIDispName->Contains("verify"))
		{
			step = 1;
		}

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif
		UpdateXY(site);
		
		// 3 stages procedure / check fuse -> blow fuse -> check fuse
		for (int i = 0; i < step; i++)
		{
			if (i != 1)
			{

				#ifndef USE_SPI
				ret = RunVectorFile("quadrant_id_fuse");
				CheckError(ret, __LINE__);
				ret = ReadVector("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI("quadrant_id_fuse");
				CheckError(ret, __LINE__);
				ret = ReadSPI("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#endif
			
				result_dac = (data >> 1) & 0x3;
							
				tf_SetResult(TPName[c], result_dac + (int)GetOffset(TPDispName[c]));
				c++;
			
			}
			else if (i == 1)
			{
				if (_glob->trimlock == 0)
				{
				

					int fuse_dac = 0;
					if ((_glob->Xcoord > _glob->Center_X) && ( _glob->Ycoord > _glob->Center_Y ))
					{
						fuse_dac = 1;
					}
					else if ((_glob->Xcoord > _glob->Center_X) && ( _glob->Ycoord < _glob->Center_Y ))
					{
						fuse_dac = 2;
					}
					else if ((_glob->Xcoord < _glob->Center_X) && ( _glob->Ycoord > _glob->Center_Y ))
					{
						fuse_dac = 0;
					}
					else if ((_glob->Xcoord < _glob->Center_X) && ( _glob->Ycoord < _glob->Center_Y ))
					{
						fuse_dac = 3;
					}
					
					if (SIM)
					{
						blow_fuse(QUADID,fuse_dac);
					}
				}

			}
		}
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif		
	
		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_radius_id_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result	= 0;
		int result_dac	= 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);
	
		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
		int c = 0;
		
		int step = 3;

		if (TIDispName->Contains("verify"))
		{
			step = 1;
		}

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif
		
		// 3 stages procedure / check fuse -> blow fuse -> check fuse
		for (int i = 0; i < step; i++)
		{
			if (i != 1)
			{
				
				#ifndef USE_SPI
				ret = RunVectorFile("radius_id_fuse");
				CheckError(ret, __LINE__);
				ret = ReadVector("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI("radius_id_fuse");
				CheckError(ret, __LINE__);
				ret = ReadVector("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#endif

				result_dac = (data >> 0) & 0x1;
							
				tf_SetResult(TPName[c], result_dac + (int)GetOffset(TPDispName[c]));
				c++;
		
			}
			else if (i == 1)
			{
				if (_glob->trimlock == 0)
				{
					// Find fuse for radiusID
					double innerRadius	= 0.0;
					double radialPoint	= 0.0;
					double xpart		= 0.0;
					double ypart		= 0.0;

					int fuse_dac = 0;
					
					innerRadius = (((wafer_diameter) / 2.0) * sqrt(2.0)) / 2.0; 
					xpart = (_glob->Xcoord - _glob->Center_X) * _glob->Die_Size_X;
					ypart = (_glob->Ycoord - _glob->Center_Y ) * _glob->Die_Size_Y;
					radialPoint = sqrt(pow(xpart, 2.0) + pow(ypart, 2.0));

					if(radialPoint <= innerRadius)
					{
						fuse_dac = 1;
					}
					else if(radialPoint > innerRadius)
					{
						fuse_dac = 0;
					}
					
					if (SIM)
					{
						blow_fuse(RADID,fuse_dac);
					}
				}
			}
			
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_sim_vref_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		_glob->Vref_Target			= (double)(tf_TestItemCondition_Cast("Target"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result = 0;
		array<double>^ result_arr = gcnew array<double>(16);

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		String ^ Test_Pin = "MTX_SMU";
		
		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
	
		if (((_glob->vref_blown_fuse == 0) && (_glob->trimlock == 0)) || (ForceBlowFuseSim))
		{		

			//smu measure vref
			OnOffCbit(11, 1);
			OnOffCbit(42,1);

			String ^ Test_Pin = "MTX_SMU";
			ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = smu->SetBandwidth(Test_Pin, Bandwidth);
			CheckError(ret, __LINE__);
			ret = smu->SetNPLC(Test_Pin, NPLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);

			double Gnds_val = 0.0;

			#ifdef USE_GNDS
			ret = Configure_GNDS_Mux(site, 0.01);
			#endif


			// setup to sweep measure vref
			#ifndef USE_SPI
			ret = RunVectorFile("write_trim_readmux_vref");
			CheckError(ret, __LINE__);
			ret = RunVectorFile("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_trim_readmux_vref");
			CheckError(ret, __LINE__);
			ret = RunSPI("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#endif
			
			// create vector array on the fly for to sweep trim fuse setting
			array<int>^ vec_arr = gcnew array<int>(37); // rw bit
			array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
			int dat_bit = 0;
		
			int dac_sweep	= 0;
			int dac			= _glob->TrimReg[VREF, FUSEDAC];
			int max_dac		= (dac / 2) - 1;
			int min_dac		= max_dac + 1;
			

			for (int i = 0; i < 2; i++ )
			{
				switch(i)
				{
					case 0: //max
						dac_sweep = max_dac;
						break;
					case 1: //min
						dac_sweep = min_dac;
						break;
				}
				
				dat_bit = (dac_sweep << _glob->TrimReg[VREF,BIT]);// & 16);

				#ifndef USE_SPI
				vec_arr = make_vector(0, _glob->TrimReg[VREF,PG], _glob->TrimReg[VREF,REG], dat_bit); // rw, pg, reg, dat
				ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(ret, __LINE__);
				ret = RunVectorArray(_glob->VectorArrSetNo);
				CheckError(ret, __LINE__);
				#else
				ret = WriteSPI(_glob->TrimReg[VREF,PG]-1, _glob->TrimReg[VREF,REG], dat_bit);
				CheckError(ret, __LINE__);
				#endif

				//_util->Wait_Sec(0.1);
				_util->Wait_Sec(Measure_Delay_s);
				#ifdef USE_GNDS
				ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
				#endif
				
				ret = smu->ReadVoltage(Test_Pin, result_arr[i]);
				CheckError(ret, __LINE__);

				result_arr[i] = result_arr[i] - TRIM_COMP - Gnds_val;
			
			}
			
			// find best fuses value
			double vref_max		= result_arr[0];
			double vref_min		= result_arr[1];
			double lsb			= 0.0 ;
			int fuse_dac		= 0;
			int target_dac = 0;
			double target_result = 0;
			double target_result_dac = 0;
			
			//check for max/min out
			if ((_glob->Vref_Target < vref_max) && ( _glob->Vref_Target > vref_min))
			{
				double vref_lsb = 5.2e-3;

				fuse_dac = _util->find_est_range(vref_min, vref_max, _glob->Vref_Target, _glob->TrimReg[VREF,FUSEDAC], lsb, NORM);
							
				// sweep_range to verify 

				ret = find_target(fuse_dac ,lsb ,target_dac, target_result, Measure_Delay_s, _glob->TrimReg[VREF,FUSEDAC], VREF, NORM);
				CheckError(ret, __LINE__);

				CorrectDac(target_dac, _glob->TrimReg[VREF,FUSE]);
				
				tf_SetResult(TPName[0], target_dac + (int)GetOffset(TPDispName[0]));
				tf_SetResult(TPName[1], target_result + GetOffset(TPDispName[1]));
			}
			else if(_glob->Vref_Target > vref_max) // Max Out
			{
				target_dac = max_dac;			
				tf_SetResult(TPName[0], max_dac + (int)GetOffset(TPDispName[0]));
				tf_SetResult(TPName[1], vref_max + GetOffset(TPDispName[1]));

			}
			else if(_glob->Vref_Target < vref_min) // Max Out
			{
				target_dac = min_dac;
				tf_SetResult(TPName[0], min_dac + (int)GetOffset(TPDispName[0]));
				tf_SetResult(TPName[1], vref_min + GetOffset(TPDispName[1]));
			}

			// blow fuse seq
			if (SIM)
			{
				ret = blow_fuse(VREF, target_dac);
				CheckError(ret, __LINE__);
				_glob->vref_fuse_toblow = target_dac;
			}
			
		}
		else
		{
			tf_SetResult(TPName[0], 0 + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], _glob->vref_pre + GetOffset(TPDispName[1]));
		}
	
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_sim_vref_trim_sweep(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		int debug = 1;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		_glob->Vref_Target			= (double)(tf_TestItemCondition_Cast("Target"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result = 0;
		array<double>^ result_arr = gcnew array<double>(16);

		double vih;
        double vil;
        double voh;
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		double Gnds_val = 0.0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, 0.01);
		#endif

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		if (((_glob->vref_blown_fuse == 0) && (_glob->trimlock != 0)) || (ForceBlowFuseSim))
		{

			// setup to sweep measure vref

			#ifndef USE_SPI
			ret = RunVectorFile("write_trim_readmux_vref");
			CheckError(ret, __LINE__);
			ret = RunVectorFile("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_trim_readmux_vref");
			CheckError(ret, __LINE__);
			ret = RunSPI("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#endif
			
			ofstream myfile;
			
			if (debug)
			{
				myfile.open("C://Aemulus/Debug/vref_sweep_test.txt");
			}	
			// create vector array on the fly for to sweep trim fuse setting
			array<int>^ vec_arr = gcnew array<int>(37); // rw bit
			array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
			int dat_bit = 0;
						
			#ifdef USE_GNDS
			ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
			#endif

			for (int i = 0; i < _glob->TrimReg[VREF,FUSEDAC]; i++ )
			{
				dat_bit = (i >> _glob->TrimReg[VREF,BIT]);// & 16);
			
				#ifndef USE_SPI
				vec_arr = make_vector(0, _glob->TrimReg[VREF,PG], _glob->TrimReg[VREF,REG], dat_bit); // rw, pg, reg, dat
				ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(ret, __LINE__);
				ret = RunVectorArray(_glob->VectorArrSetNo);
				CheckError(ret, __LINE__);
				#else
				ret = WriteSPI(_glob->TrimReg[VREF,PG]-1, _glob->TrimReg[VREF,REG], dat_bit);
				#endif

				String ^ Test_Pin = "";
		
			if (0)
			{// pmu measure
				ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(ret, __LINE__);
				ret = dm->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
				CheckError(ret, __LINE__);
				
				if (Clamp_Voltage_V < 0)
					ret = dm->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
				else 
					ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);
				CheckError(ret, __LINE__);
				
				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
				CheckError(ret, __LINE__);
				ret = dm->DPINOn(Test_Pin);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(ret, __LINE__);
				ret = dm->DPINOff(Test_Pin);
				CheckError(ret, __LINE__);
			
			}
			else
			{
				//smu measure vref
				OnOffCbit(11, 1);
				OnOffCbit(42,1);

				Test_Pin = "MTX_SMU";
				ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
				CheckError(ret, __LINE__);
				ret = smu->SetBandwidth(Test_Pin, 1);
				CheckError(ret, __LINE__);
				ret = smu->SetNPLC(Test_Pin, NPLC);
				CheckError(ret, __LINE__);
				ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
				CheckError(ret, __LINE__);
				ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
				CheckError(ret, __LINE__);
				ret = smu->OnSmuPin(Test_Pin, false, false);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin, result_arr[i]);
				CheckError(ret, __LINE__);
				ret = smu->OffSmuPin(Test_Pin);
				CheckError(ret, __LINE__);
			}		

			result_arr[i] = result_arr[i] - TRIM_COMP - Gnds_val;

				if (debug)
				{
					myfile << i << "\t" << result_arr[i] << "\n";
				}
			}
				if(debug)
				{
					myfile.close();
				}
			// find best fuses value
			double vref_target	= _glob->Vref_Target ;
			double vref_lsb		=  5.2e-3;
			int fuse_count		= 4;

			int fuse_dac = _util->find_closest(result_arr, vref_target);

			// blow fuse seq
			if (SIM)
			{
				ret = blow_fuse(VREF, fuse_dac);
				CheckError(ret, __LINE__);
				_glob->vref_fuse_toblow = fuse_dac;
			}
		
			tf_SetResult(TPName[0], fuse_dac + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], result_arr[fuse_dac] + GetOffset(TPDispName[1]));
		
		}else{
			tf_SetResult(TPName[0], 0 + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], _glob->vref_pre + GetOffset(TPDispName[1]));
		}

		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_sim_atemp_trim_sweep(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		_glob->Atemp_Target			= (double)(tf_TestItemCondition_Cast("Target"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result = 0;
		array<double>^ result_arr = gcnew array<double>(16);
		array<double>^ atemp_raw_arr = gcnew array<double>(16);
		array<double>^atemp_V_arr = gcnew array<double>(16);
		
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		ret = smu->SetBandwidth("VCC", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VCC", true, false);
		CheckError(ret, __LINE__);

		ret = smu->SetBandwidth("VEE", Bandwidth);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin("VEE", true, false);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		// calculation constant
		double atemp_offset = 131.7/182.5;
		double atemp_step = 1/182.5;
			

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		double Gnds_val = 0.0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, 0.01);
		#endif

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		_util->Wait_Sec(On_Delay_s);
		
		String ^ Test_Pin = "MTX_SMU";
			
		if (((_glob->atemp_blown_fuse == 0) && (_glob->trimlock == 0)) || (ForceBlowFuseSim))
		{

			// setup testfuse
			#ifndef USE_SPI
			ret = RunVectorFile("write_trim_readmux_atemp");
			CheckError(ret, __LINE__);
			ret = RunVectorFile("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_trim_readmux_atemp");
			CheckError(ret, __LINE__);
			ret = RunSPI("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#endif

			array<int>^ vec_arr = gcnew array<int>(37); // rw bit
			array<int>^ vec1_arr = gcnew array<int>(37); // rw bit

			ofstream myfile;

			if(Debug_Enable)
			{
				myfile.open("C://Aemulus/Debug/atemp_trim_sweep.txt");
			}
			// create vector array on the fly for to sweep trim fuse setting
			int dat_bit = 0;

			//Setup measurement resource
			ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = smu->SetBandwidth(Test_Pin, 1);
			CheckError(ret, __LINE__);
			ret = smu->SetNPLC(Test_Pin, NPLC);
			CheckError(ret, __LINE__);
			ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
			CheckError(ret, __LINE__);
			ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			
			OnOffCbit(11,1);
			OnOffCbit(42,1);

			#ifdef USE_GNDS
			ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
			#endif

			// Sweep measurement
			for (int i = 0; i < _glob->TrimReg[ATEMP,FUSEDAC]; i++ )
			{
				dat_bit = (i << _glob->TrimReg[ATEMP,BIT]) & 0xF0;
				#ifndef USE_SPI
				vec_arr = make_vector( 0, _glob->TrimReg[ATEMP,PG], _glob->TrimReg[ATEMP,REG], dat_bit); // rw, pg, reg, dat
				ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(ret, __LINE__);
				ret = RunVectorArray(_glob->VectorArrSetNo);
				CheckError(ret, __LINE__);
				#else
				ret = WriteSPI(_glob->TrimReg[ATEMP,PG]-1, _glob->TrimReg[ATEMP,REG], dat_bit);
				#endif

				//smu measure
				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin, result);
				CheckError(ret, __LINE__);

				atemp_V_arr[i]  = result - Gnds_val - _glob->mux_offset; // Compensate value
				atemp_raw_arr[i] = (atemp_V_arr[i] - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
			
				if(Debug_Enable)
				{
					myfile <<  i << "\t" << result <<"\t" << atemp_raw_arr[i] << "\n";
				}
			}
			if(Debug_Enable)
			{		
				myfile.close();
			}

			// find best fuses value
			int fuse_dac = _util->find_closest(atemp_raw_arr, _glob->Atemp_Target);

			// blow fuse seq
			if (SIM)
			{
				ret = blow_fuse(ATEMP, fuse_dac);
				CheckError(ret, __LINE__);
				_glob->atemp_blown_fuse = fuse_dac;
			}
			
			// Parse result

			tf_SetResult(TPName[0], fuse_dac + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], atemp_raw_arr[fuse_dac] + GetOffset(TPDispName[1]));
		
		}else{
			int res = 0;
			tf_SetResult(TPName[0], res);
			tf_SetResult(TPName[1], _glob->atemp_pre );
		}

		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		// Off meas pin
		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_sim_atemp_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		
		double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
		double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
		
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel				= _glob->SPD_Channel_Number;
		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Target				= (double)(tf_TestItemCondition_Cast("Target"));
		double Input_Channel_Delay_s = 0;
		_glob->Atemp_Target			= (double)(tf_TestItemCondition_Cast("Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result					= 0;
		array<double>^ result_arr		= gcnew array<double>(16);

		array<double>^ atemp_raw_arr	= gcnew array<double>(2);
		array<double>^ atemp_V_arr		= gcnew array<double>(2);

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		double atemp_offset = 131.7/182.5;
		double atemp_step = 1/182.5;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		//smu measure vref
		ret = OnOffCbit(11,1);
		CheckError(ret, __LINE__);
		ret = OnOffCbit(42,1);
		CheckError(ret, __LINE__);

		String ^ Test_Pin = "MTX_SMU";
		ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
		CheckError(ret, __LINE__);
		ret = smu->SetBandwidth(Test_Pin, 1);
		CheckError(ret, __LINE__);
		ret = smu->SetNPLC(Test_Pin, NPLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampVoltage(Test_Pin, Clamp_Voltage_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveCurrent(Test_Pin, Drive_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(Test_Pin, false, false);
		CheckError(ret, __LINE__);


		double Gnds_val = 0.0;

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, 0.01);
		#endif

		// setup to sweep measure vref

		#ifndef USE_SPI
		ret = RunVectorFile("write_trim_readmux_atemp");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("write_enable_testfuse");
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI("write_trim_readmux_atemp");
		CheckError(ret, __LINE__);
		ret = RunSPI("write_enable_testfuse");
		CheckError(ret, __LINE__);
		#endif

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); // rw bit
		array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
		int dat_bit = 0;
	
		int dac_sweep	= 0;
		int dac			= _glob->TrimReg[ATEMP, FUSEDAC];
		int min_dac		= (dac / 2) - 1;
		int max_dac		= min_dac + 1;
		
		
		#ifdef USE_GNDS
		ret = smu->ReadVoltage("GND_MUX_SENSE", Gnds_val);
		#endif

		if (((_glob->atemp_blown_fuse == 0) && (_glob->trimlock == 0))  || (ForceBlowFuseSim))
		{
			for (int i = 0; i < 2; i++ )
			{
				switch(i)
				{
					case 0: //max
						dac_sweep = max_dac;
						break;
					case 1: //min
						dac_sweep = min_dac;
						break;
				}
				
				dat_bit = (dac_sweep << _glob->TrimReg[ATEMP,BIT]);// & 16);
				
				#ifndef USE_SPI
				vec_arr = make_vector( 0, _glob->TrimReg[ATEMP,PG], _glob->TrimReg[ATEMP,REG], dat_bit); // rw, pg, reg, dat
				ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(ret, __LINE__);
				ret = RunVectorArray(_glob->VectorArrSetNo);
				CheckError(ret, __LINE__);
				#else
				ret = WriteSPI(_glob->TrimReg[ATEMP,PG]-1, _glob->TrimReg[ATEMP,REG], dat_bit);
				CheckError(ret, __LINE__);
				#endif

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadVoltage(Test_Pin, result);
				CheckError(ret, __LINE__);

				atemp_V_arr[i]  = result - Gnds_val - _glob->mux_offset; // Compensate value
				atemp_raw_arr[i] = (atemp_V_arr[i] - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
			}
			// find best fuses value

			double atemp_max		= atemp_raw_arr[0];
			double atemp_min		= atemp_raw_arr[1];
			double lsb				= 0.0 ;
			int fuse_dac			= 0;
			int target_dac			= 0;
			double target_result	= 0;
			double target_result_dac = 0;
			double target_raw_result = 0; 
			
			//check for max/min out
			if ((_glob->Atemp_Target < atemp_max) && ( _glob->Atemp_Target > atemp_min))
			{
				fuse_dac = _util->find_est_range(atemp_min, atemp_max, _glob->Atemp_Target, _glob->TrimReg[ATEMP,FUSEDAC], lsb, INV);
					// sweep_range to verify 
				ret = find_target(fuse_dac ,lsb ,target_dac, target_result, Measure_Delay_s, _glob->TrimReg[ATEMP,FUSEDAC], ATEMP, INV);
				CheckError(ret, __LINE__);
				
				CorrectDac(target_dac, _glob->TrimReg[ATEMP,FUSE]);
				target_raw_result = (target_result - atemp_offset)/atemp_step ;

			}
			else if(_glob->Atemp_Target > atemp_max) // Max Out
			{	
				target_dac		= max_dac;
				target_result = ( atemp_max * atemp_step ) +  atemp_offset; 
				target_raw_result = atemp_max;
				
			
			}
			else if(_glob->Atemp_Target < atemp_min) // Min Out
			{
				target_dac		= min_dac;
				target_result = ( atemp_min * atemp_step ) +  atemp_offset; 
				target_raw_result = atemp_min;
				
			}
			tf_SetResult(TPName[0], target_dac + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], target_raw_result + GetOffset(TPDispName[1]));
		
			// blowfuse seq
			if(SIM)
			{
				ret = blow_fuse(ATEMP, target_dac);
				CheckError(ret, __LINE__);
				_glob->atemp_fuse_toblow = target_dac;
			}
		}
		else
		{
			int res = 0;
			tf_SetResult(TPName[0], res);
			tf_SetResult(TPName[1], _glob->atemp_pre );
		}
		
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_sim_iabs_trim_sweep(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
		double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		_glob->Iabs_Target			= (double)(tf_TestItemCondition_Cast("Target"));
		
		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result = 0;
		array<double>^ result_arr = gcnew array<double>(64);

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
			
		if  (((_glob->iabs_blown_fuse == 0) && (_glob->trimlock == 0)) || (ForceBlowFuseSim))
		{

			#ifndef USE_SPI
			ret = RunVectorFile("write_trim_readmux_iabs");
			CheckError(ret, __LINE__);
			ret = RunVectorFile("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_trim_readmux_iabs");
			CheckError(ret, __LINE__);
			ret = RunSPI("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#endif

			array<int>^ vec_arr = gcnew array<int>(37); // rw bit
			array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
		
			ofstream myfile;
			if(Debug_Enable)
			{
				myfile.open("C://Aemulus/Debug/iabs_trim_test.txt");
			}
			String ^ Test_Pin = "MTX_SMU";
		
			OnOffCbit(11, 1);
			OnOffCbit(42,1);

			ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
			CheckError(ret, __LINE__);
			ret = smu->SetBandwidth(Test_Pin, 1);
			CheckError(ret, __LINE__);
			ret = smu->SetNPLC(Test_Pin, 0.01);
			CheckError(ret, __LINE__);
			ret = smu->ClampCurrent(Test_Pin, Clamp_Current_A);
			CheckError(ret, __LINE__);
			ret = smu->DriveVoltage(Test_Pin, Drive_Voltage_V);
			CheckError(ret, __LINE__);
			ret = smu->OnSmuPin(Test_Pin, false, false);
			CheckError(ret, __LINE__);
			// create vector array on the fly for to sweep trim fuse setting
			


			int dat_bit = 0;
		

			for (int i = 0; i < _glob->TrimReg[IABS,FUSEDAC]; i++ )
			{
				dat_bit = (i >> _glob->TrimReg[IABS,BIT]);// & 16);

				#ifndef USE_SPI		
				vec_arr = make_vector(0, _glob->TrimReg[IABS,PG], _glob->TrimReg[IABS,REG], dat_bit); // rw, pg, reg, dat
				ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(ret, __LINE__);
				ret = RunVectorArray(_glob->VectorArrSetNo);
				CheckError(ret, __LINE__);
				#else
				ret = WriteSPI(_glob->TrimReg[IABS,PG]-1, _glob->TrimReg[IABS,REG], dat_bit);
				CheckError(ret, __LINE__);
				#endif

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu->ReadCurrent(Test_Pin, result);
				CheckError(ret, __LINE__);

				result_arr[i] = - result/ 1e-6;
				
				if(Debug_Enable)
				{
					myfile << i << "\t" << result_arr[i] << "\n";
				}
				result_arr[i] = - result;
				
			}
			if(Debug_Enable)
			{
				myfile.close();
			}
			// get closest reading
			int fuse_dac = 0;
			fuse_dac = _util->find_closest(result_arr, _glob->Iabs_Target);
			
			// blowfuseseq
			if (SIM)
			{
				blow_fuse(IABS, fuse_dac);
				_glob->iabs_blown_fuse = fuse_dac;
			}
			
			ret = tf_SetResult(TPName[0], fuse_dac + (int)GetOffset(TPDispName[0]));
			CheckError(ret, __LINE__);
			ret = tf_SetResult(TPName[1], result_arr[fuse_dac] + GetOffset(TPDispName[1]));
			CheckError(ret, __LINE__);
		}else{
			tf_SetResult(TPName[0], 0 + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], _glob->iabs_pre + GetOffset(TPDispName[1]));
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = smu->OffSmuPin("MTX_SMU");
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_sim_iabs_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
		double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		_glob->Iabs_Target			= (double)(tf_TestItemCondition_Cast("Target"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		double result = 0;
		array<double>^ result_arr = gcnew array<double>(64);

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ResetCBit();
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
		
		String ^ Test_Pin = "MTX_SMU";
		
		OnOffCbit(11, 1);
		OnOffCbit(42,1);

		//ret = smu->ConfigurePLF(Test_Pin, Power_Line_Freq);
		//CheckError(ret, __LINE__);
		//ret = smu->SetBandwidth(Test_Pin, 1);
		//CheckError(ret, __LINE__);
		ret = smu->SetNPLC(Test_Pin, NPLC);
		CheckError(ret, __LINE__);
		ret = smu->ClampCurrent(Test_Pin, Clamp_Current_A);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage(Test_Pin, Drive_Voltage_V);
		CheckError(ret, __LINE__);
		ret = smu->OnSmuPin(Test_Pin, false, false);
		CheckError(ret, __LINE__);
		
		if (((_glob->iabs_blown_fuse == 0) && (_glob->trimlock == 0))  || (ForceBlowFuseSim))
		{
			
			#ifndef USE_SPI
			ret = RunVectorFile("write_trim_readmux_iabs");
			CheckError(ret, __LINE__);
			ret = RunVectorFile("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#else
			ret = OnOffSPI(1);
			CheckError(ret, __LINE__);
			ret = RunSPI("write_trim_readmux_iabs");
			CheckError(ret, __LINE__);
			ret = RunSPI("write_enable_testfuse");
			CheckError(ret, __LINE__);
			#endif
			
			array<int>^ vec_arr = gcnew array<int>(37); // rw bit
			array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
		
			int dac			= 64;
			int fuse_count	= 6;
			int max_dac		= (dac / 2) - 1;
			int min_dac		= max_dac + 1;
			int dat_bit = 0;
			int dac_sweep	= 0;
		
			// create vector array on the fly for to sweep trim fuse setting
			for (int i = 0; i < 2; i++ )
			{

				switch(i)
				{
					case 0: //max
						dac_sweep = max_dac;
						break;
					case 1: //min
						dac_sweep = min_dac;
						break;
				}

					dat_bit = (dac_sweep << _glob->TrimReg[IABS,BIT]);// & 16);
					#ifndef USE_SPI
					vec_arr = make_vector(0, _glob->TrimReg[IABS,PG], _glob->TrimReg[IABS,REG], dat_bit); // rw, pg, reg, dat
					ret = dm->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
					CheckError(ret, __LINE__);
					ret = RunVectorArray(_glob->VectorArrSetNo);
					CheckError(ret, __LINE__);
					#else
					ret = WriteSPI(_glob->TrimReg[IABS,PG]-1, _glob->TrimReg[IABS,REG], dat_bit);
					CheckError(ret, __LINE__);
					#endif
					// SMU measure Iabs
		
					_util->Wait_Sec(Measure_Delay_s);	
					ret = smu->ReadCurrent(Test_Pin, result);
					CheckError(ret, __LINE__);

					result_arr[i] = - result;
			}
			
			double iabs_max			= result_arr[0];
			double iabs_min			= result_arr[1];

			double lsb				= 0.0 ;
			int fuse_dac			= 0;
			int target_dac			= 0;
			double target_result	= 0;
			double target_result_dac = 0;
			
			//check for max/min out
			if ((_glob->Iabs_Target < iabs_max) && ( _glob->Iabs_Target > iabs_min))
			{

				fuse_dac = _util->find_est_range(iabs_min,iabs_max,_glob->Iabs_Target,dac, lsb, NORM);
				// sweep_range to verify 
				ret = find_target(fuse_dac ,lsb ,target_dac, target_result, Measure_Delay_s, _glob->TrimReg[IABS, FUSEDAC], IABS, NORM);
				CheckError(ret, __LINE__);

				CorrectDac(target_dac, _glob->TrimReg[IABS,FUSE]);
		
			}
			else if(_glob->Iabs_Target > iabs_max) // Max Out
			{
				target_dac = max_dac;
				target_result = iabs_max;
			}
			else if(_glob->Iabs_Target < iabs_min) // Min Out
			{
				target_dac = min_dac;
				target_result = iabs_min;
			}
		
			tf_SetResult(TPName[0], target_dac + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], target_result + GetOffset(TPDispName[1]));

			// blowfuseseq
			if (SIM)
			{
				blow_fuse(IABS, target_dac);
				_glob->iabs_fuse_toblow = target_dac;
			}
			
		}
		else
		{
			tf_SetResult(TPName[0], 0 + (int)GetOffset(TPDispName[0]));
			tf_SetResult(TPName[1], _glob->iabs_pre + GetOffset(TPDispName[1]));
		}
		ret = smu->OffSmuPin(Test_Pin);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_testPass_trim(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	
		int result = 0;
		int c = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		array<int>^ HistoryRam = gcnew array<int>(256);
		
		int vector_engine_status = 0;

		String ^ Vector_File = String::Empty;

		int data = 0;

		Stopwatch swatch;
	
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		#ifdef USE_SPI
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		#endif

		// 4 stage process
		for (int i = 0; i < 4; i++)
		{	
			if (i == 1)
			{
				// blow testpass/trimlock fuse			
				if ((_glob->GoodDIE) &&  !TIByPassed)
				{
					ret = blow_testlockfuse();
					CheckError(ret, __LINE__);
				}
				
			}		
			if (i != 2)
			{

				#ifndef USE_SPI
				ret = RunVectorFile("write_p2_reg63_extregsp_disable_l");
				CheckError(ret, __LINE__);
				ret = ReadVector("read_p2_reg57", data);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI("write_p2_reg63_extregsp_disable_l");
				CheckError(ret, __LINE__);
				ret = ReadSPI("read_p2_reg57", data);
				CheckError(ret, __LINE__);
				#endif

				// read testpass fuse
				_glob->testpass = (data >> 0) & 0x1;
				tf_SetResult(TPName[i], _glob->testpass); 
			
			}
			if (i == 2)
			{
				// 1. read lock bit
				#ifndef USE_SPI
				ret = RunVectorFile("write_trimlock_init");
				CheckError(ret, __LINE__);
				ret = ReadVector("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI("write_trimlock_init");
				CheckError(ret, __LINE__);
				ret = ReadSPI("read_p2_reg48", data);
				CheckError(ret, __LINE__);
				#endif

				_glob->trimlock = (data >> 7) & 0x1;
				tf_SetResult(TPName[i], _glob->trimlock); 
			}
		}

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		
		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	//
	int TestProgram::seq_vit_vhys_func(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		double Clamp_RWN_Current_A = (double)(tf_TestItemCondition_Cast("Clamp_RWN_Current_A"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;
				
		//For package testing on IF.PKG:
		//	1. Manually connect FLTMUX to DM_1 Ch2 via J25.3 (PC1_7G)
		//	2. Manually connect WDY to DM_1 Ch4 via J36.2 (PC3_2A/B)
		//	3. Manually connect FHCW_FETS to DM_1 Ch0 via J27.2 (PC3_3G)
		//	4. Manually connect FHCR_FETS to DM_1 Ch1 via J27.1 (PC6_2G)
		//	5. Manually connect HW_FETS to DM_1 Ch5 via J26.1 (PC3_5G)

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		int max_step = 0;
		double voltage = 0;
		double p1_point = 0;
		double diffp_V = 0;
		double diffn_V = 0;

		array<double> ^ Drive_RWN_Start_V = gcnew array<double>(total_tp);
		array<double> ^ Drive_RWN_Stop_V = gcnew array<double>(total_tp);
		array<double> ^ Drive_RWN_Step_V = gcnew array<double>(total_tp);
		array<double> ^ MinLimit = gcnew array<double>(total_tp);
		array<double> ^ MaxLimit = gcnew array<double>(total_tp);
		array<double> ^ Vth = gcnew array<double>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ result_p1 = gcnew array<double>(total_tp);
		array<double> ^ result_p2 = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			Drive_RWN_Start_V[i] = 0;
			Drive_RWN_Stop_V[i] = 0;
			Drive_RWN_Step_V[i] = 0;
			MinLimit[i] = 0;
			MaxLimit[i] = 0;
			Vth[i] = 0;
			result[i] = 0;
			result_p1[i] = 0;
			result_p2[i] = 0;
		}

		ret = dm->DPINOff("RWN");
		CheckError(ret, __LINE__);
		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("WR0P_F");
		CheckError(ret, __LINE__);
		ret = dm->Force("WR0P_F", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);
		ret = dm->DPINOff("WR0N_F");
		CheckError(ret, __LINE__);
		ret = dm->Force("WR0N_F", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime("RWN", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("WR0P_F", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUSamplingTime("WR0N_F", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction("RWN", DM_CONST_DVCI);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("WR0P_F", DM_CONST_DICV);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUOutputFunction("WR0N_F", DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLimitRange("RWN", Clamp_RWN_Current_A);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLimit("WR0P_F", 6, -2);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUVoltageLimit("WR0N_F", 6, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLevel("RWN", 1.5);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel("WR0P_F", 0);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePMUCurrentLevel("WR0N_F", 0);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WR0P_F");
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WR0N_F");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		double gnds_volt = 0;
		#ifdef USE_GNDS
		ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, gnds_volt);
		CheckError(ret, __LINE__);
		#endif
				
		for (int i=0; i<total_tp; i++)
		{
			bool isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
			
			if (!isCurrentTPBypassed)
			{
				Drive_RWN_Start_V[i]	= (double)(tf_TPCondition_Cast(TPName[i],"Drive_RWN_Start_V"));
				Drive_RWN_Stop_V[i]		= (double)(tf_TPCondition_Cast(TPName[i],"Drive_RWN_Stop_V"));
				Drive_RWN_Step_V[i]		= (double)(tf_TPCondition_Cast(TPName[i],"Drive_RWN_Step_V"));
				Vth[i]					= (double)(tf_TPCondition_Cast(TPName[i],"Vth"));
				MinLimit[i]				= (double)(tf_TestParameter_MinLimit(TPName[i]));
				MaxLimit[i]				= (double)(tf_TestParameter_MaxLimit(TPName[i]));

				result[i] = 999;

				//VIH - Step Up
				if (Drive_RWN_Start_V[i] < Drive_RWN_Stop_V[i])
				{
					Drive_RWN_Step_V[i] = Math::Abs(Drive_RWN_Step_V[i]);

					if (MinLimit[i] < Drive_RWN_Start_V[i])
						Drive_RWN_Start_V[i] = MinLimit[i];

					p1_point = MinLimit[i];
					Drive_RWN_Stop_V[i] = MaxLimit[i];
				}

				//VIL - Step Down
				else if (Drive_RWN_Start_V[i] > Drive_RWN_Stop_V[i])
				{
					Drive_RWN_Step_V[i] = Math::Abs(Drive_RWN_Step_V[i]) * -1;

					if (MaxLimit[i] > Drive_RWN_Start_V[i] )
						Drive_RWN_Start_V[i] = MaxLimit[i];

					p1_point = MaxLimit[i];
					Drive_RWN_Stop_V[i] = MinLimit[i];
				}

				else 
					return ER_INVALID_SETTING; //ret = -1; //return error

				max_step = (int)(Math::Abs((Drive_RWN_Start_V[i] - Drive_RWN_Stop_V[i]) / Drive_RWN_Step_V[i]));	

				if ((Drive_RWN_Start_V[i] == Drive_RWN_Stop_V[i]) || (max_step == 0))
					return ER_INVALID_SETTING; //ret = -1; //return error

				voltage = Drive_RWN_Start_V[i];
				int step = 0;

				while((Drive_RWN_Start_V[i] != Drive_RWN_Stop_V[i]) && (step <= max_step))
				{
					if (Drive_RWN_Step_V[i] > 0) //step up
						ret = dm->ConfigurePMUVoltageLevel("RWN", voltage - 0.15 + gnds_volt);
					else //step down
						ret = dm->ConfigurePMUVoltageLevel("RWN", voltage + 0.15 + gnds_volt);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);

					if ((voltage < (p1_point + (Math::Abs(Drive_RWN_Step_V[i])/2))) && (voltage > (p1_point - Math::Abs((Drive_RWN_Step_V[i])/2))))
					{
						_util->Wait_Sec(Measure_Delay_s);

						ret = dm->PMUMeasure("WR0P_F", DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
						ret = dm->PMUMeasure("WR0N_F", DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);
						
						result_p1[i] = Math::Abs(diffp_V - diffn_V);
					}
					 
					voltage = voltage + Drive_RWN_Step_V[i];
					step++;
				}

				if (voltage != Drive_RWN_Stop_V[i]) 
				{ 
					/* just safety resetup at point2 step input voltage, */
					/* to cover more die to passs within specs, specially edge die */
				    
					if (Drive_RWN_Step_V[i] > 0) 
						ret = dm->ConfigurePMUVoltageLevel("RWN", Drive_RWN_Stop_V[i] - 0.15 + gnds_volt);
					else
						ret = dm->ConfigurePMUVoltageLevel("RWN", Drive_RWN_Stop_V[i] + 0.15 + gnds_volt);
					CheckError(ret, __LINE__);

					ret = dm->ConfigurePMUVoltageLevel("RWN", Drive_RWN_Stop_V[i] + gnds_volt);
					CheckError(ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure("WR0P_F", DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(ret, __LINE__);
				ret = dm->PMUMeasure("WR0N_F", DM_CONST_MEASUREVOLTAGE, diffn_V);
				CheckError(ret, __LINE__);

				result_p2[i] = Math::Abs(diffp_V - diffn_V);

				if(Drive_RWN_Step_V[i] >  0)
				{
					if (result_p1[i] <= Vth[i] && result_p2[i] >= Vth[i])
						result[i] = MinLimit[i] + ((MaxLimit[i] - MinLimit[i]) / 2);
					else 
					{
						if (result_p1[i] < Vth[i])
							result[i] = -10;
						else if(result_p2[i] > Vth[i])
							result[i] = 10;
						else 
							result[i] = 1e38; //unexpected
					}
				}

				else 
				{
					if (result_p1[i] >= Vth[i] && result_p2[i] <= Vth[i])
						result[i] = MinLimit[i] + ((MaxLimit[i] - MinLimit[i]) / 2);
					else 
					{
						if (result_p1[i] < Vth[i])
							result[i] = -10;
						else if (result_p2[i] > Vth[i])
							result[i] = 10;
						else 
							result[i] = 999; //unexpected
					}
				}
	
				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		/////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_fhs_counter(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		double result_adc				= 0;
		double result_adc2				= 0;
		double result_fhs_flt_countA	= 0;
		double result_fhs_flt_countB	= 0;
		double result_fhs_flt_clearA	= 0;
		double result_fhs_flt_clearB	= 0;
		int result_count				= 0;
		int result_clear				= 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
		String ^ Vector_File		= String::Empty;
		String ^ Vector_File_Rd1	= "read_p4_reg16";
		String ^ Vector_File_Rd2	= "read_p4_reg17";

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Start);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Start);
		CheckError(ret, __LINE__);
		#endif
		
		/////////////////////////////////

		for (int i=0; i<total_tp; i++)
		{
			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

			#ifndef USE_SPI
			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif
			Vector_File = Vector_File_Rd1;

			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif

			//Read p4_reg16 (ROTESTA)
			result_adc = data;
			
			//Read p4_reg17 (ROTESTB)
			Vector_File = Vector_File_Rd2;

			#ifndef USE_SPI
			ret = ReadVector(Vector_File, data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI(Vector_File, data);
			CheckError(ret, __LINE__);
			#endif

			result_adc2 = data;

			if (i == 0)
			{
				result_fhs_flt_countA = result_adc * 256;//follow Catalyst
				result_fhs_flt_countB = result_adc2;
			}
			else
			{
				result_fhs_flt_clearA = result_adc * 256;//follow Catalyst
				result_fhs_flt_clearB = result_adc2;
			}
		}


		result_count =  (int)result_fhs_flt_countA + (int)result_fhs_flt_countB + (int)GetOffset(TPDispName[0]);
		result_clear =	(int)result_fhs_flt_clearA + (int)result_fhs_flt_clearB + (int)GetOffset(TPDispName[1]); 

		tf_SetResult(TPName[0], result_count);
		tf_SetResult(TPName[1], result_clear);
	
		/////////////////////////////////

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_End);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);
		#endif
	
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_flt_ht(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

		double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
		double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
		String ^ Test_Pin		= String::Empty;

		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
		String ^ Vector_File		= String::Empty;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		
		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin_flt);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin_flt);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		int Start_Data		= 0;
		int Stop_Data		= 0;
		int Compare_Bit		= 0;
		int Compare_Reg_Addr = 0;

		double result_Rh_trip = 0;
		double result_vheat = 0;

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_clk_divider = (int)(200e6/spi_clk_freq - 1);
		int cpol = 0;
		int cpha = 0;
		int spi_status = 0;
		int readback = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
		CheckError(ret, __LINE__);

		ret = dm->SPI_NCS_ACTIVE_STATE("DM_2", spi_group, DM_CONST_SPI_NCS_ACTIVE_HIGH);
		CheckError(ret, __LINE__);
	
		if (Input_Channel_Delay_s == 0)
		{
			ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 0);
			CheckError(ret, __LINE__);
		}
		else if (Input_Channel_Delay_s < 5e-9)
		{
			ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 2);
			CheckError(ret, __LINE__);
		}

		ret = dm->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
		CheckError(ret, __LINE__);

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		Dictionary <String ^, int> ^ TestPin = gcnew Dictionary <String ^, int>;

		for (int i=0; i<total_tp; i++)
		{
			Test_Pin	= (String ^)tf_TPCondition_Cast(TPName[i], "Test_Pin");
			Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

			ret = DriveMuxIO(TPDispName[i]);
			CheckError(ret, __LINE__);

			/////

			if (TestPin->ContainsKey(Test_Pin) == false)
			{
				ret = dm->DPINOff(Test_Pin);
				CheckError(ret, __LINE__);

				ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
				CheckError(ret, __LINE__);

				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(ret, __LINE__);

				ret = dm->DPINOn(Test_Pin);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(On_Delay_s);

				ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
				CheckError(ret, __LINE__);

				TestPin->Add(Test_Pin, 1);
			}

			/////

			// Load vector file

			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);

			//Sweep reg

			spi_wr_byte_length = 1;

			int k = Start_Data;
			while(k != Stop_Data)
			{
				int datain = _util->SwapBitSequence(k, 8);

				spi_data_dir[0] = 0x0000000; 
				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
				CheckError(ret, __LINE__);

				spi_status = 0;
			
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
					CheckError(ret, __LINE__);

					if (spi_status == 2) //0=idle, 1=busy, 2=done
						break;

					swatch.Stop();
				}

				if (spi_status == 2)
				{
					spi_status = 0;
					readback = 0;

					spi_data_dir[0] = 0x00000ff; 
					spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

					ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
					CheckError(ret, __LINE__);

					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
						CheckError(ret, __LINE__);

						if (spi_status == 2) //0=idle, 1=busy, 2=done
							break;

						swatch.Stop();
					}

					ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(ret, __LINE__);

					for (int m=0; m<spi_rd_byte_length; m++)
					{
						if (spi_rd_biterror[m] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
						}
						else
						{
							readback = -999;
						}
					}

					if (readback == ((1 << Compare_Bit) & 0xff))
					{
						ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_Rh_trip);
						CheckError(ret, __LINE__);
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vheat);
						CheckError(ret, __LINE__);

						#ifdef USE_GNDS
						double volt = 0;
						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
						ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
						CheckError(ret, __LINE__);
						result_vheat = result_vheat - volt;
						#endif

						result_Rh_trip = result_Rh_trip * -1;

						break;
					}
					else 
					{
						result_Rh_trip = 0.0000001; //follow catalyst
						result_vheat = 0;
					}
				}

				if (Start_Data < Stop_Data)
				{	
					k++;
				}
				else
				{
					k--;
				}
			}

			double result_final = 0;
			result_final = result_vheat / (135 * result_Rh_trip);

			tf_SetResult(TPName[i], result_final + GetOffset(TPDispName[i]));
		}

		/////////////////////////////////

		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);

		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_sply_flt(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double vol_flt			= (double)(tf_TestItemCondition_Cast("vol_flt"));
		double voh_flt			= (double)(tf_TestItemCondition_Cast("voh_flt"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif
		
		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		int j = 0;
		double supply		= 0;
		double step			= 10e-3;
		double result_up	= 0;
		double result_dn	= 0;
		double result_vhys	= 0;
		double Threshold	= 0;
		double res			= 0;

		//Ramp DOWN VCC (from 4.3 towards 0V) and measure FLTMUX. See when FLTMUX is not able maintain high.
		j			= 0;
		Threshold	= 3.5;
		while(1)
		{
			supply = Drive_Vcc_V - j*step;

			if (supply > Threshold)
			{
				ret = smu->DriveVoltage("VCC", supply);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, res);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//CheckError(ret, __LINE__);
				//res = res - volt;
				//#endif

				if(res < vol_flt)
				{
					result_dn = Drive_Vcc_V - j*step;

					ret = smu->DriveVoltage("VCC", Drive_Vcc_V);//drive back to normal
					CheckError(ret, __LINE__);

					break;
				}
			}
			else
			{
				result_dn = -999;

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);//drive back to normal
				CheckError(ret, __LINE__);

				break;
			}

			j++;
		}

		tf_SetResult(TPName[0], result_dn + GetOffset(TPDispName[0]));

		//Ramp UP VCC (from 3.3V towards 4.3V) and measure FLTMUX. See when FLTMUX is started to maintain high.
		j			= 0;
		Threshold	= Drive_Vcc_V;
		while(1)
		{
			supply = Drive_Vcc_V - (1 - j*step);

			if (supply < Threshold)
			{
				ret = smu->DriveVoltage("VCC", supply);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, res);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//CheckError(ret, __LINE__);
				//res = res - volt;
				//#endif

				if(res > voh_flt)
				{
					result_up = Drive_Vcc_V - (1 - j*step);

					ret = smu->DriveVoltage("VCC", Drive_Vcc_V);//drive back to normal
					CheckError(ret, __LINE__);

					break;
				}
			}
			else
			{
				result_up = -999;

				ret = smu->DriveVoltage("VCC", Drive_Vcc_V);//drive back to normal
				CheckError(ret, __LINE__);

				break;
			}

			j++;
		}

		tf_SetResult(TPName[1], result_up + GetOffset(TPDispName[1]));

		tf_SetResult(TPName[2], Math::Abs(result_up - result_dn) + GetOffset(TPDispName[2]));

		//Ramp DOWN VEE (from -3V towards 0V) and measure FLTMUX.  See when FLTMUX is not able maintain high.
		j			= 0;
		Threshold	= 2;
		while(1)
		{
			supply = Drive_Vee_V - j*step;

			if (supply > Threshold)
			{
				ret = smu->DriveVoltage("VEE", supply);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, res);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//CheckError(ret, __LINE__);
				//res = res - volt;
				//#endif

				if(res < vol_flt)
				{
					result_dn = (Drive_Vee_V - j*step) * -1;

					ret = smu->DriveVoltage("VEE", Drive_Vee_V);//drive back to normal
					CheckError(ret, __LINE__);

					break;
				}
			}
			else
			{
				result_dn = -999;

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);//drive back to normal
				CheckError(ret, __LINE__);

				break;
			}

			j++;
		}

		tf_SetResult(TPName[3], result_dn + GetOffset(TPDispName[3]));

		//Ramp UP VEE (from -2V towards -3V) and measure FLTMUX. See when FLTMUX is started to maintain high.
		j			= 0;
		Threshold	= Drive_Vee_V;
		while(1)
		{
			supply = Drive_Vee_V - (1 - j*step);

			if (supply < Threshold)
			{
				ret = smu->DriveVoltage("VEE", supply);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, res);
				CheckError(ret, __LINE__);

				//#ifdef USE_GNDS
				//double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				//CheckError(ret, __LINE__);
				//res = res - volt;
				//#endif

				if(res > voh_flt)
				{
					result_up = (Drive_Vee_V - (1 - j*step)) * -1;

					ret = smu->DriveVoltage("VEE", Drive_Vee_V);//drive back to normal
					CheckError(ret, __LINE__);

					break;
				}
			}
			else
			{
				result_up = -999;

				ret = smu->DriveVoltage("VEE", Drive_Vee_V);//drive back to normal
				CheckError(ret, __LINE__);

				break;
			}

			j++;
		}

		tf_SetResult(TPName[4], result_up + GetOffset(TPDispName[4]));

		tf_SetResult(TPName[5], Math::Abs(result_up - result_dn) + GetOffset(TPDispName[5]));
		
		/////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_sply_flt_ana(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
		CheckError(ret, __LINE__);

		/////////////////////////////////
		
		_util->Wait_Sec(Measure_Delay_s);

		double res = 0;

		ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, res);
		CheckError(ret, __LINE__);

		/*#ifdef USE_GNDS
		double volt = 0;
		ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
		CheckError(ret, __LINE__);
		res = res - volt;
		#endif*/

		double Vref	= 1.225; //follow catalyst 1.225V

		res = (-Drive_Vee_V * Vref) / res;

		tf_SetResult(TPName[0], res + GetOffset(TPDispName[0]));
		
		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_temp_flt(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
		String ^ Vector_File		= String::Empty;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Start);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Start);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		int Start_Data			= 0;
		int Stop_Data			= 0;
		int Compare_Bit			= 0;
		int Compare_Reg_Addr	= 0;
		int Sweep_Reg_Addr		= 0;

		double atemp_gain		= 182.5; //follow catalyst
		double atemp_offset		= 131.7; //follow catalyst
		double result_temp_ref	= 0;
		double result_Thot_trip = 0;

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_clk_divider = (int)(200e6/spi_clk_freq - 1);
		int cpol = 0;
		int cpha = 0;
		int spi_status = 0;
		int readback = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
		//CheckError(ret, __LINE__);

		//ret = dm->SPI_NCS_ACTIVE_STATE("DM_2", spi_group, DM_CONST_SPI_NCS_ACTIVE_HIGH);
		//CheckError(ret, __LINE__);
	
		//if (Input_Channel_Delay_s == 0)
		//{
		//	ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 0);
		//	CheckError(ret, __LINE__);
		//}
		//else if (Input_Channel_Delay_s < 5e-9)
		//{
		//	ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
		//	CheckError(ret, __LINE__);
		//}
		//else
		//{
		//	ret = dm->SPI_ConfigureInputDelay("DM_2", spi_group, 2);
		//	CheckError(ret, __LINE__);
		//}

		//ret = dm->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
		//CheckError(ret, __LINE__);

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef USE_SPI
				ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(ret, __LINE__);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif

				if (TPName[i]->Contains("V") == true)
				{
					ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_temp_ref);
					CheckError(ret, __LINE__);

					#ifdef USE_GNDS
					double volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
					CheckError(ret, __LINE__);
					result_temp_ref = result_temp_ref - volt;
					#endif
				}
				else if (TPName[i]->Contains("S") == true)
				{
					Start_Data			= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
					Stop_Data			= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
					Compare_Bit			= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
					Compare_Reg_Addr	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");
					Sweep_Reg_Addr		= (int)tf_TPCondition_Cast(TPName[i], "Sweep_Reg_Addr");

					//Sweep reg
					//ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
					//CheckError(ret, __LINE__);

					spi_wr_byte_length = 1;

					for (int k=Start_Data; k<=Stop_Data; k++)
					{
						int datain = _util->SwapBitSequence(k, 8);

						spi_data_dir[0] = 0x0000000; 
						spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

						ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
						CheckError(ret, __LINE__);

						spi_status = 0;
					
						swatch.Reset();
						swatch.Start();
						swatch.Stop();

						while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
						{
							swatch.Start();

							ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
							CheckError(ret, __LINE__);

							if (spi_status == 2) //0=idle, 1=busy, 2=done
								break;

							swatch.Stop();
						}

						if (spi_status == 2)
						{
							spi_status = 0;
							readback = 0;

							spi_data_dir[0] = 0x00000ff; 
							spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

							ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
							CheckError(ret, __LINE__);
						
							swatch.Reset();
							swatch.Start();
							swatch.Stop();

							while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
							{
								swatch.Start();

								ret = dm->SPI_STATUS("DM_2", spi_group, spi_status);
								CheckError(ret, __LINE__);

								if (spi_status == 2) //0=idle, 1=busy, 2=done
									break;

								swatch.Stop();
							}

							ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
							CheckError(ret, __LINE__);

							for (int m=0; m<spi_rd_byte_length; m++)
							{
								if (spi_rd_biterror[m] == 0)
								{
									data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
								}
								else
								{
									readback = -999;
								}
							}

							if (readback == ((1 << Compare_Bit) & 0xff))
							{
								ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_Thot_trip);
								CheckError(ret, __LINE__);

								#ifdef USE_GNDS
								double volt = 0;
								//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
								ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
								CheckError(ret, __LINE__);
								result_Thot_trip = result_Thot_trip - volt;
								#endif

								break;
							}
						}
					}
				}
			}
		}

		double result_final_0 = 0;
		double result_final_1 = 0;

		result_final_0 = (result_temp_ref * atemp_gain) - atemp_offset;
		result_final_1 = (result_Thot_trip * atemp_gain) - atemp_offset;

		tf_SetResult(TPName[0], result_temp_ref + GetOffset(TPDispName[0]));
		tf_SetResult(TPName[1], result_final_0 + GetOffset(TPDispName[1]));
		tf_SetResult(TPName[2], result_final_1 + GetOffset(TPDispName[2]));

		/////////////////////////////////

		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = RunVectorFile(Vector_File_End);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif
		
		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_fhs_flt_spd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
		double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef	USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin_flt);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin_flt);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{			
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef	USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result[i]);
				CheckError(ret, __LINE__);

				result[i] = result[i] * -1;

				tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
			}
		}

		/////////////////////////////////
		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;

	}
	int TestProgram::seq_fhs_false_flt(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<int> ^ result = gcnew array<int>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		String ^ Vector_File_Rd1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd1"));
		String ^ Vector_File_Rd2	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd2"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//#ifndef	USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		//#else
		//ret = OnOffSPI(1);
		//CheckError(ret, __LINE__);
		//ret = RunSPI(Vector_File);
		//CheckError(ret, __LINE__);
		//#endif
		
		/////////////////////////////////

		int result_adc = 0;
		int result_adc2 = 0;
		int result_fhs_flt = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				//Load setting
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				//#ifndef	USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				//#else
				//ret = RunSPI(Vector_File);
				//CheckError(ret, __LINE__);
				//#endif

				//_util->Wait_Sec(Measure_Delay_s);

				//Read from reg 1
				Vector_File = Vector_File_Rd1;
				
				//#ifndef	USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);
				//#else
				//ret = ReadSPI(Vector_File, data);
				//CheckError(ret, __LINE__);
				//#endif

				result_adc = data & 0xef; //skip bit4 check

				//_util->Wait_Sec(Measure_Delay_s);

				//Read from reg 2
				Vector_File = Vector_File_Rd2;

				//#ifndef	USE_SPI
				ret = ReadVector(Vector_File, data);
				CheckError(ret, __LINE__);
				//#else
				//ret = ReadSPI(Vector_File, data);
				//CheckError(ret, __LINE__);
				//#endif

				result_adc2 = data & 0xff;

				if(result_adc == 0 && result_adc2 == 0) //check p1_reg6 & p1_reg8 for every bit to see if any fault
					result_fhs_flt = 1;
				else 
					result_fhs_flt = 0;

				result[i] = result_fhs_flt;

				tf_SetResult(TPName[i], result[i] + (int)GetOffset(TPDispName[i]));
			}
		}

		/////////////////////////////////

		//#ifdef USE_SPI
		//ret = OnOffSPI(0);
		//CheckError(ret, __LINE__);
		//#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;

	}
	int TestProgram::seq_fhs_vtrip(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
		String ^ Vector_File		= String::Empty;
		String ^ Vector_File_1		= String::Empty;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double result				= 0;
		double result_fhs_Vout_ref	= 0;
		double result_adc_up		= 0;
		double result_adc_dn		= 0;
		double result_fhs_Vout_up	= 0;
		double result_fhs_Vout_dn	= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Start);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Start);
		CheckError(ret, __LINE__);
		#endif

		#ifdef USE_GNDS
		ret = Configure_GNDS_Mux(site, NPLC);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref);
		CheckError(ret, __LINE__);

		#ifdef USE_GNDS
		double volt = 0;
		//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
		ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
		CheckError(ret, __LINE__);
		result_fhs_Vout_ref = result_fhs_Vout_ref - volt;
		#endif

		/////////////////////////////////

		int Start_Data		= 0;
		int Stop_Data		= 0;
		int Compare_Bit		= 0;
		int Compare_Reg_Addr = 0;

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;
		int readback = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		#ifdef USE_SPI
		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		//CheckError(ret, __LINE__);
		#endif

		for (int i=0; i<total_tp; i++)
		{
			Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

			// Load vector file

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef USE_SPI
				ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(ret, __LINE__);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
				CheckError(ret, __LINE__);
				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			//Sweep reg

			spi_wr_byte_length = 1;

			int datain = 0;

			int k = Start_Data;
			while(k != Stop_Data)
			{
				datain = _util->SwapBitSequence(k, 8);

				spi_data_dir[0] = 0x0000000; 
				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				spi_status = 0;

				ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2)
				{
					spi_status = 0;
					readback = 0;

					spi_data_dir[0] = 0x00000ff; 
					spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

					ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(ret, __LINE__);

					ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(ret, __LINE__);

					for (int m=0; m<spi_rd_byte_length; m++)
					{
						if (spi_rd_biterror[m] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
						}
						else
						{
							readback = -999;
						}
					}

					if (i == 0 && readback == ((1 << Compare_Bit) & 0xff))
					{
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up);
						CheckError(ret, __LINE__);

						#ifdef USE_GNDS
						double volt = 0;
						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
						ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
						CheckError(ret, __LINE__);
						result_fhs_Vout_up = result_fhs_Vout_up - volt;
						#endif

						break;
					}
					else if (i == 1 && readback != ((1 << Compare_Bit) & 0xff))
					{
						ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_dn);
						CheckError(ret, __LINE__);

						#ifdef USE_GNDS
						double volt = 0;
						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
						ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
						CheckError(ret, __LINE__);
						result_fhs_Vout_dn = result_fhs_Vout_dn - volt;
						#endif

						break;
					}
					else if (i == 0 && readback != ((1 << Compare_Bit) & 0xff))
					{
						#ifndef USE_SPI
						ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
						CheckError(ret, __LINE__);

						ret = RunVectorFile(Vector_File_1);
						CheckError(ret, __LINE__);
						
						ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
						CheckError(ret, __LINE__);
						#else
						ret = RunSPI(Vector_File_1);
						CheckError(ret, __LINE__);
						#endif

						spi_status = 0;
						readback = 0;

						spi_data_dir[0] = 0x00000ff; 
						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						CheckError(ret, __LINE__);

						ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
							}
							else
							{
								readback = -999;
							}
						}

						if (readback == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up);
							CheckError(ret, __LINE__);

							#ifdef USE_GNDS
							double volt = 0;
							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
							ret = smu->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(ret, __LINE__);
							result_fhs_Vout_up = result_fhs_Vout_up - volt;
							#endif

							break;
						}
					}
				}

				if (i == 0)
					k++;
				else
					k--;
			}
		}

		double result_final_0 = result_fhs_Vout_up - result_fhs_Vout_ref;
		double result_final_1 = result_fhs_Vout_up - result_fhs_Vout_dn;

		tf_SetResult(TPName[0], result_final_0 + GetOffset(TPDispName[0]));
		tf_SetResult(TPName[1], result_final_1 + GetOffset(TPDispName[1]));

		/////////////////////////////////

		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = RunVectorFile(Vector_File_End);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);

		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_flt_fhs_vopen_short(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

		double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
		double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
		String ^ Vector_File		= String::Empty;
		String ^ Vector_File_1		= String::Empty;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Start);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Start);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->DPINOff(Test_Pin_flt);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin_flt);
		CheckError(ret, __LINE__);

		//

		ret = dm->DPINOff(Test_Pin_P);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin_P);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
		CheckError(ret, __LINE__);

		//

		ret = dm->DPINOff(Test_Pin_N);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin_N);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		int Start_Data		= 0;
		int Stop_Data		= 0;
		int Compare_Bit		= 0;
		int Compare_Reg_Addr = 0;

		double result_v_vmr = 0;
		double result_RO_trip = 0;
		double diffp_V = 0;
		double diffn_V = 0;

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;
		int readback = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		//CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i++)
		{
			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

			// Load vector file

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
				CheckError(ret, __LINE__);

				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			}

			//Sweep reg

			spi_wr_byte_length = 1;

			int k = Start_Data;
			while (k != Stop_Data)
			{
				int datain = _util->SwapBitSequence(k, 8);

				spi_data_dir[0] = 0x0000000; 
				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2)
				{
					spi_data_dir[0] = 0x00000ff; 
					spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

					ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(ret, __LINE__);

					ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(ret, __LINE__);

					for (int m=0; m<spi_rd_byte_length; m++)
					{
						if (spi_rd_biterror[m] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
						}
						else
						{
							readback = -999;
						}
					}

					if (readback == ((1 << Compare_Bit) & 0xff))
					{
						ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
						CheckError(ret, __LINE__);
						ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(ret, __LINE__);
						ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(ret, __LINE__);

						result_RO_trip = result_RO_trip * -1;
						result_v_vmr = Math::Abs(diffp_V - diffn_V);

						break;
					}
					else 
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
						{
							Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

							#ifndef USE_SPI
							ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
							CheckError(ret, __LINE__);

							ret = RunVectorFile(Vector_File_1);
							CheckError(ret, __LINE__);

							ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
							CheckError(ret, __LINE__);
							#else
							ret = RunSPI(Vector_File_1);
							CheckError(ret, __LINE__);
							#endif
			
							//

							spi_data_dir[0] = 0x00000ff; 
							spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

							ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
							CheckError(ret, __LINE__);

							ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
							CheckError(ret, __LINE__);

							for (int m=0; m<spi_rd_byte_length; m++)
							{
								if (spi_rd_biterror[m] == 0)
								{
									data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
								}
								else
								{
									readback = -999;
								}
							}

							if (readback == ((1 << Compare_Bit) & 0xff))
							{
								ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
								CheckError(ret, __LINE__);
								ret = dm->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
								CheckError(ret, __LINE__);
								ret = dm->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
								CheckError(ret, __LINE__);

								result_RO_trip = result_RO_trip * -1;
								result_v_vmr = Math::Abs(diffp_V - diffn_V);

								break;
							}
						}
					}
				}

				if (Start_Data > Stop_Data)
					k--;
				else
					k++;
			}

			double result_final = 0;
			result_final = result_v_vmr / (result_RO_trip * 16);

			tf_SetResult(TPName[i], result_final + GetOffset(TPDispName[i]));
		}

		/////////////////////////////////

		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = RunVectorFile(Vector_File_End);
		CheckError(ret, __LINE__);

		#else
		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);

		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_flt_wipo(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Compare_Reg_Addr	= (int)(tf_TestItemCondition_Cast("Compare_Reg_Addr"));
		int Compare_Bit			= (int)(tf_TestItemCondition_Cast("Compare_Bit"));

		double Clamp_flt_V		= (double)(tf_TestItemCondition_Cast("Clamp_flt_V"));
		double Drive_flt_A		= (double)(tf_TestItemCondition_Cast("Drive_flt_A"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));

		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= String::Empty;

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//
		ret = dm->DPINOff(Test_Pin_flt);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DICV);
		CheckError(ret, __LINE__);
				
		ret = dm->ConfigurePMUVoltageLimit(Test_Pin_flt, Clamp_flt_V, 0);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_flt, Drive_flt_A);
		CheckError(ret, __LINE__);
					
		ret = dm->DPINOn(Test_Pin_flt);
		CheckError(ret, __LINE__);
		//
	
		double vth = 0;
		int flt = 0;

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;

		double result_flt_V = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		//CheckError(ret, __LINE__);

		vih = Drive_Vo_V;	
		vil = 0;	
		voh = 0.75;	
		vol = 0.75;	
		ioh = 0.002;	
		iol = 0.002;	
		vch = 6;	
		vcl = -2;	
		vt = voh;

		ret = dm->DPINLevel(Test_Pin_P, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		ret = dm->DPINLevel(Test_Pin_N, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i=i+2)
		{
			if (tf_TPCondition_exist(TPName[i], "Drive_Vo_V") == true)
			{
				Drive_Vo_V	= (double)tf_TPCondition_Cast(TPName[i], "Drive_Vo_V");

				ret = dm->DPINLevel(Test_Pin_N, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(ret, __LINE__);

				ret = dm->DPINLevel(Test_Pin_P, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
			{
				Test_Pin = (String ^)tf_TPCondition_Cast(TPName[i], "Test_Pin");
			}

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef USE_SPI
				ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(ret, __LINE__);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
				CheckError(ret, __LINE__);

				#else

				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
				
			}


			//Sweep Test Pin
			for(int k=0; k<400; k++)
			{
				vth = Drive_Vo_V - (k * 1e-3);

				ret = dm->DPINLevel(Test_Pin, vth, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				spi_status = 0;

				spi_data_dir[0] = 0x00000ff;
				spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
				spi_wr_byte_length = 1;

				ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2)
				{
					ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(ret, __LINE__);

					for (int j=0; j<spi_rd_byte_length; j++)
					{
						if (spi_rd_biterror[j] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
							flt = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
						}
						else
						{
							flt = -999;
						}
					}

					if (flt == ((1 << Compare_Bit) & 0xff))
					{
						ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASUREVOLTAGE, result_flt_V);
						if(result_flt_V > voh) //if only both flt_wipo bit and FLTMUX pin are high then only return 1.
							break;
					}
				}
			}

			tf_SetResult(TPName[i], vth + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i+1], flt + (int)GetOffset(TPDispName[i+1]));	
		}

		

		/////////////////////////////////
		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = dm->DPINLevel(Test_Pin_P, 0, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		ret = dm->DPINLevel(Test_Pin_N, 0, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_flt_wipo2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Compare_Reg_Addr	= (int)(tf_TestItemCondition_Cast("Compare_Reg_Addr"));
		int Compare_Bit			= (int)(tf_TestItemCondition_Cast("Compare_Bit"));

		double Clamp_flt_V		= (double)(tf_TestItemCondition_Cast("Clamp_flt_V"));
		double Drive_flt_A		= (double)(tf_TestItemCondition_Cast("Drive_flt_A"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));

		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
		String ^ Test_Pin		= String::Empty;

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		//
		ret = dm->DPINOff(Test_Pin_flt);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DICV);
		CheckError(ret, __LINE__);
				
		ret = dm->ConfigurePMUVoltageLimit(Test_Pin_flt, Clamp_flt_V, 0);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_flt, Drive_flt_A);
		CheckError(ret, __LINE__);
					
		ret = dm->DPINOn(Test_Pin_flt);
		CheckError(ret, __LINE__);
		//
	
		double vth = 0;
		int flt = 0;

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;

		double result_flt_V = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		//CheckError(ret, __LINE__);

		vih = Drive_Vo_V;	
		vil = 0;	
		voh = 0.75;	
		vol = 0.75;	
		ioh = 0.002;	
		iol = 0.002;	
		vch = 6;	
		vcl = -2;	
		vt = voh;

		ret = dm->DPINLevel(Test_Pin_P, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		ret = dm->DPINLevel(Test_Pin_N, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		for (int i=0; i<total_tp; i=i+2)
		{
			if (tf_TPCondition_exist(TPName[i], "Drive_Vo_V") == true)
			{
				Drive_Vo_V	= (double)tf_TPCondition_Cast(TPName[i], "Drive_Vo_V");

				//ret = dm->DPINLevel(Test_Pin_N, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
				ret = dm->DPINSetLevel(Test_Pin_N, DM_CONST_SET_VIH, Drive_Vo_V);
				CheckError(ret, __LINE__);

				//ret = dm->DPINLevel(Test_Pin_P, Drive_Vo_V, vil, voh, vol, ioh, iol, vch, vcl, vt);
				ret = dm->DPINSetLevel(Test_Pin_P, DM_CONST_SET_VIH, Drive_Vo_V);
				CheckError(ret, __LINE__);
			}

			if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
			{
				Test_Pin = (String ^)tf_TPCondition_Cast(TPName[i], "Test_Pin");
			}

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef USE_SPI
				ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(ret, __LINE__);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
				CheckError(ret, __LINE__);

				#else

				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
				
			}


			//Sweep Test Pin
			for(int k=0; k<400; k++)
			{
				vth = Drive_Vo_V - (k * 1e-3);

				//ret = dm->DPINLevel(Test_Pin, vth, vil, voh, vol, ioh, iol, vch, vcl, vt);
				ret = dm->DPINSetLevel(Test_Pin, DM_CONST_SET_VIH, vth);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				spi_status = 0;

				spi_data_dir[0] = 0x00000ff;
				spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
				spi_wr_byte_length = 1;

				ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				CheckError(ret, __LINE__);

				if (spi_status == 2)
				{
					ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(ret, __LINE__);

					for (int j=0; j<spi_rd_byte_length; j++)
					{
						if (spi_rd_biterror[j] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
							flt = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
						}
						else
						{
							flt = -999;
						}
					}

					if (flt == ((1 << Compare_Bit) & 0xff))
					{
						ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASUREVOLTAGE, result_flt_V);
						if(result_flt_V > voh) //if only both flt_wipo bit and FLTMUX pin are high then only return 1.
							break;
					}
				}
			}

			tf_SetResult(TPName[i], vth + GetOffset(TPDispName[i]));
			tf_SetResult(TPName[i+1], flt + (int)GetOffset(TPDispName[i+1]));	
		}

		

		/////////////////////////////////
		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//ret = dm->DPINLevel(Test_Pin_P, 0, vil, voh, vol, ioh, iol, vch, vcl, vt);
		ret = dm->DPINSetLevel(Test_Pin_P, DM_CONST_SET_VIH, 0);
		CheckError(ret, __LINE__);

		//ret = dm->DPINLevel(Test_Pin_N, 0, vil, voh, vol, ioh, iol, vch, vcl, vt);
		ret = dm->DPINSetLevel(Test_Pin_N, DM_CONST_SET_VIH, 0);
		CheckError(ret, __LINE__);

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_flt_iwlow(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<int> ^ result = gcnew array<int>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Compare_Reg_Addr	= (int)(tf_TestItemCondition_Cast("Compare_Reg_Addr"));
		int Compare_Bit			= (int)(tf_TestItemCondition_Cast("Compare_Bit"));

		double Clamp_flt_V		= (double)(tf_TestItemCondition_Cast("Clamp_flt_V"));
		double Drive_flt_A		= (double)(tf_TestItemCondition_Cast("Drive_flt_A"));	
		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));

		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
		String ^ Vector_File		= String::Empty;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File_Start);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File_Start);
		CheckError(ret, __LINE__);
		#endif

		//
		ret = dm->DPINOff(Test_Pin_flt);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DICV);
		CheckError(ret, __LINE__);
				
		ret = dm->ConfigurePMUVoltageLimit(Test_Pin_flt, Clamp_flt_V, 0);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_flt, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUCurrentLevel(Test_Pin_flt, Drive_flt_A);
		CheckError(ret, __LINE__);
					
		ret = dm->DPINOn(Test_Pin_flt);
		CheckError(ret, __LINE__);
		//

		/////////////////////////////////

		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;

		double result_flt_V = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		//CheckError(ret, __LINE__);
	
		for (int i=0; i<total_tp; i++)
		{
			Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

			#ifndef USE_SPI
			ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
			CheckError(ret, __LINE__);

			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);

			ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
			CheckError(ret, __LINE__);
			#else
			ret = RunSPI(Vector_File);
			CheckError(ret, __LINE__);
			#endif

			ret = dm->DrivePin("RWN", 1); //Special setting follow the data sheet page 22
			CheckError(ret, __LINE__);
			ret = dm->DrivePin("RWN", 0);
			CheckError(ret, __LINE__);

			spi_data_dir[0] = 0x00000ff; 
			spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

			spi_status = 0;
			spi_wr_byte_length = 1;

			ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
			CheckError(ret, __LINE__);

			if (spi_status == 2)
			{
				ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
				CheckError(ret, __LINE__);
			
				for (int j=0; j<spi_rd_byte_length; j++)
				{
					if (spi_rd_biterror[j] == 0)
					{
						data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
						result[i] = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;

						if (result[i] == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm->PMUMeasure(Test_Pin_flt, DM_CONST_MEASUREVOLTAGE, result_flt_V);
							if(result_flt_V > voh) //if only both flt_wipo bit and FLTMUX pin are high then only return 1.
								result[i] = 1;
						}
					}
					else
					{
						result[i] = -999;
					}
				}
			}

			tf_SetResult(TPName[i], result[i] + (int)GetOffset(TPDispName[i]));

		}

		/////////////////////////////////

		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = RunVectorFile(Vector_File_End);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File_End);
		CheckError(ret, __LINE__);

		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}	
	int TestProgram::seq_flt_fos_ith(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;
		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));
		int Compare_Reg_Addr	= (int)(tf_TestItemCondition_Cast("Compare_Reg_Addr"));
		int Compare_Bit			= (int)(tf_TestItemCondition_Cast("Compare_Bit"));
		int Start_Data			= (int)(tf_TestItemCondition_Cast("Start_Data"));
		int	Stop_Data			= (int)(tf_TestItemCondition_Cast("Stop_Data"));

		double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
		double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_End= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_20"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_20"][testSite];

		double Rz = 45, Rh = 3, Rth = 2440;
		double result_ith			= 0;
		double result_ith_trip		= 0;
		double result_Rtrip			= 0;

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		int data = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		/////////////////////////////////

		ret = dm->DPINOff(Test_Pin);
		CheckError(ret, __LINE__);

		ret = dm->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn(Test_Pin);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result_ith);
		CheckError(ret, __LINE__);

		result_ith = result_ith*-1;

		/////////////////////////////////

		int spi_group = 0;
		double spi_clk_freq = 10e6;
		int spi_status = 0;
		int readback = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		//CheckError(ret, __LINE__);

		for (int i=1; i<total_tp; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				#ifndef USE_SPI
				ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(ret, __LINE__);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
				CheckError(ret, __LINE__);

				#else
				ret = RunSPI(Vector_File);
				CheckError(ret, __LINE__);
				#endif
			
				//Sweep reg

				spi_wr_byte_length = 1;

				int datain = 0;

				ret = dm->DrivePin("RWN", 1);
				CheckError(ret, __LINE__);

				int k = Start_Data;
				while(k != Stop_Data)
				{
					datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

					spi_status = 0;

					ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(ret, __LINE__);

					_util->Wait_Sec(0.1e-3);

					ret = dm->DrivePin("RWN", 0); //according to Catalyst's waveform, RWN only fall to low after write p4_reg19_rwtesta, 
					CheckError(ret, __LINE__);
					//_util->Wait_Sec(0.0000005); //according to Catalyst's waveform, pulse width is 500ns,
					ret = dm->DrivePin("RWN", 1); //according to Catalyst's waveform, RWN maintain back to high at any other situations.
					CheckError(ret, __LINE__);

					if (spi_status == 2)
					{
						spi_status = 0;
						readback = 0;

						spi_data_dir[0] = 0x00000ff; 
						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						CheckError(ret, __LINE__);

						ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
							}
							else
							{
								readback = -999;
							}
						}

						if (readback == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result_ith_trip);
							CheckError(ret, __LINE__);

							result_ith_trip = result_ith_trip*-1;

							break;
						}
					}

					if (Start_Data < Stop_Data )
						k++;
					else
						k--;
				}
			}
		}

		double result_final_0 = 0;
		double temp_ith_trip = result_ith - result_ith_trip;

		result_Rtrip = ((60e-3*(Rz+Rh)) / ((2*Rth*temp_ith_trip) + (Rh*60e-3))) - 1;
		result_final_0 = Rz/result_Rtrip;

		tf_SetResult(TPName[0], result_ith + GetOffset(TPDispName[0]));
		tf_SetResult(TPName[1], result_ith_trip + GetOffset(TPDispName[1]));
		tf_SetResult(TPName[2], result_final_0 + GetOffset(TPDispName[1]));

		/////////////////////////////////

		#ifndef USE_SPI
		ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(ret, __LINE__);

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);

		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);

		#endif

		ret = dm->ConfigurePMUVoltageLevel(Test_Pin, 0);
		CheckError(ret, __LINE__);
		
		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_flt_timing(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		array<double> ^ result_uts_delay	= gcnew array<double>(HDS);
		array<double> ^ result_stu_delay	= gcnew array<double>(HDS);

		for (int i=0; i<HDS; i++)
		{
			result_uts_delay[i] = 0;
			result_stu_delay[i] = 0;
		}

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;
		int retest_count = 0;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDX");
		CheckError(ret, __LINE__);

		ret = dm->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDY");
		CheckError(ret, __LINE__);

		//ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		//CheckError(ret, __LINE__);
		//ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		//CheckError(ret, __LINE__);
		//ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(ret, __LINE__);
		//ret = dm->DPINOn("RWN");
		//CheckError(ret, __LINE__);

		ret = dm->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SYNC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		//Must use vector method

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		tmu_start_threshold = 0.2; //0.75;
		tmu_stop_threshold = 0.2; //0.75;
		tmu_start_hysteresis = 0.02;//0.2;
		tmu_stop_hysteresis = 0.02;//0.2;
		number_of_samples = 1;
		tmu_timeout = 10e-3;
		sampled_result = gcnew array<double>(number_of_samples);
		retest_count = 0;

		double max_limit = 0;
		double min_limit = 0;

		for (int i=0; i<number_of_samples; i++)
		{
			sampled_result[i] = 0;
		}

		/////////////////////////////////

		for (int i=0; i<HDS; i++) //each head cell contains 2 results
		{
			Vector_File = (String ^)(tf_TestItemCondition_Cast("Vector_File_Hd" + i));

			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);

			///////////////
			// STU

			ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
			CheckError(ret, __LINE__);

			ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			retest_count = 0;

STU_RETEST:

			ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			CheckError(ret, __LINE__);

			ret = RunVectorFile("write_flt_stu"); //sync btw WDX/WDY & SYNC pin
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.1e-3);
		
			ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
			
			if (ret)
			{
				ret = 0;

				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto STU_RETEST;
				}
			}
			else
			{
				max_limit = (double)(tf_TPHighLimit_Cast(TPName[0]));
				min_limit = (double)(tf_TPLowLimit_Cast(TPName[0]));
				if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						retest_count++;
						goto STU_RETEST;
					}
				}
			}

			if (Double::IsNaN(sampled_result[0]) == false)
				result_stu_delay[i] = sampled_result[0];

			///////////////
			// UTS

			tmu_start_threshold = 0.8; //0.75;
			tmu_stop_threshold = 0.8; //0.75;

			ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
			CheckError(ret, __LINE__);

			ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
			CheckError(ret, __LINE__);

			//_util->Wait_Sec(1e-3);

			retest_count = 0;

UTS_RETEST:

			ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			CheckError(ret, __LINE__);

			ret = RunVectorFile("write_flt_uts");
			CheckError(ret, __LINE__);
			
			_util->Wait_Sec(0.5e-3);
		
			ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
			
			if (ret)
			{
				ret = 0;

				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto UTS_RETEST;
				}
			}
			else
			{
				max_limit = (double)(tf_TPHighLimit_Cast(TPName[2]));
				min_limit = (double)(tf_TPLowLimit_Cast(TPName[2]));
				if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						retest_count++;
						goto UTS_RETEST;
					}
				}
			}

			if (Double::IsNaN(sampled_result[0]) == false)
				result_uts_delay[i] = sampled_result[0];
		}

		tf_SetResult(TPName[0], result_stu_delay[0] + GetOffset(TPDispName[0]));
		tf_SetResult(TPName[1], result_stu_delay[1] + GetOffset(TPDispName[1]));
		tf_SetResult(TPName[2], result_uts_delay[0] + GetOffset(TPDispName[2]));
		tf_SetResult(TPName[3], result_uts_delay[1] + GetOffset(TPDispName[3]));

		/////////////////////////////////

		ret = Digital_Init_State(site);
		CheckError(ret, __LINE__);

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_wr_flt_timing(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int SPD_Channel			= _glob->SPD_Channel_Number;

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;
		array<int>^ HistoryRam = gcnew array<int>(256);
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		double period			= 0;
		double freq				= 0;
		int result_adc			= 0;
		int result_adc2			= 0;
		double result_wr_timing	= 0;

		/////////////////////////////////

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		vih = 1.8;
		ret = dm->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDX");
		CheckError(ret, __LINE__);

		vih = 1.5;
		ret = dm->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("WDY");
		CheckError(ret, __LINE__);

		#ifndef USE_SPI
		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);
		#else
		ret = OnOffSPI(1);
		CheckError(ret, __LINE__);
		ret = RunSPI(Vector_File);
		CheckError(ret, __LINE__);
		#endif

		for(int j=30; j<50; j++) //Catalyst's result is i=38, freq=3.44828MHz
		{
			//In Aemulus test, a full cycle consist 2 pulses (high - low).
			//In Catalyst test, a full cycle consist of 4 pulses (high - low - high - low). That means whatever freq set in Catalyst need to times 2 for Aemulus. Proved by observing scope shot. 
			freq	= 1/(100e-9 + 5e-9*j); //start with 4MHz, follow catalyst
			period	= 1/(freq*2);//times 2 is because 8 MHz for Aemulus.
			
			ret = dm->DPINPeriod("DM_2", 99, period); //always change no set 99 only
			CheckError(ret, __LINE__);
		
			//sweep WDX and WDY freq
			ret = dm->SPI_CH_UNSEL("DM_2", 0);
			CheckError(ret, __LINE__);

			ret = RunVectorFile("WDX_WDY_6400bits");
			CheckError(ret, __LINE__);

			ret = dm->SPI_CHSEL("DM_2", 0, "SPC", "SPE", "SPD", "SPD");
			CheckError(ret, __LINE__);

			//Read p1_reg6 and check for bit1 status
			#ifndef USE_SPI
			ret = ReadVector("read_p1_reg6_wr_flt_timing", data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI("read_p1_reg6_wr_flt_timing", data);
			CheckError(ret, __LINE__);
			#endif
			
			result_adc = data & 0x02;

			//Read p1_reg8 and check for bit2 status
			#ifndef USE_SPI
			ret = ReadVector("read_p1_reg8_wr_flt_timing", data);
			CheckError(ret, __LINE__);
			#else
			ret = ReadSPI("read_p1_reg8_wr_flt_timing", data);
			CheckError(ret, __LINE__);
			#endif

			result_adc2 = data & 0x04;

			if((result_adc == 2) && (result_adc2 == 4)) //if any of the FLT bit is triggered, then break
			{
				break;
			}
			else //reset & loop
			{
				result_adc	= 0;
				result_adc2 = 0;
			}
		}

		result_wr_timing = period;

		tf_SetResult(TPName[0], result_wr_timing + GetOffset(TPDispName[0]));

		/////////////////////////////////

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_rw_timing(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<int> ^ result = gcnew array<int>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double sync_rwn_timing = 0;

		if (calfactor->ContainsKey("SYNC_RWN_DELAY"))
			sync_rwn_timing = calfactor["SYNC_RWN_DELAY"][testSite];

		int sync_rwn_timing_index = (int)(sync_rwn_timing / 1e-9); //digitizer sampling interval is 1ns

		double Max_Thres		= 0;
		double Min_Thres		= 0;
		int	WRn_Trigger_Edge	= 0; //0=Rising, 1=Falling

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1  = String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = DriveMuxIO(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Setting up digitizer and DM"

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 512; //1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 100;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;
		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//ret = dm->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
		//CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		//ret = digitizer->Reset("DIGITIZER");
		//CheckError(ret, __LINE__);
		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);
		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
		}
		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);
		
		#pragma endregion "Setting up digitizer and DM"

		#pragma region "Setting up WRn vector"

		int vector_set_no = _glob->VectorArrSetNo + 1;

		//if (rw_timing_vset->ContainsKey(TIDispName) == false)
		{
			//Check WRN and SYNC pin numbers
			int WRN_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("RWN")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					WRN_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					WRN_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					WRN_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					WRN_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					WRN_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					WRN_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					WRN_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					WRN_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					WRN_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					WRN_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					WRN_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					WRN_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector (L -> H)
			int vector_size = 0;
			int l_size = 10; //=10*5ns = 50ns (5ns is the selected timing set value)
			int h_size = 10; 

			vector_size = (h_size + l_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int WRN = 0;
			if (WRN_Channel > 5)
				WRN = ((WRN_Channel-6) * 3 + 1);
			else
				WRN = WRN_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < h_size) 
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
				else
				{
					if (WRN_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != WRN_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (WRN_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<WRN;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= WRN_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo + 1;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 5e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}

			//rw_timing_vset->Add(TIDispName, vector_set_no);
		}
		
		#pragma endregion "Setting up WRn vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int digitizer_trigger_delay_index = 0;

		int retest_count = 0;

DIG_TRG_DEL_RETEST:

		double vThreshold = 0.1;

		//if (rw_timing_dig_del_index->ContainsKey(TIDispName) == false)
		{
			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}
			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] > vThreshold) //pos
					{
						digitizer_trigger_delay_index = k;

						if (digitizer_trigger_delay_index > 40)
						{
							retest_count++;

							if (retest_count < TIMING_RESET_COUNT)
							{
								goto DIG_TRG_DEL_RETEST;
							}
						}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			//rw_timing_dig_del_index->Add(TIDispName, digitizer_trigger_delay_index);
		}

		//digitizer_trigger_delay_index = rw_timing_dig_del_index[TIDispName];

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test != TEST_IF4600_PKG)
		{
			//Connect digitizer to WRxP
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}
		
		double timing = 0;

		for (int i=0; i<nbrSamples; i++)
		{
			dataArray[i] = 0;
		}

		double vThres = 15e-3; //amplitude change (diff voltage of P and N)
		int digitizer_trigger_edge_to_wrn_edge_delay_index = 20*5; //100ns (fixed in vector file)
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			Max_Thres = (double)(tf_TPCondition_Cast(TPName[i], "Max_Thres"));
			Min_Thres = (double)(tf_TPCondition_Cast(TPName[i], "Min_Thres"));
			WRn_Trigger_Edge = (int)(tf_TPCondition_Cast(TPName[i], "WRn_Trigger_Edge"));

			ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(ret, __LINE__);

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			{
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				Vector_File = "write_rw_timing_trig_" + WRn_Trigger_Edge.ToString();
				
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index+digitizer_trigger_edge_to_wrn_edge_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray[j] = dataArrayP[k] * diff2se_digitizer_factor;
						j++;
					}
				}

				index = -1;

				int ana_sample = 5;
				array<double> ^ dtmp = gcnew array<double>(ana_sample);
				double max = 0;
				double min = 0;

				for (int k=0; k<nbrSamples; k=k+ana_sample)
				{
					if (((k+ana_sample) % ana_sample == 0) && (k+ana_sample) <= nbrSamples)
					{
						dtmp[0] = dataArray[k];
						dtmp[1] = dataArray[k+1];
						dtmp[2] = dataArray[k+2];
						dtmp[3] = dataArray[k+3];
						dtmp[4] = dataArray[k+4];

						max = 0;
						min = 0;

						for (int m=0; m<ana_sample; m++)
						{			
							if (m == 0)
							{
								max = dtmp[m];
								min = dtmp[m];
							}
							else
							{
								if (dtmp[m] > max)
									max = dtmp[m];

								if (dtmp[m] < min)
									min = dtmp[m];
							}
						}

						if (Math::Abs(max - min) > vThres)
						{
							index = k;
							break;
						}
					}
				}

				if (index != -1)
				{
					timing = index * sampInterval;
				}
				else
				{
					timing = 999;
				}
		
				if (timing >= Min_Thres &&  timing <= Max_Thres)
					result[i] = 1;
				else
					result[i] = 0;

			}

			tf_SetResult(TPName[i], result[i] + (int)GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_rw_timing2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<int> ^ result = gcnew array<int>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double sync_rwn_timing = 0;

		if (calfactor->ContainsKey("SYNC_RWN_DELAY"))
			sync_rwn_timing = calfactor["SYNC_RWN_DELAY"][testSite];

		int sync_rwn_timing_index = (int)(sync_rwn_timing / 1e-9); //digitizer sampling interval is 1ns

		double Max_Thres		= 0;
		double Min_Thres		= 0;
		int	WRn_Trigger_Edge	= 0; //0=Rising, 1=Falling

		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		String ^ Vector_File_1  = String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = DriveMuxIO(TPDispName[0]);
		//CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Setting up digitizer and DM"

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 512; //1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 100;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArray = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;
		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//ret = dm->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
		//CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		//ret = digitizer->Reset("DIGITIZER");
		//CheckError(ret, __LINE__);
		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);
		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
		}
		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);
		
		#pragma endregion "Setting up digitizer and DM"

		#pragma region "Setting up WRn vector"

		int vector_set_no = _glob->VectorArrSetNo + 1;

		//if (rw_timing_vset->ContainsKey(TIDispName) == false)
		{
			//Check WRN and SYNC pin numbers
			int WRN_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("RWN")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					WRN_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					WRN_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					WRN_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					WRN_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					WRN_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					WRN_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					WRN_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					WRN_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					WRN_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					WRN_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					WRN_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					WRN_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector (L -> H)
			int vector_size = 0;
			int l_size = 1; //=100ns (100ns is the selected timing set value)
			int h_size = 1; 

			vector_size = (h_size + l_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int WRN = 0;
			if (WRN_Channel > 5)
				WRN = ((WRN_Channel-6) * 3 + 1);
			else
				WRN = WRN_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < h_size) 
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
				else
				{
					if (WRN_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != WRN_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<WRN;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (WRN_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<WRN;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= WRN_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo + 1;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 100e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}

			//rw_timing_vset->Add(TIDispName, vector_set_no);
		}
		
		#pragma endregion "Setting up WRn vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int digitizer_trigger_delay_index = 0;

		int retest_count = 0;

//DIG_TRG_DEL_RETEST:

		double vThreshold = 0.1;

		//if (rw_timing_dig_del_index->ContainsKey(TIDispName) == false)
		{
			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}
			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] > vThreshold) //pos
					{
						digitizer_trigger_delay_index = k;

						//if (digitizer_trigger_delay_index > 40)
						//{
						//	retest_count++;

						//	if (retest_count < TIMING_RESET_COUNT)
						//	{
						//		goto DIG_TRG_DEL_RETEST;
						//	}
						//}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			//rw_timing_dig_del_index->Add(TIDispName, digitizer_trigger_delay_index);
		}

		//digitizer_trigger_delay_index = rw_timing_dig_del_index[TIDispName];

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test != TEST_IF4600_PKG)
		{
			//Connect digitizer to WRxP
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);

			ret = DriveMuxIO(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}
		
		double timing = 0;

		for (int i=0; i<nbrSamples; i++)
		{
			dataArray[i] = 0;
		}

		double vThres = 15e-3; //amplitude change (diff voltage of P and N)
		int digitizer_trigger_edge_to_wrn_edge_delay_index = 1*100; //100ns (fixed in vector file)
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			Max_Thres = (double)(tf_TPCondition_Cast(TPName[i], "Max_Thres"));
			Min_Thres = (double)(tf_TPCondition_Cast(TPName[i], "Min_Thres"));
			WRn_Trigger_Edge = (int)(tf_TPCondition_Cast(TPName[i], "WRn_Trigger_Edge"));

			ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(ret, __LINE__);

			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			{
				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				_util->Wait_Sec(0.5e-3);
				Vector_File = "write_rw_timing_trig_" + WRn_Trigger_Edge.ToString();
				
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				
				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}

					int j = 0;
					for (int k=(digitizer_trigger_delay_index+digitizer_trigger_edge_to_wrn_edge_delay_index-sync_rwn_timing_index); k<dataArrayP->Length; k++)
					{
						dataArray[j] = dataArrayP[k] * diff2se_digitizer_factor;
						j++;
					}
				}

				index = -1;

				int ana_sample = 20;
				array<double> ^ dtmp = gcnew array<double>(ana_sample);
				double max = 0;
				double min = 0;

				int max_index = 0;
				int min_index = 0;

				int found = 0;

				//for (int k=0; k<nbrSamples; k=k+ana_sample)
				for (int k=0; k<nbrSamples; k++)
				{
					//if (((k+ana_sample) % ana_sample == 0) && (k+ana_sample) <= nbrSamples)
					if (k >= ana_sample-1)
					{
						//dtmp[0] = dataArray[k];
						//dtmp[1] = dataArray[k+1];
						//dtmp[2] = dataArray[k+2];
						//dtmp[3] = dataArray[k+3];
						//dtmp[4] = dataArray[k+4];

						for (int z=0; z<ana_sample; z++)
							dtmp[z] = dataArray[k-(ana_sample-z-1)];

						max = 0;
						min = 0;

						for (int m=0; m<ana_sample; m++)
						{			
							if (m == 0)
							{
								max = dtmp[m];
								min = dtmp[m];
							}
							else
							{
								if (dtmp[m] > max)
								{
									max = dtmp[m];
									max_index = m;
								}

								if (dtmp[m] < min)
								{
									min = dtmp[m];
									min_index = m;
								}
							}

							if ((m > 0) && Math::Abs(max - min) > vThres)
							{
								//index = k;
								if (max_index > min_index)
									index = k - (ana_sample-1) + max_index;
								else
									index = k - (ana_sample-1) + min_index;

								found = 1;
								break;
							}
						}	
					}

					if (found == 1)
						break;
				}

				if (index != -1)
				{
					timing = index * sampInterval;
				}
				else
				{
					timing = 999;
				}
		
				if (timing >= (Min_Thres-0.2e-9) &&  timing <= (Max_Thres+0.2e-9)) //to avoid decimation issue of double data type
					result[i] = 1;
				else
   					result[i] = 0;

			}

			tf_SetResult(TPName[i], result[i] + (int)GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_hth_timing_2hd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_hth_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_hth_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_hth_timing_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_hth_timing_calibrated[TIDispName]/2, -1 * Vswg_hth_timing_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting"

		//Trigger:
		//	Digitizer - Falling edge (sync with SPE)

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double ac_timing = 0;
		double dc_timing = 0;
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		double vThres = 0.1;
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			ret = RunVectorFile(Vector_File_Init);
			CheckError(ret, __LINE__);

			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

			if ((TPName[i]->Contains("0to1") == true)) //start test here
			{
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
			}	

			_util->Wait_Sec(0.5e-3);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}

			if ((TPName[i]->Contains("0to1") == false)) //start test here
			{
				//////////////////////////////////
				//DC (no waveform)
				//////////////////////////////////
				
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
					{
						index = k;
						break;
					}
				}

				if (index != -1)
				{
					dc_timing = index * sampInterval;
				}
				else
				{
					dc_timing = 0;
				}

				result[i] = dc_timing;
			}
			else
			{
				//////////////////////////////////
				//AC
				//////////////////////////////////
	
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				int off_time_count = 0;
				int off_time_start_index = 0;
				int found = 0;
				for (int k=0; k<nbrSamples; k++)
				{
					//Look for 50 consecutive points where amplitude < vThres (to confirm off time)

					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) < vThres)
					{
						off_time_count++;

						if (off_time_count == 50)
						{
							found = 1;
							off_time_start_index = k - 50 + 1;
							break;
						}
					}
					else
					{
						off_time_count = 0;
					}
				}

				if (found == 1)
				{
					for (int k=off_time_start_index; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							index = k - off_time_start_index;
							break;
						}
					}
				}

				if (index != -1)
				{
					ac_timing = index * sampInterval;
				}
				else
				{
					ac_timing = 999;
				}

				result[i] = ac_timing;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_hth_timing_2hd_2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_hth_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_hth_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_hth_timing_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			/*ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_hth_timing_calibrated[TIDispName]/2, -1 * Vswg_hth_timing_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);*/

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting"

		//Trigger:
		//	Digitizer - Falling edge (sync with SPE)

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Setting up SPE vector"

		int vector_set_no = _glob->VectorArrSetNo + 1;

		{
			//Check SPE and SYNC pin numbers
			int SPE_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("SPE")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					SPE_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					SPE_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					SPE_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					SPE_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					SPE_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					SPE_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					SPE_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					SPE_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					SPE_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					SPE_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					SPE_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					SPE_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector (H -> L)
			int vector_size = 0;
			int l_size = 1; //=100ns (100ns is the selected timing set value)
			int h_size = 1; 

			vector_size = (h_size + l_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int SPE = 0;
			if (SPE_Channel > 5)
				SPE = ((SPE_Channel-6) * 3 + 1);
			else
				SPE = SPE_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < h_size) 
				{
					if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<SPE;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != SPE_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<SPE;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= SPE_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
				else
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo + 1;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 100e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}
		}
		
		#pragma endregion "Setting up SPE vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int digitizer_trigger_delay_index = 0;

		int retest_count = 0;

//DIG_TRG_DEL_RETEST:

		double vThreshold = 0.1;

		{
			//CBIT13 (Connect SWG to DM_TO_ACM)
			ret = OnOffCbit(13, 1);
			CheckError(ret, __LINE__);

			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}
			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] < vThreshold) //neg
					{
						digitizer_trigger_delay_index = k;

						//if (digitizer_trigger_delay_index > 40)
						//{
						//	retest_count++;

						//	if (retest_count < TIMING_RESET_COUNT)
						//	{
						//		goto DIG_TRG_DEL_RETEST;
						//	}
						//}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = OnOffCbit(13, 0);
			CheckError(ret, __LINE__);
		}

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_hth_timing_calibrated[TIDispName]/2, -1 * Vswg_hth_timing_calibrated[TIDispName]/2, Fswg, 0);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(ret, __LINE__);
		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double ac_timing = 0;
		double dc_timing = 0;
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		double vThres = 0.1;
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			ret = RunVectorFile(Vector_File_Init);
			CheckError(ret, __LINE__);

			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

			if ((TPName[i]->Contains("0to1") == true)) //start test here
			{
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
			}	

			_util->Wait_Sec(0.5e-3);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = RunVectorFile(Vector_File);
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}

			if ((TPName[i]->Contains("0to1") == false)) //start test here
			{
				//////////////////////////////////
				//DC (no waveform)
				//////////////////////////////////
				
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
					{
						index = k;
						break;
					}
				}

				if (index != -1)
				{
					dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
				}
				else
				{
					dc_timing = 0;
				}

				result[i] = dc_timing;
			}
			else
			{
				//////////////////////////////////
				//AC
				//////////////////////////////////
	
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				int off_time_count = 0;
				int off_time_start_index = 0;
				int found = 0;
				for (int k=0; k<nbrSamples; k++)
				{
					//Look for 50 consecutive points where amplitude < vThres (to confirm off time)

					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) < vThres)
					{
						off_time_count++;

						if (off_time_count == 50)
						{
							found = 1;
							off_time_start_index = k - 50 + 1;
							break;
						}
					}
					else
					{
						off_time_count = 0;
					}
				}

				if (found == 1)
				{
					for (int k=off_time_start_index; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							//index = k - off_time_start_index;
							index = k; 
							break;
						}
					}
				}

				if (index != -1)
				{
					ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
				}
				else
				{
					ac_timing = 999;
				}

				result[i] = ac_timing;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_bias_timing(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_Bias1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Bias1"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_bias_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_bias_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_bias_timing_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_bias_timing_calibrated[TIDispName]/2, -1 * Vswg_bias_timing_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting"

		//Trigger:
		//	Digitizer - Falling edge (sync with SPE)

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double ac_timing = 0;
		double dc_timing = 0;
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);

		double vThres = 0.3;
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			if ((TPName[i]->Contains("AC") == true)) //start test here
			{
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
			}	

			_util->Wait_Sec(0.5e-3);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = RunVectorFile(Vector_File_Bias1);
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}

			if ((TPName[i]->Contains("AC") == false)) //start test here
			{
				//////////////////////////////////
				//DC (no waveform)
				//////////////////////////////////
				
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
					{
						index = k;
						break;
					}
				}

				if (index != -1)
				{
					dc_timing = index * sampInterval;
				}
				else
				{
					dc_timing = 0;
				}

				result[i] = dc_timing;
			}
			else
			{
				//////////////////////////////////
				//AC
				//////////////////////////////////
	
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				int off_time_count = 0;
				int off_time_start_index = 0;
				int found = 0;
				for (int k=0; k<nbrSamples; k++)
				{
					//Look for 50 consecutive points where amplitude < vThres (to confirm off time)

					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) < 0.1)
					{
						off_time_count++;

						if (off_time_count == 50)
						{
							found = 1;
							off_time_start_index = k - 50 + 1;
							break;
						}
					}
					else
					{
						off_time_count = 0;
					}
				}

				if (found == 1)
				{
					for (int k=off_time_start_index; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							index = k - off_time_start_index;
							break;
						}
					}
				}

				if (index != -1)
				{
					ac_timing = index * sampInterval;
				}
				else
				{
					ac_timing = 999;
				}

				result[i] = ac_timing;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_bias_timing2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File_Bias1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Bias1"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_bias_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_bias_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_bias_timing_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			//ret = acm->ResetChannel("ACM_CH");
			//CheckError(ret, __LINE__);
			//ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			//CheckError(ret, __LINE__);
			//ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_bias_timing_calibrated[TIDispName]/2, -1 * Vswg_bias_timing_calibrated[TIDispName]/2, Fswg, 0);
			//CheckError(ret, __LINE__);
			//ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			//CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting"

		//Trigger:
		//	Digitizer - Falling edge (sync with SPE)

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Setting up SPE vector"

		int vector_set_no = _glob->VectorArrSetNo + 1;

		{
			//Check SPE and SYNC pin numbers
			int SPE_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("SPE")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					SPE_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					SPE_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					SPE_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					SPE_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					SPE_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					SPE_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					SPE_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					SPE_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					SPE_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					SPE_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					SPE_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					SPE_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector (H -> L)
			int vector_size = 0;
			int l_size = 1; //=100ns (100ns is the selected timing set value)
			int h_size = 1; 

			vector_size = (h_size + l_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int SPE = 0;
			if (SPE_Channel > 5)
				SPE = ((SPE_Channel-6) * 3 + 1);
			else
				SPE = SPE_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < h_size) 
				{
					if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<SPE;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != SPE_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<SPE;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= SPE_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
				else
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo + 1;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 100e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}
		}
		
		#pragma endregion "Setting up SPE vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int digitizer_trigger_delay_index = 0;

		int retest_count = 0;

//DIG_TRG_DEL_RETEST:

		double vThreshold = 0.1;

		{
			//CBIT13 (Connect SWG to DM_TO_ACM)
			ret = OnOffCbit(13, 1);
			CheckError(ret, __LINE__);

			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}
			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] < vThreshold) //neg
					{
						digitizer_trigger_delay_index = k;

						//if (digitizer_trigger_delay_index > 40)
						//{
						//	retest_count++;

						//	if (retest_count < TIMING_RESET_COUNT)
						//	{
						//		goto DIG_TRG_DEL_RETEST;
						//	}
						//}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = OnOffCbit(13, 0);
			CheckError(ret, __LINE__);
		}

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_bias_timing_calibrated[TIDispName]/2, -1 * Vswg_bias_timing_calibrated[TIDispName]/2, Fswg, 0);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(ret, __LINE__);
		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double ac_timing = 0;
		double dc_timing = 0;
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		ret = RunVectorFile(Vector_File_Init);
		CheckError(ret, __LINE__);

		double vThres = 0.3;
		int index = -1;

		for (int i=0; i<total_tp; i++)
		{
			if ((TPName[i]->Contains("AC") == true)) //start test here
			{
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);
			}
			else
			{
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
			}	

			_util->Wait_Sec(0.5e-3);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			_util->Wait_Sec(0.5e-3);

			ret = RunVectorFile(Vector_File_Bias1);
			CheckError(ret, __LINE__);

			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}

			if ((TPName[i]->Contains("AC") == false)) //start test here
			{
				//////////////////////////////////
				//DC (no waveform)
				//////////////////////////////////
				
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				for (int k=0; k<nbrSamples; k++)
				{
					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
					{
						index = k;
						break;
					}
				}

				if (index != -1)
				{
					dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
				}
				else
				{
					dc_timing = 0;
				}

				result[i] = dc_timing;
			}
			else
			{
				//////////////////////////////////
				//AC
				//////////////////////////////////
	
				if (ret == 0)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
					CheckError(ret, __LINE__);

					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
						CheckError(ret, __LINE__);
					}
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
						}
						outFile.close();
					}

					if (Test == TEST_IF4600_PKG)
					{
						for (int k=0; k<dataArrayP->Length; k++)
						{
							dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
						}
					}
				}

				index = -1;
				int off_time_count = 0;
				int off_time_start_index = 0;
				int found = 0;
				for (int k=0; k<nbrSamples; k++)
				{
					//Look for 50 consecutive points where amplitude < vThres (to confirm off time)

					if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) < 0.1)
					{
						off_time_count++;

						if (off_time_count == 50)
						{
							found = 1;
							off_time_start_index = k - 50 + 1;
							break;
						}
					}
					else
					{
						off_time_count = 0;
					}
				}

				if (found == 1)
				{
					for (int k=off_time_start_index; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							//index = k - off_time_start_index;
							index = k;
							break;
						}
					}
				}

				if (index != -1)
				{
					ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
				}
				else
				{
					ac_timing = 999;
				}

				result[i] = ac_timing;
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_itr_timing(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		double diff2se_digitizer_factor_dc = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_100M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_100M"][testSite];

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
			diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("Vector_File_Init");
		CheckError(ret, __LINE__);
		
		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_itr_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_itr_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_itr_timing_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_itr_timing_calibrated[TIDispName]/2, -1 * Vswg_itr_timing_calibrated[TIDispName]/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting"

		//Trigger:
		//	Digitizer - Falling edge (sync with SPE)

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double ac_timing = 0;
		double dc_timing = 0;
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		double vThres = 0.1;
		int index = -1;
		double vpp = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Vsettle") == false)
			{
				ret = RunVectorFile("write_p1_reg9_mode_active");
				CheckError(ret, __LINE__);
	
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				if (TPName[i]->Contains("AC") == true) //start test here
				{
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
				}	

				_util->Wait_Sec(0.5e-3);

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}

				if ((TPName[i]->Contains("DC") == true)) //start test here
				{
					//////////////////////////////////
					//DC (no waveform)
					//////////////////////////////////
					
					if (ret == 0)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
						CheckError(ret, __LINE__);

						if (Test == TEST_IF4600_PKG)
						{
							ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
							CheckError(ret, __LINE__);
						}
				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
							}
							outFile.close();
						}

						if (Test == TEST_IF4600_PKG)
						{
							for (int k=0; k<dataArrayP->Length; k++)
							{
								dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
							}
						}
					}

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							index = k;
							break;
						}
					}

					if (index != -1)
					{
						dc_timing = index * sampInterval;
					}
					else
					{
						dc_timing = 0;
					}

					result[i] = dc_timing;
				}
				else
				{
					//////////////////////////////////
					//AC
					//////////////////////////////////
		
					if (ret == 0)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
						CheckError(ret, __LINE__);

						if (Test == TEST_IF4600_PKG)
						{
							ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
							CheckError(ret, __LINE__);
						}
				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
							}
							outFile.close();
						}

						if (Test == TEST_IF4600_PKG)
						{
							for (int k=0; k<dataArrayP->Length; k++)
							{
								dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
							}
						}
					}

					index = -1;
					int off_time_count = 0;
					int off_time_start_index = 0;
					int found = 0;
					for (int k=0; k<nbrSamples; k++)
					{
						//Look for 50 consecutive points where amplitude < vThres

						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) < vThres)
						{
							off_time_count++;

							if (off_time_count == 50)
							{
								found = 1;
								off_time_start_index = k - 50 + 1;
								break;
							}
						}
						else
						{
							off_time_count = 0;
						}
					}

					if (found == 1)
					{
						index = off_time_start_index;
					}

					if (index != -1)
					{
						ac_timing = index * sampInterval;
					}
					else
					{
						ac_timing = 999;
					}

					result[i] = ac_timing;

					//Calculate vpp of the settled voltage

					if (ac_timing != 999)
					{
						double average = 0;
						for (int k=0; k<nbrSamples-index; k++)
						{
							average += dataArrayP[k];
						}

						vpp = average / (nbrSamples-index);

						vpp = vpp * diff2se_digitizer_factor_dc;
					}
					else
					{
						vpp = 999;
					}

					result[i+1] = vpp;
				}
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:
		
		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_itr_timing2(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		double diff2se_digitizer_factor_dc = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_100M"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_100M"][testSite];

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
			diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("Vector_File_Init");
		CheckError(ret, __LINE__);
		
		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double vout_pp = 0.0;

		int max_loop = 50;

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K3, K4
			ret = DriveCBit(TPDispName[0], 1);
			CheckError(ret, __LINE__);
		}

		#pragma region "Calibration of Vpp"
		if (Vswg_itr_timing_calibrated->ContainsKey(TIDispName) == false)
		{
			double Vswg_cal = 0;
			int loop_count = 0;

			Vswg_cal = Vswg;

			ret = acm->ResetChannel("ACM_CH");
			CheckError(ret, __LINE__);
			ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
			CheckError(ret, __LINE__);
			ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm->RunFG("ACM_CH", 0, true);
			CheckError(ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			int do_once = 0;
			while(loop_count <= max_loop)
			{
				if (do_once == 0)
				{
					//ret = digitizer->Reset("DIGITIZER");
					//CheckError(ret, __LINE__);
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
					CheckError(ret, __LINE__);
					if (Test == TEST_IF4600_PKG)
					{
						ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
						CheckError(ret, __LINE__);
					}
					ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
					CheckError(ret, __LINE__);
					ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(ret, __LINE__);
					CheckError(ret, __LINE__);
					do_once = 1;
				}

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = digitizer->ForceTrigger("DIGITIZER");
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret == -1074116410) //ERROR: Instrument already stopped
					ret = 0;
				CheckError(ret, __LINE__);

				if (ret)
				{
					if (Debug_Enable == true)
					{
						StringBuilder ^ sa = gcnew StringBuilder();
						ret = digitizer->GetErrorMessage("DIGITIZER", ret, sa);

						sb->AppendLine("WaitForEndOfAcquisition return=" + ret.ToString());
						sb->AppendLine("WaitForEndOfAcquisition error msg=" + sa->ToString());
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					ret = 0;

					goto test_end;
				}

				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int i=0; i<dataArrayP->Length; i++)
					{
						dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
					}
				}

				vout_pp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

				vout_pp = vout_pp * diff2se_digitizer_factor;

				if (Math::Abs(Vswg - vout_pp) < (4e-3))
				{
					break;
				}
				else
				{
					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
					{
						CheckError(ret, __LINE__);	
					}

					if (ret != 0) 
					{
						ret = 0;

						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);
						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);
						
						if(Test == TEST_IF4600_PKG)
						{
							ret = dio->DrivePin("DIO_3", 0);
							CheckError(ret, __LINE__);
							ret = dio->DrivePin("DIO_4", 0);
							CheckError(ret, __LINE__);
						}
						else
						{
							//off K3, K4
							ret = DriveCBit(TPDispName[0], 0);
							CheckError(ret, __LINE__);
						}

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}
	
				loop_count++;
			}

			if (loop_count > max_loop)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				for (int i=0; i<total_tp; i++)
				{
					tf_SetResult(TPName[i], (double)(-999));
				}

				goto test_end;
			}
						
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			Vswg_itr_timing_calibrated->Add(TIDispName, Vswg_cal);
			Vswg_itr_timing_at_dut->Add(TIDispName, vout_pp);
		}
		else
		{
			//ret = acm->ResetChannel("ACM_CH");
			//CheckError(ret, __LINE__);
			//ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			//CheckError(ret, __LINE__);
			//ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_itr_timing_calibrated[TIDispName]/2, -1 * Vswg_itr_timing_calibrated[TIDispName]/2, Fswg, 0);
			//CheckError(ret, __LINE__);
			//ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			//CheckError(ret, __LINE__);

			ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
			if (Test == TEST_IF4600_PKG)
			{
				ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
				CheckError(ret, __LINE__);
			}
			ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(ret, __LINE__);
			ret = digitizer->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(ret, __LINE__);
		}
		#pragma endregion "Calibration of Vpp"	

		#pragma region "Setting"

		//Trigger:
		//	Digitizer - Falling edge (sync with SPE)

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		//Digitizer setting
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		trigLevel = 300;	//% of FS, or mV if external trigger is used
							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

		trigSlope = 1; //negative

		timeOut_ms = 100;

		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Setting up SPE vector"

		int vector_set_no = _glob->VectorArrSetNo + 1;

		{
			//Check SPE and SYNC pin numbers
			int SPE_Channel = 0;
			int DM_TO_ACM_Channel = 0;
			try
			{
				resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

				Resource ^ hardwareResource = resourceManager->ResolveResource("SPE")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					SPE_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					SPE_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					SPE_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					SPE_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					SPE_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					SPE_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					SPE_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					SPE_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					SPE_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					SPE_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					SPE_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					SPE_Channel = 9;

				hardwareResource = resourceManager->ResolveResource("DM_TO_ACM")[0];

				if (hardwareResource->Alias->Contains("Ch10"))
					DM_TO_ACM_Channel = 10;
				else if (hardwareResource->Alias->Contains("Ch11"))
					DM_TO_ACM_Channel = 11;
				else if (hardwareResource->Alias->Contains("Ch0"))
					DM_TO_ACM_Channel = 0;
				else if (hardwareResource->Alias->Contains("Ch1"))
					DM_TO_ACM_Channel = 1;
				else if (hardwareResource->Alias->Contains("Ch2"))
					DM_TO_ACM_Channel = 2;
				else if (hardwareResource->Alias->Contains("Ch3"))
					DM_TO_ACM_Channel = 3;
				else if (hardwareResource->Alias->Contains("Ch4"))
					DM_TO_ACM_Channel = 4;
				else if (hardwareResource->Alias->Contains("Ch5"))
					DM_TO_ACM_Channel = 5;
				else if (hardwareResource->Alias->Contains("Ch6"))
					DM_TO_ACM_Channel = 6;
				else if (hardwareResource->Alias->Contains("Ch7"))
					DM_TO_ACM_Channel = 7;
				else if (hardwareResource->Alias->Contains("Ch8"))
					DM_TO_ACM_Channel = 8;
				else if (hardwareResource->Alias->Contains("Ch9"))
					DM_TO_ACM_Channel = 9;

				if (resourceManager)
					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			//Set up vector (H -> L)
			int vector_size = 0;
			int l_size = 1; //=100ns (100ns is the selected timing set value)
			int h_size = 1; 

			vector_size = (h_size + l_size);
			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
			int LL = 0x0; //Logic Low
			int LH = 0x1; //Logic High 
			int CL = 0x2; //Compare Low
			int CH = 0x3; //Compare High
			int triX = 0x4; //Tri-state & Don't Compare

			int SPE = 0;
			if (SPE_Channel > 5)
				SPE = ((SPE_Channel-6) * 3 + 1);
			else
				SPE = SPE_Channel * 3 + 1;
			
			int DM_TO_ACM = 0;
			if (DM_TO_ACM_Channel > 5)
				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
			else
				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

			for (int i=0; i<vector_size; i++)
			{
				group0_vectors[i] = 0x0;
				group1_vectors[i] = 0x0;

				if (i < h_size) 
				{
					if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1 | LH<<SPE;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != SPE_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LH<<SPE;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= SPE_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}	
				}
				else
				{
					group0_vectors[i] |= 0x0;
					group1_vectors[i] |= 0x0;
				}
			}

			int timing_set_no = 0;
			//int vector_set_no = _glob->VectorArrSetNo + 1;
			ret = dm->DPINPeriod("DM_2", timing_set_no, 100e-9);
			CheckError(ret, __LINE__);
			ret = dm->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
			CheckError(ret, __LINE__);

			if (Debug_Enable == true)
			{
				ret = dm->RunVector("DM_2", vector_set_no);
				//CheckError(ret, __LINE__);
			}
		}
		
		#pragma endregion "Setting up SPE vector"

		#pragma region "Looking for digitizer trigger delay (vector method)"

		int digitizer_trigger_delay_index = 0;

		int retest_count = 0;

//DIG_TRG_DEL_RETEST:

		double vThreshold = 0.1;

		{
			//CBIT13 (Connect SWG to DM_TO_ACM)
			ret = OnOffCbit(13, 1);
			CheckError(ret, __LINE__);

			ret = dm->DPINOn("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = digitizer->StartAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = dm->RunVector("DM_2", vector_set_no);
			//CheckError(ret, __LINE__);
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm->AcquireVecEngineStatus("DM_2", vector_engine_status);
				CheckError(ret, __LINE__);

				if (vector_engine_status == 0)
					break;

				swatch.Stop();
			}
			if (vector_engine_status != 0)
			{
				ret = digitizer->StopAcquire("DIGITIZER");
				throw gcnew Aemulus::Hardware::AlarmException("Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
			}
			ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
			if (ret < 0) 
			{
				//ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);
			}
			if (ret == 0)
			{
				ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
				CheckError(ret, __LINE__);

				if (Test == TEST_IF4600_PKG)
				{
					ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
					CheckError(ret, __LINE__);
				}
		
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
					for (int k = 0; k < nbrSamples; k++) 
					{
						outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
					}
					outFile.close();
				}

				if (Test == TEST_IF4600_PKG)
				{
					for (int k=0; k<dataArrayP->Length; k++)
					{
						dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
					}
				}
			
				for (int k=0; k<dataArrayP->Length; k++)
				{
					if(dataArrayP[k] < vThreshold) //neg
					{
						digitizer_trigger_delay_index = k;

						//if (digitizer_trigger_delay_index > 40)
						//{
						//	retest_count++;

						//	if (retest_count < TIMING_RESET_COUNT)
						//	{
						//		goto DIG_TRG_DEL_RETEST;
						//	}
						//}

						break;
					}
				}			
			}

			ret = dm->DPINOff("DM_TO_ACM");
			CheckError(ret, __LINE__);

			ret = OnOffCbit(13, 0);
			CheckError(ret, __LINE__);
		}

		#pragma endregion "Looking for digitizer trigger delay (vector method)"

		#pragma region "Test"

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		else
		{
			//Off K3, K4
			ret = DriveCBit(TPDispName[0], 0);
			CheckError(ret, __LINE__);
		}

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);
		ret = acm->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_itr_timing_calibrated[TIDispName]/2, -1 * Vswg_itr_timing_calibrated[TIDispName]/2, Fswg, 0);
		CheckError(ret, __LINE__);
		ret = acm->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(ret, __LINE__);

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		double ac_timing = 0;
		double dc_timing = 0;
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		double vThres = 0.1;
		int index = -1;
		double vpp = 0;

		for (int i=0; i<total_tp; i++)
		{
			if (TPName[i]->Contains("Vsettle") == false)
			{
				ret = RunVectorFile("write_p1_reg9_mode_active");
				CheckError(ret, __LINE__);
	
				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				if (TPName[i]->Contains("AC") == true) //start test here
				{
					ret = acm->RunFG("ACM_CH", 0, true);
					CheckError(ret, __LINE__);
				}
				else
				{
					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
				}	

				_util->Wait_Sec(0.5e-3);

				ret = digitizer->StartAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);

				ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				if (ret < 0) 
				{
					//ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);
				}

				if ((TPName[i]->Contains("DC") == true)) //start test here
				{
					//////////////////////////////////
					//DC (no waveform)
					//////////////////////////////////
					
					if (ret == 0)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
						CheckError(ret, __LINE__);

						if (Test == TEST_IF4600_PKG)
						{
							ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
							CheckError(ret, __LINE__);
						}
				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
							}
							outFile.close();
						}

						if (Test == TEST_IF4600_PKG)
						{
							for (int k=0; k<dataArrayP->Length; k++)
							{
								dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
							}
						}
					}

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							index = k;
							break;
						}
					}

					if (index != -1)
					{
						dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
					}
					else
					{
						dc_timing = 0;
					}

					result[i] = dc_timing;
				}
				else
				{
					//////////////////////////////////
					//AC
					//////////////////////////////////
		
					if (ret == 0)
					{
						ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP);
						CheckError(ret, __LINE__);

						if (Test == TEST_IF4600_PKG)
						{
							ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
							CheckError(ret, __LINE__);
						}
				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << dataArrayP[k] << "," << dataArrayN[k] << "," << dataArrayP[k]-dataArrayN[k] <<endl;
							}
							outFile.close();
						}

						if (Test == TEST_IF4600_PKG)
						{
							for (int k=0; k<dataArrayP->Length; k++)
							{
								dataArrayP[k] = dataArrayP[k] - dataArrayN[k]; //get the differential values
							}
						}
					}

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(dataArrayP[k] * diff2se_digitizer_factor) > vThres)
						{
							index = k;
							break;
						}
					}

					if (index != -1)
					{
						ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
					}
					else
					{
						ac_timing = 999;
					}

					result[i] = ac_timing;

					//Calculate vpp of the settled voltage

					if (ac_timing != 999)
					{
						double average = 0;
						for (int k=digitizer_trigger_delay_index; k<index; k++)
						{
							average += dataArrayP[k];
						}

						vpp = average / (index-digitizer_trigger_delay_index);

						vpp = vpp * diff2se_digitizer_factor_dc;
					}
					else
					{
						vpp = 999;
					}

					result[i+1] = vpp;
				}
			}

			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}
		#pragma endregion "Test"

test_end:
		
		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);
		//ret = dm->ConfigureOutputTriggerSelect("DM_2", 0, 0);
		//CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}

	int TestProgram::seq_wtr_slow(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		String ^ Vector_File		= String::Empty;

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_DC"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("RWN");
		CheckError(ret, __LINE__);

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile("write_default_reg");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("Vector_File_Init");
		CheckError(ret, __LINE__);
	
		#pragma region "Setting"

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 320000;
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 1;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 

		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
			{
				sourcePattern = 0x80000000;
			}
			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
			{
				sourcePattern = 0x40000000;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 1;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 300;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 100;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		//ret = digitizer->Reset("DIGITIZER");
		//CheckError(ret, __LINE__);
		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(ret, __LINE__);
		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->ConfigureVertical("DIGITIZER_CH_N", fullScale, offset, coupling, bandwidth);
			CheckError(ret, __LINE__);
		}
		ret = digitizer->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(ret, __LINE__);
		ret = digitizer->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		CheckError(ret, __LINE__);

		//DM seting
		ret = dm->ConfigureOutputTriggerSelect("DM_2", 1, 26);
		CheckError(ret, __LINE__);

		#pragma endregion "Setting"	

		#pragma region "Test"
		
		for (int i=0; i<nbrSamples; i++)
		{
			dataArrayP[i] = 0;
			if (Test == TEST_IF4600_PKG)
			{
				dataArrayN[i] = 0;
			}
		}

		double vThres = 0.07;
		int index = -1;
		double vpp = 0;

		ret = digitizer->StartAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.5e-3);

		ret = RunVectorFile("write_rwn_sync");
		CheckError(ret, __LINE__);

		ret = digitizer->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms); //0xBFFA4900=timeout
		if (ret < 0) 
		{
			//ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);
		}

		ret = digitizer->RetrieveData("DIGITIZER_CH", dataArrayP); 
		CheckError(ret, __LINE__);

		if (Test == TEST_IF4600_PKG)
		{
			ret = digitizer->RetrieveData("DIGITIZER_CH_N", dataArrayN); 
			CheckError(ret, __LINE__);
		}

		if (Debug_Enable == true)
		{
			ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
			for (int i = 0; i < nbrSamples; i++) 
			{
				if (Test == TEST_IF4600_PKG)
				{
					outFile << dataArrayP[i] << "," << dataArrayN[i] << "," << dataArrayP[i]-dataArrayN[i] <<endl;
				}
				else
				{
					outFile << dataArrayP[i] << endl;
				}
			}
			outFile.close();
		}

		if (Test == TEST_IF4600_PKG)
		{
			for (int i=0; i<dataArrayP->Length; i++)
			{
				dataArrayP[i] = dataArrayP[i] - dataArrayN[i]; //get the differential values
			}
		}

		double vp_peak = 0;
		double vn_peak = 0;

		double vp_peak_index = 0;
		double vn_peak_index = 0;

		int found = 0;
				
		for (int i=0; i<nbrSamples; i=i+100) //as if 10MHz sampling rate
		{
			if (i == 0)
			{
				vp_peak = dataArrayP[i];
				vn_peak = dataArrayP[i];
			}

			if (dataArrayP[i] > vp_peak)
			{
				vp_peak = dataArrayP[i];
				vp_peak_index = i / 100;
			}

			if (dataArrayP[i] < vn_peak)
			{
				vn_peak = dataArrayP[i];
				vn_peak_index = i / 100;
			}

			if (found == 0)
			{
				if (Math::Abs(dataArrayP[i]) * diff2se_digitizer_factor > vThres)
				{
					result[0] = (i/100) * sampInterval + 1e-6; //+1us, follow Catalyst
					found = 1;
				}
			}
		}

		if (found == 0)
		{
			result[0] = 1e-6;
		}

		if (Math::Abs(vp_peak) > Math::Abs(vn_peak))
		{
			result[1] = vp_peak * diff2se_digitizer_factor;
			result[2] = vp_peak_index * sampInterval + 1e-6; //+1us, follow Catalyst
		}
		else
		{
			result[1] = vn_peak * diff2se_digitizer_factor;
			result[2] = vn_peak_index * sampInterval + 1e-6; //+1us, follow Catalyst
		}
		
		for (int i=0; i<total_tp; i++)
		{
			tf_SetResult(TPName[i], result[i] + GetOffset(TPDispName[i]));
		}

		#pragma endregion "Test"

		ret = digitizer->StopAcquire("DIGITIZER");
		CheckError(ret, __LINE__);

		ret = Digital_Init_State(site); 
		CheckError(ret, __LINE__);
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_autocal(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<int> ^ result = gcnew array<int>(total_tp);
		
		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		bool isCurrentTPBypassed	= false; 
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		String ^ Vector_File_Wr	= String::Empty;
		String ^ Vector_File_Rd	= String::Empty;
		int Mask_Bit = 0;
		int Shift_Bit = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		///////////////////////////////////

		for (int i=0; i<total_tp; i++)
		{
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

			if (isCurrentTPBypassed == false)
			{
				Vector_File_Wr = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_Wr");
				Vector_File_Rd = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_Rd");
				Mask_Bit = (int)tf_TPCondition_Cast(TPName[i], "Mask_Bit");
				Shift_Bit = (int)tf_TPCondition_Cast(TPName[i], "Shift_Bit");

				#ifndef USE_SPI
				ret = RunVectorFile(Vector_File_Wr);
				CheckError(ret, __LINE__);
				#else
				ret = OnOffSPI(1);
				CheckError(ret, __LINE__);
				ret = RunSPI(Vector_File_Wr);
				CheckError(ret, __LINE__);
				#endif

				_util->Wait_Sec(Measure_Delay_s);

				int data = 0;

				#ifndef USE_SPI
				ret = ReadVector(Vector_File_Rd, data);
				CheckError(ret, __LINE__);
				#else
				ret = ReadSPI(Vector_File_Rd, data);
				CheckError(ret, __LINE__);
				#endif

				result[i] = data & Mask_Bit;

				result[i] = result[i] >> Shift_Bit;

				if (TPName[i]->Contains("AutoCalResult") == true)
				{
					switch(result[i])
					{
						case 0:  result[i]=0; break;
						case 1:  result[i]=1; break;
						case 3:  result[i]=2; break;
						case 7:  result[i]=3; break;
						case 15: result[i]=4; break;
						case 31: result[i]=5; break;
						default: result[i]=99;break; 
					}
				}

				tf_SetResult(TPName[i], result[i] + (int)GetOffset(TPDispName[i]));
			}
		}

		///////////////////////////////////

		#ifdef USE_SPI
		ret = OnOffSPI(0);
		CheckError(ret, __LINE__);
		#endif

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_fhs_dmux_spd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 0;
		double tmu_timeout = 0;
		int returned_sample_count = 0;
		array<double> ^ sampled_result;
		int retest_count = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);

		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		/////////////////////////////////

		ret = dm->DPINOff("FLTMUX");
		CheckError(ret, __LINE__);

		ret = dm->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit("FLTMUX", 6, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel("FLTMUX", 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn("FLTMUX");
		CheckError(ret, __LINE__);

		/////////////////////////////////
		
		ret = dm->DPINOff("TA0P_F");
		CheckError(ret, __LINE__);

		ret = dm->Force("TA0P_F", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime("TA0P_F", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction("TA0P_F", DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit("TA0P_F", 6, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel("TA0P_F", 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn("TA0P_F");
		CheckError(ret, __LINE__);

		ret = dm->DPINOff("TA0N_F");
		CheckError(ret, __LINE__);

		ret = dm->Force("TA0N_F", DM_CONST_FORCE_STATE_PMU);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUSamplingTime("TA0N_F", NPLC, DM_CONST_PLC);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUOutputFunction("TA0N_F", DM_CONST_DICV);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUVoltageLimit("TA0N_F", 6, -2);
		CheckError(ret, __LINE__);

		ret = dm->ConfigurePMUCurrentLevel("TA0N_F", 0);
		CheckError(ret, __LINE__);

		ret = dm->DPINOn("TA0N_F");
		CheckError(ret, __LINE__);

		#pragma region "FHS Read mode"

		double result_d = 0;
		double resultp_d = 0;
		double resultn_d = 0;
		int result_i = 0;

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		for (int i=0; i<=4; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(Measure_Delay_s);

			if (TPName[i]->Contains("Bias_V"))
			{
				ret = dm->PMUMeasure("TA0P_F", DM_CONST_MEASUREVOLTAGE, resultp_d);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure("TA0N_F", DM_CONST_MEASUREVOLTAGE, resultn_d);
				CheckError(ret, __LINE__);

				result_d = Math::Abs(resultp_d - resultn_d);

				tf_SetResult(TPName[i], result_d + GetOffset(TPDispName[i]));
			}
			else
			{
				ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_d);
				CheckError(ret, __LINE__);

				if (result_d > 0.5)
					result_i = 0;
				else
					result_i = 1;

				tf_SetResult(TPName[i], result_i + (int)GetOffset(TPDispName[i]));
			}
		}

		#pragma endregion "FHS Read mode"

		#pragma region "FHS Read And Write mode"

		for (int i=5; i<=9; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
				
			}

			ret = dm->DrivePin("RWN", 0);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("RWN", 1);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			if (TPName[i]->Contains("Bias_V"))
			{
				ret = dm->PMUMeasure("TA0P_F", DM_CONST_MEASUREVOLTAGE, resultp_d);
				CheckError(ret, __LINE__);

				ret = dm->PMUMeasure("TA0N_F", DM_CONST_MEASUREVOLTAGE, resultn_d);
				CheckError(ret, __LINE__);

				result_d = Math::Abs(resultp_d - resultn_d);

				tf_SetResult(TPName[i], result_d + GetOffset(TPDispName[i]));
			}
			else
			{
				ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_d);
				CheckError(ret, __LINE__);

				if (result_d > 0.5)
					result_i = 0;
				else
					result_i = 1;

				tf_SetResult(TPName[i], result_i + (int)GetOffset(TPDispName[i]));
			}
		}

		#pragma endregion "FHS Read And Write mode"

		#pragma region "Digital Timing Sequence 1"

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		ret = DriveCBit(TPDispName[10]);
		CheckError(ret, __LINE__);

		//SPE - TMU START
		//FLTMUX - TMU STOP

		tmu_start_threshold = 0.5;
		tmu_stop_threshold = 0.5;
		tmu_start_hysteresis = 0.02;//0.2;
		tmu_stop_hysteresis = 0.02;//0.2;
		number_of_samples = 1;
		tmu_timeout = 10e-3;
		sampled_result = gcnew array<double>(number_of_samples);
		retest_count = 0;
		sampled_result[0] = 0;

		double result1 = 0;
		double result2 = 0;

		double max_limit = 0;
		double min_limit = 0;

		ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_fhs_dmux_dig_tim1_off_fhs");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("write_fhs_dmux_dig_tim1_chg_fhs");
		CheckError(ret, __LINE__);
		ret = RunVectorFile("write_fhs_dmux_dig_tim1_on_fhs");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		retest_count = 0;

DTS1_RETEST1:

		ret = RunVectorFile("write_fhs_dmux_dig_tim1_fhs_sleep_off");
		CheckError(ret, __LINE__);
	
		//ret = ReadFaultStatusBits();
		//CheckError(ret, __LINE__);

		_util->Wait_Sec(0.1e-3);

		ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_fhs_dmux_dig_tim1_on_fhs");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.1e-3);
		
		ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
				
		result1 = sampled_result[0];
		
		if (ret)
		{
			ret = 0;

			if (retest_count < TIMING_RESET_COUNT)
			{
				retest_count++;
				goto DTS1_RETEST1;
			}
		}
		else
		{
			max_limit = (double)(tf_TPHighLimit_Cast(TPName[10]));
			min_limit = (double)(tf_TPLowLimit_Cast(TPName[10]));
			if ((result1 < min_limit) || (result1 > max_limit))
			{
				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto DTS1_RETEST1;
				}
			}
		}

		tf_SetResult(TPName[10], result1 + GetOffset(TPDispName[10]));

		retest_count = 0;
		sampled_result[0] = 0;

DTS1_RETEST2:

		ret = RunVectorFile("write_fhs_dmux_dig_tim1_fhs_stdby_off");
		CheckError(ret, __LINE__);

		ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_fhs_dmux_dig_tim1_on_fhs");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.1e-3);
		
		ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

		result2 = sampled_result[0];

		if (ret)
		{
			ret = 0;

			if (retest_count < TIMING_RESET_COUNT)
			{
				retest_count++;
				goto DTS1_RETEST2;
			}
		}
		else
		{
			max_limit = (double)(tf_TPHighLimit_Cast(TPName[11]));
			min_limit = (double)(tf_TPLowLimit_Cast(TPName[11]));
			if ((result2 < min_limit) || (result2 > max_limit))
			{
				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto DTS1_RETEST2;
				}
			}
		}

		tf_SetResult(TPName[11], result2-result1 + GetOffset(TPDispName[11]));

		#pragma endregion "Digital Timing Sequence 1"

		#pragma region "Digital Timing Sequence 2"

		ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(ret, __LINE__);

		retest_count = 0;
		sampled_result[0] = 0;

DTS2_RETEST1:

		ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_reg23_fhs_enable_0");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.1e-3);
		
		ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

		result1 = sampled_result[0];
		
		if (ret)
		{
			ret = 0;

			if (retest_count < TIMING_RESET_COUNT)
			{
				retest_count++;
				goto DTS2_RETEST1;
			}
		}
		else
		{
			max_limit = (double)(tf_TPHighLimit_Cast(TPName[12]));
			min_limit = (double)(tf_TPLowLimit_Cast(TPName[12]));
			if ((result1 < min_limit) || (result1 > max_limit))
			{
				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto DTS2_RETEST1;
				}
			}
		}

		tf_SetResult(TPName[12], result1 + GetOffset(TPDispName[12]));

		retest_count = 0;
		sampled_result[0] = 0;

DTS2_RETEST2:

		ret = RunVectorFile("write_fhs_dmux_dig_tim2_fhs_sleep_on");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.1e-3);

		ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_reg23_fhs_enable_0");
		CheckError(ret, __LINE__);

		_util->Wait_Sec(0.1e-3);
		
		ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

		result2 = sampled_result[0];

		if (ret)
		{
			ret = 0;

			if (retest_count < TIMING_RESET_COUNT)
			{
				retest_count++;
				goto DTS2_RETEST2;
			}
		}
		else
		{
			max_limit = (double)(tf_TPHighLimit_Cast(TPName[13]));
			min_limit = (double)(tf_TPLowLimit_Cast(TPName[13]));
			if ((result2 < min_limit) || (result2 > max_limit))
			{
				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto DTS2_RETEST2;
				}
			}
		}

		tf_SetResult(TPName[13], result2-result1 + GetOffset(TPDispName[13]));

		#pragma endregion "Digital Timing Sequence 2"

		/////////////////////////////////
		// DETCR Programmable Blanking

		//RWN - TMU START
		//FLTMUX - TMU STOP

		#pragma region "FHS Mode Blanking"

		double result_fhs_mode0_blanking = 0;

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		ret = DriveCBit(TPDispName[14]);
		CheckError(ret, __LINE__);

		tmu_start_threshold = 0.5;
		tmu_stop_threshold = 0.5;
		tmu_start_hysteresis = 0.02;//0.2;
		tmu_stop_hysteresis = 0.02;//0.2;
		number_of_samples = 1;
		tmu_timeout = 10e-3;
		sampled_result = gcnew array<double>(number_of_samples);
		retest_count = 0;
		sampled_result[0] = 0;

		ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(ret, __LINE__);

		for (int i=14; i<=15; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(0.1e-3);

			retest_count = 0;
			sampled_result[0] = 0;

FHS_MB_RETEST:

			ret = dm->DrivePin("RWN", 0);
			CheckError(ret, __LINE__);

			ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm->DrivePin("RWN", 1);
			CheckError(ret, __LINE__);

			ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

			if (ret)
			{
				ret = 0;

				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto FHS_MB_RETEST;
				}
			}
			else
			{
				max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
				min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));
				if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						retest_count++;
						goto FHS_MB_RETEST;
					}
				}
			}

			if (i == 14)
				result_fhs_mode0_blanking = sampled_result[0];

			tf_SetResult(TPName[i], sampled_result[0] + GetOffset(TPDispName[i]));
		}

		#pragma endregion "FHS Mode Blanking"

		#pragma region "Heater Blanking"

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		ret = DriveCBit(TPDispName[16]);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_t_detcr_heater0");
		CheckError(ret, __LINE__);
			
		_util->Wait_Sec(0.1e-3);

		ret = dm->DrivePin("RWN", 1);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		result_d = 0;
		ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_d);
		CheckError(ret, __LINE__);

		if (result_d < 0.5)
			result_i = 1;
		else
			result_i = 0;

		tf_SetResult(TPName[16], result_i + (int)GetOffset(TPDispName[16]));

		//
		ret = DriveCBit(TPDispName[14]);
		CheckError(ret, __LINE__);
		
		ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(ret, __LINE__);

		for (int i=17; i<=18; i++)
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");
			
				ret = RunVectorFile(Vector_File);
				CheckError(ret, __LINE__);
			}

			_util->Wait_Sec(0.1e-3);

			retest_count = 0;
			sampled_result[0] = 0;

FHS_HB_RETEST:

			ret = dm->DrivePin("RWN", 0);
			CheckError(ret, __LINE__);

			ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			CheckError(ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm->DrivePin("RWN", 1);
			CheckError(ret, __LINE__);

			ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

			if (ret)
			{
				ret = 0;

				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto FHS_HB_RETEST;
				}
			}
			else
			{
				max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
				min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));
				if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
				{
					if (retest_count < TIMING_RESET_COUNT)
					{
						retest_count++;
						goto FHS_HB_RETEST;
					}
				}
			}

			tf_SetResult(TPName[i], sampled_result[0] + GetOffset(TPDispName[i]));
		}

		#pragma endregion "Heater Blanking"

		#pragma region "Fast Mode Blanking"

		ret = tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_t_detcr_fastmode0");
		CheckError(ret, __LINE__);

		retest_count = 0;
		sampled_result[0] = 0;

FHS_FMB_RETEST:

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		ret = tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(On_Delay_s);

		ret = dm->DrivePin("RWN", 1);
		CheckError(ret, __LINE__);

		ret = tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

		if (ret)
		{
			ret = 0;

			if (retest_count < TIMING_RESET_COUNT)
			{
				retest_count++;
				goto FHS_FMB_RETEST;
			}
		}
		else
		{
			max_limit = (double)(tf_TPHighLimit_Cast(TPName[19]));
			min_limit = (double)(tf_TPLowLimit_Cast(TPName[19]));
			if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
			{
				if (retest_count < TIMING_RESET_COUNT)
				{
					retest_count++;
					goto FHS_FMB_RETEST;
				}
			}
		}

		tf_SetResult(TPName[19], sampled_result[0]-result_fhs_mode0_blanking + GetOffset(TPDispName[19]));

		#pragma endregion "Heater Blanking"

		#pragma region "Fast Heater Blanking"
		
		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		ret = DriveCBit(TPDispName[16]);
		CheckError(ret, __LINE__);

		ret = RunVectorFile("write_t_detcr_fastheater0");
		CheckError(ret, __LINE__);
			
		_util->Wait_Sec(0.1e-3);

		ret = dm->DrivePin("RWN", 1);
		CheckError(ret, __LINE__);

		ret = dm->DrivePin("RWN", 0);
		CheckError(ret, __LINE__);

		result_d = 0;
		ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_d);
		CheckError(ret, __LINE__);

		if (result_d < 0.5)
			result_i = 1;
		else
			result_i = 0;

		tf_SetResult(TPName[20], result_i + (int)GetOffset(TPDispName[20]));
		
		#pragma endregion "Fast Heater Blanking"

		/////////////////////////////////

		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = ResetCBit();
		CheckError(ret, __LINE__);
		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::seq_lfp_spd(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;
		
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
		double Fswg_Test		= (double)(tf_TestItemCondition_Cast("Fswg_Test"));
		double Fswg_Ref			= (double)(tf_TestItemCondition_Cast("Fswg_Ref"));
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

		if (Debug_Enable == true)
		{
			sb = gcnew StringBuilder();
			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
		}

		double diff2se_digitizer_factor = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][testSite];

		double diff2se_digitizer_factor_dc = 1;

		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
			diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC"][testSite];

		double result = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(site);
		CheckError(ret, __LINE__);
		//ret = DriveDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);
		ret = DriveCBit(TPDispName[0]);
		CheckError(ret, __LINE__);
		ret = DriveMuxIO(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Setup Power supplies
		//ret = smu->SetBandwidth("VCC", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VCC", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VCC", true, false);
		//CheckError(ret, __LINE__);

		//ret = smu->SetBandwidth("VEE", Bandwidth);
		//CheckError(ret, __LINE__);
		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//CheckError(ret, __LINE__);
		//ret = smu->DriveVoltage("VEE", 0);
		//CheckError(ret, __LINE__);
		//ret = smu->OnSmuPin("VEE", true, false);
		//CheckError(ret, __LINE__);
		//_util->Wait_Sec(0.001);

		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		//if(Test != TEST_IF4600_PKG)
		//{
		//	ret = dm->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//	CheckError(ret, __LINE__);
		//	ret = dm->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DrivePin("VCM_SE_DIFF_CONVERT", 0);
		//	CheckError(ret, __LINE__);
		//	ret = dm->DPINOn("VCM_SE_DIFF_CONVERT");
		//	CheckError(ret, __LINE__);
		//}

		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPE");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPD");
		CheckError(ret, __LINE__);

		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(ret, __LINE__);
		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(ret, __LINE__);
		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(ret, __LINE__);
		ret = dm->DPINOn("SPC");
		CheckError(ret, __LINE__);

		ret = DriveDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Configure Input Delay
		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);

		if (Debug_Enable == true)
		{
			sb->AppendLine("-----------------------------------------------------------------------");
			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
			sb->AppendLine("On_Delay_s=" + On_Delay_s);
		}

		ret = RunVectorFile(Vector_File);
		CheckError(ret, __LINE__);

		//Digitizer setting
		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval = 1e-9;
		double delayTime = 0.0;
		int nbrSamples = 1024; //8192; //must be 2^n
		int nbrSegments = 1;
		int coupling = 3;	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth = 0;	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		double fullScale = 2.0; //1V or 2V
		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		long trigClass = 0;		//0 edge trigger 
		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2

		int Decimation_Factor = 1; //1GS/s
		
		try
		{
			resourceManager = gcnew ResourceManager(HardwareProfile, testHead, testSite);

			Resource ^ hardwareResource = resourceManager->ResolveResource("DIGITIZER_CH")[0];

			if (hardwareResource->Alias->Contains("Ch1"))
			{
				sourcePattern = 0x00000001;
			}
			else if (hardwareResource->Alias->Contains("Ch2"))
			{
				sourcePattern = 0x00000002;
			}

			if (resourceManager)
				delete resourceManager;
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
		}

		long trigCoupling = 0;	//0 DC
								//1 AC
								//2 HF Reject (if available)
								//3 DC, 50 (ext. trigger only, if available)
								//4 AC, 50 (ext. trigger only, if available)
		long trigSlope = 0;	//0 Positive
							//1 Negative
							//2 out of Window
							//3 into Window
							//4 HF divide
							//5 Spike Stretcher
		double trigLevel = 0;	//% of FS 
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
		int timeOut_ms = 1;

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		array<double> ^ dataArrayN;

		if (Test == TEST_IF4600_PKG)
		{
			dataArrayN = gcnew array<double>(nbrSamples);
		}

		double dataTemp = 0;
		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
		array<double> ^ magn = gcnew array<double>(nbrSamples);
		double fftBIN = 0;
		int magn_peak_index = 0;

		int max_loop = 50;

		double Vswg_cal = 0;
		int loop_count = 0;

		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		digitizer_setting[0] = sampInterval;
		digitizer_setting[1] = delayTime;
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[3] = (double)nbrSegments;
		digitizer_setting[4] = fullScale; 
		digitizer_setting[5] = offset;
		digitizer_setting[6] = (double)coupling;
		digitizer_setting[7] = (double)bandwidth;
		digitizer_setting[8] = (double)trigClass;
		digitizer_setting[9] = (double)sourcePattern;
		digitizer_setting[10] = (double)trigCoupling;
		digitizer_setting[11] = (double)trigSlope;
		digitizer_setting[12] = trigLevel;
		digitizer_setting[13] = (double)timeOut_ms;
		digitizer_setting[14] = (double)Decimation_Factor;

		/////////////////////////////////////////////
		//Calibration of Vpp
		/////////////////////////////////////////////

		array<double> ^ Fswg = gcnew array<double>(2);
		array<double> ^ do_once = gcnew array<double>(2);
		array<double> ^ factor = gcnew array<double>(2); 
		array<double> ^ vout_pp = gcnew array<double>(2); 

		Fswg[0] = Fswg_Ref;
		Fswg[1] = Fswg_Test;
		do_once[0] = 0;
		do_once[1] = 0;
		factor[0] = diff2se_digitizer_factor;
		factor[1] = diff2se_digitizer_factor_dc;

		for (int i=0; i<2; i++)
		{
			if (Vswg_lpd_spd_calibrated->ContainsKey(Fswg[i]) == false)
			{
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 1);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 1);
					CheckError(ret, __LINE__);
				}
				else
				{
					//On K3, K4
					ret = DriveCBit(TPDispName[0], 1);
					CheckError(ret, __LINE__);
				}

				Vswg_cal = 0;
				loop_count = 0;

				if (Fswg[i] < 0.5e6)
				{
					Decimation_Factor = 16; //31.25MS/s
					nbrSamples = 8192;
				}
				else
				{
					Decimation_Factor = 1; //1GS/s
					nbrSamples = 1024;
				}

				digitizer_setting[2] = (double)nbrSamples;
				digitizer_setting[14] = (double)Decimation_Factor;

				Vswg_cal = Vswg;

				ret = SWG_Configure();
				CheckError(ret, __LINE__);

				ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg[i], 0);
				CheckError(ret, __LINE__);
				
				_util->Wait_Sec(1e-3);
				
				ret = acm->RunFG("ACM_CH", 0, true);
				CheckError(ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				do_once[i] = 0;
				while(loop_count <= max_loop)
				{
					if (do_once[i] == 0)
					{
						ret = DigitizerFFT_Configure(digitizer_setting);
						CheckError(ret, __LINE__);

						do_once[i] = 1;
					}

					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, factor[i], vout_pp[i]);
					ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, factor[i], vout_pp[i]);

					if (ret)
					{
						ret = digitizer->StopAcquire("DIGITIZER");
						CheckError(ret, __LINE__);

						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult(TPName[i], (double)(-999));
						}

						goto test_end;
					}
		
					if (Math::Abs(Vswg - vout_pp[i]) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp[i]);

						ret = acm->StopFG("ACM_CH"); 
						CheckError(ret, __LINE__);	

						ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg[i], 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;

							ret = digitizer->StopAcquire("DIGITIZER");
							CheckError(ret, __LINE__);

							ret = acm->StopFG("ACM_CH"); 
							CheckError(ret, __LINE__);

							if(Test == TEST_IF4600_PKG)
							{
								ret = dio->DrivePin("DIO_3", 0);
								CheckError(ret, __LINE__);
								ret = dio->DrivePin("DIO_4", 0);
								CheckError(ret, __LINE__);
							}
							else
							{
								//off K3, K4
								ret = DriveCBit(TPDispName[0], 0);
								CheckError(ret, __LINE__);
							}

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult(TPName[i], (double)(-999));
							}

							goto test_end;
						}

						ret = acm->RunFG("ACM_CH", 0, true);
						CheckError(ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
					ret = digitizer->StopAcquire("DIGITIZER");
					CheckError(ret, __LINE__);

					ret = acm->StopFG("ACM_CH"); 
					CheckError(ret, __LINE__);
					
					if(Test == TEST_IF4600_PKG)
					{
						ret = dio->DrivePin("DIO_3", 0);
						CheckError(ret, __LINE__);
						ret = dio->DrivePin("DIO_4", 0);
						CheckError(ret, __LINE__);
					}
					else
					{
						//off K3, K4
						ret = DriveCBit(TPDispName[0], 0);
						CheckError(ret, __LINE__);
					}

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult(TPName[i], (double)(-999));
					}

					goto test_end;
				}
							
				ret = digitizer->StopAcquire("DIGITIZER");
				CheckError(ret, __LINE__);

				ret = acm->StopFG("ACM_CH"); 
				CheckError(ret, __LINE__);
				
				if(Test == TEST_IF4600_PKG)
				{
					ret = dio->DrivePin("DIO_3", 0);
					CheckError(ret, __LINE__);
					ret = dio->DrivePin("DIO_4", 0);
					CheckError(ret, __LINE__);
				}
				else
				{
					//off K3, K4
					ret = DriveCBit(TPDispName[0], 0);
					CheckError(ret, __LINE__);
				}

				Vswg_lpd_spd_calibrated->Add(Fswg[i], Vswg_cal);
				Vswg_lpd_spd_at_dut->Add(Fswg[i], vout_pp[i]);
			}
		}

		/////////////////////////////////////////////////////
		//Test
		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 1);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 1);
			CheckError(ret, __LINE__);
		}
		else
		{
			//On K1, K2
			ret = DriveCBit(TPDispName[0], 2);
			CheckError(ret, __LINE__);
		}

		ret = SWG_Configure();
		CheckError(ret, __LINE__);

		/////////////////////////////////////////////////////
		//Fswg_Ref

		Decimation_Factor = 1; //1GS/s
		nbrSamples = 1024;
	
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[14] = (double)Decimation_Factor;

		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[Fswg_Ref]/2, -1 * Vswg_lpd_spd_calibrated[Fswg_Ref]/2, Fswg_Ref, 0);
		CheckError(ret, __LINE__);
				
		ret = Digitizer_Configure(digitizer_setting);
		CheckError(ret, __LINE__);

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp[0]);
		ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp[0]);
		if (ret)
		{
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				tf_SetResult(TPName[i], (double)(-999));
			}

			goto test_end;
		}

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);

		double vout_ref = 20 * Math::Log10(vout_pp[0]);
		
		/////////////////////////////////////////////////////
		//Fswg_Test

		Decimation_Factor = 16; //31.25MS/s
		nbrSamples = 8192;
	
		digitizer_setting[2] = (double)nbrSamples;
		digitizer_setting[14] = (double)Decimation_Factor;

		ret = acm->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[Fswg_Test]/2, -1 * Vswg_lpd_spd_calibrated[Fswg_Test]/2, Fswg_Test, 0);
		CheckError(ret, __LINE__);
				
		ret = Digitizer_Configure(digitizer_setting);
		CheckError(ret, __LINE__);

		ret = acm->RunFG("ACM_CH", 0, true);
		CheckError(ret, __LINE__);

		_util->Wait_Sec(Measure_Delay_s);

		//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor_dc, vout_pp[1]);
		ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor_dc, vout_pp[1]);
		if (ret)
		{
			ret = digitizer->StopAcquire("DIGITIZER");
			CheckError(ret, __LINE__);

			ret = acm->StopFG("ACM_CH"); 
			CheckError(ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				tf_SetResult(TPName[i], (double)(-999));
			}

			goto test_end;
		}

		ret = acm->StopFG("ACM_CH"); 
		CheckError(ret, __LINE__);

		double vin_ratio	= Vswg_lpd_spd_at_dut[Fswg_Test] / Vswg_lpd_spd_at_dut[Fswg_Ref];

		double vout_lpf		= 20 * Math::Log10(vout_pp[1] * vin_ratio);
		
		double db_loss		= vout_ref - vout_lpf;

		double lfp_spd		= Fswg_Test * Math::Sqrt(Math::Pow(10, db_loss/10)-1);

		if (_util->IsInf(lfp_spd) == false)
			result = lfp_spd;
		else
			result = 0;

		tf_SetResult(TPName[0], result + GetOffset(TPDispName[0]));
		
test_end:
		
		ret = acm->ResetChannel("ACM_CH");
		CheckError(ret, __LINE__);

		if(Test == TEST_IF4600_PKG)
		{
			ret = dio->DrivePin("DIO_1", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_2", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_3", 0);
			CheckError(ret, __LINE__);
			ret = dio->DrivePin("DIO_4", 0);
			CheckError(ret, __LINE__);
		}
		
		ret = ResetDMPin(TPDispName[0]);
		CheckError(ret, __LINE__);

		//Power down supplies
		ret = smu->DriveVoltage("VEE", 0);
		CheckError(ret, __LINE__);
		ret = smu->DriveVoltage("VCC", 0);
		CheckError(ret, __LINE__);

		//IO setting
		//ret = ResetDIOPin(TPDispName[0]);
		//CheckError(ret, __LINE__);

		ret = ResetCBit();
		CheckError(ret, __LINE__);

		ret = ResetMuxIO();
		CheckError(ret, __LINE__);

		if (Debug_Enable == true)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;

			Debug_Enable = false;
		}

		return ret;
	}
	int TestProgram::Test_Fuse_Branch(Site ^ site)
	{
		BinSortResult^ res = site->BinSorting(BinSortEvalModes::IgnoreUntestedPhase);

		_glob->GoodDIE = 0;

		if(res->Status == BinSorterRuleType::Pass)
		{
			_glob->GoodDIE = 1;
		}
 
		return 0;
	}
	int TestProgram::Pre_Test(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		SetupBarrier();

		_glob->contact_open_l_short_h = 0;
		_glob->contact_fail = 0;

		_glob->jump_on_fail = site->Sequencer->JumpOnFailSettingBySite->Enable;

		for (int i=0; i<TOTAL_GLOBAL_VARIABLE; i++)
		{
			_glob->Global_Result[i] = 0;
		}

		_glob->global_who_i = gcnew array<double>(HDS); 
		_glob->global_who_v = gcnew array<double>(HDS); 

		for (int i=0; i<HDS; i++)
		{
			_glob->global_who_i[i] = -999;
			_glob->global_who_v[i] = -999;
		}

		_glob->trimlock		= 0;
		_glob->FuseBlown	= 0;
		_glob->testpass		= 0;
		_glob->GoodDIE		= 0;

		_glob->vref_pre		= 0;
		_glob->iabs_pre		= 0;
		_glob->atemp_pre	= 0;
		
		_glob->mux_offset	= 0;

		_glob->vref_blown_fuse			= 0;
		_glob->atemp_blown_fuse			= 0;
		_glob->iabs_blown_fuse			= 0;
		_glob->waferid_blown_fuse		= 0;
		_glob->quadrantid_blown_fuse	= 0;
		_glob->radiusid_blown_fuse		= 0;

		_glob->vref_fuse_toblow			= 0;
		_glob->atemp_fuse_toblow		= 0;
		_glob->iabs_fuse_toblow			= 0;
		_glob->waferid_fuse_toblow		= 0;
		_glob->quadrantid_fuse_toblow	= 0;
		_glob->radiusid_fuse_toblow		= 0;

		ret = OnOffFETGnd(1);
		CheckError(ret, __LINE__);

		//_util->Wait_Sec(1);
 
		return ret;
	}
	int TestProgram::Post_Test(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0; 

		int idx = (int)tf_ControlItemCondition_Cast("Barrier_Index");

		// Last barrier
		if(__barrierActive) 
		{
			if (Barrier_Debug_Enable == true)
			{
				DateTime _now = DateTime::Now;
				sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "barriers[" + idx + "]" + ",site" + testSite);
			}

			__barriers[idx]->Signal(testSite);
			__barriers[idx]->Wait();
		}

		//if ((MultiSite == MULTISITE && testSite == QUADRANTA) ||
		//	MultiSite == SINGLESITE)
		{
			ret = dm->DrivePin("HW_FETS", 0);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("FHCR_FETS", 0);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("FHCW_FETS", 0);
			CheckError(ret, __LINE__);
		}

		return ret;
	}
	int TestProgram::Probe_Card_FET_Control(int hw_fet, int fhcr_fet, int fhcw_fet)
	{
		int ret = 0; 

		//if ((MultiSite == MULTISITE && testSite == QUADRANTA) ||
		//	MultiSite == SINGLESITE)
		{
			ret = dm->DrivePin("HW_FETS", hw_fet);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("FHCR_FETS", fhcr_fet);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("FHCW_FETS", fhcw_fet);
			CheckError(ret, __LINE__);

		//	_util->Wait_Sec(0.1e-3);
		}

		return ret;
	}
	int TestProgram::Probe_Card_FET_Control(Site ^ site)
	{
		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

		int ret = 0;

		int HW_FET = (int)tf_ControlItemCondition_Cast("HW_FET");
		int FHCR_FET = (int)tf_ControlItemCondition_Cast("FHCR_FET");
		int FHCW_FET = (int)tf_ControlItemCondition_Cast("FHCW_FET");
		int idx = (int)tf_ControlItemCondition_Cast("Barrier_Index");

		ret = Probe_Card_FET_Control(idx, HW_FET, FHCR_FET, FHCW_FET);
		CheckError(ret, __LINE__);

		return ret;
	}
	int TestProgram::Probe_Card_FET_Control(int barrier_index, int hw_fet, int fhcr_fet, int fhcw_fet)
	{
		int ret = 0; 

		Barrier(barrier_index);

		//if ((MultiSite == MULTISITE && testSite == QUADRANTA) ||
		//	MultiSite == SINGLESITE)
		{
			ret = dm->DrivePin("HW_FETS", hw_fet);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("FHCR_FETS", fhcr_fet);
			CheckError(ret, __LINE__);

			ret = dm->DrivePin("FHCW_FETS", fhcw_fet);
			CheckError(ret, __LINE__);
		}
		
		//_util->Wait_Sec(0.1e-3);

		Barrier(barrier_index+1);

		return ret;
	}
	//SPI method
	int TestProgram::LoadSPI(String ^ vec, int SPISetNumber)
	{
		int ret = 0;

		//String ^ VectoFilePath = SetupFileDirectory + "\\SPI\\" + vec + ".txt";
		String ^ VectoFilePath = SPIFileDirectory + "\\" + vec + ".txt";
		array<String ^> ^ vecStr = gcnew array<String ^>(1);

		int index = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(37);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";
		StreamReader ^ sr = gcnew StreamReader(VectoFilePath);
		
		vecStr[0] = vec;

		if (SPISetNo->ContainsKey(vecStr[0]) == false)
			SPISetNo->Add(vecStr[0], SPISetNumber);
					
		while(( (line = sr->ReadLine() ) != nullptr) )
		{
			if (line != "")
			{
				ArrStr = line->Split(Separator, StringSplitOptions::RemoveEmptyEntries);
				_glob->SPI_Data_Arr[SPISetNumber, index, PG]	= _util->StrToInt(ArrStr[0]);
				_glob->SPI_Data_Arr[SPISetNumber, index, REG]	= _util->StrToInt(ArrStr[1]);
				_glob->SPI_Data_Arr[SPISetNumber, index, BIT]	= _util->StrToInt(ArrStr[2]);
				index++;
			}
		}
		_glob->SPI_Data_Index[SPISetNumber] = index;
		
		sr->Close();
		sr = nullptr;

		return ret;
	
	}
	int TestProgram::RunSPI(String ^ spi_str)
	{
		int ret = 0;
		
		if (SPISetNo->ContainsKey(spi_str))
		{

			int index			= 0;
			int SPISetNumber	= 0;

			int datain			= 0;
			int spi_group		= 0;
			int addr			= 0;
			int	Sweep_Reg_Addr	= 0;
			double spi_clk_freq = 2e6;
			int spi_status		= 0;
			double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
			
			int spi_wr_byte_length = 1;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			SPISetNumber =  SPISetNo[spi_str];
			index = _glob->SPI_Data_Index[SPISetNumber];

			for (int i = 0 ; i < index ; i++)
			{
				datain			= _glob->SPI_Data_Arr[SPISetNumber, i, BIT];
				datain			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, BIT], 8);
				
				addr			= _glob->SPI_Data_Arr[SPISetNumber, i, REG];
				addr			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, REG], 5);
				
				Sweep_Reg_Addr	= ((_glob->SPI_Data_Arr[SPISetNumber, i, PG] << 6) | (addr << 1) );

				spi_data_dir[i] = 0x0000000; 
				spi_data[i]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				spi_status = 0;
				spi_wr_byte_length = i+1;
			}
			
			ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
			CheckError(ret, __LINE__);
		
		}

		return ret;
	}

	int TestProgram::ReadSPI(String ^ spi_str, int % data)
	{
		int ret = 0;
		
		if (SPISetNo->ContainsKey(spi_str))
		{

			int index			= 0;
			int SPISetNumber	= 0;
			int readback		= 0;
			int datain			= 0;
			int spi_group		= 0;
			int addr			= 0;
			int	Sweep_Reg_Addr	= 0;
			double spi_clk_freq = 2e6;
			int spi_status		= 0;
			double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
			
			int spi_wr_byte_length = 1;
			int spi_rd_byte_length = 0;
			
			array<int> ^ spi_data = gcnew array<int>(1);
			array<int> ^ spi_data_dir = gcnew array<int>(1);
			array<int> ^ spi_rd_data = gcnew array<int>(1);
			array<int> ^ spi_rd_biterror = gcnew array<int>(1);
			array<double> ^ delay_s_after_byte = gcnew array<double>(1);

			for (int i=0; i<1; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0.000;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			SPISetNumber =  SPISetNo[spi_str];
			index = _glob->SPI_Data_Index[SPISetNumber];
			int	i = 0;
			
			{
				datain			= _glob->SPI_Data_Arr[SPISetNumber, i, BIT];
				datain			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, BIT], 8);
				
				addr			= _glob->SPI_Data_Arr[SPISetNumber, i, REG];
				addr			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, REG], 5);
				
				Sweep_Reg_Addr	= ((_glob->SPI_Data_Arr[SPISetNumber, i, PG] << 6) | (addr << 1) );

				spi_data_dir[i] = 0x00000ff; 
				spi_data[i]	= 0x3008000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				spi_status = 0;
			
				ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				CheckError(ret, __LINE__);
			
				ret = dm->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
				CheckError(ret, __LINE__);

				for (int m=0; m<spi_rd_byte_length; m++)
				{
					if (spi_rd_biterror[m] == 0)
					{
						data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
						readback = (data & 0xff);
					}
					else
					{
						readback = -999;
					}
				}
			}
			
			data = readback;
	
		}

		return ret;
	}

	int TestProgram::OnOffSPI(int OnOff)
	{
		int ret = 0;

		int spi_group		= 0;
		_glob->spi_clk_freq = SPI_CLK_FREQ;
		int spi_status		= 0;
		double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
		
		if (OnOff)
		{
			ret = SPI_Configure(spi_group, _glob->spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			CheckError(ret, __LINE__);
			//ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
			//CheckError(ret, __LINE__);
		}
		else
		{
			ret = dm->SPI_CH_UNSEL("DM_2", spi_group);
			CheckError(ret, __LINE__);	
		
		}

		return ret;
	}
	int TestProgram::VectorToSPI(String ^ vec)
	{
		int ret = 0;

		int ByteSize	= 37;
		int lineNum		= 0;
		int SPD_seq		= 10;
		int SPE_seq		= 11;
		
		int index		= 0;
		int regStartBit = 4;
		int dataStartBit= 16;
		int temp		= 0;
		int debug		= 1;
		int linelength	= 0;

		//String ^ VectoFilePath = SetupFileDirectory + "\\Vector\\" + vec + ".txt";
		//String ^ SPIFilePath = SetupFileDirectory + "\\SPI\\" + vec + ".txt";

		String ^ VectoFilePath = VectorFileDirectory + "\\" + vec + ".txt";
		String ^ SPIFilePath = SPIFileDirectory + "\\" + vec + ".txt";
		
		sb = gcnew StringBuilder();
		sw = gcnew StreamWriter(SPIFilePath);

		int line_number = 0;
		String ^ line = String::Empty;

		array<int,2>^ SPI_data_arr = gcnew array<int,2>(512 ,3);;//256
		
		array<String ^> ^ ArrStr = gcnew array<String ^>(33);
		
		//array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = " ";
		StreamReader ^ sr = gcnew StreamReader(VectoFilePath);

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		
		int i = 0;

		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			// check valid vector data
			if (line->StartsWith("X") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("L") == true ||
				line->StartsWith("l") == true ||
				line->StartsWith("H") == true ||
				line->StartsWith("h") == true ||
				line->StartsWith("Z") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("1") == true ||
				line->StartsWith("0") == true)
			{
				

				ArrStr2 = line->Split(Separator, StringSplitOptions::RemoveEmptyEntries);
				if(ArrStr2[SPE_seq] == "1")
				{
					ArrStr[lineNum] = ArrStr2[SPD_seq];
					if ((ArrStr[0]) == "1")
					{
						linelength = 31;	//read

					}else{
						linelength = 32;	//write
					}

					if (lineNum == linelength)
					{
						// extract page, 
						SPI_data_arr[index,0] = _util->StrToInt(ArrStr[2]);

						temp = 0;
						//extract reg 
						for (int j = 0 ; j < (5 * 2); j=j+2)
						{
							if (ArrStr[j+regStartBit] == "1" )
							{
								temp = temp + (int)(pow(2.0, j/2)) ; 
							}
						}
						SPI_data_arr[index,1] = temp;
						
							
						//extract data
						temp = 0;
						for (int j = 0 ; j < (8 * 2); j=j+2)
						{
							if (ArrStr[j+dataStartBit] == "1" )
							{
								temp = temp + (int)(pow(2.0, j/2)); 
							}
						}
						
						SPI_data_arr[index,2] = temp;
			
						// print data to file
						if(debug)
						{
							sb->AppendLine(SPI_data_arr[index,PG] + ",\t" + SPI_data_arr[index,REG] + ",\t" + SPI_data_arr[index,BIT] + "\n" );
						}

						lineNum = 0;
						index++;
					
					}else{
						lineNum++;
					}
				}

			}
			
		}

		if(debug)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;
		}

		sr->Close();
		sr = nullptr;

		return ret ;
	}

	int TestProgram::LoadSPIFiles(Site ^ site)
	{   
		int ret = 0;
		int i = 0;
		int indexCount= 0;
		String ^ vec_str = "" ;
		
		String ^ str1 = "write_default_reg";

		for each  (KeyValuePair<String ^ , int>^ pair in VectorSetNo)
		{
			vec_str = pair->Key;

			int setno = pair->Value;
		
			//ret = _util->SampleRes("spi", 0, setno, "");
			
			if(0)
			{
				VectorToSPI(str1);
				LoadSPI(str1, i);
				
			}
			else
			{
				if ((vec_str->Contains("checkerboard") == 0) && (vec_str->Contains("WDX_WDY_6400bits") == 0))
				{ 
					//exclusion
					VectorToSPI(vec_str);
					LoadSPI(vec_str, i);
					indexCount++;
				}
			}
			i++;
		}

		//RunSPI(str1);
	
		return ret;
	
	}
	int TestProgram::WriteSPI(int page, int reg, int data)
	{
		int ret = 0;
		
		int datain			= 0;
		int spi_group		= 0;
		int addr			= 0;
		int	Sweep_Reg_Addr	= 0;
		double spi_clk_freq = 2e6;
		int spi_status		= 0;
		double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
		
		int spi_wr_byte_length = 1;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(1);
		array<int> ^ spi_data_dir = gcnew array<int>(1);
		array<double> ^ delay_s_after_byte = gcnew array<double>(1);

		datain			= _util->SwapBitSequence(data, 8);
		addr			= _util->SwapBitSequence(reg, 5);
		Sweep_Reg_Addr	= ((page << 6) | (addr << 1) ) ;

		//ret = dm->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
		//CheckError(ret, __LINE__);

		spi_data_dir[0] = 0x0000000; 
		spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

		spi_status = 0;
			
		ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(ret, __LINE__);
					
		return ret;
	}

	//Barrier method
	bool TestProgram::IsRunningProduction(Site^ site)
	{
		IProductionSystem^ ps = (IProductionSystem^)site->FlowEngine->EngineManager->GetService(IProductionSystem::typeid);
		if(RemotingServices::IsTransparentProxy(ps))
			return false;
		else
			return true;
	}
	void TestProgram::ResetBarrier(CountdownEvent^ barrier)
	{
		msclr::lock enter(__barrierLock);
		__barrierSetup = false;

		if (Barrier_Debug_Enable == true)
		{
			DateTime _now = DateTime::Now;
			sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "ResetBarrier" + ",site" + testSite);
		}
	}
	void TestProgram::SetupBarrier()
	{
		if(__barrierActive)
		{
			msclr::lock enter(__barrierLock);
			if(!__barrierSetup)
			{
				int i = 0;
				for each(IUutEDData^ uut in __barrierEdUuts) {
					__barrierFlags[i] = (uut->Status == UutEDStatus::Present) ? false : true;
					i++;
				}

				for each(CountdownEvent^ barrier in __barriers)
					barrier->Reset(__barrierFlags);

				__barrierSetup = true;

				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "SetupBarrier" + ",site" + testSite);
				}
			}
		}
	}
	void TestProgram::Barrier(int idx)
	{
		if(__barrierActive) 
		{
			if (Barrier_Debug_Enable == true)
			{
				DateTime _now = DateTime::Now;
				sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "barriers[" + idx + "]" + ",site" + testSite);
				//_util->Wait_Sec(100e-3);
			}
 
			__barriers[idx]->Signal(testSite);
			__barriers[idx]->Wait();
		}
	}
	void TestProgram::RunEnded(Site^ site, Phase^ phase, RunResult^ runResult)
	{
		RunConclude(site, runResult);
	}

	void TestProgram::RunStopped(Site^ site)
	{
		RunConclude(site, site->CurrentRunResult);
	}

	void TestProgram::RunConclude(Site^ site, RunResult^ runResult)
	{
		// signal all barriers
		try 
		{
			if( (runResult->RunStatus == RunStatus::Error) ||
				(runResult->RunStatus == RunStatus::Exception) ||
				(runResult->RunStatus == RunStatus::UserInterrupted))
			{
				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded (err)" + ",site" + testSite);
				}

				for (int i=0; i<__barrierCount; i++)
					__barriers[i]->Signal(testSite);
			} 
			else if (_glob->jump_on_fail == true && runResult->IfAnyTestParameterFailed == true)
			{
				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded (jof)" + ",site" + testSite);
				}

				for (int i=0; i<__barrierCount; i++)
					__barriers[i]->Signal(testSite);
			}
			else if (runResult->IfAnyTestParameterFailed == true)
			{
				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded (jof)" + ",site" + testSite);
				}

				for (int i=0; i<__barrierCount; i++)
					__barriers[i]->Signal(testSite);
			}
		}
		catch (Exception ^ e)
		{
			if (Barrier_Debug_Enable == true)
			{
				DateTime _now = DateTime::Now;
				sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded exception" + ",site" + testSite
					+ ": " + e->Message);
			}
		}
	}
	void TestProgram::Check_Barrier_Flow(Site^ site)
	{
		//Loop through the whole test flow to check for barrier matching
		// Check if index <= __barrierCount and >= 0
		// Check if there are duplicated indexes
		// Check if index covers from 0 to __barrierCount
		// Check for valid index value:
		//	Must be even number, as every index goes in pair in test program. E.g. 0&1, 2&3, etc.
		
		array<String ^> ^ ItemName = gcnew array<String ^>(256);
		array<int> ^ index = gcnew array<int>(256);

		String ^ errorMsg = String::Empty;
		String ^ str = String::Empty;

		Dictionary <int, int> ^ barrier_index = gcnew Dictionary <int, int>;

		int count = 0;
		int error = 0;

		//Iterate FlowItems (ControlItem/TestItem)
		for each(AFlowItem^ fi in site->Flow->FlowItems)
		{
			//Iterate FlowItem Conditions
			for each(Condition^ fiCond in fi->Conditions)
			{
				String^ conditionName = fiCond->Name;
				Object^ conditionBaseValue = fiCond[site]->Value;

				if (conditionName->Contains("Barrier_Index"))
				{
					ItemName[count] = fi->DisplayName;
					index[count] = (int)(conditionBaseValue);
					count++;
				}
			}
			
			if(fi->GetType() == TestItem::typeid)
			{
				TestItem^ ti = (TestItem^)fi;
              
				//Iterate TestParameters
				for each(TestParameter^ tp in ti->TestParameters)
				{
					//Iterate TestParameter Conditions
					for each(Condition^ tpCond in tp->Conditions)
					{
						String^ conditionName = tpCond->Name;
						Object^ conditionBaseValue = tpCond[site]->Value;

						if (conditionName->Contains("Barrier_Index"))
						{
							ItemName[count] = fi->DisplayName + "." + tp->DisplayName;
							index[count] = (int)(conditionBaseValue);
							count++;
						}
					}
				}                             
			}
		}

		if ((count * 2 - 1) != __barrierCount)
		{
			str = "ERR: Total barrier indexes (" + (count * 2 - 1) + ") does not match Barrier_Count (" + __barrierCount + ") in AppsWideVariable!\r\n";
			errorMsg = String::Concat(errorMsg, str);
			error++;
		}

		if (! (__barrierCount % 2))
		{
			str = "ERR: Barrier count (AppsWideVariable) is not an odd number (" + __barrierCount + ")!\r\n";
			errorMsg = String::Concat(errorMsg, str);
			error++;
		}

		// Check for index entry error
		for (int i=0; i<count; i++)
		{
			if (index[i] >= __barrierCount || index[i] < 0)
			{
				str = "ERR: Incorrect barrier index @ " + ItemName[i] + " (value = " + index[i] + ")!\r\n";
				errorMsg = String::Concat(errorMsg, str);
				error++;
				continue;
			}

			if (index[i] % 2)
			{
				str = "ERR: Barrier index (" + index[i] + ") is not an even number! Every barrier index in TP must go in pair\r\n";
				errorMsg = String::Concat(errorMsg, str);
				error++;
				continue;
			}

			if (barrier_index->ContainsKey(index[i]) == false)
			{
				barrier_index->Add(index[i], 0); //check for unique index[i]=Key. Use dummy val as "Value" for the dict
			}
			else
			{
				str = "ERR: Barrier of same index (" + index[i] + ") has been added!\r\n";
				errorMsg = String::Concat(errorMsg, str);
				error++;
				continue;
			}
		}	

		// Check whether index covers from 0->__barrierCount
		if (error == 0)
		{
			array<int> ^ expected_index = gcnew array<int>(__barrierCount);
			array<int> ^ found_index = gcnew array<int>(__barrierCount);
			for (int i=0; i<__barrierCount; i++)
			{	
				expected_index[i] = i;
				found_index[i] = 0;
			}

			for (int i=0; i<count; i++)
			{
				for (int j=0; j<__barrierCount; j++)
				{
					if (index[i] == expected_index[j])
						found_index[j] = 1;

					if ((index[i]+1) == expected_index[j]) //for its pair
						found_index[j] = 1;
				}
			}

			for (int i=0; i<__barrierCount; i++)
			{
				if (found_index[i] == 0)
				{
					str = "ERR: Barrier of this index (" + found_index[i] + ") is missing in the flow!\r\n";
					errorMsg = String::Concat(errorMsg, str);
				}
			}	
		}

		if (Barrier_Debug_Enable == true)
		{

			StringBuilder ^ sb_barrier = gcnew StringBuilder();
			StreamWriter ^ sw_barrier = gcnew StreamWriter("C:\\Aemulus\\Debug\\BarrierCheck" + testSite + ".txt");

			if (error)
			{
				sb_barrier->AppendLine("IFO: Total error found: " + error);	
				sb_barrier->AppendLine(errorMsg);
			}
			sb_barrier->AppendLine("IFO: Barrier count (AppsWideVariable): " + __barrierCount);
			sb_barrier->AppendLine("IFO: Barrier index in flow:");
			for (int i=0; i<count; i++)
			{
				if (i == count-1)
				{
					sb_barrier->AppendLine("     " + ItemName[i] + "," + index[i]);
				}
				else
				{
					sb_barrier->AppendLine("     " + ItemName[i] + "," + index[i] + "," + (index[i]+1).ToString());
				}
			}

			sw_barrier->Write(sb_barrier);	
			sb_barrier = nullptr;
			sw_barrier->Close();
			sw_barrier = nullptr;

		}

		if (error)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Incorrect barrier setup for multisite testing!", ER_GENERAL);
		}
	}
	int TestProgram::seq_force_next(Site ^ site)
	{
		return 0;
	}
}
