#pragma warning(disable: 4091 4101)

#include "TestProgram.h"

namespace SS294502E1_55
{
	// TestProgram Constructor
	TestProgram::TestProgram(void)
	{
		UUTCount = 0;
		TestOffset = 0;

		OffsetFile = String::Empty;
		offset = gcnew Dictionary <String ^ , array<double> ^>;

		TesterCalFile = String::Empty;
		calfactor = gcnew Dictionary <String ^ , array<double> ^>;

		DIOSettingFile = String::Empty;
		DIOSetting = gcnew Dictionary <String ^ , array<String ^> ^>;

		DMSettingFile = String::Empty;
		DMSetting = gcnew Dictionary <String ^ , array<String ^> ^>;

		CBitSettingFile = String::Empty;
		CBitSetting = gcnew Dictionary <String ^ , array<String ^> ^>;

		MuxSettingFile = String::Empty;
		MuxSetting = gcnew Dictionary <String ^ , array<String ^> ^>;
		
		VectorSetNo = gcnew Dictionary <String ^ , int>;
		VectorLineCount = gcnew Dictionary <String ^ , int>;

		//SPI
		SPISetNo = gcnew Dictionary <String ^ , int>;
		SPISetIndex = gcnew Dictionary <String ^ , int>;

		VectorFileDirectory = String::Empty;

		SetupFileDirectory = String::Empty;
		
		SPI_started = gcnew array<int>(4);
		
		//// SPI glob array
		spi_data = gcnew array<int>(256);
		spi_data_dir = gcnew array<int>(256);
		delay_s_after_byte = gcnew array<double>(256);

	
		//DGT
		readdata_big = gcnew array<int>(MAX_DIG_SAMPLE);
		readdata = gcnew array<int>(NORM_DIG_SAMPLE);		//sidi mask
		
		Vswg_calibrated = gcnew Dictionary <String^, double>;
		Vswg_at_dut = gcnew Dictionary <String^, double>;

		Vswg_calibrated_gainhds = gcnew Dictionary <String^, double>;
		Vswg_at_dut_gainhds = gcnew Dictionary <String^, double>;

		Vswg_calibrated_gainhds_virvor = gcnew Dictionary <String^, double>;

		Vswg_calibrated_gainsup = gcnew Dictionary <String^, double>;
		Vswg_at_dut_gainsup = gcnew Dictionary <String^, double>;

		Vswg_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_hth_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hth_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_bias_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_bias_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_itr_timing_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_itr_timing_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_fhsgain_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_spd_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_fhsgain_spd_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_spd_0_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_fhsgain_spd_0_at_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_spd_8_calibrated = gcnew Dictionary <String ^, double>;		//
		Vswg_fhsgain_spd_8_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_spd_4_calibrated = gcnew Dictionary <String ^, double>;		//
		Vswg_fhsgain_spd_4_dut = gcnew Dictionary <String ^, double>;

		Vswg_fhsgain_spd_2_calibrated = gcnew Dictionary <String ^, double>;		//
		Vswg_fhsgain_spd_2_dut = gcnew Dictionary <String ^, double>;

		Vswg_proxdetect_20k_calibrated = gcnew Dictionary <String ^, double>;	//
		Vswg_proxdetect_20k_dut = gcnew Dictionary <String ^, double>;
		
		Vswg_proxdetect_120k_calibrated = gcnew Dictionary <String ^, double>;	//
		Vswg_proxdetect_120k_dut = gcnew Dictionary <String ^, double>;
		
		Vswg_proxdetect_600k_calibrated = gcnew Dictionary <String ^, double>;	//
		Vswg_proxdetect_600k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_50k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_50k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_140k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_140k_dut = gcnew Dictionary <String ^, double>;
		
		Vswg_hsm_35k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_35k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_100k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_100k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_1M_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_1M_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_110k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_110k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_180k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_180k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_250k_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_250k_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_2M_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_2M_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_3M_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_3M_dut = gcnew Dictionary <String ^, double>;

		Vswg_hsm_20M_calibrated = gcnew Dictionary <String ^, double>;
		Vswg_hsm_20M_dut = gcnew Dictionary <String ^, double>;

		Vswg_lpd_spd_calibrated = gcnew Dictionary <String^, double>;
		Vswg_lpd_spd_at_dut = gcnew Dictionary <String^, double>;

		Vswg_filter_calibrated = gcnew Dictionary <String^, double>;
		Vswg_filter_at_dut = gcnew Dictionary <String^, double>;

		wr_timing_siggen_del_index = gcnew Dictionary <String ^, int>;
		wr_timing_vset = gcnew Dictionary <String ^, int>;
		wr_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		bias_timing_siggen_del_index = gcnew Dictionary <String ^, int>;
		bias_timing_vset = gcnew Dictionary <String ^, int>;
		bias_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		itr_timing_siggen_del_index = gcnew Dictionary <String ^, int>;
		itr_timing_vset = gcnew Dictionary <String ^, int>;
		itr_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		hth_timing_siggen_del_index = gcnew Dictionary <String ^, int>;
		hth_timing_vset = gcnew Dictionary <String ^, int>;
		hth_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		rw_timing_vset = gcnew Dictionary <String ^, int>;
		rw_timing_dig_del_index = gcnew Dictionary <String ^, int>;

		Debug_Enable = false;

		Power_Line_Freq = 50;

		HDS = 0;

		testHead = 0;

		TIByPassed = false;

		CBitHist = gcnew Dictionary <String ^, int>;

		USE_SPI = false;	//ML true


		// Statistical Contact Monitoring 
		SampleCount		= 1;
		CD_idx      = 0;
		Cont_Data		= gcnew array<double, 2>(31, 4000); 
		Cont_Data_idx	= gcnew array<int>(31); 
		Cont_Data_mean	= gcnew array<double>(31); 
		Cont_Data_max	= gcnew array<double>(31); 
		Cont_Data_max	= gcnew array<double>(31); 
		Cont_Data_sum	= gcnew array<double>(31);
		Cont_Data_stdev	= gcnew array<double>(31);
		Cont_Data_meas	= gcnew array<int>(31);
		//
		gwatch.Reset() ;
	}
	// Private Methods
	void TestProgram::InitializeGlobalVariables()
	{
		_glob->VectorListFile = String::Empty;

		_glob->contact_open_l_short_h	= gcnew array<int>(_numOffset);
		_glob->contact_fail				= gcnew array<int>(_numOffset);
		_glob->Xcoord					= gcnew array<int>(_numOffset);
		_glob->Ycoord					= gcnew array<int>(_numOffset);
		_glob->global_who_i				= gcnew array<double, 2>(_numOffset, HDS); 
		_glob->global_who_v				= gcnew array<double, 2>(_numOffset, HDS); 
		_glob->Global_Result			= gcnew array<double, 2> (_numOffset, TOTAL_GLOBAL_VARIABLE);
		_glob->GoodDIE					= gcnew array<int>(_numOffset);

		_glob->mux_offset				= gcnew array<double>(_numOffset);
		_glob->vref_pre					= gcnew array<double>(_numOffset); 
		_glob->iabs_pre					= gcnew array<double>(_numOffset); 
		_glob->atemp_pre				= gcnew array<double>(_numOffset); 

		_glob->vref_blown_fuse			= gcnew array<int>(_numOffset); 
		_glob->atemp_blown_fuse			= gcnew array<int>(_numOffset); 
		_glob->iabs_blown_fuse			= gcnew array<int>(_numOffset); 
		_glob->waferid_blown_fuse		= gcnew array<int>(_numOffset); 
		_glob->quadrantid_blown_fuse	= gcnew array<int>(_numOffset); 
		_glob->radiusid_blown_fuse		= gcnew array<int>(_numOffset); 

		_glob->vref_fuse_toblow			= gcnew array<int>(_numOffset); 
		_glob->atemp_fuse_toblow		= gcnew array<int>(_numOffset); 
		_glob->iabs_fuse_toblow			= gcnew array<int>(_numOffset); 
		_glob->waferid_fuse_toblow		= gcnew array<int>(_numOffset); 
		_glob->quadrantid_fuse_toblow	= gcnew array<int>(_numOffset); 
		_glob->radiusid_fuse_toblow		= gcnew array<int>(_numOffset); 

		_glob->trimlock					= gcnew array<int>(_numOffset); 
		_glob->FuseBlown				= gcnew array<int>(_numOffset); 
		_glob->testpass					= gcnew array<int>(_numOffset); 

		_glob->w_slope				= gcnew array<double, 2>(_numOffset, HDS); 
		_glob->r_slope				= gcnew array<double, 2>(_numOffset, HDS); 
		
		for (int i=0; i<_numOffset; i++)
		{
			_glob->contact_open_l_short_h[i] = 0;
			_glob->contact_fail[i] = 0;
			_glob->Xcoord[i] = 0;
			_glob->Ycoord[i] = 0;

			_glob->GoodDIE[i] = 0;

			_glob->mux_offset[i] = 0;

			_glob->vref_pre[i] = 0;
			_glob->iabs_pre[i] = 0;
			_glob->atemp_pre[i]	= 0;

			_glob->vref_blown_fuse[i] = 0;
			_glob->atemp_blown_fuse[i] = 0;
			_glob->iabs_blown_fuse[i] = 0;
			_glob->waferid_blown_fuse[i] = 0;
			_glob->quadrantid_blown_fuse[i] = 0;
			_glob->radiusid_blown_fuse[i] = 0;

			_glob->vref_fuse_toblow[i] = 0;
			_glob->atemp_fuse_toblow[i] = 0;
			_glob->iabs_fuse_toblow[i] = 0;
			_glob->waferid_fuse_toblow[i] = 0;
			_glob->quadrantid_fuse_toblow[i] = 0;
			_glob->radiusid_fuse_toblow[i] = 0;

			_glob->trimlock[i]		= 0;
			_glob->FuseBlown[i]		= 0;
			_glob->testpass[i]		= 0;
			
		

			for (int j=0; j<HDS; j++)
			{
				_glob->global_who_i[i, j] = INVALID_RESULT;
				_glob->global_who_v[i, j] = INVALID_RESULT;

				_glob->w_slope[i, j] = 0;
				_glob->r_slope[i, j] = 0;
			}

			for (int j=0; j<TOTAL_GLOBAL_VARIABLE; j++)
			{
				_glob->Global_Result[i, j] = 0;
			}
		}

		_glob->SPD_Channel_Number = 2;

		_glob->spi_clk_freq = SPI_CLK_FREQ;

		_glob->global_fsav0 = 0;		//ML initialize

		//Polarity global variable
		_glob->PolWR_PROBE	= gcnew array<int,2>(2,4);
		_glob->PolRD_PROBE	= gcnew array<int,2>(2,4);
		_glob->PolTA_PROBE	= gcnew array<int,2>(2,4);
		_glob->PolWR_DUT	= gcnew array<int,2>(2,4);
		_glob->PolRD_DUT	= gcnew array<int,2>(2,4);
		_glob->PolTA_DUT	= gcnew array<int,2>(2,4);

		//Trimming test global variable
		_glob->TrimReg = gcnew array<int,2>(10,5);
		_glob->TrimRegWHD = gcnew array<int,2>(10,5);
		_glob->TrimRegRHD = gcnew array<int,2>(10,5);

		_glob->DieID_Query_Flag = false;

		_glob->Center_X = 0;
		_glob->Center_Y = 0;
		_glob->Die_Size_X = 0;
		_glob->Die_Size_Y = 0;

		// SPI global variable
		_glob->SPI_Data_Arr = gcnew array<int, 3>(MAX_SPI_SET, MAX_SPI_SET_INDEX, 3); // for loading all SPI data
		_glob->SPI_Data_Index = gcnew array<int, 1>(MAX_SPI_SET_INDEX);

		// DIGITIZER global variable
		//_glob->DIG_Data_Arr	   = gcnew array<double, 3>(_numOffset, BIG_DIG_SAMPLE, DIG_DATAARR_INDEX);    // Indexed sidi for itr BIG_DIG_SAMPLE
		_glob->DIG_Data_Arr	   = gcnew array<double, 3>(_numOffset, NORM_DIG_SAMPLE, DIG_DATAARR_INDEX);    // Indexed
		_glob->DIG_temp_Arr_S0 = gcnew array<double, 1>(NORM_DIG_SAMPLE);
		_glob->DIG_temp_Arr_S1 = gcnew array<double, 1>(NORM_DIG_SAMPLE);
		_glob->DIG_temp_Arr_S2 = gcnew array<double, 1>(NORM_DIG_SAMPLE);
		_glob->DIG_temp_Arr_S3 = gcnew array<double, 1>(NORM_DIG_SAMPLE);

		// DIGITIZER global variable (Upsize)
		_glob->DIG_Big_Data_Arr	   = gcnew array<double, 2>(_numOffset, MAX_DIG_SAMPLE); // Non indexed
		_glob->DIG_Big_temp_Arr_S0 = gcnew array<double, 1>(MAX_DIG_SAMPLE);
		_glob->DIG_Big_temp_Arr_S1 = gcnew array<double, 1>(MAX_DIG_SAMPLE);
		_glob->DIG_Big_temp_Arr_S2 = gcnew array<double, 1>(MAX_DIG_SAMPLE);
		_glob->DIG_Big_temp_Arr_S3 = gcnew array<double, 1>(MAX_DIG_SAMPLE);
		//
		_glob->digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		_glob->waveAmplitude = gcnew array<double>(100);
		_glob->dataArray_vpp = gcnew array<double>(128);

		_glob->DUT_Counter = gcnew array<int, 1>(_numOffset);
		_glob->jump_on_fail = false;

		_glob->DA_OffsetError = gcnew array<double, 2>(_numOffset, TOTAL_MUX_GROUP_PER_SITE);
		_glob->DA_GainError = gcnew array<double, 2>(_numOffset, TOTAL_MUX_GROUP_PER_SITE);
		_glob->DA_m = gcnew array<double, 1>(_numOffset);
		_glob->DA_c = gcnew array<double, 1>(_numOffset);

		_glob->DA_OffsetError_X1 = gcnew array<double, 2>(_numOffset, TOTAL_MUX_GROUP_PER_SITE);
		_glob->DA_GainError_X1 = gcnew array<double, 2>(_numOffset, TOTAL_MUX_GROUP_PER_SITE);
		_glob->DA_m_X1 = gcnew array<double, 1>(_numOffset);
		_glob->DA_c_X1 = gcnew array<double, 1>(_numOffset);

		SPI_started[0] = 0;
		SPI_started[1] = 0;
		SPI_started[2] = 0;
		SPI_started[3] = 0;

	}
	void TestProgram::LoadTrimReg(void)
	{
		int trim_reg[10][5] = 
		//// pg, reg, bitshift, fuse count , dac
		{
		{ 2, 23, 0, 4, 16},		// 0: VREF
		{ 2, 22, 0, 6, 64},		// 1: IABS
		{ 2, 23, 4, 4, 16},		// 2: ATEMP
		{ 2, 24, 3, 5, 32},		// 3: WAFERID
		{ 2, 24, 1, 2,  3},		// 4: QUADID
		{ 2, 24, 0, 1,  1},		// 5: RADID
		{ 2, 14, 3, 3,  8},		// 6: WHTRCORE
		{ 2, 14, 0, 3,  8},		// 7: RHTRCORE
		{ 2, 25, 5, 1,	1},		// 8: Test
		{ 2, 25, 4, 1,	1},		// 9: Lock
		};
		
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 5; j++)
			{	
				_glob->TrimReg[i,j] = trim_reg[i][j]; 				
			}		
		}

		int trim_reg_WHD[10][5] = 
		// pg, reg, bitshift, fuse count 
		{
		{ 2, 9, 2, 2, 3},	// WHTR_HD_0: 
		{ 2, 9, 6, 2, 3},	// WHTR_HD_1:
		{ 2, 10, 2, 2, 3},	// WHTR_HD_2: 
		{ 2, 10, 6, 2, 3},	// WHTR_HD_3:
		{ 2, 11, 2, 2, 3},	// WHTR_HD_4: 
		{ 2, 11, 6, 2, 3},	// WHTR_HD_5:
		{ 2, 12, 2, 2, 3},	// WHTR_HD_6: 
		{ 2, 12, 6, 2, 3},	// WHTR_HD_7:
		{ 2, 13, 2, 2, 3},	// WHTR_HD_8:
		{ 2, 13, 6, 2, 3},	// WHTR_HD_9:
		};
		
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 5; j++)
			{	
				_glob->TrimRegWHD[i,j] = trim_reg_WHD[i][j]; 				
			}		
		}

		int trim_reg_RHD[10][5] = 
		// pg, reg, bitshift, fuse count 
		{
		{ 2, 9, 0, 2, 3},	// WHTR_HD_0: 
		{ 2, 9, 4, 2, 3},	// WHTR_HD_1:
		{ 2, 10, 0, 2, 3},	// WHTR_HD_2: 
		{ 2, 10, 4, 2, 3},	// WHTR_HD_3:
		{ 2, 11, 0, 2, 3},	// WHTR_HD_4: 
		{ 2, 11, 4, 2, 3},	// WHTR_HD_5:
		{ 2, 12, 0, 2, 3},	// WHTR_HD_6: 
		{ 2, 12, 4, 2, 3},	// WHTR_HD_7:
		{ 2, 13, 0, 2, 3},	// WHTR_HD_8:
		{ 2, 13, 4, 2, 3},	// WHTR_HD_9:
		};
		
		for (int i = 0; i < 10; i++)
		{
			for (int j = 0; j < 5; j++)
			{	
				_glob->TrimRegRHD[i,j] = trim_reg_RHD[i][j]; 				
			}		
		}
	}
	void TestProgram::LoadPolarity(void)
	{
		//WRx_ProbeCard
		int polwr_probe[2][4] = 
		// site0, site1, site2, site3
		{
			//{  1,  1,  1,  1},		// 0: HSEL0
			//{  1,  1,  1,  1},		// 1: HSEL1
			{ -1, -1, -1, -1},		// 0: HSEL0
			{  1,  1,  1,  1},		// 1: HSEL1
		};	
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{	
				_glob->PolWR_PROBE[i,j] = polwr_probe[i][j]; 				
			}		
		}

		//WRx_DUTCard
		int polwr_dut[2][4] = 
		// site0, site1, site2, site3
		{
			//{ -1, -1, -1, -1},		// 0: HSEL0
			//{  1,  1,  1,  1},		// 1: HSEL1
			{  1,  1,  1,  1},		// 0: HSEL0
			{  1,  1,  1,  1},		// 1: HSEL1
		};	
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{	
				_glob->PolWR_DUT[i,j] = polwr_dut[i][j]; 				
			}		
		}



		//RDx_ProbeCard
		int polrd_probe[2][4] = 
		// site0, site1, site2, site3
		{
			//{  1,  1,  1,  1},		// 0: HSEL0
			//{ -1, -1, -1, -1},		// 1: HSEL1
			{ -1, -1, -1, -1},		// 0: HSEL0
			{  1,  1,  1,  1},		// 1: HSEL1
		};	
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{	
				_glob->PolRD_PROBE[i,j] = polrd_probe[i][j]; 				
			}		
		}

		//RDx_DUTCard
		int polrd_dut[2][4] = 
		// site0, site1, site2, site3
		{
			//{ -1, -1, -1, -1},		// 0: HSEL0
			//{ -1, -1, -1, -1},		// 1: HSEL1
			{ -1, -1, -1, -1},		// 0: HSEL0
			{  1,  1,  1,  1},		// 1: HSEL1
		};	
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{	
				_glob->PolRD_DUT[i,j] = polrd_dut[i][j]; 				
			}		
		}



		//TAx_ProbeCard
		int polta_probe[2][4] = 
		// site0, site1, site2, site3
		{
			//{  1,  1,  1,  1},		// 0: HSEL0
			//{ -1, -1, -1, -1},		// 1: HSEL1
			{ -1, -1, -1, -1},		// 0: HSEL0
			{  1,  1,  1,  1},		// 1: HSEL1
		};	
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{	
				_glob->PolTA_PROBE[i,j] = polta_probe[i][j]; 				
			}		
		}

		//TAx_DUTCard
		int polta_dut[2][4] = 
		// site0, site1, site2, site3
		{
			{ -1, -1, -1, -1},		// 0: HSEL0
			{  1,  1,  1,  1},		// 1: HSEL1
		};	
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < 4; j++)
			{	
				_glob->PolTA_DUT[i,j] = polta_dut[i][j]; 				
			}		
		}

	}
	int TestProgram::LoadVectorFileList(Site ^ site)
	{
		int ret = 0;

		_glob->VectorListFile = site->GetExternalDependency("VECTOR_LIST_FILE");
		if (!File::Exists(_glob->VectorListFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(_glob->VectorListFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(_glob->VectorListFile);

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != 2)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain correct format!", ER_READ_FILE_ERROR);
				}
		
				if (VectorSetNo->ContainsKey(ArrStr[0]) == false)
					VectorSetNo->Add(ArrStr[0], _util->StrToInt(ArrStr[1]));
					_glob->VectorArrSetNo++;
			}
		}

		_glob->VectorArrSetNo = _glob->VectorArrSetNo + 10; 

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::LoadVectorFiles(Site ^ site, int UutOffsetIndex)
	{
		int ret = 0;

		VectorFileDirectory = site->GetExternalDependency("VECTOR");

		array<int>^ resourceArr = gcnew array<int>(DM_CONST_MAX_VECTOR_SET);

		for(int i=0; i<DM_CONST_MAX_VECTOR_SET; i++)
		{
			resourceArr[i] = 1;
		}

		ret = dm[UutOffsetIndex]->ConfigureVectorEngineAttribute("DM_2", 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINVectorResourceAllocation("DM_2", DM_CONST_MAX_VECTOR_SET, resourceArr);
		CheckError(UutOffsetIndex, ret, __LINE__);
				
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		StreamReader ^ sr;
		int vector_count = 0;
		int flag = 0;
		int coun = 0;
		for each (String ^ s in VectorSetNo->Keys)
		{
			ret = dm[UutOffsetIndex]->DPINVecLoad("DM_2", DM_CONST_BIDIRECTIONAL_IO, VectorSetNo[s], VectorFileDirectory + "\\" + s + ".txt");
			if (ret < 0) 
			{
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			coun++;
			//Get total vector lines in each vector file (VectorCount)
			sr = gcnew StreamReader(VectorFileDirectory + "\\" + s + ".txt");

			vector_count = 0;

			while((line = sr->ReadLine()) != nullptr)
			{
				if (line->StartsWith("X") == true ||
					line->StartsWith("x") == true ||
					line->StartsWith("L") == true ||
					line->StartsWith("l") == true ||
					line->StartsWith("H") == true ||
					line->StartsWith("h") == true ||
					line->StartsWith("Z") == true ||
					line->StartsWith("x") == true ||
					line->StartsWith("1") == true ||
					line->StartsWith("0") == true)
				{
					vector_count++;
				}
			}

			if (VectorLineCount->ContainsKey(s) == false)
				VectorLineCount->Add(s, vector_count);
			
			sr->Close();
			sr = nullptr;
		}
		
		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 1, DM_CONST_VECTOR_PERIOD_1MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 2, DM_CONST_VECTOR_PERIOD_2MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 10, DM_CONST_VECTOR_PERIOD_10MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 20, DM_CONST_VECTOR_PERIOD_20MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 25, DM_CONST_VECTOR_PERIOD_25MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 40, DM_CONST_VECTOR_PERIOD_40MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 50, DM_CONST_VECTOR_PERIOD_50MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 60, DM_CONST_VECTOR_PERIOD_60MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 70, DM_CONST_VECTOR_PERIOD_70MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 80, DM_CONST_VECTOR_PERIOD_80MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 90, DM_CONST_VECTOR_PERIOD_90MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 100, DM_CONST_VECTOR_PERIOD_100MHZ);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::GetDataByteFromHistoryRam(String^ VectorFileName, array<int>^ HistoryRam, int % data_one_byte, int data_channel)
	{
		int ret = 0;

		array<String ^, 2>^ res_Arr = gcnew array<String ^, 2>(VectorLineCount[VectorFileName], DM_CONST_TOTAL_CHANNEL_PER_CARD);
		String ^ res_out = String::Empty;

		int i=0, j=0, k=0;

		//Convert 2-bit to corresponding logic state, for every vector line (excluding t0 and t1)
		for(i=0; i<VectorLineCount[VectorFileName]; i++)
		{
			bitset<24> b(HistoryRam[i]); //12 channels, where each channel logic is represented by 2 bits (00, 01, or 10) -> 24
			for (j=0; j<24; j=j+2)
			{
				if ((b[j]==0) && (b[j+1]==0)) 
				{
					res_Arr[i, j/2] = "L";
				}
				else if ((b[j+1]==0) && (b[j]==1)) 
				{
					res_Arr[i, j/2] = "H";
				}
				else if ((b[j+1]== 1) && (b[j]==0)) 
				{
					res_Arr[i, j/2] = "Z";
				}
			}
		}

		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = "//"; //to filter out comments

		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = " ";

		int vector_count = 0;
		int data = 0;
		i = 0;

		StreamReader ^ sr = gcnew StreamReader(VectorFileDirectory + "\\" + VectorFileName + ".txt");

		while((line = sr->ReadLine()) != nullptr)
		{
			if (line->StartsWith("X") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("L") == true ||
				line->StartsWith("l") == true ||
				line->StartsWith("H") == true ||
				line->StartsWith("h") == true ||
				line->StartsWith("Z") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("1") == true ||
				line->StartsWith("0") == true)
			{
				vector_count++;

				ArrStr = line->Split(Separator, StringSplitOptions::None);

				if(ArrStr[0]->Contains("L") == true ||
					ArrStr[0]->Contains("l") == true ||
					ArrStr[0]->Contains("H") == true ||
					ArrStr[0]->Contains("h") == true)
				{
					if (res_Arr[vector_count-1, data_channel] == "H")
						data = data | (1 << i);

					if (res_Arr[vector_count-1, data_channel] == "L" || res_Arr[vector_count, data_channel] == "Z")
						data = data | (0 << i);

					i++;
				}
			}
		}
	
		sr->Close();

		sr = nullptr;

		data_one_byte = data;

		return ret;
	}
	int TestProgram::LoadDMSettingFile(Site ^ site)
	{
		int ret = 0;

		DMSettingFile = site->GetExternalDependency("DM_Setting");
		if (!File::Exists(DMSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(DMSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(DMSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != TOTAL_DM_IN_SETTING_FILE + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + TOTAL_DM_IN_SETTING_FILE + " I/O(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(TOTAL_DM_IN_SETTING_FILE);

				index = ArrStr[1];

				for (i=0; i<TOTAL_DM_IN_SETTING_FILE; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //include "Index" column
				}

				DMSetting->Add(ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::LoadCBitSettingFile(int UutOffsetIndex)
	{
		int ret = 0;

		switch (UutOffsetIndex)
		{
			case 0:
				CBitSettingFile = SetupFileDirectory + "\\CBITA_Setting.csv";
				break;

			case 1:
				CBitSettingFile = SetupFileDirectory + "\\CBITD_Setting.csv";
				break;

			case 2:
				CBitSettingFile = SetupFileDirectory + "\\CBITB_Setting.csv";
				break;

			case 3:
				CBitSettingFile = SetupFileDirectory + "\\CBITC_Setting.csv";
				break;

			default:
				CBitSettingFile = SetupFileDirectory + "\\CBITA_Setting.csv";
		}

		if (!File::Exists(CBitSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(CBitSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(CBitSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != IOM_CONST_TOTAL_CBITS + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + IOM_CONST_TOTAL_CBITS + " CBit(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(IOM_CONST_TOTAL_CBITS);

				index = ArrStr[1];

				for (i=0; i<IOM_CONST_TOTAL_CBITS; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //include "Index" column
				}

				CBitSetting->Add(UutOffsetIndex + "_" + ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::LoadMuxSettingFile(int UutOffsetIndex)
	{
		int ret = 0;
		
		switch (UutOffsetIndex)
		{
			case 0:
				MuxSettingFile = SetupFileDirectory + "\\MUXA_Setting.csv";
				break;

			case 1:
				MuxSettingFile = SetupFileDirectory + "\\MUXD_Setting.csv";
				break;

			case 2:
				MuxSettingFile = SetupFileDirectory + "\\MUXB_Setting.csv";
				break;

			case 3:
				MuxSettingFile = SetupFileDirectory + "\\MUXC_Setting.csv";
				break;

			default:
				MuxSettingFile = SetupFileDirectory + "\\MUXA_Setting.csv";
		}

		if (!File::Exists(MuxSettingFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(MuxSettingFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(MuxSettingFile);
		array<String ^> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		String^ index = String::Empty;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != IFBRD_CONST_TOTAL_MUX_IO + 2) //include "Index" column
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + IFBRD_CONST_TOTAL_MUX_IO + " MUX I/O(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<String ^>(IFBRD_CONST_TOTAL_MUX_IO);

				index = ArrStr[1];

				for (i=0; i<IFBRD_CONST_TOTAL_MUX_IO; i++)
				{
					ArrTemp[i] = ArrStr[i+2]; //include "Index" column 
				}

				MuxSetting->Add(UutOffsetIndex + "_" + ArrStr[0] + "_" + index, ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::LoadOffsetFile(Site ^ site)
	{
		int ret = 0;

		OffsetFile = site->GetExternalDependency("Offset");
		if (!File::Exists(OffsetFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(OffsetFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(OffsetFile);
		array<double> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != TOTAL_SITES + 1)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + TOTAL_SITES + " site(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<double>(TOTAL_SITES);

				for (i=0; i<TOTAL_SITES; i++)
				{
					ArrTemp[i] = _util->StrToDouble(ArrStr[i+1]); 
				}

				offset->Add(ArrStr[0], ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}
	double TestProgram::GetOffset(int UutOffsetIndex, String ^ TestParamDisplayName)
	{
		double val = 0.0;

		if (offset->ContainsKey(TestParamDisplayName))
			val = offset[TestParamDisplayName][UutOffsetIndex];
		else
			val = 0.0;

		return val;
	}
	int TestProgram::SetupDigital(int UutOffsetIndex)
	{
		int ret = 0;

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		//vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm[UutOffsetIndex]->Force("FHCW_FETS", DM_CONST_FORCE_STATE_DIO);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->ConfigurePEAttribute("FHCW_FETS", 0, 0, 0, 0);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->DPINLevel("FHCW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->SetPinDirection("FHCW_FETS", DM_CONST_DIR_OUTPUT);
		//CheckError(UutOffsetIndex, ret, __LINE__);

		//vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm[UutOffsetIndex]->Force("FHCR_FETS", DM_CONST_FORCE_STATE_DIO);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->ConfigurePEAttribute("FHCR_FETS", 0, 0, 0, 0);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->DPINLevel("FHCR_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->SetPinDirection("FHCR_FETS", DM_CONST_DIR_OUTPUT);
		//CheckError(UutOffsetIndex, ret, __LINE__);

		//vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		//ret = dm[UutOffsetIndex]->Force("HW_FETS", DM_CONST_FORCE_STATE_DIO);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->ConfigurePEAttribute("HW_FETS", 0, 0, 0, 0);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->DPINLevel("HW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = dm[UutOffsetIndex]->SetPinDirection("HW_FETS", DM_CONST_DIR_OUTPUT);
		//CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//vih = 1.8;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		vih = 2;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("WDX", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("WDX", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("WDX", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 1.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("WDY", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("WDY", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("WDY", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("MODE", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("MODE", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("MODE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("MODE", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 2e-3;	iol = 2e-3;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("FLTMUX", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("FLTMUX", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("FLTMUX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("FLTMUX", DM_CONST_DIR_INPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::DriveDMPin(int UutOffsetIndex, String ^ TestParamDisplayName)
	{
		int ret = 0;
		int i = 0;

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("HW_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("HW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}
			
			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("FHCR_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("FHCR_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}

			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("FHCW_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("FHCW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("RWN");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("RWN", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("WDX");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("WDX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("WDY");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("WDY", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("MODE");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("MODE", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("FLTMUX");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("FLTMUX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		return ret;
	}
	int TestProgram::DriveDMPin(int UutOffsetIndex, String ^ TestParamDisplayName, int index)
	{
		int ret = 0;
		int i = 0;

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("HW_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("HW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}
			
			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("FHCR_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("FHCR_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}

			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("FHCW_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("FHCW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("RWN");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("RWN", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("WDX");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("WDX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("WDY");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("WDY", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("MODE");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("MODE", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				ret = dm[UutOffsetIndex]->DPINOn("FLTMUX");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("FLTMUX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		return ret;
	}
	int TestProgram::DriveDMPin2(int UutOffsetIndex, String ^ TestParamDisplayName)
	{
		int ret = 0;
		int i = 0;

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("HW_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("HW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}
			
			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("FHCR_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("FHCR_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}

			i++;
			//if (DMSetting[TestParamDisplayName][i] == "1" ||
			//	DMSetting[TestParamDisplayName][i] == "0")
			//{
			//	ret = dm[UutOffsetIndex]->DPINOn("FHCW_FETS");
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//	ret = dm[UutOffsetIndex]->DrivePin("FHCW_FETS", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
			//	CheckError(UutOffsetIndex, ret, __LINE__);
			//}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm[UutOffsetIndex]->DPINOn("RWN");
				//CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("RWN", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm[UutOffsetIndex]->DPINOn("WDX");
				//CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("WDX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm[UutOffsetIndex]->DPINOn("WDY");
				//CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("WDY", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm[UutOffsetIndex]->DPINOn("MODE");
				//CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("MODE", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1" ||
				DMSetting[TestParamDisplayName][i] == "0")
			{
				//ret = dm[UutOffsetIndex]->DPINOn("FLTMUX");
				//CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("FLTMUX", _util->StrToInt(DMSetting[TestParamDisplayName][i]));
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		return ret;
	}
	int TestProgram::ResetDMPin(int UutOffsetIndex, String ^ TestParamDisplayName)
	{
		int ret = 0;

		int i = 3; //start with RWN

		//Default to index = 0
		TestParamDisplayName = TestParamDisplayName + "_0";
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("RWN", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("RWN");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("WDX", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("WDX");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("WDY", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("WDY");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{	
				ret = dm[UutOffsetIndex]->DrivePin("MODE", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("MODE");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("FLTMUX", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("FLTMUX");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		return ret;
	}
	int TestProgram::ResetDMPin(int UutOffsetIndex, String ^ TestParamDisplayName, int index)
	{
		int ret = 0;

		int i = 3; //start with RWN

		TestParamDisplayName = TestParamDisplayName + "_" + index.ToString();
		
		if (DMSetting->ContainsKey(TestParamDisplayName))
		{
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("RWN", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("RWN");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("WDX", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("WDX");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("WDY", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("WDY");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{	
				ret = dm[UutOffsetIndex]->DrivePin("MODE", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("MODE");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			i++;
			if (DMSetting[TestParamDisplayName][i] == "1")
			{
				ret = dm[UutOffsetIndex]->DrivePin("FLTMUX", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("FLTMUX");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		return ret;
	}
	int TestProgram::Digital_Init_State(int UutOffsetIndex)
	{
		int ret = 0;

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("RWN", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("RWN");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 1.8;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("WDX", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("WDX", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("WDX", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("WDX", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("WDX");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 1.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("WDY", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("WDY", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("WDY", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("WDY", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("WDY");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("MODE", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("MODE", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("MODE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("MODE", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("MODE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("MODE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 2e-3;	iol = 2e-3;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("FLTMUX", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("FLTMUX", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("FLTMUX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("FLTMUX", DM_CONST_DIR_INPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOff("MODE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("SPE", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPE", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("SPE", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("SPE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("SPD", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPD", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("SPD", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("SPD", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPD");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 2.5;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
        ret = dm[UutOffsetIndex]->Force("SPC", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPC", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("SPC", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("SPC", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPC");
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::SetupDIO(int UutOffsetIndex)
	{
		int ret = 0;

		for (int i=0; i<IOM_CONST_TOTAL_PORTS; i++)
		{
			ret = dio[UutOffsetIndex]->DrivePort("IOM_Port_" + i, 0x0);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		//Reset CBits
		ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 0);		// CLR	
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin("DIO_20", 1);		// Reset 
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Reset MuxIO
		ret = dio[UutOffsetIndex]->DrivePin("DIO_8", 0);	
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::OnOffCbit(int UutOffsetIndex, int Cbit, int value)
	{
		int ret =0;

		int adc[8][3] = {
			//A0, A1, A2
			{0,	0, 0,},
			{1,	0, 0,},
			{0,	1, 0,},
			{1,	1, 0,},
			{0,	0, 1,},
			{1,	0, 1,},
			{0,	1, 1,},
			{1,	1, 1}};
	
		array<String ^> ^ CH_Sel = gcnew array<String ^>(8);
		CH_Sel[0] = "DIO_24";
		CH_Sel[1] = "DIO_25";
		CH_Sel[2] = "DIO_26";
		CH_Sel[3] = "DIO_27";
		CH_Sel[4] = "DIO_28";
		CH_Sel[5] = "DIO_29";
		CH_Sel[6] = "DIO_30";
		CH_Sel[7] = "DIO_31";

		String ^ Clk_Sel_Cbit_A0 = "DIO_23";
		String ^ Clk_Sel_Cbit_A1 = "DIO_22";
		String ^ Clk_Sel_Cbit_A2 = "DIO_21";

		//Reset latch
		for (int i = 0; i <= 7; i++)
		{
			ret = dio[UutOffsetIndex]->DrivePin(CH_Sel[i], 0);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		int Cbit_CH = Cbit/8;
		int s = (Cbit -(Cbit /8)*8);
		int k = 0;
		int start_Cbit = Cbit_CH * 8; 

		//Load Same latch Cbit from CbitHis
		for (int i = start_Cbit ; i <= 7 + start_Cbit; i++)
		{
			if (CBitHist[UutOffsetIndex + "_" + i.ToString()] == 1)
			{
				k = (i -(i /8)*8);
				ret = dio[UutOffsetIndex]->DrivePin(CH_Sel[k], 1);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		//record to CbitHist
		CBitHist[UutOffsetIndex + "_" + Cbit.ToString()] = value;
		ret = dio[UutOffsetIndex]->DrivePin(CH_Sel[s], value);		
		CheckError(UutOffsetIndex, ret, __LINE__);

		//select CLK
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A0, adc[Cbit_CH][0]);		
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A1, adc[Cbit_CH][1]);		
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A2, adc[Cbit_CH][2]);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 1);	
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 0);	//Clock in
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin("DIO_20", 0);   //Set Output Enable
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::DriveCBit(int UutOffsetIndex, String ^ TestParamDisplayName)
	{
		int ret = 0;

		//Default to index = 0
		TestParamDisplayName = UutOffsetIndex.ToString() + "_" + TestParamDisplayName + "_0";
		
		if (CBitSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_CBITS; i++)
			{
				if ((i != 53) && (i != 54))   // maintain smu mode
				{
					if (CBitSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnOffCbit(UutOffsetIndex, i, 1);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}

					if (CBitSetting[TestParamDisplayName][i] == "0")
					{
						ret = OnOffCbit(UutOffsetIndex, i, 0);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			}
		}
		
		return ret;
	}
	int TestProgram::DriveCBit(int UutOffsetIndex, String ^ TestParamDisplayName, int index)
	{
		int ret = 0;

		TestParamDisplayName = UutOffsetIndex.ToString() + "_" + TestParamDisplayName + "_" + index.ToString();
		
		if (CBitSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IOM_CONST_TOTAL_CBITS; i++)
			{
				if ((i != CBIT_VCC_FORWARD) && (i != CBIT_VEE_FORWARD))   // maintain smu mode
				{
					if (CBitSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnOffCbit(UutOffsetIndex, i, 1);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}

					if (CBitSetting[TestParamDisplayName][i] == "0")
					{
						ret = OnOffCbit(UutOffsetIndex, i, 0);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			}
		}
		
		return ret;
	}
	int TestProgram::ResetCBit(int UutOffsetIndex)
	{
		int ret = 0;

		int adc[8][3] = {
			//A0, A1, A2
			{0,	0,	0,},
			{1,	0,	0,},
			{0,	1,	0,},
			{1,	1,	0,},
			{0,	0,	1,},
			{1,	0,	1,},
			{0,	1,	1,},
			{1,	1,	1}};
	
		array<String ^> ^ CH_Sel = gcnew array<String ^>(8);
		CH_Sel[0] = "DIO_24";
		CH_Sel[1] = "DIO_25";
		CH_Sel[2] = "DIO_26";
		CH_Sel[3] = "DIO_27";
		CH_Sel[4] = "DIO_28";
		CH_Sel[5] = "DIO_29";
		CH_Sel[6] = "DIO_30";
		CH_Sel[7] = "DIO_31";

		String ^ Clk_Sel_Cbit_A0 = "DIO_23";
		String ^ Clk_Sel_Cbit_A1 = "DIO_22";
		String ^ Clk_Sel_Cbit_A2 = "DIO_21";

		// Reset all Latch except 6
		for (int i = 0; i <= 7; i++)
		{
			ret = dio[UutOffsetIndex]->DrivePin(CH_Sel[i], 0);	// Reset All Input
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
				
		for (int i = 0; i <= 7; i++)
		{
			if (i !=6)
			{
				ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A0, adc[i][0]);		//Sel CLK except 6
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A1, adc[i][1]);		
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A2, adc[i][2]);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 1);	
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 0);		
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		// Reset Latch6
		for (int i = 0; i <= 7; i++)
		{
			if ((i != 6) && (i != 5))
			{
				ret = dio[UutOffsetIndex]->DrivePin(CH_Sel[i], 0);	// Reset Input except 5 & 6
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		    else
			{
				ret = dio[UutOffsetIndex]->DrivePin(CH_Sel[i], 1);	// Reset Input except 5 & 6
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}
		
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A0, adc[6][0]);		//Sel CLK 6
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A1, adc[6][1]);		
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A2, adc[6][2]);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 1);	
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin("DIO_19", 0);		
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A0, 0);	
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A1, 0);		
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dio[UutOffsetIndex]->DrivePin(Clk_Sel_Cbit_A2, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = ResetCBitHist(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Set Vcc relay on adaptor board
		//ret = OnOffCbit(UutOffsetIndex, CBIT_VCC_FORWARD, 1);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//ret = OnOffCbit(UutOffsetIndex, CBIT_VEE_FORWARD, 1);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		
		return ret;
	}
	int TestProgram::OnMux(int UutOffsetIndex, int mux_grp, int mux_pin)  
	{
		int ret = 0;
		int pin_index = 0;

		if (!(mux_grp == -1))
		{ 
			int adc[16][4] = {
			//A0, A1, A2, A3
			{0,	0, 0, 0,},	//S1
			{1,	0, 0, 0,},	//S2
			{0,	1, 0, 0,},	//S3
			{1,	1, 0, 0,},	//S4
			{0,	0, 1, 0,},	//S5
			{1,	0, 1, 0,},	//S6
			{0,	1, 1, 0,},	//S7
			{1,	1, 1, 0,},	//S8
			{0,	0, 0, 1,},	//S9
			{1,	0, 0, 1,},	//S10
			{0,	1, 0, 1,},	//S11
			{1,	1, 0, 1,},	//S12
			{0,	0, 1, 1,},	//S13
			{1,	0, 1, 1,},	//S14
			{0,	1, 1, 1,},	//S15
			{1,	1, 1, 1}};	//S16
			
			array<String ^> ^ Mux_WR	= gcnew array<String ^>(8);
			Mux_WR[0] = "DIO_0";	//G1-FH
			Mux_WR[1] = "DIO_1";	//G1-SH
			Mux_WR[2] = "DIO_2";	//G1-SL
			Mux_WR[3] = "DIO_3";	//G1-FL
			Mux_WR[4] = "DIO_4";	//G2-FH
			Mux_WR[5] = "DIO_5";	//G2-SH
			Mux_WR[6] = "DIO_6";	//G2-SL
			Mux_WR[7] = "DIO_7";	//G2-FL

			//init mux
			for (int i = 0; i <= 7; i++)
			{
				ret = dio[UutOffsetIndex]->DrivePin(Mux_WR[i], 1);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}

			String ^ MuxAddr_A0 = "DIO_13";
			String ^ MuxAddr_A1 = "DIO_12";
			String ^ MuxAddr_A2 = "DIO_11";
			String ^ MuxAddr_A3 = "DIO_10";

			String ^ Mux_EN = "DIO_9";
			String ^ Mux_RS = "DIO_8";

			pin_index = mux_pin - 1;					

			ret = dio[UutOffsetIndex]->DrivePin(Mux_EN, 1);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = dio[UutOffsetIndex]->DrivePin(Mux_RS, 1);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = dio[UutOffsetIndex]->DrivePin(Mux_WR[mux_grp], 0);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			ret = dio[UutOffsetIndex]->DrivePin(MuxAddr_A0, adc[pin_index][0]);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = dio[UutOffsetIndex]->DrivePin(MuxAddr_A1, adc[pin_index][1]);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = dio[UutOffsetIndex]->DrivePin(MuxAddr_A2, adc[pin_index][2]);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = dio[UutOffsetIndex]->DrivePin(MuxAddr_A3, adc[pin_index][3]);
			CheckError(UutOffsetIndex, ret, __LINE__);			
		}

		return ret;
	}
	int TestProgram::DriveMuxIO(int UutOffsetIndex, String ^ TestParamDisplayName)
	{
		int ret = 0;
		int switch_number = 0;
		int mux_group = 0;

		//Default to index = 0
		TestParamDisplayName = UutOffsetIndex.ToString() + "_" + TestParamDisplayName + "_0";
		
		if (MuxSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IFBRD_CONST_TOTAL_MUX_IO; i++)
			{
				if (i >= 0 && i <= 127)
				{
					if (i >= 0 && i <= 15)
					{
						mux_group = 0;
						switch_number = i;
					}
					else if(i >= 16 && i <= 31)
					{
						mux_group = 1;
						switch_number = i - 16;
					}
					else if(i >= 32 && i <= 47)
					{
						mux_group = 3;
						switch_number = i - 32;
					}
					else if(i >= 48 && i <= 63)
					{
						mux_group = 2;
						switch_number = i - 48;
					}
					else if(i >= 64 && i <= 79)
					{
						mux_group = 4;
						switch_number = i - 64;
					}
					else if(i >= 80 && i <= 95)
					{
						mux_group = 5;
						switch_number = i - 80;
					}
					else if(i >= 96 && i <= 111)
					{
						mux_group = 7;
						switch_number = i - 96;
					}
					else if(i >= 112 && i <= 127)
					{
						mux_group = 6;
						switch_number = i - 112;
					}

					if (MuxSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnMux(UutOffsetIndex, mux_group, switch_number + 1);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			}
		}
		
		return ret;
	}
	int TestProgram::DriveMuxIO(int UutOffsetIndex, String ^ TestParamDisplayName, int index)
	{
		int ret = 0;
		int switch_number = 0;
		int mux_group = 0;

		TestParamDisplayName = UutOffsetIndex.ToString() + "_" + TestParamDisplayName + "_" + index.ToString();
		
		if (MuxSetting->ContainsKey(TestParamDisplayName))
		{
			for (int i=0; i<IFBRD_CONST_TOTAL_MUX_IO; i++)
			{
				if (i >= 0 && i <= 127)
				{
					if (i >= 0 && i <= 15)
					{
						mux_group = 0;
						switch_number = i;
					}
					else if(i >= 16 && i <= 31)
					{
						mux_group = 1;
						switch_number = i - 16;
					}
					else if(i >= 32 && i <= 47)
					{
						mux_group = 3;
						switch_number = i - 32;
					}
					else if(i >= 48 && i <= 63)
					{
						mux_group = 2;
						switch_number = i - 48;
					}
					else if(i >= 64 && i <= 79)
					{
						mux_group = 4;
						switch_number = i - 64;
					}
					else if(i >= 80 && i <= 95)
					{
						mux_group = 5;
						switch_number = i - 80;
					}
					else if(i >= 96 && i <= 111)
					{
						mux_group = 7;
						switch_number = i - 96;
					}
					else if(i >= 112 && i <= 127)
					{
						mux_group = 6;
						switch_number = i - 112;
					}

					if (MuxSetting[TestParamDisplayName][i] == "1")
					{
						ret = OnMux(UutOffsetIndex, mux_group, switch_number + 1);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			}
		}
		
		return ret;
	}
	int TestProgram::ResetMuxIO(int UutOffsetIndex)
	{
		int ret = 0;

		String ^ Mux_RS = "DIO_8";
		
		ret = dio[UutOffsetIndex]->DrivePin(Mux_RS, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		return ret;
	}
	int TestProgram::InitCBitHist()
	{
		int ret = 0;
			
		CBitHist->Clear(); 
		
		for(int idx=0; idx<_numOffset; idx++)
		{
			for (int i = 0; i <= 64; i++)
			{
				CBitHist->Add(idx + "_" + i.ToString(), 0);
			}
		}

		return ret;	
	}
	int TestProgram::ResetCBitHist(int UutOffsetIndex)
	{
		int ret = 0;
			
		for (int i = 0; i <= 64; i++)
		{
			if ((i != 53) && (i != 54))
			{
				CBitHist[UutOffsetIndex + "_" + i.ToString()] = 0;
			}
		}

		return ret;	
	}
	int TestProgram::Configure_GND_FET(int UutOffsetIndex)
	{
		int ret = 0;

		ret = dm[UutOffsetIndex]->Force("GND_FETS", DM_CONST_FORCE_STATE_PMU);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUOutputFunction("GND_FETS", DM_CONST_DVCI);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUCurrentLimitRange("GND_FETS", 0.025);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLevel("GND_FETS", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GND_FETS");
		CheckError(UutOffsetIndex, ret, __LINE__);

		return 0;
	}
	int TestProgram::OnOffFETGnd(int UutOffsetIndex, int On_h_Off_l)
	{
		int ret = 0;

		if (On_h_Off_l == 1)
		{
			ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLevel("GND_FETS", -2);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if (On_h_Off_l == 0)
		{
			ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLevel("GND_FETS", 2);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		return ret;
	}
	int TestProgram::LoadTesterCalFile()
	{
		int ret = 0;

		TesterCalFile = "C:\\Aemulus\\TesterInfo\\Calibration.csv";
		if (!File::Exists(TesterCalFile))
		{
			throw gcnew Aemulus::Hardware::AlarmException(TesterCalFile + " does not exist!", ER_FILE_NOT_FOUND);
		}

		int line_number = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		StreamReader ^ sr = gcnew StreamReader(TesterCalFile);
		array<double> ^ ArrTemp;

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator2 = gcnew array<String ^>(1);
		Separator2[0] = "\"";

		int i = 0;
		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			line2 = String::Empty;
			ArrStr2 = line->Split(Separator, StringSplitOptions::None);
			for (int j=0; j<ArrStr2->Length; j++)
			{
				if (ArrStr2[j]->StartsWith("\"") && ArrStr2[j]->EndsWith("\""))
				{
					temp = ArrStr2[j]->Split(Separator2, StringSplitOptions::None);
					if (j == ArrStr2->Length-1)
						line2 = line2 + temp[1];
					else	
						line2 = line2 + temp[1] + ",";
				}
				else
				{
					if (j == ArrStr2->Length-1)
						line2 = line2 + ArrStr2[j];
					else
						line2 = line2 + ArrStr2[j] + ",";
				}
			}

			if (line2->StartsWith("//") == false)
			{
				ArrStr = line2->Split(Separator, StringSplitOptions::None);

				if (ArrStr->Length != TOTAL_SITES + 1)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Line " + line_number + " does not contain data for " + TOTAL_SITES + " site(s)!", ER_READ_FILE_ERROR);
				}

				ArrTemp = gcnew array<double>(TOTAL_SITES);

				for (i=0; i<TOTAL_SITES; i++)
				{
					ArrTemp[i] = _util->StrToDouble(ArrStr[i+1]); 
				}

				calfactor->Add(ArrStr[0], ArrTemp);

				delete ArrTemp;
			}
		}

		sr->Close();

		sr = nullptr;

		return ret;
	}
	int TestProgram::Measure_GNDS_Voltage(int UutOffsetIndex, double nplc, double meas_delay, double % volt)
	{
		int ret = 0;

		volt = 0;

		int data = 0;

		if (Test == TEST_QS_BLKDGN_PROBE_IF2 || Test == TEST_QS_BLKDGN_DUT_IF2)
		{
			data = 0x10;
		}
		else
		{
			switch (UutOffsetIndex)
			{
				// (D7 D6 D5 D4 D3 D2 D1 D0)1 (D7 D6 D5 D4 D3 D2 D1 D0)0
				case 0: // 0000 0000 0001 0000
					data = 0x10;
					break;

				case 1: // 0000 0000 0010 0000
					data = 0x20;
					break;

				case 2: // 0000 0000 0100 0000
					data = 0x40;				
					break;

				case 3: // 0000 0000 1000 0000
					data = 0x80;
					break;

				default:
					data = 0x0;
			}
		}

		int spi_status = 0;
		int spi_group = 1;
		int spi_byte_length = 1;

		array<int> ^ spi_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_data_dir = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_biterror = gcnew array<int>(spi_byte_length);
		array<double> ^ delay_s_after_byte = gcnew array<double>(spi_byte_length);

		for (int i=0; i<spi_byte_length; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		spi_data[0]		= ((0x200 << 16) & 0xffff0000) | (data & 0xffff); //write (D7->D0 for GNDS, and then D7->D0 for GND)=16 bit data, then deassert NCS
		spi_data_dir[0] = 0x0000000; 

		ret = dm[UutOffsetIndex]->SPI_RUN("DM_1", spi_group, spi_data, spi_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		//Stopwatch swatch;

		//swatch.Reset();
		//swatch.Start();
		//swatch.Stop();

		//while (swatch.Elapsed.TotalSeconds < 0.1)
		//{
		//	swatch.Start();

		//	ret = dm[UutOffsetIndex]->SPI_STATUS("DM_1", spi_group, spi_status);
		//	CheckError(UutOffsetIndex, ret, __LINE__);

		//	if (spi_status == 2) //0=idle, 1=busy, 2=done
		//		break;

		//	swatch.Stop();
		//}

		ret = smu[UutOffsetIndex]->ConfigureSamplingTime("GND_MUX_SENSE", nplc, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = _util->Wait_Sec(meas_delay);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ReadVoltage("GND_MUX_SENSE", volt);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::Configure_GNDS_Mux(int UutOffsetIndex, double nplc)
	{
		int ret = 0;

		int data = 0;

		if (Test == TEST_QS_BLKDGN_PROBE_IF2 || Test == TEST_QS_BLKDGN_DUT_IF2)
		{
			data = 0x10;
		}
		else
		{
			switch (UutOffsetIndex)
			{
				// (D7 D6 D5 D4 D3 D2 D1 D0)1 (D7 D6 D5 D4 D3 D2 D1 D0)0
				case 0: // 0000 0000 0001 0000
					data = 0x10;
					break;

				case 1: // 0000 0000 0010 0000
					data = 0x20;
					break;

				case 2: // 0000 0000 0100 0000
					data = 0x40;				
					break;

				case 3: // 0000 0000 1000 0000
					data = 0x80;
					break;

				default:
					data = 0x0;
			}
		}

		int spi_status = 0;
		int spi_group = 1;
		int spi_byte_length = 1;

		array<int> ^ spi_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_data_dir = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_data = gcnew array<int>(spi_byte_length);
		array<int> ^ spi_rd_biterror = gcnew array<int>(spi_byte_length);
		array<double> ^ delay_s_after_byte = gcnew array<double>(spi_byte_length);

		for (int i=0; i<spi_byte_length; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		spi_data[0]		= ((0x200 << 16) & 0xffff0000) | (data & 0xffff); //write (D7->D0 for GNDS, and then D7->D0 for GND)=16 bit data, then deassert NCS
		spi_data_dir[0] = 0x0000000; 

		ret = dm[UutOffsetIndex]->SPI_RUN("DM_1", spi_group, spi_data, spi_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		//Stopwatch swatch;

		//swatch.Reset();
		//swatch.Start();
		//swatch.Stop();

		//while (swatch.Elapsed.TotalSeconds < 0.1)
		//{
		//	swatch.Start();

		//	ret = dm[UutOffsetIndex]->SPI_STATUS("DM_1", spi_group, spi_status);
		//	CheckError(UutOffsetIndex, ret, __LINE__);

		//	if (spi_status == 2) //0=idle, 1=busy, 2=done
		//		break;

		//	swatch.Stop();
		//}

		ret = smu[UutOffsetIndex]->ConfigureSamplingTime("GND_MUX_SENSE", nplc, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->OnSmuPin("GND_MUX_SENSE", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);



		return ret;
	}
	int TestProgram::Configure_GNDS(int UutOffsetIndex)
	{
		int ret = 0;

		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;

		vih = 3.3;	vil = 0;	voh = 1;	 vol = 1;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
       
		ret = dm[UutOffsetIndex]->Force("GND_MUX_RST_N", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("GND_MUX_RST_N", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("GND_MUX_RST_N", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("GND_MUX_RST_N", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("GND_MUX_RST_N", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GND_MUX_RST_N");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->Force("GND_MUX_SCLK", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("GND_MUX_SCLK", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("GND_MUX_SCLK", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("GND_MUX_SCLK", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("GND_MUX_SCLK", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GND_MUX_SCLK");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->Force("GND_MUX_SYNC", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("GND_MUX_SYNC", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("GND_MUX_SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("GND_MUX_SYNC", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("GND_MUX_SYNC", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GND_MUX_SYNC");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->Force("GND_MUX_SDIN", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("GND_MUX_SDIN", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("GND_MUX_SDIN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("GND_MUX_SDIN", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("GND_MUX_SDIN", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GND_MUX_SDIN");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DrivePin("GND_MUX_RST_N", 1);
		CheckError(UutOffsetIndex, ret, __LINE__);

		int spi_group = 1;
		double spi_clk_freq = 100e3;
		int spi_clk_divider = (int)(100e6/spi_clk_freq - 1);
		int cpol = 0;
		int cpha = 1;

		ret = dm[UutOffsetIndex]->SPI_CHSEL("DM_1", spi_group, "GND_MUX_SCLK", "GND_MUX_SYNC", "GND_MUX_SDIN", "GND_MUX_SDIN");
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SPI_NCS_ACTIVE_STATE("DM_1", spi_group, DM_CONST_SPI_NCS_ACTIVE_LOW);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SPI_ConfigureInputDelay("DM_1", spi_group, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SPI_CONFIGURE("DM_1", spi_group, spi_clk_divider, cpol, cpha);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->ClampVoltage("GND_MUX_SENSE", 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("GND_MUX_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("GND_MUX_SENSE", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::find_target(int UutOffsetIndex, int target_range_dac, double lsb, int % target_dac, double % target_result, double Measure_Delay_s, int dac, int parameter,int DACmode)
	{
		int ret = 0;
		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr		= gcnew array<int>(37); 
		array<int>^ vec1_arr	= gcnew array<int>(37); 
		double result			= 0.0;

		int dat_bit			= 0;
		int direction		= 0;    // 0 -> stop; 1 -> up; -1 -> down
		int dac_sweep		= target_range_dac;
		double min_dev		= lsb;	
		int FOUND			= 0;				
		int mode			= 0;
		double target		= 0;
		double dev = 0.0;
		int counter = 0;
		
		double Gnds_val = 0.0;

		do
		{
			dat_bit = (dac_sweep << _glob->TrimReg[parameter,BIT]);// & 16);			
			if(!USE_SPI)
			{
				vec_arr = make_vector(0, _glob->TrimReg[parameter,PG], _glob->TrimReg[parameter,REG], dat_bit); // rw, pg, reg, dat
				ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			else
			{
				ret = WriteSPI(UutOffsetIndex, _glob->TrimReg[parameter,PG]-1, _glob->TrimReg[parameter,REG], dat_bit); // rw, pg, reg, dat
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			// measurement
			String ^ Test_Pin  = "MTX_SMU";
			
			ret = smu[UutOffsetIndex]->OnSmuPin(Test_Pin, false,false);
			CheckError(UutOffsetIndex, ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			switch (parameter)
			{
				case VREF:
					target = _glob->Vref_Target;
					mode = AM_CONST_DICV;
					break;
				case IABS:
					target = _glob->Iabs_Target;						
					mode = AM_CONST_DVCI;
					break;
				case ATEMP: 
					target = _glob->Atemp_Target;	
					mode = AM_CONST_DICV;
					break;
			}

			if(mode == AM_CONST_DVCI) // 1: 
			{
				ret = smu[UutOffsetIndex]->ReadCurrent(Test_Pin, result);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			else if(mode == AM_CONST_DICV)
			{
				ret = smu[UutOffsetIndex]->ReadVoltage("GND_MUX_SENSE", Gnds_val);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = smu[UutOffsetIndex]->ReadVoltage(Test_Pin, result);
				result = result - Gnds_val;
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		
			ret = smu[UutOffsetIndex]->OffSmuPin(Test_Pin);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			double RawResult = result;

			ProcessReading(UutOffsetIndex, parameter , result);
			
			// check for direction
			dev = abs(result - target);
			if (min_dev > dev )
			{
				target_dac = dac_sweep;
				min_dev = dev;
				if (parameter == ATEMP)
				{
					target_result = RawResult - TRIM_COMP;
				}
				else
				{
					target_result = result;
				}

			}
			// check target found
			if ((min_dev < lsb) || (counter > 32))
			{
				FOUND = 1;
			}
			// check for sweep direction
			if (!FOUND)
			{
				if ((result - target) > 0 )
				{
					direction = -1 * DACmode;
				}
				else
				{
					direction = 1 * DACmode;
				}
			dac_sweep = dac_sweep + direction;
			}
		
			//timeout
			if (counter > 32)
			{
				target_result = -999;			
				FOUND = 1;
			}	

			counter++;

		} while (!FOUND);
		target_dac = dac_sweep;

		return ret;
	}
	void TestProgram::ProcessReading(int UutOffsetIndex, int parameter, double % reading) 
	{	
		// roundoff to neareast int
		
		switch(parameter)
		{
		case VREF:
			reading = reading - TRIM_COMP - _glob->mux_offset[UutOffsetIndex];
			break;
		case IABS:
			reading = -reading;
			break;
		case ATEMP:
			reading = reading;
			double atemp_V  = reading - TRIM_COMP - _glob->mux_offset[UutOffsetIndex]; // Compensate value
			double atemp_offset = 131.7/182.5;
			double atemp_step = 1/182.5;
			double atemp_raw = (atemp_V - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
			reading = atemp_raw;
			break;
		}
	}
	array<int>^ TestProgram::make_vector(int rw, int page, int reg, int dat)
	{
		int ret = 0;
		int debug = 0;
		// vector mapping	
		int SPD	= 3; // pin 2
		int SPC	= 5; // pin 4
		int SPE	= 2; // pin 1
		int t0		= 0; // t0
		
		int bit_length = 0;
		int clk = 0;
		int coun = 0;
		int dac_en =0;
		int dum = 0;

		string  str_e;
		string  str_o;

		string str_lb;
	
		page--;

		// DM vector format
		string vec[5] = 
		{"000"	, "001"	, "010"	,"011"	, "100",};
		//    0		,   1		,	L		,	H		,	X 
		array<int>^ vec0_arr = gcnew array<int>(37);
		

		// convert databit 
		string dat_str = _util->dec2bin(dat, 8);
		
		int dat_bit[8];
		for (int i = 0; i < 8 ;i++)
		{
			dat_bit[7-i] = dat_str[i] - 48;
		}

		// convert regbit
		string reg_str = _util->dec2bin(reg, 5);
		
		int reg_bit[5];
		for (int i = 0; i < 5 ;i++)
		{
			reg_bit[4-i] = reg_str[i] - 48;
		}

		for (int c=-1; c < 6 ; c++)
		{
			switch(c)
			{
			case -1:
				bit_length = 1;
				dac_en = 0;
				dum = 1;
				str_lb = "--";
				break;				

			case 0: // rw
				bit_length = 1;
				dac_en = 3;
				dum = 0;
				str_lb = "rw";
				break;				
			
			case 1: // pg
				bit_length = 1;
				dac_en = 4;
				dum = 0;
				str_lb = "pg";
				break;				

			case 2 : // reg
				bit_length = 5;
				dac_en = 2;
				dum = 0;
				str_lb = "reg";
				break;				
		
			case 3: // t
				bit_length = 1;
				dac_en = 0;
				dum = 0;
				str_lb = "t";
				break;				

			case 4: // data
				bit_length = 8;
				dac_en = 1;
				str_lb = "data";
				dum = 0;
				break;	
			
			case 5:
				bit_length = 1;
				dac_en = 0;
				str_lb = "--";
				dum = 1;
				break;			

			}

			for (int j =0; j < bit_length; j++)
			{
				for (int i = 0; i < 7; i++)
				{
					if (i == SPE)				
					{
						if(!dum)
						{
							str_e =  vec[1] + str_e;
							str_o =  vec[1] + str_o;
						}else{
							str_e =  vec[0] + str_e;
							str_o =  vec[0] + str_o;
						}
					}
					else if(i == SPD)
					{
						if(dac_en == 1) // databit
						{
							str_e =   vec[dat_bit[j]] + str_e;
							str_o =   vec[dat_bit[j]] + str_o;
						}
						else if (dac_en == 2) // regbit
						{
							str_e =   vec[reg_bit[j]] + str_e;
							str_o =   vec[reg_bit[j]] + str_o;
						}
						else if (dac_en == 3) // rw
						{
							str_e =   vec[rw] + str_e ;
							str_o =   vec[rw] + str_o ;
						}else if (dac_en == 4) // pg
						{
							str_e =   vec[page] + str_e ;
							str_o =   vec[page] + str_o ;
						}else{
							str_e =   vec[0] + str_e ;
							str_o =   vec[0] + str_o ;
						}
					}
					else if(i == SPC)
					{
						if(!dum)
						{
							str_e =  vec[0] + str_e;
							str_o =  vec[1] + str_o;
						}else{
							str_e =  vec[0] + str_e;
							str_o =  vec[0] + str_o;
						}
					}
					else if(i == t0)
					{
						str_e = "0" + str_e ; //0 , 0
						str_o = "0" + str_o ;
					}
					else
					{
						str_e = vec[4] +str_e  ; // X , 4
						str_o = vec[4] +str_o  ; 
					}
				}
			
				int value_e = std::bitset<19>(str_e).to_ulong();
  				int value_o = std::bitset<19>(str_o).to_ulong();
				


				vec0_arr[coun] = value_e;
				vec0_arr[coun+1] = value_o;
				
				coun = coun + 2;
				str_e = "";
				str_o ="";
			}
			
		}

		return vec0_arr ;
	}
	int TestProgram::RunVectorFile(int UutOffsetIndex, String ^ Vector_str)
	{
		// Run vector from vector file
		int ret =0;

		Stopwatch swatch;
		int vector_engine_status = 0;
		double Vector_Timeout_s = 0.1;

	//EW: Checking whether SPI is enabled previously. Need to off. Ensuring RunVector is in right mode
	if(SPI_started[UutOffsetIndex]) {
		ret = OnOffSPI(UutOffsetIndex,0);
		SPI_started[UutOffsetIndex] = 0;
	} 

		if (VectorSetNo->ContainsKey(Vector_str))
		{
			ret = dm[UutOffsetIndex]->RunVector("DM_2", VectorSetNo[Vector_str]);
			//CheckError(UutOffsetIndex, ret, __LINE__);
		}

		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
		{
			swatch.Start();

			ret = dm[UutOffsetIndex]->AcquireVecEngineStatus("DM_2", vector_engine_status);
			CheckError(UutOffsetIndex, ret, __LINE__);

			if (vector_engine_status == 0)
				break;

			swatch.Stop();
		}

		if (vector_engine_status != 0)
		{
		//	throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": Vector engine timeout @ " + Vector_str + " (line#" + __LINE__ + ")", ER_TIMEOUT);
			_util->SampleRes("VET", "1\n");
		}

		return ret;
	
	}
	int TestProgram::RunVectorArray(int UutOffsetIndex, int Vector_set_no)
	{
		// Run vector Array
		int ret = 0;

		Stopwatch swatch;
		int vector_engine_status = 0;
		double Vector_Timeout_s = 0.1;

	//EW: Checking whether SPI is enabled previously. Need to off. Ensuring RunVector is in right mode
	if(SPI_started[UutOffsetIndex]) {
		ret = OnOffSPI(UutOffsetIndex,0);
		SPI_started[UutOffsetIndex] = 0;
	} 

		ret = dm[UutOffsetIndex]->RunVector("DM_2", Vector_set_no);
		//CheckError(UutOffsetIndex, ret, __LINE__);

		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
		{
			swatch.Start();

			ret = dm[UutOffsetIndex]->AcquireVecEngineStatus("DM_2", vector_engine_status);
			CheckError(UutOffsetIndex, ret, __LINE__);

			if (vector_engine_status == 0)
				break;

			swatch.Stop();
		}

		if (vector_engine_status != 0)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
		}

		return ret;
	
	}
	int TestProgram::CorrectDac(int % dac, int fuse_count)
	{
		// correct neg dac to pos dac// 2's comp 
		int ret = 0 ;
		double converted_dac = 0;
		
		if (dac < 0)
		{
			converted_dac = pow (2.0, fuse_count) + dac;							
			dac = (int)converted_dac;
		}

		return ret;
	}
	int TestProgram::ReadVector(int UutOffsetIndex, String ^ Vector_str, int % data)
	{
		int ret = 0; 
		int result_adc = 0;
		int vector_engine_status = 0;
		double Vector_Timeout_s = 0.3;

		array<int>^ HistoryRam = gcnew array<int>(256);

		Stopwatch swatch;

	//EW: Checking whether SPI is enabled previously. Need to off. Ensuring RunVector is in right mode
	if(SPI_started[UutOffsetIndex]) {
		ret = OnOffSPI(UutOffsetIndex,0);
		SPI_started[UutOffsetIndex] = 0;
	} 

		if (VectorSetNo->ContainsKey(Vector_str))
		{
			ret = dm[UutOffsetIndex]->RunVector("DM_2", VectorSetNo[Vector_str]);
			//CheckError(UutOffsetIndex, ret, __LINE__);
		}
		
		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
		{
			swatch.Start();

			ret = dm[UutOffsetIndex]->AcquireVecEngineStatus("DM_2", vector_engine_status);
			CheckError(UutOffsetIndex, ret, __LINE__);

			if (vector_engine_status == 0)
				break;

			swatch.Stop();
		}
				
		if (vector_engine_status == 0)
		{
			ret = dm[UutOffsetIndex]->ReadHistoryRam("DM_2", VectorLineCount[Vector_str], 0, VectorSetNo[Vector_str], HistoryRam);
			CheckError(UutOffsetIndex, ret, __LINE__);
	
			ret = GetDataByteFromHistoryRam(Vector_str, HistoryRam, data, _glob->SPD_Channel_Number);
			CheckError(UutOffsetIndex, ret, __LINE__);

			result_adc = data ;
		}
		else
		{
			throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": Vector engine timeout @ " + Vector_str + " (line#" + __LINE__ + ")", ER_TIMEOUT);
			//result_adc = -999;
		}

		return ret;
	}
	int TestProgram::blow_fuse(int UutOffsetIndex, int parameter, int fuse_bit)
	{
		int ret			= 0;			
		int dat_bit		= 0;
		int vector_enginSbeee_status = 0;
		int bitCount = 0;

		double Vector_Timeout_s = 0.1;
		Stopwatch swatch;

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); 
		String ^ Vector_File = "";

		if(!USE_SPI)
		{
			ret = RunVectorFile(UutOffsetIndex, "write_set_ext_reg");
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			//ret = OnOffSPI(UutOffsetIndex, 1);
			//CheckError(UutOffsetIndex, ret, __LINE__);
			ret = RunSPI(UutOffsetIndex, "write_set_ext_reg");
			CheckError(UutOffsetIndex, ret, __LINE__);
		}	
		
		int fuse_mask = 1;
		fuse_mask = fuse_mask << _glob->TrimReg[parameter, BIT];
		fuse_bit = fuse_bit << _glob->TrimReg[parameter, BIT];

		for (int i = 0; i < _glob->TrimReg[parameter, FUSE]; i++)  // blow fuse bit one by one
		{
			dat_bit = (fuse_bit & fuse_mask) ;
			if (dat_bit != 0)
			{
				{
					// set fuse bit to be blown
					if(!USE_SPI)
					{
						vec_arr = make_vector(0, _glob->TrimReg[parameter, PG], _glob->TrimReg[parameter, REG], dat_bit); // rw, pg, reg, dat
						ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
					else
					{
						ret = WriteSPI(UutOffsetIndex, _glob->TrimReg[parameter, PG]-1, _glob->TrimReg[parameter, REG], dat_bit);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			
				if(Blow_Fuse)	//blowfusecmd execution
				{		
					if(!USE_SPI)
					{
						ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_on");
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(1e-6);
						ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_off");
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
					else
					{
						ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_on");
						CheckError(UutOffsetIndex, ret, __LINE__);
						
						_util->Wait_Sec(1e-6);

						ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_off");
						CheckError(UutOffsetIndex, ret, __LINE__);
					}				
				}
			}
			
			fuse_mask = fuse_mask << 1;
		}
		
		// clear fuse bit after blown
		dat_bit = 0 ;
		if(!USE_SPI)
		{
			vec_arr = make_vector(0, _glob->TrimReg[parameter, PG], _glob->TrimReg[parameter, REG], dat_bit); // rw, pg, reg, dat
			ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0,_glob-> VectorArrSetNo, 36, vec_arr, vec_arr);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			ret = WriteSPI(UutOffsetIndex, _glob->TrimReg[parameter, PG]-1, _glob->TrimReg[parameter, REG], dat_bit);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		return ret;
	}
	int TestProgram::blow_fuse_WHD(int UutOffsetIndex, int HD, int fuse_bit)
	{
		int ret			= 0;			
		int dat_bit		= 0;
		int bitCount = 0;

		double Vector_Timeout_s = 0.1;
		Stopwatch swatch;

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); 
		String ^ Vector_File = "";
		
		if(!USE_SPI)
		{
			RunVectorFile(UutOffsetIndex, "write_set_ext_reg");
		}else{
			RunSPI(UutOffsetIndex, "write_set_ext_reg");
		}

		int fuse_mask = 1;
		fuse_mask = fuse_mask << _glob->TrimRegWHD[HD, BIT];
		fuse_bit = fuse_bit << _glob->TrimRegWHD[HD, BIT];

		for (int i = 0; i < _glob->TrimRegWHD[HD, FUSE]; i++)  // blow fuse bit one by one
		{
			dat_bit = (fuse_bit & fuse_mask) ;


			if (dat_bit != 0)
			{
				{
					// set fuse bit to be blown
					if(!USE_SPI)
					{
						vec_arr = make_vector( 0, _glob->TrimRegWHD[HD, PG], _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
						ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
					else
					{
						ret = WriteSPI(UutOffsetIndex, _glob->TrimRegWHD[HD, PG]-1, _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}

				if(1)	//blowfusecmd execution
				{		
					if(!USE_SPI)
					{
						ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_on");
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(1e-6);
						ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_off");
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
					else
					{
						ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_on");
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(1e-6);
						ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_off");
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			}
			
			fuse_mask = fuse_mask << 1;
		}
		
		// clear fuse bit after blown
		dat_bit = 0 ;
		if(!USE_SPI)
		{
			vec_arr = make_vector(0, _glob->TrimRegWHD[HD, PG], _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
			ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			ret = WriteSPI(UutOffsetIndex, _glob->TrimRegWHD[HD, PG]-1, _glob->TrimRegWHD[HD, REG], dat_bit); // rw, pg, reg, dat
			CheckError(UutOffsetIndex, ret, __LINE__);
		}


		return ret;
	}
	int TestProgram::blow_fuse_RHD(int UutOffsetIndex, int HD, int fuse_bit)
	{
		int ret			= 0;			
		int dat_bit		= 0;
		int bitCount = 0;

		double Vector_Timeout_s = 0.1;
		Stopwatch swatch;

		// create vector array on the fly for to sweep trim fuse setting
		array<int>^ vec_arr = gcnew array<int>(37); 
		String ^ Vector_File = "";

		if(!USE_SPI)
		{
			RunVectorFile(UutOffsetIndex, "write_set_ext_reg");
		}else{
			RunSPI(UutOffsetIndex, "write_set_ext_reg");
		}

		int fuse_mask = 1;
		fuse_mask = fuse_mask << _glob->TrimRegRHD[HD, BIT];
		fuse_bit = fuse_bit << _glob->TrimRegRHD[HD, BIT];

		for (int i = 0; i < _glob->TrimRegRHD[HD, FUSE]; i++)  // blow fuse bit one by one
		{
			
			dat_bit = (fuse_bit & fuse_mask);
			if (dat_bit != 0)
			{
				{
					if(!USE_SPI)
					{
						// set fuse bit to be blown
						vec_arr = make_vector( 0, _glob->TrimRegRHD[HD, PG], _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
						ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
					else
					{
						ret = WriteSPI(UutOffsetIndex, _glob->TrimRegRHD[HD, PG]-1, _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			
				if(Blow_Fuse)	//blowfusecmd execution
				{			
					if(!USE_SPI)
					{
						ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_on");
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(1e-6);
						ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_off");
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
					else
					{
						ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_on");
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(1e-6);
						ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_off");
						CheckError(UutOffsetIndex, ret, __LINE__);
					}
				}
			}
			
			fuse_mask = fuse_mask << 1;
		}
		
		// clear fuse bit after blown
		dat_bit = 0 ;
		if(!USE_SPI)
		{
			vec_arr = make_vector(0, _glob->TrimRegRHD[HD, PG], _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
			ret = dm[UutOffsetIndex]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec_arr);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = RunVectorArray(UutOffsetIndex, _glob->VectorArrSetNo);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			ret = WriteSPI(UutOffsetIndex, _glob->TrimRegRHD[HD, PG]-1, _glob->TrimRegRHD[HD, REG], dat_bit); // rw, pg, reg, dat
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		return ret;
	}
	int TestProgram::SPI_Configure(int UutOffsetIndex, int spiGroup, double clk_freq, String ^ clk, String ^ ncs, String ^ mosi, String ^ miso, double input_delay)
	{
		int ret = 0;

		int spi_clk_divider = (int)(100e6/clk_freq - 1);
		int cpol = 0;
		int cpha = 0;

//EW: code to check whether SPI mode is already enabled. Mainly referring to SPI_started[UutOffsetIndex] flag. if not enabled then turned run ONOFFSPI
if(!SPI_started[UutOffsetIndex]) {
	ret = OnOffSPI(UutOffsetIndex, 1);
}	

		ret = dm[UutOffsetIndex]->SPI_CHSEL("DM_2", spiGroup, clk, ncs, mosi, miso);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->SPI_NCS_ACTIVE_STATE("DM_2", spiGroup, DM_CONST_SPI_NCS_ACTIVE_HIGH);
		CheckError(UutOffsetIndex, ret, __LINE__);
	
		if (input_delay == 0)
		{
			ret = dm[UutOffsetIndex]->SPI_ConfigureInputDelay("DM_2", spiGroup, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if (input_delay < 5e-9)
		{
			ret = dm[UutOffsetIndex]->SPI_ConfigureInputDelay("DM_2", spiGroup, 1);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			ret = dm[UutOffsetIndex]->SPI_ConfigureInputDelay("DM_2", spiGroup, 2);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		ret = dm[UutOffsetIndex]->SPI_CONFIGURE("DM_2", spiGroup, spi_clk_divider, cpol, cpha);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::SPI(int UutOffsetIndex, int spiGroup, array<int> ^ spi_data_array, int spi_array_length, array<double> ^ delay_s_after_byte, int bit_width, array<int> ^ spi_data_direction, int % spiStatus)
	{
		int ret = 0;

		Stopwatch swatch;
		spiStatus = 0;
		double Vector_Timeout_s = 0.1;

//EW: code to check whether SPI mode is already enabled. Mainly referring to SPI_started[UutOffsetIndex] flag. if not enabled then turned run ONOFFSPI
if(!SPI_started[UutOffsetIndex]) {
	ret = OnOffSPI(UutOffsetIndex, 1);
}

		ret = dm[UutOffsetIndex]->SPI_RUN("DM_2", spiGroup, spi_data_array, spi_array_length, delay_s_after_byte, bit_width, spi_data_direction);
		CheckError(UutOffsetIndex, ret, __LINE__);
		SPI_started[UutOffsetIndex] = 1;
	
		if (_glob->spi_clk_freq < 8e6)
		{
			swatch.Reset();
			swatch.Start();
			swatch.Stop();

			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
			{
				swatch.Start();

				ret = dm[UutOffsetIndex]->SPI_STATUS("DM_2", spiGroup, spiStatus);
				CheckError(UutOffsetIndex, ret, __LINE__);

				if (spiStatus == 2) //0=idle, 1=busy, 2=done
					break;

				swatch.Stop();
			}
		}

		return ret;
	}
	int TestProgram::Digitizer_Configure(int UutOffsetIndex, array<double> ^ data)
	{
		int ret = 0;
	
		//data:
		//[0] = sampInterval
		//[1] = delayTime
		//[2] = nbrSamples
		//[3] = nbrSegments
		//[4] = coupling
		//[5] = bandwidth
		//[6] = fullScale
		//[7] = offset
		//[8] = trigClass
		//[9] = sourcePattern
		//[10] = trigCoupling
		//[11] = trigSlope
		//[12] = trigLevel
		//[13] = timeOut_ms

		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval	= data[0];
		double delayTime	= data[1];
		int nbrSamples		= (int)data[2]; 
		int nbrSegments		= (int)data[3];
		double fullScale	= data[4]; //1V or 2V
		double offset		= data[5];	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		int coupling		= (int)data[6];	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth		= (int)data[7];	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		long trigClass		= (int)data[8];		//0 edge trigger 
		long sourcePattern	= (int)data[9];//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2
		int trigCoupling	= (int)data[10];
		int trigSlope		= (int)data[11];
		double trigLevel	= data[12];
		int timeOut_ms		= (int)data[13];
		int Decimation_Factor = (int)data[14];

		ret = digitizer[UutOffsetIndex]->StopAcquire("DIGITIZER");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::Digitizer_CaptureVpp(int UutOffsetIndex, array<double> ^ data, double diff2se_digitizer_factor, double % vpp, array<double> ^ rawData)
	{
		int ret = 0;

		vpp = 0;

		double sampInterval	= data[0];
		int nbrSamples		= (int)data[2];
		int timeOut_ms		= (int)data[13];
		int Decimation_Factor = (int)data[14];

		//double diff2se_digitizer_factor = 1;	//mask by bk

		//if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
		//	diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][UutOffsetIndex];

		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
		//dataArrayP = gcnew array<double>(nbrSamples);


		ret = digitizer[UutOffsetIndex]->StartAcquire("DIGITIZER");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ForceTrigger("DIGITIZER");
		if (ret == -1074116410) //ERROR: Instrument already stopped
			ret = 0;
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
		if (ret == -1074116410) //ERROR: Instrument already stopped
			ret = 0;
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", dataArrayP); 
		CheckError(UutOffsetIndex, ret, __LINE__);

		vpp = _fft->GetVpp(dataArrayP, sampInterval, NONE, false);

		vpp = vpp * diff2se_digitizer_factor;
		for (int i = 0; i < nbrSamples; i++) 
		{
			rawData[i] = dataArrayP[i];
		}


		return ret;
	}
	int TestProgram::DigitizerFFT_Configure(int UutOffsetIndex, array<double> ^ data)
	{
		int ret = 0;
	
		//data:
		//[0] = sampInterval
		//[1] = delayTime
		//[2] = nbrSamples
		//[3] = nbrSegments
		//[4] = coupling
		//[5] = bandwidth
		//[6] = fullScale
		//[7] = offset
		//[8] = trigClass
		//[9] = sourcePattern
		//[10] = trigCoupling
		//[11] = trigSlope
		//[12] = trigLevel
		//[13] = timeOut_ms

		int mode = 0;	//0 = normal data acquisition (digitizer)
						//2 = averaging mode (it makes the instrument run as a real-time averager)
		int flag = 0;	//0 = normal
						//1 = ‘Start on Trigger’ mode
		double sampInterval	= data[0];
		double delayTime	= data[1];
		int nbrSamples		= (int)data[2]; 
		int nbrSegments		= (int)data[3];
		double fullScale	= data[4]; //1V or 2V
		double offset		= data[5];	//1V range: ±2 V (max signal = ±3.6 V)
								//2V range: ±4 V (max signal = ±6.3 V)
		int coupling		= (int)data[6];	//0 Ground (Averagers ONLY)
							//1 DC, 1 M-ohm
							//2 AC, 1 M-ohm
							//3 DC, 50 M-ohm
							//4 AC, 50 M-ohm
		int bandwidth		= (int)data[7];	//0 no bandwidth limit (default)
							//1 bandwidth limit at 25 MHz
							//2 bandwidth limit at 700 MHz
							//3 bandwidth limit at 200 MHz
							//4 bandwidth limit at 20 MHz
							//5 bandwidth limit at 35 MHz
		long trigClass		= (int)data[8];		//0 edge trigger 
		long sourcePattern	= (int)data[9];//0x000n0001 for Channel 1
										//0x000n0002 for Channel 2
		int trigCoupling	= (int)data[10];
		int trigSlope		= (int)data[11];
		double trigLevel	= data[12];
		int timeOut_ms		= (int)data[13];
		int Decimation_Factor = (int)data[14];

		ret = digitizer[UutOffsetIndex]->StopAcquire("DIGITIZER");
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureOperationMode("DIGITIZER", 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
		ret = digitizer[UutOffsetIndex]->StopAcquire("DIGITIZER");
		
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::DigitizerFFT_CaptureVpp(int UutOffsetIndex, array<double> ^ data, double diff2se_digitizer_factor, double % vpp)
	{
		int ret = 0;

		vpp = 0;

		double sampInterval	= data[0];
		int nbrSamples		= (int)data[2];
		int timeOut_ms		= (int)data[13];
		//double fullScale	= data[6];
		double fullScale	= data[4];
		int Decimation_Factor = (int)data[14];

		double RawSamplingRate = 1000000000; //1 / sampInterval;

		int RDY = 0;

		int FFTLength = 0xA; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details

		if (nbrSamples == 128) {FFTLength = 0x7;}
		else if (nbrSamples == 256) {FFTLength = 0x8;}
		else if (nbrSamples == 512) {FFTLength = 0x9;}
		else if (nbrSamples == 1024) {FFTLength = 0xA;}
		else if (nbrSamples == 2048) {FFTLength = 0xB;}
		else if (nbrSamples == 4096) {FFTLength = 0xC;}
		else if (nbrSamples == 8192) {FFTLength = 0xD;}
		else if (nbrSamples == 16384) {FFTLength = 0xE;}
		else
			return ER_INVALID_SETTING;

		int FFTnbrSamples = 0;
		if(FFTLength == 0x7) { FFTnbrSamples = 128; }
		if(FFTLength == 0x8) { FFTnbrSamples = 256; }
		if(FFTLength == 0x9) { FFTnbrSamples = 512; }
		if(FFTLength == 0xA) { FFTnbrSamples = 1024; }
		if(FFTLength == 0xB) { FFTnbrSamples = 2048; }
		if(FFTLength == 0xC) { FFTnbrSamples = 4096; }
		if(FFTLength == 0xD) { FFTnbrSamples = 8192; }
		if(FFTLength == 0xE) { FFTnbrSamples = 16384; }

		int Decimation = 0x0; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details
		int DecimationFactor = 1;

		if (Decimation_Factor == 1) {Decimation = 0x0;}
		else if (Decimation_Factor == 2) {Decimation = 0x1;}
		else if (Decimation_Factor == 4) {Decimation = 0x2;}
		else if (Decimation_Factor == 8) {Decimation = 0x3;}
		else if (Decimation_Factor == 16) {Decimation = 0x4;}
		else
			return ER_INVALID_SETTING;

		if( Decimation == 0x0 ) { DecimationFactor = 1; }
		if( Decimation == 0x1 ) { DecimationFactor = 2; }
		if( Decimation == 0x2 ) { DecimationFactor = 4; }
		if( Decimation == 0x3 ) { DecimationFactor = 8; }
		if( Decimation == 0x4 ) { DecimationFactor = 16; }

		double FFTSamplingRate = RawSamplingRate / double(DecimationFactor);
		double FFTBinValue = FFTSamplingRate / FFTnbrSamples;
		double NyquistFreq = FFTSamplingRate / 2.0;

		int Accumulation = 0x0; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		//int Accumulation = 0x5; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		int AccumulationNbr = Accumulation+1;

		int FFTStart     = 0x1; // To start FFT
		int FFTStop      = 0x2; // To Stop FFT
		int FFTStopped   = 0x0; // To check FFT stopped

		int FFTConfigure = FFTLength * 256 + Accumulation * 16 + Decimation; // "shift bits to the corresponding position
		int ReadConfig = 0x0; // to read config register
		int MaxPeakPos = 0x0; // to handle read maxpos result 

		double PeakPosA = 0;

		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", 320, FFTStop, 0); //init start/stop
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", 321, FFTConfigure, 0); //configure
		CheckError(UutOffsetIndex, ret, __LINE__);

		//ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", 321, ReadConfig); //configure
		//CheckError(UutOffsetIndex, ret, __LINE__);

		int Write0 = 0;
		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", 320, Write0, 0); //reset start bit
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", 320, FFTStart, 0); //start
		CheckError(UutOffsetIndex, ret, __LINE__);

		Stopwatch swatch;
		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		double TimeOut_s = 0.1;

		while (swatch.Elapsed.TotalSeconds < TimeOut_s)
		{
			swatch.Start();

			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", 322, MaxPeakPos); //check end of measure & read max peak position
			CheckError(UutOffsetIndex, ret, __LINE__);
			RDY = MaxPeakPos & 0x80000000;

			if (RDY == 0x80000000)
				break;

			swatch.Stop();
		}

		if (RDY == 0x80000000)
		{
			#ifndef DIGITIZER_795
			PeakPosA = (double(double(MaxPeakPos & 0x00FFFFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			#else
			PeakPosA = (double(double(MaxPeakPos & 0x0000FFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			#endif
		
			int BiggestNbrSample = FFTnbrSamples;
			int rdStartAddr = 0x0;

			if (Debug_Enable == true)
			{
				ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", 324, rdStartAddr, 0);
				CheckError(UutOffsetIndex, ret, __LINE__);

				array<int> ^ rddata = gcnew array<int>(BiggestNbrSample);
				for(int i = 0; i < BiggestNbrSample; i++)
				{
					ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", 323, rddata[i]);
					CheckError(UutOffsetIndex, ret, __LINE__);
					
					//ofstream outFile("C:\\Aemulus\\Debug\\rawdata_fast.txt");
					//for (int i = 0; i < nbrSamples; i++) 
					//{
					//	outFile << rddata[i] << endl;
					//}
					//outFile.close();
				}
			}

			rdStartAddr = (int)(PeakPosA / FFTBinValue);
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", 324, rdStartAddr, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			int readdata = 0;
			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", 323, readdata);
			CheckError(UutOffsetIndex, ret, __LINE__);

			double FS = 0;
			if (BiggestNbrSample == 1024 || BiggestNbrSample == 4096 || BiggestNbrSample == 16384)
				FS = 16383;
			else
				FS = 32767;

			vpp = (double)readdata * (1/FS) * fullScale / AccumulationNbr;

			vpp = vpp * diff2se_digitizer_factor;
		}
		else
		{
			vpp = 999;
		}

		return ret;
	}
	//int TestProgram::DigitizerFFT_CaptureVpp(int UutOffsetIndex, int ch, array<double> ^ data, double diff2se_digitizer_factor, double % vpp)
	//{
	//	int ret = 0;

	//	vpp = 0;

	//	double sampInterval	= data[0];
	//	int nbrSamples		= (int)data[2];
	//	int timeOut_ms		= (int)data[13];
	//	//double fullScale	= data[6];
	//	double fullScale	= data[4];
	//	int Decimation_Factor = (int)data[14];

	//	double RawSamplingRate = 1000000000; //1 / sampInterval;

	//	int RDY = 0;

	//	int FFTLength = 0xA; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details

	//	if (nbrSamples == 128) {FFTLength = 0x7;}
	//	else if (nbrSamples == 256) {FFTLength = 0x8;}
	//	else if (nbrSamples == 512) {FFTLength = 0x9;}
	//	else if (nbrSamples == 1024) {FFTLength = 0xA;}
	//	else if (nbrSamples == 2048) {FFTLength = 0xB;}
	//	else if (nbrSamples == 4096) {FFTLength = 0xC;}
	//	else if (nbrSamples == 8192) {FFTLength = 0xD;}
	//	else if (nbrSamples == 16384) {FFTLength = 0xE;}
	//	else
	//		return ER_INVALID_SETTING;

	//	int FFTnbrSamples = 0;
	//	if(FFTLength == 0x7) { FFTnbrSamples = 128; }
	//	if(FFTLength == 0x8) { FFTnbrSamples = 256; }
	//	if(FFTLength == 0x9) { FFTnbrSamples = 512; }
	//	if(FFTLength == 0xA) { FFTnbrSamples = 1024; }
	//	if(FFTLength == 0xB) { FFTnbrSamples = 2048; }
	//	if(FFTLength == 0xC) { FFTnbrSamples = 4096; }
	//	if(FFTLength == 0xD) { FFTnbrSamples = 8192; }
	//	if(FFTLength == 0xE) { FFTnbrSamples = 16384; }

	//	int Decimation = 0x0; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details
	//	int DecimationFactor = 1;

	//	if (Decimation_Factor == 1) {Decimation = 0x0;}
	//	else if (Decimation_Factor == 2) {Decimation = 0x1;}
	//	else if (Decimation_Factor == 4) {Decimation = 0x2;}
	//	else if (Decimation_Factor == 8) {Decimation = 0x3;}
	//	else if (Decimation_Factor == 16) {Decimation = 0x4;}
	//	else if (Decimation_Factor == 32) {Decimation = 0x5;}
	//	else if (Decimation_Factor == 64) {Decimation = 0x6;}
	//	else
	//		return ER_INVALID_SETTING;

	//	if( Decimation == 0x0 ) { DecimationFactor = 1; }
	//	if( Decimation == 0x1 ) { DecimationFactor = 2; }
	//	if( Decimation == 0x2 ) { DecimationFactor = 4; }
	//	if( Decimation == 0x3 ) { DecimationFactor = 8; }
	//	if( Decimation == 0x4 ) { DecimationFactor = 16; }
	//	if( Decimation == 0x5 ) { DecimationFactor = 32; }
	//	if( Decimation == 0x6 ) { DecimationFactor = 64; }

	//	double FFTSamplingRate = RawSamplingRate / double(DecimationFactor);
	//	double FFTBinValue = FFTSamplingRate / FFTnbrSamples;
	//	double NyquistFreq = FFTSamplingRate / 2.0;

	//	int Accumulation = 0x0; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
	//	//int Accumulation = 0x5; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
	//	int AccumulationNbr = Accumulation+1;

	//	int FFTStart     = 0x1; // To start FFT
	//	int FFTStop      = 0x2; // To Stop FFT
	//	int FFTStopped   = 0x0; // To check FFT stopped

	//	int FFTConfigure = FFTLength * 256 + Accumulation * 16 + Decimation; // "shift bits to the corresponding position
	//	int ReadConfig = 0x0; // to read config register
	//	int MaxPeakPos = 0x0; // to handle read maxpos result 

	//	double PeakPosA = 0;
	//	
	//	if (ch == 1)
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
	//	else
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
	//	CheckError(UutOffsetIndex, ret, __LINE__);

	//	if (ch == 1)
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONFIGURATION1, FFTConfigure, 0); //configure
	//	else
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONFIGURATION1, FFTConfigure, 0); //configure
	//	CheckError(UutOffsetIndex, ret, __LINE__);

	//	//if (ch == 1)
	//	//	ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", CH1_CONFIGURATION1, ReadConfig); //configure
	//	//else
	//	//	ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", CH2_CONFIGURATION1, ReadConfig); //configure
	//	//CheckError(UutOffsetIndex, ret, __LINE__);

	//	int Write0 = 0;
	//	if (ch == 1)
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, Write0, 0); //reset start bit
	//	else
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, Write0, 0); //reset start bit
	//	CheckError(UutOffsetIndex, ret, __LINE__);

	//	if (ch == 1)
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStart, 0); //start
	//	else
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStart, 0); //start
	//	CheckError(UutOffsetIndex, ret, __LINE__);

	//	Stopwatch swatch;
	//	swatch.Reset();
	//	swatch.Start();
	//	swatch.Stop();

	//	double TimeOut_s = 0.1;

	//	while (swatch.Elapsed.TotalSeconds < TimeOut_s)
	//	{
	//		swatch.Start();

	//		if (ch == 1)
	//			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_STATUS, MaxPeakPos); //check end of measure & read max peak position
	//		else
	//			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_STATUS, MaxPeakPos); //check end of measure & read max peak position
	//		CheckError(UutOffsetIndex, ret, __LINE__);
	//		RDY = MaxPeakPos & 0x80000000;

	//		if (RDY == 0x80000000)
	//			break;

	//		swatch.Stop();
	//	}

	//	if (RDY == 0x80000000)
	//	{
	//		#ifndef DIGITIZER_795
	//		PeakPosA = (double(double(MaxPeakPos & 0x00FFFFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
	//		#else
	//		PeakPosA = (double(double(MaxPeakPos & 0x0000FFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
	//		#endif
	//	
	//		int BiggestNbrSample = FFTnbrSamples;
	//		int rdStartAddr = 0x0;

	//		if (Debug_Enable == true)
	//		{
	//			if (ch == 1)
	//				ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr, 0);
	//			else
	//				ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr, 0);
	//			CheckError(UutOffsetIndex, ret, __LINE__);

	//			array<int> ^ rddata = gcnew array<int>(BiggestNbrSample);
	//			for(int i = 0; i < BiggestNbrSample; i++)
	//			{
	//				if (ch == 1)
	//					ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, rddata[i]);
	//				else
	//					ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, rddata[i]);
	//				CheckError(UutOffsetIndex, ret, __LINE__);
	//				
	//				ofstream outFile("C:\\Aemulus\\Debug\\rawdata_fast.txt");
	//				for (int i = 0; i < nbrSamples; i++) 
	//				{
	//					outFile << rddata[i] << endl;
	//				}
	//				outFile.close();
	//			}
	//		}

	//		rdStartAddr = (int)(PeakPosA / FFTBinValue);
	//		if (ch == 1)
	//			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr, 0);
	//		else
	//			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr, 0);
	//		CheckError(UutOffsetIndex, ret, __LINE__);

	//		int readdata = 0;
	//		if (ch == 1)
	//			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, readdata);
	//		else
	//			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, readdata);
	//		CheckError(UutOffsetIndex, ret, __LINE__);

	//		double FS = 0;
	//		if (BiggestNbrSample == 1024 || BiggestNbrSample == 4096 || BiggestNbrSample == 16384)
	//			FS = 16383;
	//		else
	//			FS = 32767;

	//		vpp = (double)readdata * (1/FS) * fullScale / AccumulationNbr;

	//		vpp = vpp * diff2se_digitizer_factor;
	//	}
	//	else
	//	{
	//		vpp = 999;
	//	}

	//	return ret;
	//}
	int TestProgram::DigitizerFFT_CaptureVpp(int UutOffsetIndex, int ch, array<double> ^ data, double diff2se_digitizer_factor, double % vpp)
	{
		int ret = 0;
		
		vpp = 0;

		double sampInterval	= data[0];
		int nbrSamples		= (int)data[2];
		int timeOut_ms		= (int)data[13];
		//double fullScale	= data[6];
		double fullScale	= data[4];
		int Decimation_Factor = (int)data[14];

		double RawSamplingRate = 1000000000; //1 / sampInterval;

		int RDY = 0;

		int FFTLength = 0xA; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details

		if (nbrSamples == 128) {FFTLength = 0x7;}
		else if (nbrSamples == 256) {FFTLength = 0x8;}
		else if (nbrSamples == 512) {FFTLength = 0x9;}
		else if (nbrSamples == 1024) {FFTLength = 0xA;}
		else if (nbrSamples == 2048) {FFTLength = 0xB;}
		else if (nbrSamples == 4096) {FFTLength = 0xC;}
		else if (nbrSamples == 8192) {FFTLength = 0xD;}
		else if (nbrSamples == 16384) {FFTLength = 0xE;}
		else
			return ER_INVALID_SETTING;

		int FFTnbrSamples = 0;
		if(FFTLength == 0x7) { FFTnbrSamples = 128; }
		if(FFTLength == 0x8) { FFTnbrSamples = 256; }
		if(FFTLength == 0x9) { FFTnbrSamples = 512; }
		if(FFTLength == 0xA) { FFTnbrSamples = 1024; }
		if(FFTLength == 0xB) { FFTnbrSamples = 2048; }
		if(FFTLength == 0xC) { FFTnbrSamples = 4096; }
		if(FFTLength == 0xD) { FFTnbrSamples = 8192; }
		if(FFTLength == 0xE) { FFTnbrSamples = 16384; }

		int Decimation = 0x0; // FFTLength, Valid value 0x7 to 0xE -> 128 to 16384 points, see below for more details
		int DecimationFactor = 1;

		if (Decimation_Factor == 1) {Decimation = 0x0;}
		else if (Decimation_Factor == 2) {Decimation = 0x1;}
		else if (Decimation_Factor == 4) {Decimation = 0x2;}
		else if (Decimation_Factor == 8) {Decimation = 0x3;}
		else if (Decimation_Factor == 16) {Decimation = 0x4;}
		else if (Decimation_Factor == 32) {Decimation = 0x5;}
		else if (Decimation_Factor == 64) {Decimation = 0x6;}
		else
			return ER_INVALID_SETTING;

		if( Decimation == 0x0 ) { DecimationFactor = 1; }
		if( Decimation == 0x1 ) { DecimationFactor = 2; }
		if( Decimation == 0x2 ) { DecimationFactor = 4; }
		if( Decimation == 0x3 ) { DecimationFactor = 8; }
		if( Decimation == 0x4 ) { DecimationFactor = 16; }
		if( Decimation == 0x5 ) { DecimationFactor = 32; }
		if( Decimation == 0x6 ) { DecimationFactor = 64; }

		double FFTSamplingRate = RawSamplingRate / double(DecimationFactor);
		double FFTBinValue = FFTSamplingRate / FFTnbrSamples;
		double NyquistFreq = FFTSamplingRate / 2.0;

		int Accumulation = 0x0; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		//int Accumulation = 0x5; // FFT Nbr of accumulated spectrums. Valid value 0x0 to 0x7, the total number of waveforms accumulated is "Accumulation+1"
		int AccumulationNbr = Accumulation+1;

		int FFTStart     = 0x1; // To start FFT
		int FFTStop      = 0x2; // To Stop FFT
		int FFTStopped   = 0x0; // To check FFT stopped

		int FFTConfigure = FFTLength * 256 + Accumulation * 16 + Decimation; // "shift bits to the corresponding position
		int ReadConfig = 0x0; // to read config register
		int MaxPeakPos = 0x0; // to handle read maxpos result 

		double PeakPosA = 0;
		int CHx_ControlFS = 0;

		int ReadStatus = 0;
		
		if (ch == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (ch == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONFIGURATION1, FFTConfigure, 0); //configure
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONFIGURATION1, FFTConfigure, 0); //configure
		CheckError(UutOffsetIndex, ret, __LINE__);

		//if (ch == 1)
		//	ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", CH1_CONFIGURATION1, ReadConfig); //configure
		//else
		//	ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", CH2_CONFIGURATION1, ReadConfig); //configure
		//CheckError(UutOffsetIndex, ret, __LINE__);

		int Write0 = 0;
		if (ch == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, Write0, 0); //reset start bit
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, Write0, 0); //reset start bit
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (ch == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStart, 0); //start
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStart, 0); //start
		CheckError(UutOffsetIndex, ret, __LINE__);

		Stopwatch swatch;
		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		double TimeOut_s = 0.1;

		while (swatch.Elapsed.TotalSeconds < TimeOut_s)
		{
			swatch.Start();

			if (ch == 1)
				ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_STATUS, MaxPeakPos); //check end of measure & read max peak position
			else
				ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_STATUS, MaxPeakPos); //check end of measure & read max peak position
			CheckError(UutOffsetIndex, ret, __LINE__);
			RDY = MaxPeakPos & 0x80000000;

			if (RDY == 0x80000000)
				break;

			swatch.Stop();
		}

		if (RDY == 0x80000000)
		{
			
			PeakPosA = (double(double(MaxPeakPos & 0x0000FFFF)) * FFTSamplingRate) / double(FFTnbrSamples-1);
			

			int BiggestNbrSample = FFTnbrSamples;
			int rdStartAddr = 0x0;

			if (Debug_Enable == true)
			{
				if (ch == 1)
					ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr, 0);
				else
					ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr, 0);
				CheckError(UutOffsetIndex, ret, __LINE__);

				array<int> ^ rddata = gcnew array<int>(BiggestNbrSample);
				for(int i = 0; i < BiggestNbrSample; i++)
				{
					if (ch == 1)
						ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, rddata[i]);
					else
						ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, rddata[i]);
					CheckError(UutOffsetIndex, ret, __LINE__);
					
					ofstream outFile("C:\\Aemulus\\Debug\\rawdata_fast.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << rddata[i] << endl;
					}
					outFile.close();
				}
			}

			rdStartAddr = (int)(PeakPosA / FFTBinValue);
			double FS = 0;
			if (BiggestNbrSample == 1024 || BiggestNbrSample == 4096 || BiggestNbrSample == 16384)
				FS = 16383;
			else
				FS = 32767;

			int readdata = 0;
			double readdata_d = 0;

			array<int> ^ rddata = gcnew array<int>(POWER_BINS*2+1); //+/-POWER_BINS from MAX BIN 

			if (rdStartAddr > POWER_BINS)
			{
				if (ch == 1)
					ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr-POWER_BINS, 0);
				else
					ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr-POWER_BINS, 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
			
				for(int i = 0; i < POWER_BINS*2+1; i++)
				{
					if (ch == 1)
						ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, rddata[i]);
					else
						ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, rddata[i]);
					CheckError(UutOffsetIndex, ret, __LINE__);

					readdata += rddata[i]*rddata[i];
				}

				readdata_d = Math::Sqrt(readdata);

			vpp = readdata_d * (1/FS) * fullScale / AccumulationNbr;
			}
			else
			{
				if (ch == 1)
					ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_BRAMADDR, rdStartAddr, 0);
				else
					ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_BRAMADDR, rdStartAddr, 0);
				CheckError(UutOffsetIndex, ret, __LINE__);

				if (ch == 1)
					ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_BRAMREAD, readdata);
				else
					ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_BRAMREAD, readdata);
				CheckError(UutOffsetIndex, ret, __LINE__);

				vpp = (double)readdata * (1/FS) * fullScale / AccumulationNbr;
			}

			vpp = vpp * diff2se_digitizer_factor;
		}
		else
		{
			vpp = 999;
		}

		return ret;
	}
	void TestProgram::Digitizer_GetVpp(int UutOffsetIndex, array<double> ^ config, double diff2se_digitizer_factor, array<double> ^ rawData, double % vpp) //294502
	{
		//(in) config: Digitizer configuration setting
		//(in) rawData: waveform array captured by digitizer
		//(out) vpp: returned value, as the vpp

		double sampInterval	= config[0];

		//double diff2se_digitizer_factor = 1;

		//if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
		//	diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][UutOffsetIndex];

		double average = 0;
		for (int i=0; i<rawData->Length; i++)
		{
			average += rawData[i];
		}
		average = average/rawData->Length;

		array<double> ^ data_filtered = gcnew array<double>(rawData->Length);

		for (int i=0; i<rawData->Length; i++)
		{
			data_filtered[i] = rawData[i] - average;
		}

		vpp = _fft->GetVpp(data_filtered, sampInterval, NONE, false);

		vpp = vpp * diff2se_digitizer_factor;
	}	
	int TestProgram::SWG_Configure(int UutOffsetIndex, double amplitude, double freq, double phase)
	{
		int ret = 0;

		ret = acm[UutOffsetIndex]->ResetChannel("ACM_CH");
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = acm[UutOffsetIndex]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = acm[UutOffsetIndex]->ConfigureFGSineWaveform("ACM_CH", amplitude/2, -1 * amplitude/2, freq, phase);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = acm[UutOffsetIndex]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::ReadFaultStatusBits(int UutOffsetIndex)
	{	
		int ret = 0;

		double Input_Channel_Delay_s = 0;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][UutOffsetIndex];
	
		int spi_group = 0;
		double spi_clk_freq = 2e6;
		int spi_status = 0;

		int spi_wr_byte_length = 0;
		int spi_rd_byte_length = 0;

		int data = 0;

		array<int> ^ spi_data = gcnew array<int>(256);
		array<int> ^ spi_data_dir = gcnew array<int>(256);
		array<int> ^ spi_rd_data = gcnew array<int>(256);
		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

		for (int i=0; i<256; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}

		ret = SPI_Configure(UutOffsetIndex, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Pg1 Reg30 WIPO
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x9E00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg5
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xA800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg7
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xB800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg6
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x9800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg8
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x8400; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg20
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0x8A00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg23
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xBA00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg29
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xAE00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg39
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xF800; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		//Pg1 Reg62
		spi_status = 0;
		spi_data_dir[0] = 0x00000ff;
		spi_data[0]	= 0x3000000 | 0xDE00; //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
		spi_wr_byte_length = 1;
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (spi_status == 2)
		{
			ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
			CheckError(UutOffsetIndex, ret, __LINE__);

			for (int j=0; j<spi_rd_byte_length; j++)
			{
				if (spi_rd_biterror[j] == 0)
				{
					data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
				}
			}
		}

		ret = dm[UutOffsetIndex]->SPI_CH_UNSEL("DM_2", spi_group);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::readlockbit(int UutOffsetIndex)
	{	
		int ret		= 0;
		int data	= 0;

		//read lock bit

		if(!USE_SPI)
		{
			ret = RunVectorFile(UutOffsetIndex, "write_trimlock_init");
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = ReadVector(UutOffsetIndex, "read_p2_reg48", data);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			ret = OnOffSPI(UutOffsetIndex, 1);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = RunSPI(UutOffsetIndex, "write_trimlock_init");
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = ReadSPI(UutOffsetIndex, "read_p2_reg48", data);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = OnOffSPI(UutOffsetIndex, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		_glob->trimlock[UutOffsetIndex] = (data >> 7) & 0x1;

		if (_glob->trimlock[UutOffsetIndex] == 1)
		{
			_glob->FuseBlown[UutOffsetIndex] = 1;
		}
	
		return ret;
	}
	int TestProgram::blow_testlockfuse(int UutOffsetIndex)
	{
		int ret = 0;

		if(!USE_SPI)
		{
			ret = RunVectorFile(UutOffsetIndex, "write_set_ext_reg");
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else
		{
			ret = OnOffSPI(UutOffsetIndex, 1);
			CheckError(UutOffsetIndex, ret, __LINE__);
			ret = RunSPI(UutOffsetIndex, "write_set_ext_reg");
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		if(Blow_Fuse)	//blowfusecmd execution
		{		
			if(!USE_SPI)
			{
				ret = RunVectorFile(UutOffsetIndex, "write_blow_testfuse");
				CheckError(UutOffsetIndex, ret, __LINE__);
				_util->Wait_Sec(0.1);
				ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_off");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(UutOffsetIndex, 1);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = RunSPI(UutOffsetIndex, "write_blow_testfuse");
				CheckError(UutOffsetIndex, ret, __LINE__);
				_util->Wait_Sec(0.1);
				ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_off");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		if(Blow_Fuse)	//blowfusecmd execution
		{		
			if(!USE_SPI)
			{
				ret = RunVectorFile(UutOffsetIndex, "write_blow_lockfuse");
				CheckError(UutOffsetIndex, ret, __LINE__);
				_util->Wait_Sec(0.1);
				ret = RunVectorFile(UutOffsetIndex, "write_blow_fuse_cmd_off");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(UutOffsetIndex, 1);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = RunSPI(UutOffsetIndex, "write_blow_lockfuse");
				CheckError(UutOffsetIndex, ret, __LINE__);
				_util->Wait_Sec(0.1);
				ret = RunSPI(UutOffsetIndex, "write_blow_fuse_cmd_off");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}
		return ret;
	}
	void TestProgram::CheckError(int UutOffsetIndex, int return_code, int line_number)
	{
		String ^ errorMsg = String::Empty;

		if (return_code.ToString("X")->StartsWith("AE"))
		{
			//Check whether it's AEM resources (error code starts with 0xAE)
			if (return_code.ToString("X")->StartsWith("AE0F")) //0xAE0F = ACM
			{
			errorMsg = "Site " + UutOffsetIndex.ToString() + ": Sinewave generator module error! @ line#" + line_number;
			}	
			else if (return_code.ToString("X")->StartsWith("AE0C")) //0xAE0C = TM
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": Time measurement module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE0B")) //0xAE0B = DM
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": Digital module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE0A")) //0xAE0A = DM
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": Digital module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE09")) //0xAE09 = General
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": General PXI error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE08")) //0xAE08 = IOM
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": IO module error! @ line#" + line_number;
			}
			else if (return_code.ToString("X")->StartsWith("AE07")) //0xAE07 = AM
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": Analog module error! @ line#" + line_number;
			}
			else
			{
				errorMsg = "Site " + UutOffsetIndex.ToString() + ": Unknown error! @ line#" + line_number;
			}

			throw gcnew Aemulus::Hardware::AlarmException(errorMsg, return_code);
		}
		else if (return_code == 160) //ERROR_BAD_ARGUMENTS
		{
			throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": ERROR_BAD_ARGUMENTS @ line#" + line_number, return_code);
		}
		else if (return_code == 8) //ERROR_NOT_ENOUGH_MEMORY
		{
			throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": ERROR_NOT_ENOUGH_MEMORY @ line#" + line_number, return_code);
		}
		else if (return_code == 110) //ERROR_OPEN_FAILED
		{
			throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": ERROR_OPEN_FAILED @ line#" + line_number, return_code);
		}
		else if (return_code.ToString("X")->StartsWith("BFFA") || return_code.ToString("X")->StartsWith("BFFC")) //Digitizer
		{
			StringBuilder ^ sa = gcnew StringBuilder();

			int ret = digitizer[UutOffsetIndex]->GetErrorMessage("DIGITIZER", return_code, sa);

			throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": " + sa->ToString() + " @ line#" + line_number, return_code);
		}
		else if (return_code > 0) //ignore warning
		{
			return_code = 0;
		}
	}
	int TestProgram::InitPowerSupplies(int UutOffsetIndex)
	{
		int ret = 0;

		int Bandwidth = 0;
		double Clamp_Vcc_Current_A = 0.099;

		ret = smu[UutOffsetIndex]->SetBandwidth("VCC", Bandwidth);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveVoltage("VCC", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("VCC", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->SetBandwidth("VEE", Bandwidth);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveVoltage("VEE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("VEE", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		_util->Wait_Sec(0.001); 

		return ret;
	}
	int TestProgram::ReadReg(int UutOffsetIndex, int page, int reg, int % data)
	{
		int ret = 0;
	
		int index			= 0;
		int readback		= 0;
		int datain			= 0;
		int spi_group		= 0;
		int addr			= 0;
		int s_page			= 0; //2945
		int	Sweep_Reg_Addr	= 0;
		double spi_clk_freq = SPI_CLK_FREQ;
		int spi_status		= 0;
		
		int spi_wr_byte_length = 1;
		int spi_rd_byte_length = 0;
		
		array<int> ^ spi_data = gcnew array<int>(1);
		array<int> ^ spi_data_dir = gcnew array<int>(1);
		array<int> ^ spi_rd_data = gcnew array<int>(1);
		array<int> ^ spi_rd_biterror = gcnew array<int>(1);
		array<double> ^ delay_s_after_byte = gcnew array<double>(1);

		for (int i=0; i<1; i++)
		{
			spi_data[i] = 0;
			delay_s_after_byte[i] = 0.000;
			spi_rd_data[i] = 0;
			spi_rd_biterror[i] = 0;
		}
		
	if(!SPI_started[UutOffsetIndex]) {			//EW: will not run if SPI already started
		SPI_started[UutOffsetIndex] = 1;
		ret = dm[UutOffsetIndex]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
		CheckError(UutOffsetIndex, ret, __LINE__);
			}


		int	i = 0;
	
		datain			= 0;
		addr			= _util->SwapBitSequence(reg, 4);	 //2935 addr			= _util->SwapBitSequence(reg, 5);
		s_page			= _util->SwapBitSequence(page, 3);
		Sweep_Reg_Addr	= ((s_page << 4) | addr);			 //2935 Sweep_Reg_Addr	= ((page << 6) | (addr << 1) );

		spi_data_dir[i] = 0x00000ff; 
		spi_data[i]	= 0x3008000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

		spi_status = 0;
	
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);
	
		ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
		CheckError(UutOffsetIndex, ret, __LINE__);

		for (int m=0; m<spi_rd_byte_length; m++)
		{
			if (spi_rd_biterror[m] == 0)
			{
				data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
				readback = (data & 0xff);
			}
			else
			{
				readback = -999;
			}
		}
		
			
		data = readback;
				
		return ret;
	}
	int TestProgram::ReadAllReg(int UutOffsetIndex, string filename)
	{   
		// Customization:-
		int mode	 = 1;	// 0: vector		1: SPI
		int datatype = 3;	// 1: hexadecimal,	2: binary string MSB->LSB,	3: decimal
		string filepath = "C:/Aemulus/Debug/" + filename + ".txt";
		//
		int ret		= 0;
		int setno	= 0;
		int data	= 0;
		int page	= 1;
		int reg		= 0;
		int reg_count= 64;
		int reg_c	= 0;
		
		String ^ vec_str = "" ;
		char hexString[8];
		string binString;
		
		ofstream myfile;
		myfile.open(filepath.c_str(), ofstream::out);

		string dataString;
		
		myfile << "Page\tReg\tdata\n" ; 
		
		for (int c = 0; c < 2; c++)
		{
			// ExtSP reg

			if (c == 1) // extSP reg
			{
				if(mode == 0)
				{
					ret = RunVectorFile(UutOffsetIndex, "write_p2_reg63_extregsp_enable_h");
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				else if(mode == 1)
				{
					ret = WriteSPI(UutOffsetIndex, 1, 63, 1);
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				myfile << "\n\nEXTSP\n";
			}

			for (int i = 0; i < reg_count; i++)
			{	
				if (i > 31)
				{
					page = 2;
				}
				else
				{
					page = 1;
				}
				
				reg = i;

				if (mode == 0)	// vector mode
				{
					ret = OnOffSPI(UutOffsetIndex, 0); 
					vec_str = "read_p" + page + "_reg" + reg  ;
					ret = ReadVector(UutOffsetIndex, vec_str, data);
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				else if (mode == 1)	// SPI mode
				{
					ret = OnOffSPI(UutOffsetIndex, 1); 
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = ReadReg(UutOffsetIndex, page-1, reg, data);
					CheckError(UutOffsetIndex, ret, __LINE__);
				}

				reg_c = reg;
				if (reg_c > 31)
				{
					reg_c = reg_c - 32;	
				}
			
				// Print result
				if(datatype == 1)
				{ //hexadecimal
					_itoa(data, hexString, 16);
					myfile << page << "\t" << reg_c << "\t0x" << hexString << "\n" ; 
				}
				else if(datatype == 2)
				{ // binary string
					binString = _util->dec2bin(data, 8);
					myfile << page << "\t" << reg_c << "\t" << binString << "\n" ; 
				}
				else if(datatype == 3)
				{ // decimal
					myfile << page << "\t" << reg_c << "\t" << data << "\n" ; 
				}
				
			}
			
		}


		if(mode == 0)
		{
			ret = RunVectorFile(UutOffsetIndex, "write_p2_reg63_extregsp_disable_l");
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if(mode == 1)
		{
			ret = WriteSPI(UutOffsetIndex, 1, 63, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		if (mode == 1)  //SPI
		{
			ret = OnOffSPI(UutOffsetIndex, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		myfile.close();
		
		return ret;
	
	}
	void TestProgram::CheckTestItemByPassed(Site ^ site)
	{
		int TICount = 0;
		for each(AFlowItem^ fi in site->FlowItems)
		{
			TestItem^ ti = dynamic_cast<TestItem^>(fi);
			if(ti != nullptr) {
				// This is Test Item
				if(ti->Bypass)
				{
					TIByPassed = true;
					break;// If bypassed
				}
				TICount++;
			}
		}
	}
	void TestProgram::InitDieID()
	{


		if (!((int)high_x % 2))
			high_x++;
		if (!((int)high_y % 2)) 
			high_y++;

		_glob->Die_Size_X = (wafer_diameter / high_x);
		_glob->Die_Size_Y = (wafer_diameter / high_y);

		_glob->Center_X = (float)(high_x / 2);
		_glob->Center_Y = (float)(high_y / 2);
	}
	void TestProgram::UpdateXY(Site ^ site, int UutOffsetIndex)
	{
		Result::CustomResultCollection^ fields = site->ResultsByOffset[site->UUTOffsetResolver->UUTOffsets[UutOffsetIndex]]->CurrentResult->CustomFieldResults;
		
        // If the project has wafer testing enabled in Recipe Editor > Sublot, then there will be X and Y in CustomFieldResults collection.
        //    But the project could be otherwise, so we use ContainsKey() to check first to avoid exception.
        if(fields->ContainsKey("X"))
			_glob->Xcoord[UutOffsetIndex] = (short)fields["X"]->Value;
    
		if(fields->ContainsKey("Y"))
            _glob->Ycoord[UutOffsetIndex] = (short)fields["Y"]->Value;
	}
	int TestProgram::CalibrateDiffAmp_X3(int UutOffsetIndex)
	{
		int ret = 0;

		for (int i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			_glob->DA_OffsetError[UutOffsetIndex, i] = 0;
			_glob->DA_GainError[UutOffsetIndex, i] = 0;
		}

		double nplc = 1;
		int step = 1; //0.1 * 10; 
		int start = 0;
		int p_end = 19; //1.9 * 10; //to avoid data type decimation error. e.g. 1.9 as 1.899999
		int n_end = 6; //0.6 * 10;

		double res = 0;
		int i = 0;
		int j = 0;

		int reCalCount = 0;

		//Cal strategy
		// Set n_in=0, vary p_in from start to p_end
		// Set p_in=0, vary n_in from start to n_end
		// Construct best fit line to get y=mx+c
		// Short DA input, measure output, and get c1
		// Final equation = y=mx+c+c1

		int size = (int)((p_end - start) / step) + 1 + (int)((n_end - start) / step) + 1;

		array<double, 2>^ y = gcnew array<double, 2>(2, size); 
		array<double, 2>^ x = gcnew array<double, 2>(2, size); 
		array<double>^ x_tmp = gcnew array<double>(size);
		array<double>^ y_tmp = gcnew array<double>(size);
		double m = 0;
		double c1 = 0;
		double c2 = 0;

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			for (j=0; j<size; j++)
			{		
				x[i, j] = 0;
				y[i, j] = 0;
			}	
		}

		/////////////////////
		//Resource Configuration
		/////////////////////
		//Configure Source

		String ^ p_in = "MTX_SMU";

		ret = smu[UutOffsetIndex]->ConfigureSamplingTime(p_in, nplc, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampCurrent(p_in, 0.1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin(p_in, true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		String ^ n_in = "MTX_SMU_2";

		ret = smu[UutOffsetIndex]->ConfigureSamplingTime(n_in, nplc, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampCurrent(n_in, 0.1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin(n_in, true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		//Configure Measure

		ret = dm[UutOffsetIndex]->Force("GRP1_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUOutputFunction("GRP1_DIFF_SENSE", DM_CONST_DICV);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLimit("GRP1_DIFF_SENSE", 6, -2);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUCurrentLevel("GRP1_DIFF_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUSamplingTime("GRP1_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GRP1_DIFF_SENSE");
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		ret = dm[UutOffsetIndex]->Force("GRP2_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUOutputFunction("GRP2_DIFF_SENSE", DM_CONST_DICV);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLimit("GRP2_DIFF_SENSE", 6, -2);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUCurrentLevel("GRP2_DIFF_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUSamplingTime("GRP2_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GRP2_DIFF_SENSE");
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

RECAL:
		/////////////////////
		//Group 1
		/////////////////////
					
		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT0, 1); //Connect "MTX_SMU" to p
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN1_OUT1, 1); //Connect "MTX_SMU_2" to n
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP1_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[0, i] = (double)k/10;
			y[0, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[0, i] = (-1 * (double)k/10);
			y[0, i] = res;

			i++;
		}

		//Get best fit line from x and y

		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[0, i];
			y_tmp[i] = y[0, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		_glob->DA_GainError[UutOffsetIndex, 0] = m;

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		/////////////////////
		//Group 2
		/////////////////////
			
		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT3, 1); //Connect "MTX_SMU" to p
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN1_OUT4, 1); //Connect "MTX_SMU_2" to n
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP2_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[1, i] = (double)k/10;
			y[1, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[1, i] = (-1 * (double)k/10);
			y[1, i] = res;

			i++;
		}

		//Get best fit line from x and y
		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[1, i];
			y_tmp[i] = y[1, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		_glob->DA_GainError[UutOffsetIndex, 1] = m;

		//End

		ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		/////////////////////
		//Check offset error by shorting DA inputs to GND directly
		/////////////////////

		ret = smu[UutOffsetIndex]->OffSmuPin(p_in);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->ClampVoltage(p_in, 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent(p_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin(p_in, true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		//Group 1

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP1_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
		CheckError(UutOffsetIndex, ret, __LINE__);

		_util->Wait_Sec(10e-3);

		ret = smu[UutOffsetIndex]->ReadVoltage(p_in, res);

		res = res / _glob->DA_GainError[UutOffsetIndex, 0];

		//ret = smu[UutOffsetIndex]->ConfigureSamplingTime(p_in, 0.1, AM_CONST_PLC);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//array<double>^ tmp = gcnew array<double>(1000);
		//for (int z=0; z<1000; z++)
		//{
		//	ret = smu[UutOffsetIndex]->ReadVoltage(p_in, res);
		//	tmp[z] = res;
		//}

		_glob->DA_OffsetError[UutOffsetIndex, 0] = res;

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Group 2

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP2_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
		CheckError(UutOffsetIndex, ret, __LINE__);

		_util->Wait_Sec(10e-3);

		ret = smu[UutOffsetIndex]->ReadVoltage(p_in, res);

		res = res / _glob->DA_GainError[UutOffsetIndex, 1];

		_glob->DA_OffsetError[UutOffsetIndex, 1] = res;

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		/////////////////////
		//Print results
		/////////////////////
	
		DateTime _now = DateTime::Now;
		//String ^ DA_calFile = String::Format("{0}_{1:00}{2:00}{3:00}{4:00}{5:00}{6:00}.txt",
		//	"C:\\Aemulus\\TesterInfo\\DiffAmpCal" + UutOffsetIndex.ToString(), _now.Year, _now.Month, _now.Day, 
		//	_now.Hour, _now.Minute, _now.Second);

		String ^ DA_calFile = "C:\\Aemulus\\TesterInfo\\DiffAmpCal" + UutOffsetIndex + ".txt";

		StringBuilder ^ sbl = gcnew StringBuilder();
		StreamWriter ^ swl = gcnew StreamWriter(DA_calFile);

		String ^ temp = String::Format("{0} : {1:00}{2:00}{3:00}{4:00}{5:00}{6:00}", 
			"Last Cal", _now.Year, _now.Month, _now.Day, _now.Hour, _now.Minute, _now.Second);
		sbl->AppendLine(temp);

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			sbl->AppendLine("------------------");
			sbl->AppendLine("Group " + (i+1).ToString());
			sbl->AppendLine("------------------");

			for (j=0; j<size; j++)
			{
				sbl->AppendLine("x[" + (j).ToString() + "] = " + x[i, j] + "; y[" + (j).ToString() + "] = " + y[i, j]);
			}
				
			sbl->AppendLine("DA_GainError[" + (i).ToString() + "] = " + _glob->DA_GainError[UutOffsetIndex, i]);
			sbl->AppendLine("DA_OffsetError[" + (i).ToString() + "] = " + _glob->DA_OffsetError[UutOffsetIndex, i]);

			sbl->AppendLine("");
		}

		//Check for nominal values
		int err = 0;
		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			String ^ errorMsg = String::Empty;

			double error = Math::Abs(_glob->DA_GainError[UutOffsetIndex, i] - DA_IDEAL_GAIN) / DA_IDEAL_GAIN;

			if (error * 100 > DA_GAIN_ERROR_TOL_PERCENT)
			{
				if (reCalCount > 0)
				{
					sbl->AppendLine("");

					errorMsg = "Gain error for Site " + UutOffsetIndex + ", Mux Group " + (i+1).ToString() + " is larger than " + 
						DA_GAIN_ERROR_TOL_PERCENT + "% from ideal gain (" + DA_IDEAL_GAIN + ")";

					sbl->AppendLine(errorMsg);

					err++;
					reCalCount++;
				}
				else
				{
					swl->Close();
					swl = nullptr;
					goto RECAL;
				}
			}


			if (_glob->DA_OffsetError[UutOffsetIndex, i] > DA_OFFSET_ERR_TOL)
			{
				if (reCalCount > 0)
				{
					errorMsg = "Gain offset for Site " + UutOffsetIndex + ", Mux Group " + (i+1).ToString() + " is larger than " + 
					DA_OFFSET_ERR_TOL + ")";

					sbl->AppendLine(errorMsg);

					err++;
					reCalCount++;
				}
				else
				{
					swl->Close();
					swl = nullptr;
					goto RECAL;
				}
			}
		}

		swl->Write(sbl);	
		sbl = nullptr;
		swl->Close();
		swl = nullptr;

		if (err)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Differential Amp self-cal failed for Site " + UutOffsetIndex.ToString() + "! Check DiffAmpCal file for details!", ER_GENERAL);
		}

		return ret;
	}	
	int TestProgram::CalibrateDiffAmp_X1(int UutOffsetIndex)
	{
		int ret = 0;

		for (int i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			_glob->DA_OffsetError_X1[UutOffsetIndex, i] = 0;
			_glob->DA_GainError_X1[UutOffsetIndex, i] = 0;
		}

		double nplc = 1;
		int step = 1; //0.1 * 10; 
		int start = 0;
		int p_end = 19; //1.9 * 10; //to avoid data type decimation error. e.g. 1.9 as 1.899999
		int n_end = 6; //0.6 * 10;

		double res = 0;
		int i = 0;
		int j = 0;

		int reCalCount = 0;
		int MaxRecal = 5;

		//Cal strategy
		// Set n_in=0, vary p_in from start to p_end
		// Set p_in=0, vary n_in from start to n_end
		// Construct best fit line to get y=mx+c
		// Short DA input, measure output, and get c1
		// Final equation = y=mx+c+c1

		int size = (int)((p_end - start) / step) + 1 + (int)((n_end - start) / step) + 1;

		array<double, 2>^ y = gcnew array<double, 2>(2, size); 
		array<double, 2>^ x = gcnew array<double, 2>(2, size); 
		array<double>^ x_tmp = gcnew array<double>(size);
		array<double>^ y_tmp = gcnew array<double>(size);
		double m = 0;
		double c1 = 0;
		double c2 = 0;

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			for (j=0; j<size; j++)
			{		
				x[i, j] = 0;
				y[i, j] = 0;
			}	
		}

		/////////////////////
		//Resource Configuration
		/////////////////////
		//Configure Source

		String ^ p_in = "MTX_SMU";

		ret = smu[UutOffsetIndex]->ConfigureSamplingTime(p_in, nplc, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampCurrent(p_in, 0.1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin(p_in, true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		String ^ n_in = "MTX_SMU_2";

		ret = smu[UutOffsetIndex]->ConfigureSamplingTime(n_in, nplc, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampCurrent(n_in, 0.1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin(n_in, true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		//Configure Measure

		ret = dm[UutOffsetIndex]->Force("GRP1_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUOutputFunction("GRP1_DIFF_SENSE", DM_CONST_DICV);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLimit("GRP1_DIFF_SENSE", 6, -2);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUCurrentLevel("GRP1_DIFF_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUSamplingTime("GRP1_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GRP1_DIFF_SENSE");
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		ret = dm[UutOffsetIndex]->Force("GRP2_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUOutputFunction("GRP2_DIFF_SENSE", DM_CONST_DICV);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUVoltageLimit("GRP2_DIFF_SENSE", 6, -2);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUCurrentLevel("GRP2_DIFF_SENSE", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePMUSamplingTime("GRP2_DIFF_SENSE", nplc, DM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("GRP2_DIFF_SENSE");
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

RECAL:
		/////////////////////
		//Group 1
		/////////////////////
					
		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT0, 1); //Connect "MTX_SMU" to p
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN1_OUT1, 1); //Connect "MTX_SMU_2" to n
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP1_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, 31 , 1); //Turn on connection to X1 gain
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[0, i] = (double)k/10;
			y[0, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[0, i] = (-1 * (double)k/10);
			y[0, i] = res;

			i++;
		}

		//Get best fit line from x and y

		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[0, i];
			y_tmp[i] = y[0, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		_glob->DA_GainError_X1[UutOffsetIndex, 0] = m;

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		/////////////////////
		//Group 2
		/////////////////////
			
		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT3, 1); //Connect "MTX_SMU" to p
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN1_OUT4, 1); //Connect "MTX_SMU_2" to n
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP2_IA_SEL, 1); //Turn on connection to diff amp
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, 34 , 1); //Turn on connection to X1 gain

		//Measurement

		i = 0;
		for (int k=start; k<=p_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[1, i] = (double)k/10;
			y[1, i] = res;

			i++;
		}

		for (int k=start; k<=n_end; k=k+step)
		{
			ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
			CheckError(UutOffsetIndex, ret, __LINE__);

			ret = smu[UutOffsetIndex]->DriveVoltage(n_in, (double)k/10);
			CheckError(UutOffsetIndex, ret, __LINE__);

			_util->Wait_Sec(10e-3);
		
			ret = dm[UutOffsetIndex]->PMUMeasure("GRP2_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, res);
			CheckError(UutOffsetIndex, ret, __LINE__);
			
			x[1, i] = (-1 * (double)k/10);
			y[1, i] = res;

			i++;
		}

		//Get best fit line from x and y
		for (i=0; i<size; i++)
		{
			x_tmp[i] = x[1, i];
			y_tmp[i] = y[1, i];
		}
		_util->line_fit_d(x_tmp, y_tmp, size, m, c1);

		_glob->DA_GainError_X1[UutOffsetIndex, 1] = m;

		//End

		ret = smu[UutOffsetIndex]->DriveVoltage(p_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->DriveVoltage(n_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		/////////////////////
		//Check offset error by shorting DA inputs to GND directly
		/////////////////////

		ret = smu[UutOffsetIndex]->OffSmuPin(p_in);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = smu[UutOffsetIndex]->ClampVoltage(p_in, 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent(p_in, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin(p_in, true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);
		_util->Wait_Sec(10e-3);

		//Group 1

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP1_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
		CheckError(UutOffsetIndex, ret, __LINE__);

		_util->Wait_Sec(10e-3);

		ret = smu[UutOffsetIndex]->ReadVoltage(p_in, res);

		res = res / _glob->DA_GainError_X1[UutOffsetIndex, 0];

		//ret = smu[UutOffsetIndex]->ConfigureSamplingTime(p_in, 0.1, AM_CONST_PLC);
		//CheckError(UutOffsetIndex, ret, __LINE__);
		//array<double>^ tmp = gcnew array<double>(1000);
		//for (int z=0; z<1000; z++)
		//{
		//	ret = smu[UutOffsetIndex]->ReadVoltage(p_in, res);
		//	tmp[z] = res;
		//}

		_glob->DA_OffsetError_X1[UutOffsetIndex, 0] = res;

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Group 2

		ret = OnOffCbit(UutOffsetIndex, CBIT_RLY_GRP2_IA_SEL, 0); //Turn off connection to diff amp (short inputs to GND)
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
		CheckError(UutOffsetIndex, ret, __LINE__);

		_util->Wait_Sec(10e-3);

		ret = smu[UutOffsetIndex]->ReadVoltage(p_in, res);

		res = res / _glob->DA_GainError_X1[UutOffsetIndex, 1];

		_glob->DA_OffsetError_X1[UutOffsetIndex, 1] = res;

		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		/////////////////////
		//Print results
		/////////////////////
	
		DateTime _now = DateTime::Now;
		//String ^ DA_calFile = String::Format("{0}_{1:00}{2:00}{3:00}{4:00}{5:00}{6:00}.txt",
		//	"C:\\Aemulus\\TesterInfo\\DiffAmpCal" + UutOffsetIndex.ToString(), _now.Year, _now.Month, _now.Day, 
		//	_now.Hour, _now.Minute, _now.Second);

		String ^ DA_calFile = "C:\\Aemulus\\TesterInfo\\DiffAmpCal_X1_" + UutOffsetIndex + ".txt";

		StringBuilder ^ sbl = gcnew StringBuilder();
		StreamWriter ^ swl = gcnew StreamWriter(DA_calFile);

		String ^ temp = String::Format("{0} : {1:00}{2:00}{3:00}{4:00}{5:00}{6:00}", 
			"Last Cal", _now.Year, _now.Month, _now.Day, _now.Hour, _now.Minute, _now.Second);
		sbl->AppendLine(temp);

		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			sbl->AppendLine("------------------");
			sbl->AppendLine("Group " + (i+1).ToString());
			sbl->AppendLine("------------------");

			for (j=0; j<size; j++)
			{
				sbl->AppendLine("x[" + (j).ToString() + "] = " + x[i, j] + "; y[" + (j).ToString() + "] = " + y[i, j]);
			}
				
			sbl->AppendLine("DA_GainError[" + (i).ToString() + "] = " + _glob->DA_GainError_X1[UutOffsetIndex, i]);
			sbl->AppendLine("DA_OffsetError[" + (i).ToString() + "] = " + _glob->DA_OffsetError_X1[UutOffsetIndex, i]);

			sbl->AppendLine("");
		}

		//Check for nominal values
		int err = 0;
		for (i=0; i<TOTAL_MUX_GROUP_PER_SITE; i++)
		{
			String ^ errorMsg = String::Empty;

			double error = Math::Abs(_glob->DA_GainError_X1[UutOffsetIndex, i] - DA_IDEAL_GAIN_X1) / DA_IDEAL_GAIN_X1;

			if (error * 100 > DA_GAIN_ERROR_TOL_PERCENT)
			{
				if (reCalCount > MaxRecal)
				{
					sbl->AppendLine("");

					errorMsg = "Gain error for Site " + UutOffsetIndex + ", Mux Group " + (i+1).ToString() + " is larger than " + 
						DA_GAIN_ERROR_TOL_PERCENT + "% from ideal gain (" + DA_IDEAL_GAIN_X1 + ")";

					sbl->AppendLine(errorMsg);

					err++;
					reCalCount++;
				}
				else
				{
					swl->Close();
					swl = nullptr;
					reCalCount++;
					goto RECAL;
				}
			}


			if (_glob->DA_OffsetError_X1[UutOffsetIndex, i] > DA_OFFSET_ERR_TOL)
			{
				if (reCalCount > MaxRecal)
				{
					errorMsg = "Gain offset for Site " + UutOffsetIndex + ", Mux Group " + (i+1).ToString() + " is larger than " + 
					DA_OFFSET_ERR_TOL + ")";

					sbl->AppendLine(errorMsg);

					err++;
					reCalCount++;
				}
				else
				{
					swl->Close();
					swl = nullptr;
					reCalCount++;
					goto RECAL;
				}
			}
		}

		swl->Write(sbl);	
		sbl = nullptr;
		swl->Close();
		swl = nullptr;

		if (err)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Differential Amp self-cal failed for Site " + UutOffsetIndex.ToString() + "! Check DiffAmpCal file for details!", ER_GENERAL);
		}

		return ret;
	}	
	int TestProgram::Probe_Card_FET_Control(int UutOffsetIndex, int hw_fet, int fhcr_fet, int fhcw_fet)
	{
		int ret = 0; 

		ret = dm[UutOffsetIndex]->DrivePin("HW_FETS", hw_fet);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DrivePin("FHCR_FETS", fhcr_fet);
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = dm[UutOffsetIndex]->DrivePin("FHCW_FETS", fhcw_fet);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	void TestProgram::IsRunTest(Site^ site, array<bool>^ run_test)
	{
				
		if (SingleSiteTest == true)
		{
			for(int UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
			{

				if (UutOffsetIndex == ForceSingleSiteNumber)
					run_test[UutOffsetIndex] = true;
				else
					run_test[UutOffsetIndex] = false;
			}
		


		}else{

			for(int UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
			{

				AUUTOffset^ UUTOffset = site->UUTOffsetResolver->UUTOffsets[UutOffsetIndex];

				if (ForceSingleSite == true)
				{
					if (UutOffsetIndex == ForceSingleSiteNumber)
					{
						if (UUTOffset->Active)
						{
							if (_glob->jump_on_fail == true)
							{
								if (site->ResultsByOffset[UUTOffset]->CurrentResult->IfAnyTestParameterFailed == false)
								{
									run_test[UutOffsetIndex] = true;
								}
							}
							else
							{
								run_test[UutOffsetIndex] = true;
							}
						}
					}
					else
						continue;				
				}
				else
				{
					if (UUTOffset->Active)
					{
						if (_glob->jump_on_fail == true)
						{
							if (site->ResultsByOffset[UUTOffset]->CurrentResult->IfAnyTestParameterFailed == false)
							{
								run_test[UutOffsetIndex] = true;
							}
							else
							{
								//String^ tps = "";
								//for each(String^ tp in site->ResultsByOffset[UUTOffset]->CurrentResult->FailedTestParameters)
								//	tps += tp + ",";
								//tps += ";";
							}
						}
						else
						{
							run_test[UutOffsetIndex] = true;
						}
					}
				}
			}
		}
	

	}
	void TestProgram::IsRunTest_NoJoF(Site^ site, array<bool>^ run_test)
	{
		
		if (SingleSiteTest == true)
		{
			for(int UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
			{

				if (UutOffsetIndex == ForceSingleSiteNumber)
					run_test[UutOffsetIndex] = true;
				else
					run_test[UutOffsetIndex] = false;
			}
		


		}else{
			for(int UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
			{
				run_test[UutOffsetIndex] = false;

				AUUTOffset^ UUTOffset = site->UUTOffsetResolver->UUTOffsets[UutOffsetIndex];

				if (ForceSingleSite == true)
				{
					if (UutOffsetIndex == ForceSingleSiteNumber)
					{
						if (UUTOffset->Active)
						{
							run_test[UutOffsetIndex] = true;
						}
					}
					else
						continue;				
				}
				else
				{
					if (UUTOffset->Active)
					{
						run_test[UutOffsetIndex] = true;
					}
				}
			}
		}
	}
	int TestProgram::DoThread(ParameterizedThreadStart^ func, Site^ site)
	{
		List<TestProgramData^>^ tpdatas = gcnew List<TestProgramData^>();

		try 
		{
			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			for(int i=0; i<_numOffset; i++)
			{
				if(run_test[i])
				{
					Thread^ t = gcnew Thread(func);
					t->IsBackground = true;

					TestProgramData^ tpdata = gcnew TestProgramData();
					tpdata->UutOffsetIndex = i;	
					tpdata->Thread = t;
					tpdata->t_site = site;
					tpdatas->Add(tpdata);		
					t->Start(tpdata);			
				}
			}

			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread->Join(); 

				if(tpdata->Exception != nullptr) 
				{
					throw tpdata->Exception;
					//throw gcnew Aemulus::Hardware::AlarmException(tpdata->Exception->Message, tpdata->ErrorCode);
				} 
			}
		} 
		finally 
		{
			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread = nullptr;
				tpdata->Exception = nullptr;
				tpdata->t_site = nullptr;
			}
			tpdatas->Clear();
			tpdatas = nullptr;
		}

		return 0;
	}
	int TestProgram::DoThreadWithoutVee(ParameterizedThreadStart^ func, Site^ site)
	{
		List<TestProgramData^>^ tpdatas = gcnew List<TestProgramData^>();

		try 
		{
			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			int ret = 0;
			double Drive_Vee_V = (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = smu[idx]->OffSmuPin("VEE");
					CheckError(idx, ret, __LINE__);

					ret = OnOffFETGnd(idx, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOff("FLTMUX");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("MODE");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("WDX");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("WDY");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("RWN");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("SPD");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("SPC");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("SPE");
					CheckError(idx, ret, __LINE__);
				}
			}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					Thread^ t = gcnew Thread(func);
					t->IsBackground = true;

					TestProgramData^ tpdata = gcnew TestProgramData();
					tpdata->UutOffsetIndex = idx;	
					tpdata->Thread = t;
					tpdata->t_site = site;
					tpdatas->Add(tpdata);		
					t->Start(tpdata);			
				}
			}

			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread->Join(); 

				if(tpdata->Exception != nullptr) 
				{
					throw tpdata->Exception;
					//throw gcnew Aemulus::Hardware::AlarmException(tpdata->Exception->Message, tpdata->ErrorCode);
				} 
			}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					ret = smu[idx]->DriveVoltage("VEE", 0);
					CheckError(idx, ret, __LINE__);
				}
			}
		} 
		finally 
		{
			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread = nullptr;
				tpdata->Exception = nullptr;
				tpdata->t_site = nullptr;
			}
			tpdatas->Clear();
			tpdatas = nullptr;
		}

		return 0;		
	}
	int TestProgram::DoThreadWithoutVee_AWG(ParameterizedThreadStart^ func, Site^ site)
	{
		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		////////////////////////////////////////////////////////
		//Create threads for AWG Ch0 (UUTOffSet 0 & 2)
		List<TestProgramData^>^ tpdatas = gcnew List<TestProgramData^>();

		try 
		{
			int ret = 0;
			double Drive_Vee_V = (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));

			for(int idx=0; idx<_numOffset; idx++)
			{
				//if (idx == 0 || idx == 2)
				{
					if(run_test[idx])
					{
						ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->OffSmuPin("VEE");
						CheckError(idx, ret, __LINE__);

						ret = OnOffFETGnd(idx, 0);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->DPINOff("FLTMUX");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("MODE");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("WDX");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("WDY");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("RWN");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("SPD");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("SPC");
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOff("SPE");
						CheckError(idx, ret, __LINE__);
					}
				}
			}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					if (idx == 0 || idx == 2)
					{
						Thread^ t = gcnew Thread(func);
						t->IsBackground = true;

						TestProgramData^ tpdata = gcnew TestProgramData();
						tpdata->UutOffsetIndex = idx;	
						tpdata->Thread = t;
						tpdata->t_site = site;
						tpdatas->Add(tpdata);		
						t->Start(tpdata);	
					}
				}
			}

			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread->Join(); 

				if(tpdata->Exception != nullptr) 
				{
					throw tpdata->Exception;
					//throw gcnew Aemulus::Hardware::AlarmException(tpdata->Exception->Message, tpdata->ErrorCode);
				} 
			}

			//for(int idx=0; idx<_numOffset; idx++)
			//{
			//	if(run_test[idx])
			//	{
			//		if (idx == 0 || idx == 2)
			//		{
			//			ret = smu[idx]->DriveVoltage("VEE", 0);
			//			CheckError(idx, ret, __LINE__);
			//		}
			//	}
			//}
		} 
		finally 
		{
			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread = nullptr;
				tpdata->Exception = nullptr;
				tpdata->t_site = nullptr;
			}
			tpdatas->Clear();
			tpdatas = nullptr;
		}

		////////////////////////////////////////////////////////
		//Create threads for AWG Ch1 (UUTOffSet 1 & 3)
		tpdatas = gcnew List<TestProgramData^>();

		try 
		{
			int ret = 0;
			double Drive_Vee_V = (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));

			//for(int idx=0; idx<_numOffset; idx++)
			//{
			//	if (idx == 1 || idx == 3)
			//	{
			//		if(run_test[idx])
			//		{
			//			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//			CheckError(idx, ret, __LINE__);
			//		}
			//		else
			//		{
			//			ret = smu[idx]->OffSmuPin("VEE");
			//			CheckError(idx, ret, __LINE__);

			//			ret = OnOffFETGnd(idx, 0);
			//			CheckError(idx, ret, __LINE__);

			//			ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
			//			CheckError(idx, ret, __LINE__);

			//			ret = dm[idx]->DPINOff("FLTMUX");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("MODE");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("WDX");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("WDY");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("RWN");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("SPD");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("SPC");
			//			CheckError(idx, ret, __LINE__);
			//			ret = dm[idx]->DPINOff("SPE");
			//			CheckError(idx, ret, __LINE__);
			//		}
			//	}
			//}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					if (idx == 1 || idx == 3)
					{
						Thread^ t = gcnew Thread(func);
						t->IsBackground = true;

						TestProgramData^ tpdata = gcnew TestProgramData();
						tpdata->UutOffsetIndex = idx;	
						tpdata->Thread = t;
						tpdata->t_site = site;
						tpdatas->Add(tpdata);		
						t->Start(tpdata);	
					}
				}
			}

			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread->Join(); 

				if(tpdata->Exception != nullptr) 
				{
					throw tpdata->Exception;
					//throw gcnew Aemulus::Hardware::AlarmException(tpdata->Exception->Message, tpdata->ErrorCode);
				} 
			}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					//if (idx == 1 || idx == 3)
					{
						ret = smu[idx]->DriveVoltage("VEE", 0);
						CheckError(idx, ret, __LINE__);
					}
				}
			}
		} 
		finally 
		{
			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread = nullptr;
				tpdata->Exception = nullptr;
				tpdata->t_site = nullptr;
			}
			tpdatas->Clear();
			tpdatas = nullptr;
		}

		return 0;		
	}
	int TestProgram::DoThreadWithoutVccVee(ParameterizedThreadStart^ func, Site^ site)
	{
		List<TestProgramData^>^ tpdatas = gcnew List<TestProgramData^>();

		try 
		{
			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			int ret = 0;
			double Drive_Vee_V = (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Drive_Vcc_V = (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
				
					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				
					
				}
				else
				{
					ret = smu[idx]->OffSmuPin("VEE");
					CheckError(idx, ret, __LINE__);
			
					ret = smu[idx]->OffSmuPin("VCC");
					CheckError(idx, ret, __LINE__);

					ret = OnOffFETGnd(idx, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOff("FLTMUX");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("MODE");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("WDX");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("WDY");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("RWN");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("SPD");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("SPC");
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff("SPE");
					CheckError(idx, ret, __LINE__);			
					
				}
			}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					Thread^ t = gcnew Thread(func);
					t->IsBackground = true;

					TestProgramData^ tpdata = gcnew TestProgramData();
					tpdata->UutOffsetIndex = idx;	
					tpdata->Thread = t;
					tpdata->t_site = site;
					tpdatas->Add(tpdata);		
					t->Start(tpdata);			
				}
			}

			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread->Join(); 

				if(tpdata->Exception != nullptr) 
				{
					throw tpdata->Exception;
					//throw gcnew Aemulus::Hardware::AlarmException(tpdata->Exception->Message, tpdata->ErrorCode);
				} 
			}

			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					ret = smu[idx]->DriveVoltage("VEE", 0);
					CheckError(idx, ret, __LINE__);

					ret = smu[idx]->DriveVoltage("VCC", 0);
					CheckError(idx, ret, __LINE__);
				}
			}
		} 
		finally 
		{
			for each(TestProgramData^ tpdata in tpdatas)
			{
				tpdata->Thread = nullptr;
				tpdata->Exception = nullptr;
				tpdata->t_site = nullptr;
			}
			tpdatas->Clear();
			tpdatas = nullptr;
		}

		return 0;		
	}
	//Pin Initialize
	int TestProgram::reader_init(int UutOffsetIndex, String^ Test_Pin_PN, double NPLC, double Input_Channel_Delay_s)
	{ 
		int ret = 0;

		double vih;
		double vil;
		double voh; 
		double vol;
		double ioh;
		double iol;
		double vch;
		double vcl;
		double vt;

		vih = 2.5;
		vil = 0.00;
		voh = 0.75; 
		vol = 0.75;
		ioh = 0.002;
		iol = 0.002;
		vch = 6;
		vcl = -0.1;
		vt = 0;

		//Reset Cbit & MUX
		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = ResetMuxIO(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Digital Pins
		ret = SetupDigital(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPE
		ret = dm[UutOffsetIndex]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPD
		ret = dm[UutOffsetIndex]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPD");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPC
		ret = dm[UutOffsetIndex]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPC");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure RWN
		ret = dm[UutOffsetIndex]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("RWN");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Input Delay
		ret = dm[UutOffsetIndex]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure MTX_SMU
		ret = smu[UutOffsetIndex]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampVoltage("MTX_SMU", 2);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("MTX_SMU", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("MTX_SMU", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure DiffAmp
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 0];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 0];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 1];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 1];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		return ret;
	}
	int TestProgram::writer_init(int UutOffsetIndex, String^ Test_Pin_PN, double NPLC, double Input_Channel_Delay_s)
	{ 
		int ret = 0;

		double vih;
		double vil;
		double voh; 
		double vol;
		double ioh;
		double iol;
		double vch;
		double vcl;
		double vt;

		vih = 2.5;
		vil = 0.00;
		voh = 0.75; 
		vol = 0.75;
		ioh = 0.002;
		iol = 0.002;
		vch = 6;
		vcl = -0.1;
		vt = 0;

		//Reset Cbit & MUX
		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = ResetMuxIO(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Digital Pins
		ret = SetupDigital(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPE
		ret = dm[UutOffsetIndex]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPD
		ret = dm[UutOffsetIndex]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPD");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPC
		ret = dm[UutOffsetIndex]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPC");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure RWN
		ret = dm[UutOffsetIndex]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("RWN");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Input Delay
		ret = dm[UutOffsetIndex]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure MTX_SMU
		ret = smu[UutOffsetIndex]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampVoltage("MTX_SMU", 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("MTX_SMU", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("MTX_SMU", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure DiffAmp
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 0];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 0];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 1];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 1];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		return ret;
	}
	int TestProgram::heater_init(int UutOffsetIndex, String^ Test_Pin_PN, double NPLC, double Input_Channel_Delay_s)
	{ 
		int ret = 0;

		double vih;
		double vil;
		double voh; 
		double vol;
		double ioh;
		double iol;
		double vch;
		double vcl;
		double vt;

		vih = 2.5;
		vil = 0.00;
		voh = 0.75; 
		vol = 0.75;
		ioh = 0.002;
		iol = 0.002;
		vch = 6;
		vcl = -0.1;
		vt = 0;

		//Reset Cbit & MUX
		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = ResetMuxIO(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Digital Pins
		ret = SetupDigital(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPE
		ret = dm[UutOffsetIndex]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPD
		ret = dm[UutOffsetIndex]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPD");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPC
		ret = dm[UutOffsetIndex]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPC");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure RWN
		ret = dm[UutOffsetIndex]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("RWN");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Input Delay
		ret = dm[UutOffsetIndex]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure MTX_SMU
		ret = smu[UutOffsetIndex]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampVoltage("MTX_SMU", 5);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("MTX_SMU", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("MTX_SMU", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure DiffAmp
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 0];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 0];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 1];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 1];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}	

		return ret;
	}
	int TestProgram::fhs_init(int UutOffsetIndex, String^ Test_Pin_PN, double NPLC, double Input_Channel_Delay_s)
	{ 
		int ret = 0;

		double vih;
		double vil;
		double voh; 
		double vol;
		double ioh;
		double iol;
		double vch;
		double vcl;
		double vt;

		vih = 2.5;
		vil = 0.00;
		voh = 0.75; 
		vol = 0.75;
		ioh = 0.002;
		iol = 0.002;
		vch = 6;
		vcl = -0.1;
		vt = 0;

		//Reset Cbit & MUX
		ret = ResetCBit(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = ResetMuxIO(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Digital Pins
		ret = SetupDigital(UutOffsetIndex);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPE
		ret = dm[UutOffsetIndex]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPE");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPD
		ret = dm[UutOffsetIndex]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPD");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure SPC
		ret = dm[UutOffsetIndex]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("SPC");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure RWN
		ret = dm[UutOffsetIndex]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("RWN");
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure Input Delay
		ret = dm[UutOffsetIndex]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure MTX_SMU
		ret = smu[UutOffsetIndex]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->ClampVoltage("MTX_SMU", 1);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->DriveCurrent("MTX_SMU", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = smu[UutOffsetIndex]->OnSmuPin("MTX_SMU", true, false);
		CheckError(UutOffsetIndex, ret, __LINE__);

		//Configure DiffAmp
		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 0];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 0];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
		{
			_glob->DA_m[UutOffsetIndex] = _glob->DA_GainError[UutOffsetIndex, 1];
			_glob->DA_c[UutOffsetIndex] = _glob->DA_OffsetError[UutOffsetIndex, 1];

			ret = OnOffCbit(UutOffsetIndex, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		return ret;
	}
	//SPI method
	//SPI method
	int TestProgram::LoadSPI(String ^ vec, int SPISetNumber)
	{
		int ret = 0;

		String ^ VectoFilePath = SPIFileDirectory + "\\" + vec + ".txt";
		array<String ^> ^ vecStr = gcnew array<String ^>(1);

		int index = 0;
		String ^ line = String::Empty;
		array<String ^> ^ ArrStr = gcnew array<String ^>(37);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";
		StreamReader ^ sr = gcnew StreamReader(VectoFilePath);
		
		vecStr[0] = vec;

		if (SPISetNo->ContainsKey(vecStr[0]) == false)
			SPISetNo->Add(vecStr[0], SPISetNumber);
					
		while(( (line = sr->ReadLine() ) != nullptr) )
		{
			if (line != "")
			{
				ArrStr = line->Split(Separator, StringSplitOptions::RemoveEmptyEntries);
				_glob->SPI_Data_Arr[SPISetNumber, index, PG]	= _util->StrToInt(ArrStr[0]);
				_glob->SPI_Data_Arr[SPISetNumber, index, REG]	= _util->StrToInt(ArrStr[1]);
				_glob->SPI_Data_Arr[SPISetNumber, index, BIT]	= _util->StrToInt(ArrStr[2]);
				index++;
			}
		}
		_glob->SPI_Data_Index[SPISetNumber] = index;
		
		sr->Close();
		sr = nullptr;

		return ret;
	
	}
	int TestProgram::RunSPI(int UutOffsetIndex, String ^ spi_str)
	{
		int ret = 0;
		
		if (SPISetNo->ContainsKey(spi_str))
		{
			int index			= 0;
			int SPISetNumber	= 0;

			int datain			= 0;
			int spi_group		= 0;
			int addr			= 0;
			int s_page			= 0; //2945
			int	Sweep_Reg_Addr	= 0;
			double spi_clk_freq = SPI_CLK_FREQ ;
			
			int spi_status		= 0;
			double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][UutOffsetIndex];
			
			int spi_wr_byte_length = 1;
			int spi_rd_byte_length = 0;

			/*array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);*/
			
			//clear SPI data
			for (int i = 0; i < 256 ; i++)
			{
				spi_data[i] = 0;
				spi_data_dir[i] = 0;
				delay_s_after_byte[i] = 0;
			}

			SPISetNumber = SPISetNo[spi_str];
			index = _glob->SPI_Data_Index[SPISetNumber];

			for (int i = 0 ; i < index ; i++)
			{
				datain			= _glob->SPI_Data_Arr[SPISetNumber, i, BIT];
				datain			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, BIT], 8);
				
				addr			= _glob->SPI_Data_Arr[SPISetNumber, i, REG];
				addr			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, REG], 4);	 //2935 is 5

				s_page			= _glob->SPI_Data_Arr[SPISetNumber, i, PG];
				s_page			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, PG], 3);
				
				////Sweep_Reg_Addr	= ((_glob->SPI_Data_Arr[SPISetNumber, i, PG] << 6) | (addr << 1) );
				Sweep_Reg_Addr	= ((_glob->SPI_Data_Arr[SPISetNumber, i, PG] << 4) | addr);
				//Sweep_Reg_Addr    = ((s_page << 4) | addr );

				spi_data_dir[i] = 0x0000000; 
				spi_data[i]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				spi_status = 0;
				spi_wr_byte_length = i+1;
			}
			
			ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
			CheckError(UutOffsetIndex, ret, __LINE__);
		
		}else{
			return -999;
		}
		return ret;
	}
	int TestProgram::ReadSPI(int UutOffsetIndex, String ^ spi_str, int % data)
	{
		int ret = 0;
		
		if (SPISetNo->ContainsKey(spi_str))
		{

			int index			= 0;
			int SPISetNumber	= 0;
			int readback		= 0;
			int datain			= 0;
			int spi_group		= 0;
			int addr			= 0;
			int s_page			= 0; //2945
			int	Sweep_Reg_Addr	= 0;
			double spi_clk_freq = 2e6;
			int spi_status		= 0;
			double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][UutOffsetIndex];
			
			int spi_wr_byte_length = 1;
			int spi_rd_byte_length = 0;
			
			array<int> ^ spi_data = gcnew array<int>(1);
			array<int> ^ spi_data_dir = gcnew array<int>(1);
			array<int> ^ spi_rd_data = gcnew array<int>(1);
			array<int> ^ spi_rd_biterror = gcnew array<int>(1);
			array<double> ^ delay_s_after_byte = gcnew array<double>(1);

			for (int i=0; i<1; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0.000;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			SPISetNumber = SPISetNo[spi_str];
			index = _glob->SPI_Data_Index[SPISetNumber];
			int	i = 0;
			
			{
				datain			= _glob->SPI_Data_Arr[SPISetNumber, i, BIT];
				datain			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, BIT], 8);
				
				addr			= _glob->SPI_Data_Arr[SPISetNumber, i, REG];
				addr			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, REG], 4);	 //2935 is 5
				
				s_page			= _glob->SPI_Data_Arr[SPISetNumber, i, PG];
				s_page			= _util->SwapBitSequence(_glob->SPI_Data_Arr[SPISetNumber, i, PG], 3);

				//Sweep_Reg_Addr	= ((_glob->SPI_Data_Arr[SPISetNumber, i, PG] << 6) | (addr << 1) );
				Sweep_Reg_Addr	= ((_glob->SPI_Data_Arr[SPISetNumber, i, PG] << 4) | addr);

				spi_data_dir[i] = 0x00000ff; 
				spi_data[i]	= 0x3008000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				spi_status = 0;
			
				ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				CheckError(UutOffsetIndex, ret, __LINE__);
			
				ret = dm[UutOffsetIndex]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
				CheckError(UutOffsetIndex, ret, __LINE__);

				for (int m=0; m<spi_rd_byte_length; m++)
				{
					if (spi_rd_biterror[m] == 0)
					{
						data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
						readback = (data & 0xff);
					}
					else
					{
						readback = -999;
					}
				}
			}
			
			data = readback;
	
		}

		return ret;
	}
	int TestProgram::OnOffSPI(int UutOffsetIndex, int OnOff)
	{
		int ret = 0;

		int spi_group		= 0;
		_glob->spi_clk_freq = SPI_CLK_FREQ;
		int spi_status		= 0;
		double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][UutOffsetIndex];
		
		if (OnOff)
		{
			if(!SPI_started[UutOffsetIndex]) {			//EW: will not run if SPI already started
			SPI_started[UutOffsetIndex] = 1;
			ret = SPI_Configure(UutOffsetIndex, spi_group, _glob->spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			CheckError(UutOffsetIndex, ret, __LINE__);
											} else 
												ret = 1;
		}
		else
		{
			SPI_started[UutOffsetIndex] = 0;
			ret = dm[UutOffsetIndex]->SPI_CH_UNSEL("DM_2", spi_group);
			CheckError(UutOffsetIndex, ret, __LINE__);	
		}

		return ret;
	}
	int TestProgram::VectorToSPI(String ^ vec)
	{
		int ret = 0;

		int ByteSize	= 37;
		int lineNum		= 0;
		int SPD_seq		= 10;
		int SPE_seq		= 11;
		
		int index		= 0;
        int pageStartBit= 2;  //new in 2945
		int regStartBit = 8;  //4 in 2935
		int dataStartBit= 16;
		int temp		= 0;
		int debug		= 1;
		int linelength	= 0;

		String ^ VectoFilePath = VectorFileDirectory + "\\" + vec + ".txt";
		String ^ SPIFilePath = SPIFileDirectory + "\\" + vec + ".txt";
		
		StringBuilder ^ sb = gcnew StringBuilder();
		StreamWriter ^ sw = gcnew StreamWriter(SPIFilePath);

		int line_number = 0;
		String ^ line = String::Empty;

		array<int,2>^ SPI_data_arr = gcnew array<int,2>(512 ,3);;//256
		
		array<String ^> ^ ArrStr = gcnew array<String ^>(33);
		
		//array<String ^> ^ temp = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = " ";
		StreamReader ^ sr = gcnew StreamReader(VectoFilePath);

		String ^ line2 = String::Empty;
		array<String ^> ^ ArrStr2 = gcnew array<String ^>(0);
		
		int i = 0;

		while((line = sr->ReadLine()) != nullptr)
		{
			line_number++;

			// check valid vector data
			if (line->StartsWith("X") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("L") == true ||
				line->StartsWith("l") == true ||
				line->StartsWith("H") == true ||
				line->StartsWith("h") == true ||
				line->StartsWith("Z") == true ||
				line->StartsWith("x") == true ||
				line->StartsWith("1") == true ||
				line->StartsWith("0") == true)
			{
				ArrStr2 = line->Split(Separator, StringSplitOptions::RemoveEmptyEntries);
				if(ArrStr2[SPE_seq] == "1")
				{
					ArrStr[lineNum] = ArrStr2[SPD_seq];
					if ((ArrStr[0]) == "1")
					{
						linelength = 31;	//read

					}else{
						linelength = 31;	//write	//2935 is 32
					}

					if (lineNum == linelength)
					{
						// extract page by cb
						//SPI_data_arr[index,0] = _util->StrToInt(ArrStr[2]);
						// extract page - by cb 
						temp = 0;
						for (int j = 0 ; j < (3 * 2); j=j+2)
						{
							if (ArrStr[j+pageStartBit] == "1" )
							{
								temp = temp + (int)(pow(2.0, j/2)) ; 
							}
						}
						SPI_data_arr[index,0] = temp;


						temp = 0;
						//extract reg 
						for (int j = 0 ; j < (4 * 2); j=j+2) //2935 (int j = 0 ; j < (5 * 2); j=j+2)
						{
							if (ArrStr[j+regStartBit] == "1" )
							{
								temp = temp + (int)(pow(2.0, j/2)) ; 
							}
						}
						SPI_data_arr[index,1] = temp;
						
						//extract data
						temp = 0;
						for (int j = 0 ; j < (8 * 2); j=j+2)
						{
							if (ArrStr[j+dataStartBit] == "1" )
							{
								temp = temp + (int)(pow(2.0, j/2)); 
							}
						}
						
						SPI_data_arr[index,2] = temp;
			
						// print data to file
						if(debug)
						{
							sb->AppendLine(SPI_data_arr[index,PG] + ",\t" + SPI_data_arr[index,REG] + ",\t" + SPI_data_arr[index,BIT] + "\n" );
						}

						lineNum = 0;
						index++;
					
					}else{
						lineNum++;
					}
				}
			}
		}

		if(debug)
		{
			sw->Write(sb);	
			sb = nullptr;
			sw->Close();
			sw = nullptr;
		}

		sr->Close();
		sr = nullptr;

		return ret ;
	}
	int TestProgram::LoadSPIFiles(Site ^ site)
	{   
		int ret = 0;
		int i = 0;
		int indexCount= 0;
		String ^ vec_str = "" ;
		
		String ^ str1 = "write_default_reg";

		for each  (KeyValuePair<String ^ , int>^ pair in VectorSetNo)
		{
			vec_str = pair->Key;

			int setno = pair->Value;
		
			//ret = _util->SampleRes("spi", 0, setno, "");
			
			if(1)  //ML enable first, to be change back to 0 after all done
			{
				VectorToSPI(vec_str); //str1	//vec_str
				LoadSPI(vec_str, i); //LoadSPI(vec_str, i); so that it loads all the SPI files
				
			}
			else
			{
				if ((vec_str->Contains("checkerboard") == 0) && (vec_str->Contains("WDX_WDY_6400bits") == 0))
				{ 
					//exclusion
					//VectorToSPI(vec_str);
					LoadSPI(vec_str, i);
					indexCount++;
				}
			}
			i++;
		}

		//RunSPI(str1);
	
		return ret;
	
	}
	int TestProgram::WriteSPI(int UutOffsetIndex, int page, int reg, int data)
	{
		int ret = 0;
		
		int datain			= 0;
		int spi_group		= 0;
		int addr			= 0;
		int s_page			= 0; //2945
		int	Sweep_Reg_Addr	= 0;
		double spi_clk_freq = SPI_CLK_FREQ;
		int spi_status		= 0;
		double Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][UutOffsetIndex];
		
		int spi_wr_byte_length = 1;
		int spi_rd_byte_length = 0;

		array<int> ^ spi_data = gcnew array<int>(1);
		array<int> ^ spi_data_dir = gcnew array<int>(1);
		array<double> ^ delay_s_after_byte = gcnew array<double>(1);

		datain			= _util->SwapBitSequence(data, 8);
		addr			= _util->SwapBitSequence(reg, 4);  //2935 is 5
		s_page			= _util->SwapBitSequence(page, 3);
		Sweep_Reg_Addr	= ((s_page << 4) | addr);		   //2935 Sweep_Reg_Addr	= ((page << 6) | (addr << 1) ) ;

		spi_data_dir[0] = 0x0000000; 
		spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

		spi_status = 0;
			
		ret = SPI(UutOffsetIndex, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
		CheckError(UutOffsetIndex, ret, __LINE__);
					
		return ret;
	}	
	//Barrier method
	bool TestProgram::IsRunningProduction(Site^ site)
	{
		IProductionSystem^ ps = (IProductionSystem^)site->FlowEngine->EngineManager->GetService(IProductionSystem::typeid);
		if(RemotingServices::IsTransparentProxy(ps))
			return false;
		else
			return true;
	}
	void TestProgram::ResetBarrier(CountdownEvent^ barrier)
	{
		msclr::lock enter(__barrierLock);
		__barrierSetup = false;

		if (Barrier_Debug_Enable == true)
		{
			DateTime _now = DateTime::Now;
			sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "ResetBarrier" + ",site" + testSite);
		}
	}
	void TestProgram::SetupBarrier()
	{
		if(__barrierActive)
		{
			msclr::lock enter(__barrierLock);
			if(!__barrierSetup)
			{
				int i = 0;
				for each(IUutEDData^ uut in __barrierEdUuts) {
					__barrierFlags[i] = (uut->Status == UutEDStatus::Present) ? false : true;
					i++;
				}

				for each(CountdownEvent^ barrier in __barriers)
					barrier->Reset(__barrierFlags);

				__barrierIndex = 0;
				__barrierSetup = true;

				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "SetupBarrier" + ",site" + testSite);
				}
			}
		}
	}
	void TestProgram::Barrier(int barrier_idx, int site_idx)
	{
		if(__barrierActive) 
		{
			if (Barrier_Debug_Enable == true)
			{
				DateTime _now = DateTime::Now;
				sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "barriers[" + barrier_idx + "]" + ",site" + site_idx);
				//_util->Wait_Sec(100e-3);
			}

			__barriers[barrier_idx]->Signal(site_idx);
			__barriers[barrier_idx]->Wait();
		}
	}
	void TestProgram::RunEnded(Site^ site, Phase^ phase, RunResult^ runResult)
	{
		RunConclude(site, runResult);
	}

	void TestProgram::RunStopped(Site^ site)
	{
		RunConclude(site, site->CurrentRunResult);
	}

	void TestProgram::RunConclude(Site^ site, RunResult^ runResult)
	{
		// signal all barriers
		try 
		{
			if( (runResult->RunStatus == RunStatus::Error) ||
				(runResult->RunStatus == RunStatus::Exception) ||
				(runResult->RunStatus == RunStatus::UserInterrupted))
			{
				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded (err)" + ",site" + testSite);
				}

				for (int i=0; i<__barrierCount; i++)
					__barriers[i]->Signal(testSite);
			} 
			else if (_glob->jump_on_fail == true && runResult->IfAnyTestParameterFailed == true)
			{
				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded (jof)" + ",site" + testSite);
				}

				for (int i=0; i<__barrierCount; i++)
					__barriers[i]->Signal(testSite);
			}
			else if (runResult->IfAnyTestParameterFailed == true)
			{
				if (Barrier_Debug_Enable == true)
				{
					DateTime _now = DateTime::Now;
					sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded (jof)" + ",site" + testSite);
				}

				for (int i=0; i<__barrierCount; i++)
					__barriers[i]->Signal(testSite);
			}
		}
		catch (Exception ^ e)
		{
			if (Barrier_Debug_Enable == true)
			{
				DateTime _now = DateTime::Now;
				sb_sync->AppendLine(_now.Minute + "_" + _now.Second + "_" + _now.Millisecond + "_" + "RunEnded exception" + ",site" + testSite
					+ ": " + e->Message);
			}
		}
	}
	void TestProgram::Check_Barrier_Flow(Site^ site)
	{
		//Loop through the whole test flow to check for barrier matching
		// Check if index <= __barrierCount and >= 0
		// Check if there are duplicated indexes
		// Check if index covers from 0 to __barrierCount
		// Check for valid index value:
		//	Must be even number, as every index goes in pair in test program. E.g. 0&1, 2&3, etc.
		
		array<String ^> ^ ItemName = gcnew array<String ^>(256);
		array<int> ^ index = gcnew array<int>(256);

		String ^ errorMsg = String::Empty;
		String ^ str = String::Empty;

		Dictionary <int, int> ^ barrier_index = gcnew Dictionary <int, int>;

		int count = 0;
		int error = 0;

		//Iterate FlowItems (ControlItem/TestItem)
		for each(AFlowItem^ fi in site->Flow->FlowItems)
		{
			//Iterate FlowItem Conditions
			for each(Condition^ fiCond in fi->Conditions)
			{
				String^ conditionName = fiCond->Name;
				Object^ conditionBaseValue = fiCond[site]->Value;

				if (conditionName->Contains("Barrier_Index"))
				{
					ItemName[count] = fi->DisplayName;
					index[count] = (int)(conditionBaseValue);
					count++;
				}
			}
			
			if(fi->GetType() == TestItem::typeid)
			{
				TestItem^ ti = (TestItem^)fi;
              
				//Iterate TestParameters
				for each(TestParameter^ tp in ti->TestParameters)
				{
					//Iterate TestParameter Conditions
					for each(Condition^ tpCond in tp->Conditions)
					{
						String^ conditionName = tpCond->Name;
						Object^ conditionBaseValue = tpCond[site]->Value;

						if (conditionName->Contains("Barrier_Index"))
						{
							ItemName[count] = fi->DisplayName + "." + tp->DisplayName;
							index[count] = (int)(conditionBaseValue);
							count++;
						}
					}
				}                             
			}
		}

		//if ((count * 2 - 1) != __barrierCount)
		//{
		//	str = "ERR: Total barrier indexes (" + (count * 2 - 1) + ") does not match Barrier_Count (" + __barrierCount + ") in AppsWideVariable!\r\n";
		//	errorMsg = String::Concat(errorMsg, str);
		//	error++;
		//}

		//if (! (__barrierCount % 2))
		//{
		//	str = "ERR: Barrier count (AppsWideVariable) is not an odd number (" + __barrierCount + ")!\r\n";
		//	errorMsg = String::Concat(errorMsg, str);
		//	error++;
		//}

		// Check for index entry error
		for (int i=0; i<count; i++)
		{
			if (index[i] >= __barrierCount || index[i] < 0)
			{
				str = "ERR: Incorrect barrier index @ " + ItemName[i] + " (value = " + index[i] + ")!\r\n";
				errorMsg = String::Concat(errorMsg, str);
				error++;
				continue;
			}

			//if (index[i] % 2)
			//{
			//	str = "ERR: Barrier index (" + index[i] + ") is not an even number! Every barrier index in TP must go in pair\r\n";
			//	errorMsg = String::Concat(errorMsg, str);
			//	error++;
			//	continue;
			//}

			if (barrier_index->ContainsKey(index[i]) == false)
			{
				barrier_index->Add(index[i], 0); //check for unique index[i]=Key. Use dummy val as "Value" for the dict
			}
			else
			{
				str = "ERR: Barrier of same index (" + index[i] + ") has been added!\r\n";
				errorMsg = String::Concat(errorMsg, str);
				error++;
				continue;
			}
		}	

		// Check whether index covers from 0->__barrierCount
		if (error == 0)
		{
			array<int> ^ expected_index = gcnew array<int>(__barrierCount);
			array<int> ^ found_index = gcnew array<int>(__barrierCount);
			for (int i=0; i<__barrierCount; i++)
			{	
				expected_index[i] = i;
				found_index[i] = 0;
			}

			for (int i=0; i<count; i++)
			{
				for (int j=0; j<__barrierCount; j++)
				{
					if (index[i] == expected_index[j])
						found_index[j] = 1;

					if ((index[i]+1) == expected_index[j]) //for its pair
						found_index[j] = 1;
				}
			}

			for (int i=0; i<__barrierCount; i++)
			{
				if (found_index[i] == 0)
				{
					str = "ERR: Barrier of this index (" + found_index[i] + ") is missing in the flow!\r\n";
					errorMsg = String::Concat(errorMsg, str);
				}
			}	
		}

		if (Barrier_Debug_Enable == true)
		{

			StringBuilder ^ sb_barrier = gcnew StringBuilder();
			StreamWriter ^ sw_barrier = gcnew StreamWriter("C:\\Aemulus\\Debug\\BarrierCheck" + testSite + ".txt");

			if (error)
			{
				sb_barrier->AppendLine("IFO: Total error found: " + error);	
				sb_barrier->AppendLine(errorMsg);
			}
			sb_barrier->AppendLine("IFO: Barrier count (AppsWideVariable): " + __barrierCount);
			sb_barrier->AppendLine("IFO: Barrier index in flow:");
			for (int i=0; i<count; i++)
			{
				if (i == count-1)
				{
					sb_barrier->AppendLine("     " + ItemName[i] + "," + index[i]);
				}
				else
				{
					sb_barrier->AppendLine("     " + ItemName[i] + "," + index[i] + "," + (index[i]+1).ToString());
				}
			}

			sw_barrier->Write(sb_barrier);	
			sb_barrier = nullptr;
			sw_barrier->Close();
			sw_barrier = nullptr;

		}

		if (error)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Incorrect barrier setup for multisite testing!", ER_GENERAL);
		}
	}
	// Public Methods
	int TestProgram::Load(Site ^ site)
	{
		int ret	= 0;

		HDS = (int)(tf_FlowCondition_Cast("HDS"));

		//_numOffset = site->UUTOffsetResolver->UUTOffsets->Count;
		_numOffset = 1;	//ML multisite change to 4, MUST setup 4 sites for vee measurement to avoid leakage
		
		offline = false;
		int powerlinefreq = 0;
		int Blow_Fuse_Enable = 0 ;
		
		int UutOffsetIndex = 0;

		pxi_controller = gcnew array<CM ^>(_numOffset);
		smu = gcnew array<SMU ^>(_numOffset);
		dio = gcnew array<DIO ^>(_numOffset);
		dm  = gcnew array<DM ^>(_numOffset);
		tm	= gcnew array<TM ^>(_numOffset);
		acm	= gcnew array<ACM ^>(_numOffset);
		digitizer = gcnew array<ACM ^>(_numOffset);
		resourceManager = gcnew array<ResourceManager ^>(_numOffset);

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			pxi_controller[UutOffsetIndex] = nullptr;
			smu[UutOffsetIndex] = nullptr;
			dio[UutOffsetIndex] = nullptr;
			dm[UutOffsetIndex] = nullptr;
			tm[UutOffsetIndex] = nullptr;
			acm[UutOffsetIndex] = nullptr;
			digitizer[UutOffsetIndex] = nullptr;
		
			resourceManager[UutOffsetIndex] = nullptr;
		}

		HardwareProfile = nullptr;
				
		testHead = site->FlowEngine->HeadNumber;
		
		if(String::IsNullOrEmpty(site->Recipe->ResourceMappingFilePath))
			throw gcnew Aemulus::Hardware::AlarmException("Hardware profile unspecified!", ER_INVALID_SETTING);
		else
			HardwareProfile = site->Recipe->ResourceMappingFilePath;

		if (tf_AppWideVariable_exist("PowerLineFreq"))
			powerlinefreq = (int)(tf_AppWideVariable_Cast("PowerLineFreq"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Power line freq unspecified!", ER_INVALID_SETTING);


		if (tf_AppWideVariable_exist("TestOffset"))
			TestOffset = (int)(tf_AppWideVariable_Cast("TestOffset"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("TestOffset unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("SingleSiteTest"))
			SingleSiteTest = (bool)(tf_AppWideVariable_Cast("SingleSiteTest"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("EnableSites unspecified!", ER_INVALID_SETTING);


		if (tf_AppWideVariable_exist("EnableContStat"))
			EnableContStat = (bool)(tf_AppWideVariable_Cast("EnableContStat"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("EnableContStat unspecified!", ER_INVALID_SETTING);

		if (powerlinefreq == 0)
			Power_Line_Freq = 50;
		else
			Power_Line_Freq = 60;

		if (tf_AppWideVariable_exist("offline"))
			offline = (bool)(tf_AppWideVariable_Cast("offline"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("offline mode unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("Test"))
			Test = (int)(tf_AppWideVariable_Cast("Test"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Test mode unspecified!", ER_INVALID_SETTING);

		if (Test < 1 || Test > 4)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Invalid Test mode specified!", ER_INVALID_SETTING);
		}

		if (tf_AppWideVariable_exist("Blow_Fuse_Enable"))
			Blow_Fuse = (int)(tf_AppWideVariable_Cast("Blow_Fuse_Enable"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("Blow_Fuse unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("ForceBlowFuseSim"))
			ForceBlowFuseSim = (bool)(tf_AppWideVariable_Cast("ForceBlowFuseSim"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("ForceBlowFuseSim unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("ForceSingleSite"))
			ForceSingleSite = (bool)(tf_AppWideVariable_Cast("ForceSingleSite"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("ForceSingleSite unspecified!", ER_INVALID_SETTING);

		if (tf_AppWideVariable_exist("ForceSingleSiteNumber"))
			ForceSingleSiteNumber = (int)(tf_AppWideVariable_Cast("ForceSingleSiteNumber"));
		else
			throw gcnew Aemulus::Hardware::AlarmException("ForceSingleSiteNumber unspecified!", ER_INVALID_SETTING);

		if (ForceSingleSiteNumber < 0 || ForceSingleSiteNumber > 3)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Invalid ForceSingleSiteNumber specified!", ER_INVALID_SETTING);
		}

		try
		{
			SetupFileDirectory = site->GetExternalDependency(Test.ToString());
		}
		catch (Exception ^ e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Setup file directory not present! (" + e->ToString() + ")", ER_GENERAL);
		}

		_fft = gcnew FFT();
		_util = gcnew Utilities();
		_glob = gcnew Global();

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

//#pragma region "Barrier"
//
//		if (Barrier_Debug_Enable == true)
//		{
//			sb_sync = gcnew StringBuilder();
//			sw_sync = gcnew StreamWriter("C:\\Aemulus\\Debug\\Barrier" + testSite + ".txt");
//		}
//
//		if (tf_AppWideVariable_exist("Barrier_Count"))
//			__barrierCount = (int)(tf_AppWideVariable_Cast("Barrier_Count"));
//		else
//			throw gcnew Aemulus::Hardware::AlarmException("Barrier_Count unspecified!", ER_INVALID_SETTING);
//
////		Check_Barrier_Flow(site);
//
//		//if(IsRunningProduction(site) == true && ForceSingleSite == false)
//		//{
//			//IsRunningEditor = false;
//
//			msclr::lock enter(__barrierLoadLock);
//			if(!__barrierLoaded)
//			{
//				AEquipmentDriver^ ed = site->FlowEngine->EquipmentDrivers[0];
//				IMultiUutED^ med = dynamic_cast<IMultiUutED^>(ed);
//				if(med != nullptr) {
//					__barrierEdUuts = med->UUTsData;
//					__barrierFlags = gcnew array<bool>(__barrierEdUuts->Count);
//
//					__barriers = gcnew array<CountdownEvent^>(__barrierCount);
//
//					for (int i=0; i<__barrierCount-1; i++)
//					{
//						__barriers[i] = gcnew CountdownEvent(__barrierEdUuts->Count); //normal barrier
//					}
//					__barriers[__barrierCount-1] = gcnew CountdownEvent(__barrierEdUuts->Count, //last barrier - reset all barriers
//						gcnew Action<CountdownEvent^>(this, &TestProgram::ResetBarrier) );
//
//					__barrierActive = true;
//				}
//				__barrierLoaded = true;
//			}
//		//}
//		//else
//		//{
//		//	IsRunningEditor = true;
//		//}
//
//		//if(__barrierActive) {
//		//	site->RunPhaseEnded += gcnew RunEnd(this, &TestProgram::RunEnded);
//		//	site->RunPhaseStopped += gcnew RunStop(this, &TestProgram::RunStopped);
//		//}
//
//#pragma endregion "Barrier"

//#pragma region "CM"
//
//		int pxi_trigger_enable = 0;
//		int pxi_trigger_direction = 0;
//
//		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
//		{
//			//if (run_test[UutOffsetIndex])
//			{
//				pxi_controller[UutOffsetIndex] = gcnew CM(HardwareProfile, testHead, UutOffsetIndex, offline);
//
//				if (UutOffsetIndex == 0 || UutOffsetIndex == 2)
//				{
//					//PXI_TRIGGER0, from A->B
//					pxi_trigger_enable = 0x1;
//					pxi_trigger_direction = 0x0;
//
//					ret = pxi_controller[UutOffsetIndex]->ConfigurePXES2780_TriggerBusAB("PXI_CONTROLLER", pxi_trigger_enable, pxi_trigger_direction);
//				}
//				if (UutOffsetIndex == 1 || UutOffsetIndex == 3)
//				{
//					//PXI_TRIGGER1, from C->B
//					pxi_trigger_enable = 0x2;
//					pxi_trigger_direction = 0x2;
//
//					ret = pxi_controller[UutOffsetIndex]->ConfigurePXES2780_TriggerBusBC("PXI_CONTROLLER", pxi_trigger_enable, pxi_trigger_direction);
//				}
//			}
//		}
//		
//#pragma endregion "CM"

#pragma region "Resource Manager"

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			try
			{
				resourceManager[UutOffsetIndex] = gcnew ResourceManager(HardwareProfile, testHead, UutOffsetIndex);
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}
		}		

#pragma endregion "Resource Manager"

#pragma region "DM"

		double vih = 2.5;
		double vil = 0.00;
		double voh = 0.75; 
		double vol = 0.75;
		double ioh = 0.002;
		double iol = 0.002;
		double vch = 6;
		double vcl = -0.1;
		double vt = 0;

		try
		{
			ret = LoadVectorFileList(site);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load Vector File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			//must always init all DM resources (to control writer/reader heater loads, as well as GND FETs)
			{
				dm[UutOffsetIndex] = gcnew DM(HardwareProfile, 3, testHead, UutOffsetIndex, offline, 0x0); //Should not reset DM_0 as its resources that control FETs are shared. Reset will reset those independent channels (GND_FETS and VCM_SE_DIFF_CONVERT) as well

				ret = dm[UutOffsetIndex]->ConfigureMultiSiteMode("DM_0", 1);
				CheckError(UutOffsetIndex, ret, __LINE__);

				//Should not reset DM_0 as its resources that control FETs are shared. Reset will reset those independent channels (GND_FETS and VCM_SE_DIFF_CONVERT) as well

				ret = dm[UutOffsetIndex]->Reset("DM_1");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->Reset("DM_2");
				CheckError(UutOffsetIndex, ret, __LINE__);

				try
				{
					//resourceManager[UutOffsetIndex] = gcnew ResourceManager(HardwareProfile, testHead, UutOffsetIndex);

					for each (String ^ resource in resourceManager[UutOffsetIndex]->MapNames)
					{
						Resource ^ hardwareResource = resourceManager[UutOffsetIndex]->ResolveResource(resource)[0];

						if (hardwareResource->Hierarchy->Length > 1 && 
							hardwareResource->Hierarchy[0]->StartsWith("DM") == true)
						{
							ret = dm[UutOffsetIndex]->ConfigurePMUSense(resource, DM_CONST_LOCAL);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = dm[UutOffsetIndex]->ConfigurePowerLineFrequency(resource, Power_Line_Freq);
							CheckError(UutOffsetIndex, ret, __LINE__);

							if (resource == "SPD")
							{
								_glob->SPD_Channel_Number = _util->StrToInt(hardwareResource->Value);
							}
						}
					}

					//if (resourceManager[UutOffsetIndex])
					//	delete resourceManager[UutOffsetIndex];
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + UutOffsetIndex.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				ret = dm[UutOffsetIndex]->DrivePin("GND_MUX_RST_N", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = Configure_GND_FET(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = OnOffFETGnd(UutOffsetIndex, 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				
				ret = LoadVectorFiles(site, UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);

				// Always enable VCM_SE_DIFF_CONVERT
				ret = dm[UutOffsetIndex]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOn("VCM_SE_DIFF_CONVERT");
				CheckError(UutOffsetIndex, ret, __LINE__);

				//Turn off all channels to DUT
				ret = dm[UutOffsetIndex]->DPINOff("RWN");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("SPD");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("SPC");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("SPE");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("FLTMUX");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("MODE");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("WDX");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dm[UutOffsetIndex]->DPINOff("WDY");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		UutOffsetIndex = 0;

		vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		ret = dm[UutOffsetIndex]->Force("FHCW_FETS", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("FHCW_FETS", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("FHCW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("FHCW_FETS", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("FHCW_FETS", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("FHCW_FETS");
		CheckError(UutOffsetIndex, ret, __LINE__);		

		vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		ret = dm[UutOffsetIndex]->Force("FHCR_FETS", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("FHCR_FETS", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("FHCR_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("FHCR_FETS", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("FHCR_FETS", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("FHCR_FETS");
		CheckError(UutOffsetIndex, ret, __LINE__);

		vih = 5;	vil = -2;	voh = 0;	vol = 0;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
		ret = dm[UutOffsetIndex]->Force("HW_FETS", DM_CONST_FORCE_STATE_DIO);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->ConfigurePEAttribute("HW_FETS", 0, 0, 0, 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINLevel("HW_FETS", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->SetPinDirection("HW_FETS", DM_CONST_DIR_OUTPUT);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DrivePin("HW_FETS", 0);
		CheckError(UutOffsetIndex, ret, __LINE__);
		ret = dm[UutOffsetIndex]->DPINOn("HW_FETS");
		CheckError(UutOffsetIndex, ret, __LINE__);
	
#pragma endregion "DM"

#pragma region "AM"

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			//init all DM resources and turn them off (to prevent common substrate prob)
			//if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) || (run_test[UutOffsetIndex])  || )
			{
				smu[UutOffsetIndex] = gcnew SMU(HardwareProfile, testHead, UutOffsetIndex, offline, 0x8);

				ret = smu[UutOffsetIndex]->ConfigureMultiSiteMode("AM_2", 1);
				CheckError(UutOffsetIndex, ret, __LINE__);

				//try
				//{
				//	resourceManager[UutOffsetIndex] = gcnew ResourceManager(HardwareProfile, testHead, UutOffsetIndex);
				//}
				//catch (Exception ^ e)
				//{
				//	throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				//}

				for each (String ^ resource in resourceManager[UutOffsetIndex]->MapNames)
				{
					Resource ^ hardwareResource = resourceManager[UutOffsetIndex]->ResolveResource(resource)[0];

					if (hardwareResource->Hierarchy->Length > 1 && 
						hardwareResource->Hierarchy[0]->StartsWith("AM") == true)
					{
						ret = smu[UutOffsetIndex]->ConfigurePLF(resource, Power_Line_Freq);
						CheckError(UutOffsetIndex, ret, __LINE__);

						ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_10V_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						if (hardwareResource->Hierarchy[0]->StartsWith("AM430"))
						{
							ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_1V_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_2V_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_5V_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);
						}

						ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_1UA_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_10UA_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_100UA_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_1MA_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_10MA_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_100MA_RANGE);
						CheckError(UutOffsetIndex, ret, __LINE__);
						ret = smu[UutOffsetIndex]->ResetChannel(resource);
						CheckError(UutOffsetIndex, ret, __LINE__);
						_util->Wait_Sec(5e-3);

						if (hardwareResource->Hierarchy[0]->StartsWith("AM471"))
						{
							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_1A_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_3A_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);
						}
					}
				}

				//if (resourceManager[UutOffsetIndex])
				//	delete resourceManager[UutOffsetIndex];

				//Turn off all channels
				ret = smu[UutOffsetIndex]->OffSmuPin("VCC");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = smu[UutOffsetIndex]->OffSmuPin("VEE");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = smu[UutOffsetIndex]->OffSmuPin("MTX_SMU");
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = smu[UutOffsetIndex]->OffSmuPin("MTX_SMU_2");
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

#pragma endregion "AM"

#pragma region "IOM"

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) || (run_test[UutOffsetIndex]))
			{
				dio[UutOffsetIndex] = gcnew DIO(HardwareProfile, testHead, UutOffsetIndex, offline);

				ret = dio[UutOffsetIndex]->PowerOnOff("IOM", IOM_CONST_OUTPUT_VCCOUT5_OFF, IOM_CONST_OUTPUT_VCCOUT12_ON);
				CheckError(UutOffsetIndex, ret, __LINE__);
				_util->Wait_Sec(5e-3);
				ret = dio[UutOffsetIndex]->PowerOnOff("IOM", IOM_CONST_OUTPUT_VCCOUT5_ON, IOM_CONST_OUTPUT_VCCOUT12_ON);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->SetVIO("IOM", IOM_CONST_OUTPUT_VIO_3_3V);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->SetPortDirection("IOM_Port_0", IOM_CONST_DIR_OUTPUT);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->SetPortDirection("IOM_Port_1", IOM_CONST_DIR_OUTPUT);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->SetPortDirection("IOM_Port_2", IOM_CONST_DIR_OUTPUT);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->SetPortDirection("IOM_Port_3", IOM_CONST_DIR_OUTPUT);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = dio[UutOffsetIndex]->SetPortDirection("IOM_Port_4", IOM_CONST_DIR_OUTPUT);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = SetupDIO(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

#pragma endregion "IOM"

#pragma region "TM"

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) || (run_test[UutOffsetIndex]))
			{
				tm[UutOffsetIndex] = gcnew TM(HardwareProfile, testHead, UutOffsetIndex, offline, 0x8);

				ret = tm[UutOffsetIndex]->ConfigureMultiSiteMode("TM", 1);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

#pragma endregion "TM"

#pragma region "ACM"

		for (UutOffsetIndex=0; UutOffsetIndex<1; UutOffsetIndex++)
		{
			if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) || (run_test[UutOffsetIndex]))
			{
				acm[UutOffsetIndex] = gcnew ACM(HardwareProfile, testHead, UutOffsetIndex, offline, 0x8);

				digitizer[UutOffsetIndex] = acm[UutOffsetIndex];
		
				ret = acm[UutOffsetIndex]->ConfigureMultiSiteMode("ACM", 1);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = acm[UutOffsetIndex]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_OFF, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_RESERVED, DAT_RESERVED, 0); 
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

#pragma endregion "ACM"

#pragma region "External Dependencies"

		SPIFileDirectory = site->GetExternalDependency("SPI");

		try
		{
			LoadOffsetFile(site);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load Offset File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		try
		{
			LoadDMSettingFile(site);
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load DM Setting File error! (" + e->ToString() + ")", ER_GENERAL);
		}

		InitCBitHist();

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			try
			{
				ret = LoadCBitSettingFile(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			catch (Exception ^e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load CBit Setting File error! (" + e->ToString() + ")", ER_GENERAL);
			}

			try
			{
				ret = LoadMuxSettingFile(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
			catch (Exception ^e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Load Mux Setting File error! (" + e->ToString() + ")", ER_GENERAL);
			}
		}

		try 
		{
			LoadTesterCalFile();
		}
		catch (Exception ^e)
		{
			throw gcnew Aemulus::Hardware::AlarmException("Load IF Board Calibration File error! (" + e->ToString() + ")", ER_GENERAL);
		}

#pragma endregion "External Dependencies"

		InitializeGlobalVariables();

		if(USE_SPI)
		{
			LoadSPIFiles(site);
		}

#pragma region "Trimming Test"
		
		LoadTrimReg();

#pragma endregion "Trimming Test"

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			if (run_test[UutOffsetIndex])
			{
				ret = SetupDigital(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);

				LoadPolarity();

				//Set Vcc relay on adaptor board
				ret = OnOffCbit(UutOffsetIndex, CBIT_VCC_FORWARD, 1);
				CheckError(UutOffsetIndex, ret, __LINE__);
				ret = OnOffCbit(UutOffsetIndex, CBIT_VEE_FORWARD, 1);
				CheckError(UutOffsetIndex, ret, __LINE__);

				ret = Configure_GNDS(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);

				//Init SMU
				ret = InitPowerSupplies(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);

				// Diff Amp Self-Calibration
				ret = CalibrateDiffAmp_X1(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);
			
				ret = CalibrateDiffAmp_X3(UutOffsetIndex);
				CheckError(UutOffsetIndex, ret, __LINE__);
			}
		}

		CheckTestItemByPassed(site);

		return ret;
	}
	int TestProgram::Unload(Site ^ site)
	{
		int ret = 0;

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		int UutOffsetIndex = 0;

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			if (run_test[UutOffsetIndex])
			{
				try
				{
					//resourceManager[UutOffsetIndex] = gcnew ResourceManager(HardwareProfile, testHead, UutOffsetIndex);

					for each (String ^ resource in resourceManager[UutOffsetIndex]->MapNames)
					{
						Resource ^ hardwareResource = resourceManager[UutOffsetIndex]->ResolveResource(resource)[0];

						if (hardwareResource->Hierarchy->Length > 1 && 
							hardwareResource->Hierarchy[0]->StartsWith("AM") == true)
						{
							ret = smu[UutOffsetIndex]->ConfigurePLF(resource, Power_Line_Freq);
							CheckError(UutOffsetIndex, ret, __LINE__);

							ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_1V_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_10V_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							if (hardwareResource->Hierarchy[0]->StartsWith("AM430"))
							{
								ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_2V_RANGE);
								CheckError(UutOffsetIndex, ret, __LINE__);
								ret = smu[UutOffsetIndex]->ResetChannel(resource);
								CheckError(UutOffsetIndex, ret, __LINE__);
								_util->Wait_Sec(5e-3);

								ret = smu[UutOffsetIndex]->VoltageNulling(resource, AM_CONST_5V_RANGE);
								CheckError(UutOffsetIndex, ret, __LINE__);
								ret = smu[UutOffsetIndex]->ResetChannel(resource);
								CheckError(UutOffsetIndex, ret, __LINE__);
								_util->Wait_Sec(5e-3);
							}

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_1UA_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_10UA_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_100UA_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_1MA_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_10MA_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_100MA_RANGE);
							CheckError(UutOffsetIndex, ret, __LINE__);
							ret = smu[UutOffsetIndex]->ResetChannel(resource);
							CheckError(UutOffsetIndex, ret, __LINE__);
							_util->Wait_Sec(5e-3);

							if (hardwareResource->Hierarchy[0]->StartsWith("AM471"))
							{
								ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_1A_RANGE);
								CheckError(UutOffsetIndex, ret, __LINE__);
								ret = smu[UutOffsetIndex]->ResetChannel(resource);
								CheckError(UutOffsetIndex, ret, __LINE__);
								_util->Wait_Sec(5e-3);

								ret = smu[UutOffsetIndex]->CurrentNulling(resource, AM_CONST_3A_RANGE);
								CheckError(UutOffsetIndex, ret, __LINE__);
								ret = smu[UutOffsetIndex]->ResetChannel(resource);
								CheckError(UutOffsetIndex, ret, __LINE__);
								_util->Wait_Sec(5e-3);
							}
						}
					}

					//if (resourceManager[UutOffsetIndex])
					//	delete resourceManager[UutOffsetIndex];
				}
				catch (Exception ^ e)
				{
					;//throw gcnew Aemulus::Hardware::AlarmException("Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				try
				{
					ret = digitizer[UutOffsetIndex]->Uninitialize("DIGITIZER");
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				catch (Exception ^ e) {;}

				try
				{
					ret = pxi_controller[UutOffsetIndex]->Uninitialize("PXI_CONTROLLER");
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				catch (Exception ^ e) {;}

				try
				{
					ret = ResetMuxIO(UutOffsetIndex);
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = ResetCBit(UutOffsetIndex);
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = dio[UutOffsetIndex]->PowerOnOff("IOM", IOM_CONST_OUTPUT_VCCOUT5_OFF, IOM_CONST_OUTPUT_VCCOUT12_OFF);
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = dio[UutOffsetIndex]->Reset("IOM");
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				catch (Exception ^ e) {;}

				if (resourceManager[UutOffsetIndex])
					delete resourceManager[UutOffsetIndex];
			}
		}

		for (UutOffsetIndex=0; UutOffsetIndex<_numOffset; UutOffsetIndex++)
		{
			if (run_test[UutOffsetIndex]) //only do for active sites
			{
				try
				{
					ret = OnOffFETGnd(UutOffsetIndex, 0);
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = SetupDIO(UutOffsetIndex);
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = dm[UutOffsetIndex]->Reset("DM_0");
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = dm[UutOffsetIndex]->Reset("DM_1");
					CheckError(UutOffsetIndex, ret, __LINE__);
					ret = dm[UutOffsetIndex]->Reset("DM_2");
					CheckError(UutOffsetIndex, ret, __LINE__);
				}
				catch (Exception ^ e) {;}
			}			
		}
		
		
		return ret;
	}
	int TestProgram::seq_force_next(Site ^ site)
	{

		
		return 0;
	}
	int TestProgram::seq_math(Site ^ site)
	{
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		bool isCurrentTPBypassed = false;

		double result = 0;

		//Get test condition from techFlow
		String ^ Global_Result_Index_A	= String::Empty;
		String ^ Global_Result_Index_B	= String::Empty;
		String ^ Operation			= String::Empty;

		array<String ^> ^ ArrStr = gcnew array<String ^>(0);
		array<String ^> ^ Separator = gcnew array<String ^>(1);
		Separator[0] = ",";

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if (run_test[idx])
			{
				for (int i=0; i<total_tp; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

						if (Operation == "A-B")
						{
							Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
							Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));

							int A = 0;
							int B = 0;

							A = _util->StrToInt(Global_Result_Index_A);
							B = _util->StrToInt(Global_Result_Index_B);

							result = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];

							tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
						}

						else if (Operation == "MAX[A]-MIN[B]")
						{
							Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
							Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));

							double max = 0;
							double min = 0;

							ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							result = max - min;

							tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
						}

						else if (Operation == "MAX[A]-MIN[A]")
						{
							Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));

							double max = 0;
							double min = 0;

							ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							result = Math::Abs(max - min);

							tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
						}
					}
				}
			}
		}

		return 0;
	}
	int TestProgram::Pre_Test(Site ^ site)
	{
		int ret = 0;
		
		_glob->jump_on_fail = site->Sequencer->JumpOnFailSettingBySite->Enable;

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		//_util->Wait_Sec(1);

		for(int idx=0; idx<_numOffset; idx++)
		{
			//Every 100 test, Nulling for VEE 1mA current range
			//if(_glob->DUT_Counter[idx] == 100)
			if(0)
			{
				ret = smu[idx]->CurrentNulling("VEE", AM_CONST_1MA_RANGE);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ResetChannel("VEE");
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(5e-3);
				_glob->DUT_Counter[idx] = 0;
			}

			_glob->contact_open_l_short_h[idx] = 0;
			_glob->contact_fail[idx] = 0;

			_glob->GoodDIE[idx] = 0;

			_glob->mux_offset[idx] = 0;

			_glob->vref_pre[idx] = 0;
			_glob->iabs_pre[idx] = 0;
			_glob->atemp_pre[idx] = 0;

			_glob->vref_blown_fuse[idx] = 0;
			_glob->atemp_blown_fuse[idx] = 0;
			_glob->iabs_blown_fuse[idx] = 0;
			_glob->waferid_blown_fuse[idx] = 0;
			_glob->quadrantid_blown_fuse[idx] = 0;
			_glob->radiusid_blown_fuse[idx] = 0;

			_glob->vref_fuse_toblow[idx] = 0;
			_glob->atemp_fuse_toblow[idx] = 0;
			_glob->iabs_fuse_toblow[idx] = 0;
			_glob->waferid_fuse_toblow[idx] = 0;
			_glob->quadrantid_fuse_toblow[idx] = 0;
			_glob->radiusid_fuse_toblow[idx] = 0;

			_glob->trimlock[idx]		= 0;
			_glob->FuseBlown[idx]		= 0;
			_glob->testpass[idx]		= 0;


			for (int i=0; i<TOTAL_GLOBAL_VARIABLE; i++)
			{
				_glob->Global_Result[idx, i] = 0;
			}

			for (int i=0; i<HDS; i++)
			{
				_glob->global_who_i[idx, i] = INVALID_RESULT;
				_glob->global_who_v[idx, i] = INVALID_RESULT;
			}

			if (run_test[idx])
			{
				ret = OnOffFETGnd(idx, 1);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OnSmuPin("VEE", true, false);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);
			}

			_glob->DUT_Counter[idx]++;
		}

		
		
	//	_glob->jump_on_fail = site->Sequencer->JumpOnFailSettingBySite->Enable;

		// DieID query for once.
		if (_glob->DieID_Query_Flag == false)
		{
			if (tf_AppWideVariable_exist("high_x"))
				high_x = (float)(tf_AppWideVariable_Cast("high_x"));
			else
				throw gcnew Aemulus::Hardware::AlarmException("high_x unspecified!", ER_INVALID_SETTING);

			if (tf_AppWideVariable_exist("high_y"))
				high_y = (float)(tf_AppWideVariable_Cast("high_y"));
			else
				throw gcnew Aemulus::Hardware::AlarmException("high_y unspecified!", ER_INVALID_SETTING);

			if (tf_AppWideVariable_exist("wafer_diameter"))
				wafer_diameter = (float)(tf_AppWideVariable_Cast("wafer_diameter"));
			else
				throw gcnew Aemulus::Hardware::AlarmException("Wafer diameter unspecified!", ER_INVALID_SETTING);

			_glob->DieID_Query_Flag = true;

			InitDieID();
		}

		return 0;
	}
	int TestProgram::Post_Test(Site ^ site)
	{
		int ret = 0;

		if (EnableContStat)
			PrintContStat();

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) || (run_test[idx]))
			{
				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
		}

		ret = dm[0]->DrivePin("HW_FETS", 0);
		CheckError(0, ret, __LINE__);

		ret = dm[0]->DrivePin("FHCR_FETS", 0);
		CheckError(0, ret, __LINE__);

		ret = dm[0]->DrivePin("FHCW_FETS", 0);
		CheckError(0, ret, __LINE__);

		array<bool>^ do_once = gcnew array<bool>(2);
		do_once[0] = false;
		do_once[1] = false;

		//for(int idx=0; idx<_numOffset; idx++)
		//{
		//	if (run_test[idx])
		//	{
		//		//ret = acm[idx]->StopFG("ACM_CH");
		//		//CheckError(idx, ret, __LINE__);

		//		//ret = acm[idx]->AWGWaveformFlush("ACM");
		//		//CheckError(idx, ret, __LINE__);

		//		//array<double> ^ waveAmplitude = gcnew array<double>(100);
		//		//for (int i = 0; i < 100; i++) waveAmplitude[i] = 0;

		//		//ret = acm[idx]->AWGWaveformLoad("ACM_CH", 0, waveAmplitude->Length, 0, waveAmplitude); //The waveform is transfered to the onboard RAM. Waveform number is 0
		//		//CheckError(idx, ret, __LINE__);

		//		//ret = acm[idx]->ModulationAmplitudeConfig("ACM_CH", 0, 1);
		//		//CheckError(idx, ret, __LINE__);

		//		//ret = acm[idx]->StopAWG("ACM_CH");
		//		//CheckError(idx, ret, __LINE__);

		//		//ret = acm[idx]->AWGQueueWaveform("ACM_CH", 0, ACM_CONST_EXTTRIG, 0, 2, 0);
		//		//CheckError(idx, ret, __LINE__);

		//		//ret = acm[idx]->StopFG("ACM_CH");
		//		//CheckError(idx, ret, __LINE__);

		//		//if (do_once[0] == false && (idx == 0 || idx == 1))
		//		//{
		//		//	ret = acm[0]->AWGWaveformFlush("ACM");
		//		//	CheckError(idx, ret, __LINE__);
		//		//	do_once[0] = true;
		//		//}

		//		//if (do_once[1] == false && (idx == 2 || idx == 3))
		//		//{
		//		//	ret = acm[2]->AWGWaveformFlush("ACM");
		//		//	CheckError(idx, ret, __LINE__);
		//		//	do_once[1] = true;
		//		//}
		//	}
		//}

		return 0;
	}
	int TestProgram::Probe_Card_FET_Control(Site ^ site)
	{
		int ret = 0;

		int HW_FET = (int)tf_ControlItemCondition_Cast("HW_FET");
		int FHCR_FET = (int)tf_ControlItemCondition_Cast("FHCR_FET");
		int FHCW_FET = (int)tf_ControlItemCondition_Cast("FHCW_FET");

		int UutOffsetIndex = 0; //Use Quadrant A resource

		ret = Probe_Card_FET_Control(UutOffsetIndex, HW_FET, FHCR_FET, FHCW_FET);
		CheckError(UutOffsetIndex, ret, __LINE__);

		return 0;
	}
	int TestProgram::Test_Fuse_Branch(Site ^ site) 
	{
		array<BinSortResult^>^ res = gcnew array<BinSortResult^>(_numOffset);



		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for (int i=0; i<_numOffset; i++)
		{
			if (run_test[i])
			{
				AUUTOffset^ UUTOffset = site->UUTOffsetResolver->UUTOffsets[i];
				res[i] = site->BinSorting(BinSortEvalModes::IgnoreUntestedPhase, UUTOffset);

				_glob->GoodDIE[i] = 0;

				if(res[i]->Status == BinSorterRuleType::Pass)
				{
					_glob->GoodDIE[i] = 1;
				}else{
					//string binsort = res[i]->ToString();
					//_util->SampleRes("Failbin", binsort);
				}
			}


		}
 
		return 0;
	}	
	// Tests
	int TestProgram::seq_gnds_cont(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::gnds_cont), site);
	}
	int TestProgram::seq_depmos_test(Site ^ site)
	{	
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::depmos_test), site);
	}
	int TestProgram::seq_vendor(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::vendor), site);
	}
	int TestProgram::seq_vcc_cont(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::vcc_cont), site);
	}
	int TestProgram::seq_vee_cont(Site ^ site)
	{
		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		bool isCurrentTPBypassed	= false; 
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

		double Drive_Current_A	= 0;
		double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

		String ^ Test_Pin		= String::Empty;

		double meas_curr = 0;

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				ret = InitPowerSupplies(idx); //to discharge cap
				CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->Reset("AM_0");
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->Reset("AM_1");
				//CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(0.001);

				//ret = smu[idx]->DriveVoltage("VCC", 0);
				//CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);

				//ret = OnOffCbit(idx, CBIT_VCC_FORWARD, 0);
				//CheckError(idx, ret, __LINE__);
				ret = OnOffCbit(idx, CBIT_VEE_FORWARD, 0);
				CheckError(idx, ret, __LINE__);
			
			}
			else
			{
				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);
		
				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOff("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPE");
				CheckError(idx, ret, __LINE__);			
			}
		}

		_util->Wait_Sec(0.01);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				int i = 0;

				for (i=0; i<total_tp; i++)
				{
					TPName[i] = tf_TestParameter_Name(i);

					{
						Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
						Drive_Current_A = (double)(tf_TPCondition_Cast(TPName[0], "Drive_Current_A"));

#ifdef AM430E_SUPPLY_CONT
						ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
						CheckError(idx, ret, __LINE__);

						ret = OnOffFETGnd(idx, 1);
						CheckError(idx, ret, __LINE__);

						if (Test_Pin == "VCC")
						{ 
							Test_Pin = "MTX_SMU";
						}
						else
						{
							Test_Pin = "MTX_SMU_2";
						}
#endif
						//ret = smu[idx]->OnSmuPin("VCC", true, false);
						//CheckError(idx, ret, __LINE__);

						ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						
						ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
						CheckError(idx, ret, __LINE__);

						ret = smu[idx]->DriveCurrent(Test_Pin, 0);
						CheckError(idx, ret, __LINE__);

						ret = smu[idx]->OnSmuPin(Test_Pin, true, false);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);

#ifndef AM430E_SUPPLY_CONT
						if (Drive_Current_A < 0)
							ret = smu[idx]->DriveCurrent(Test_Pin, Math::Abs(Drive_Current_A));
						else
							ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
#else
						ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
#endif

						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage(Test_Pin, result);
						CheckError(idx, ret, __LINE__);

						////debug
						//array<double>^ data = gcnew array<double>(1000);
						//for(int z=0; z<1000; z++)
						//{
						//	ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
						//	_util->Wait_Sec(Measure_Delay_s);
						//	ret = smu[idx]->ReadVoltage(Test_Pin, data[z]);
						//}
						////debug


						if (Drive_Current_A < 0)
							result = -1 * result;
#ifndef AM430E_SUPPLY_CONT
						if (Test_Pin == "VEE")
							result = -1 * result;
#endif
						tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result, i+12);
						if (Debug_Enable == true)
						{
							ret = smu[idx]->ReadCurrent(Test_Pin, result);
							CheckError(idx, ret, __LINE__);
						}

						//ret = smu[idx]->ClampVoltage(Test_Pin, 0.1); //discharge cap
						//CheckError(idx, ret, __LINE__);

						ret = smu[idx]->DriveCurrent(Test_Pin, 0);
						CheckError(idx, ret, __LINE__);

						//_util->Wait_Sec(10e-3);

						ret = smu[idx]->OffSmuPin(Test_Pin);
						CheckError(idx, ret, __LINE__);

						ret = OnOffFETGnd(idx, 0);
						CheckError(idx, ret, __LINE__);

						//ret = smu[idx]->OffSmuPin("VCC");
						//CheckError(idx, ret, __LINE__);

#ifdef AM430E_SUPPLY_CONT
						ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
						CheckError(idx, ret, __LINE__);
#endif

						if (_glob->contact_fail[idx] == 0)
						{
							if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
							{
								_glob->contact_open_l_short_h[idx] = 1;
								_glob->contact_fail[idx] = 1;
								//continue;
							}
							else if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
							{
								_glob->contact_open_l_short_h[idx] = 0;
								_glob->contact_fail[idx] = 1;
								//continue;
							}
						}
					}
				}
			}
		}

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				//ret = OnOffCbit(idx, CBIT_VCC_FORWARD, 1);
				//CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 1);
				CheckError(idx, ret, __LINE__);

				ret = OnOffCbit(idx, CBIT_VEE_FORWARD, 1);
				CheckError(idx, ret, __LINE__);
			}
		}

		_util->Wait_Sec(On_Delay_s);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				ret = smu[idx]->OnSmuPin("VEE", true, false);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OnSmuPin("VCC", true, false);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OnSmuPin(Test_Pin, true, false);
				CheckError(idx, ret, __LINE__);

				ret = InitPowerSupplies(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		return 0;
	}
	int TestProgram::seq_hsd_cont(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::hsd_cont), site);
	}
	int TestProgram::seq_analog_rd_cont(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::analog_rd_cont), site);
	}
	int TestProgram::seq_mux_cont_diff(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::mux_cont_diff), site);
	}
	int TestProgram::seq_mux_cont_se_kelvin(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::mux_cont_se_kelvin), site);
	}
	int TestProgram::seq_analog_fhs_cont(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::analog_fhs_cont), site);
	}
	int TestProgram::seq_open_short(Site ^ site)
	{
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName		= gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName	= gcnew array<String ^>(total_tp);
		int result = 0;

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest_NoJoF(site, run_test);

		//Check for short
		result = 0;
		int ret = 0;

		for(int idx=0; idx<_numOffset; idx++)
		{
			result = 0;

			if(run_test[idx])
			{ 
				result = 0;

				if (_glob->contact_fail[idx] == 1)
				{
					if (_glob->contact_open_l_short_h[idx] == 1)
					{
						result = 1;
					}
				}

				tf_SetResult_UUTOffset(TPName[0], result + (int)GetOffset(idx, TPDispName[0]), idx);
				
				//Check for open
				result = 0;

				if (_glob->contact_fail[idx] == 1)
				{
					if (_glob->contact_open_l_short_h[idx] == 0)
					{
						result = 1;
					}
				}


				if ((idx != ForceSingleSiteNumber) && SingleSiteTest)   //forceopen for inactive site
					result = 1;

				tf_SetResult_UUTOffset(TPName[1], result + (int)GetOffset(idx, TPDispName[1]), idx);
			}
		}

		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(!run_test[idx])
			{
				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);
		
				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOff("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPE");
				CheckError(idx, ret, __LINE__);	
			}
		}

		return 0;
	}
	int TestProgram::seq_input_leakage(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::input_leakage), site);
	}
	int TestProgram::seq_vcc_leakage(Site ^ site)
	{
		return DoThread(gcnew ParameterizedThreadStart(this, &TestProgram::vcc_leakage), site);
	}
	int TestProgram::seq_vee_leakage(Site ^ site)
	{
		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		double result = 0.0;

		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Clamp_Current_A  = (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
		double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

		String ^ Test_Pin			= String::Empty;

		double meas_voltage = 0;

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				ret = smu[idx]->DriveVoltage("VCC", 0);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
		
				ret = smu[idx]->ClampCurrent("VEE", Clamp_Current_A);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->DriveVoltage("VEE", 0);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOff("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPE");
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOff("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPE");
				CheckError(idx, ret, __LINE__);
			}

		}

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ClampCurrent("VCC", Clamp_Current_A);
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->OnSmuPin("VCC", true, false);
				//CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 1);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OnSmuPin("VCC", true, false);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OnSmuPin("VEE", true, false);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(On_Delay_s);

				//ret = smu[idx]->DriveVoltage("VCC", Drive_Voltage_V);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				//ret = smu[idx]->ReadCurrent("VCC", result);
				//CheckError(idx, ret, __LINE__);

				//tf_SetResult_UUTOffset(TPName[0], result + GetOffset(idx, TPDispName[0]), idx);
				////tf_SetResult_UUTOffset(TPName[2], result + GetOffset(idx, TPDispName[2]), idx);
				//tf_SetResult_UUTOffset(TPName[1], result + GetOffset(idx, TPDispName[1]), idx);

				//if (Debug_Enable == true)
				//{
				//	ret = smu[idx]->ReadVoltage("VCC", result);
				//	CheckError(idx, ret, __LINE__);
				//}

				//ret = smu[idx]->ClampCurrent("VCC", 10e-3);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->DriveVoltage("VCC", 0);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(On_Delay_s);

				//VEE
								
				//drive vcc =0v
				ret = smu[idx]->DriveVoltage("VCC", 0);

				ret = smu[idx]->DriveVoltage("VEE", Drive_Voltage_V);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadCurrent("VEE", result);
				CheckError(idx, ret, __LINE__);

				result = -1 * result;

				tf_SetResult_UUTOffset(TPName[0], result + GetOffset(idx, TPDispName[0]), idx);
				//tf_SetResult_UUTOffset(TPName[3], result + GetOffset(idx, TPDispName[3]), idx);
				tf_SetResult_UUTOffset(TPName[1], result + GetOffset(idx, TPDispName[1]), idx);

				if (Debug_Enable == true)
				{
					ret = smu[idx]->ReadVoltage("VEE", result);
					CheckError(idx, ret, __LINE__);
				}

				ret = smu[idx]->ClampCurrent("VEE", 10e-3);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->DriveVoltage("VEE", 0);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(On_Delay_s);

				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
		}

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				ret = smu[idx]->DriveVoltage("VEE", 0);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->ClampCurrent("VEE", 100e-3); //reduce spkies
				CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ClampCurrent("VCC", 100e-3);
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ClampCurrent("VCC", 0.5);
				//CheckError(idx, ret, __LINE__);

				ret = smu[idx]->ClampCurrent("VEE", 0.5);
				CheckError(idx, ret, __LINE__);
				
				//_util->Wait_Sec(On_Delay_s);

				ret = smu[idx]->OnSmuPin("VEE", true, false);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin("VCC", true, false);
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 1);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOn("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPE");
				CheckError(idx, ret, __LINE__);

				//IO setting
				//ret = ResetDMPin(idx, TPDispName[0]);
				//CheckError(idx, ret, __LINE__);
				//ret = ResetCBit(idx);
				//CheckError(idx, ret, __LINE__);
				//ret = ResetMuxIO(idx);
				//CheckError(idx, ret, __LINE__);
			}
		}
		
		return 0;
	}
	//15/2
	int TestProgram::seq_serial_pwrup(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::serial_pwrup), site);
	}
	int TestProgram::seq_serial_ck_brd(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::serial_ck_brd), site);
	}
	int TestProgram::seq_por(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::por), site);
	}
	int TestProgram::seq_serial_ck_brd_level(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::serial_ck_brd_level), site);
	}
	int TestProgram::seq_mux_offset(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::mux_offset), site);
		//return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::mux_offset), site);
	}
	int TestProgram::seq_pre_vref_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::pre_vref_trim), site);
	}
	int TestProgram::seq_sim_vref_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_vref_trim), site);
	}
	int TestProgram::seq_sim_vref_trim_sweep(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_vref_trim_sweep), site);
	}
	int	TestProgram::seq_pre_iabs_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::pre_iabs_trim), site);
	}
	int TestProgram::seq_sim_iabs_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_iabs_trim), site);
	}
	int TestProgram::seq_sim_iabs_trim_sweep(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_iabs_trim_sweep), site);
	}

	int TestProgram::seq_pre_atemp_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::pre_atemp_trim), site);
	}
	int TestProgram::seq_sim_atemp_trim_sweep(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_atemp_trim_sweep), site);
	}
	int TestProgram::seq_sim_atemp_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_atemp_trim), site);
	}

	int TestProgram::seq_htslope(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::htslope), site);
	}
	int TestProgram::seq_htr(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::htr), site);
	}
	int TestProgram::seq_sim_htr(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::sim_htr), site);
	}
	int TestProgram::seq_drheat(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::drheat), site);
	}
	int TestProgram::seq_testPass_trim(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::testPass_trim), site);
	}
	int TestProgram::seq_dig_vol_voh(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::dig_vol_voh), site);
	}
	int TestProgram::seq_input_current(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::input_current), site);
	}
	int TestProgram::seq_writer_in2(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::writer_in2), site);
	}
	int TestProgram::seq_vit_vhys_func(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::vit_vhys_func), site);
	}
	int TestProgram::seq_digfunc(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::digfunc), site);
	}
	int TestProgram::seq_dietemp_i(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::dietemp_i), site);
	}
	int TestProgram::seq_power(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::power), site);
	}
	int TestProgram::seq_power_vee(Site ^ site)
	{
		int ret = 0;

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<double> ^ result = gcnew array<double>(total_tp);
		array<double> ^ result2 = gcnew array<double>(total_tp);
		array<double> ^ result3 = gcnew array<double>(total_tp);
		array<double> ^ result4 = gcnew array<double>(total_tp);
		array<int> ^ Drive_WRN_V = gcnew array<int>(total_tp);
		array<int> ^ Drive_PWR_SAVE = gcnew array<int>(total_tp);
		array<int> ^ data_pg1 = gcnew array<int>(32);
		array<int> ^ data_pg2 = gcnew array<int>(32);
		array<int> ^ data_pg4 = gcnew array<int>(32);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
			result2[i] = 0;
			result3[i] = 0;
			result4[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double Clamp_Vee_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vee_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= 0;
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		bool isCurrentTPBypassed = false;

		double Input_Channel_Delay_s = 0;

		String ^ Vector_File	= String::Empty;
		String ^ Vector_File_1	= String::Empty;
		String ^ Measure_Pin	= String::Empty;
		String ^ Measure_Pin_1	= String::Empty;
		int Global_Result_Index = 0;
		int Global_Result_Index_1 = 0;
		String ^ Operation		= String::Empty; 

		double Drive_Vcc2_V		= 0;
		double Drive_Vee2_V		= 0;
		array<int> ^ On_SPI_Once = gcnew array<int> (_numOffset);

		double vih;
		double vil;
		double voh; 
		double vol;
		double ioh;
		double iol;
		double vch;
		double vcl;
		double vt;
		
		int vector_engine_status = 0;

		Stopwatch swatch;

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			ret = smu[idx]->OffSmuPin("VCC");
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OffSmuPin("VEE");
			CheckError(idx, ret, __LINE__);

			ret = OnOffFETGnd(idx, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
			CheckError(idx, ret, __LINE__);
		
			ret = dm[idx]->DPINOff("FLTMUX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("MODE");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("WDX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("WDY");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPD");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPC");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPE");
			CheckError(idx, ret, __LINE__);


		}

		for(int idx=0; idx<_numOffset; idx++)
		{
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			On_SPI_Once[idx] = 0;

			if(run_test[idx])
			{
				//IO setting
			
				//Setup Power supplies
				//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->ClampCurrent("VCC", 0.5);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->DriveVoltage("VCC", 0);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->OnSmuPin("VCC", true, false);
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->ClampCurrent("VEE", 0.5);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->DriveVoltage("VEE", 0);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->OnSmuPin("VEE", true, false);
				//CheckError(idx, ret, __LINE__);
				//_util->Wait_Sec(0.001);

				//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->OffSmuPin("VCC");
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->OffSmuPin("VEE");
				//CheckError(idx, ret, __LINE__);

				//ret = OnOffFETGnd(idx, 0);
				//CheckError(idx, ret, __LINE__);

				//ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
				//CheckError(idx, ret, __LINE__);

				vih = 2.5;
				vil = 0.00;
				voh = 0.75; 
				vol = 0.75;
				ioh = 0.002;
				iol = 0.002;
				vch = 6;
				vcl = -0.1;
				vt = 0;

				ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOn("SPE");
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOn("SPD");
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOn("SPC");
				CheckError(idx, ret, __LINE__);

				//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
				//ret = dm[idx]->DPINOff("FLTMUX");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("MODE");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("WDX");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("WDY");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("RWN");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("SPD");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("SPC");
				//CheckError(idx, ret, __LINE__);
				//ret = dm[idx]->DPINOff("SPE");
				//CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOff("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPE");
				CheckError(idx, ret, __LINE__);
			}
		}

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				ret = OnOffFETGnd(idx, 1);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->OnSmuPin("VCC", true, false);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin("VEE", true, false);
				CheckError(idx, ret, __LINE__);

				ret = SetupDigital(idx);
				CheckError(idx, ret, __LINE__);
				ret = DriveCBit(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(On_Delay_s);

				int retestCount = 0;
				double max_limit = 0;
				double min_limit = 0;

				for (int i=0; i<total_tp; i++)
				{
				
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
RETEST:	
						if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
						{
							NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
						
							ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
							CheckError(idx, ret, __LINE__);

							ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

							ret = dm[idx]->DPINOn("SPE");
							ret = dm[idx]->DPINOn("SPD");
							ret = dm[idx]->DPINOn("SPC");

							if(On_SPI_Once[idx] == 0)
							{
								if(USE_SPI)
								{
									ret = OnOffSPI(idx, 1);
									CheckError(idx, ret, __LINE__);
								}

								ret = DriveDMPin2(idx, TPDispName[0]);
								CheckError(idx, ret, __LINE__);
								On_SPI_Once[idx] = 1;
							}

							if((TPDispName[i]->Contains("3p3") == true) || (TPDispName[i]->Contains("Icc_i^") == true) || (TPDispName[i]->Contains("Iee_i^") == true) ||
								(TPDispName[i]->Contains("Icc_s^") == true) || (TPDispName[i]->Contains("Iee_s^") == true)) //follow Catalyst to remove pin loading for icc_s_3p3 & iee_s_3p3
							{
								ret = dm[idx]->DPINOn("SPE");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("SPD");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("SPC");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("RWN");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("WDX");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("WDY");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOff("FLTMUX");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOff("MODE");
								CheckError(idx, ret, __LINE__);
							}
							else 
							{
								ret = dm[idx]->DPINOn("SPE");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("SPD");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("SPC");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("RWN");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("WDX");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("WDY");
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOff("FLTMUX");//Follow Catalyst's code
								CheckError(idx, ret, __LINE__);
								ret = dm[idx]->DPINOn("MODE");
								CheckError(idx, ret, __LINE__);
							}

							//Set Icmpl to 0.5A before any register changes
							ret = smu[idx]->ClampCurrent("VCC", 0.5);
							CheckError(idx, ret, __LINE__);

							//Set Icmpl to 0.5A before any register changes
							ret = smu[idx]->ClampCurrent("VEE", 0.5);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(0.001);

							//if(!USE_SPI)
							//{
							//	ret = RunVectorFile(idx, Vector_File);
							//	CheckError(idx, ret, __LINE__);
							//}
							//else
							//{
							//	ret = RunSPI(idx, Vector_File);
							//	CheckError(idx, ret, __LINE__);
							//}
						}

						if (tf_TPCondition_exist(TPName[i], "Drive_WRN_V") == true)
						{
							Drive_WRN_V[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_WRN_V");
							ret = dm[idx]->DrivePin("RWN", Drive_WRN_V[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Drive_PWR_SAVE") == true)
						{
							Drive_PWR_SAVE[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_PWR_SAVE");
							ret = dm[idx]->DrivePin("MODE", Drive_PWR_SAVE[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Clamp_Vcc_Current_A") == true)
						{
							Clamp_Vcc_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vcc_Current_A"));
							ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Clamp_Vee_Current_A") == true)
						{
							Clamp_Vee_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vee_Current_A"));
							ret = smu[idx]->ClampCurrent("VEE", Clamp_Vee_Current_A);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Drive_Vcc2_V") == true)
						{
							Drive_Vcc2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc2_V"));
							ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc2_V);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Drive_Vee2_V") == true)
						{
							Drive_Vee2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee2_V"));
							ret = smu[idx]->DriveVoltage("VEE", Drive_Vee2_V);
							CheckError(idx, ret, __LINE__);
						}

						if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
						{
							Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
							_util->Wait_Sec(Measure_Delay_s);
						}

						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							if(!USE_SPI)
							{
								ret = RunVectorFile(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
							else
							{
								ret = RunSPI(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
						}
						if (tf_TPCondition_exist(TPName[i], "Measure_Pin") == true)
						{
							Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));
			
							if (Measure_Pin == "VCC")
							{
								ret = smu[idx]->ReadCurrent("VCC", result[i]);
								CheckError(idx, ret, __LINE__);
							}

							if (Measure_Pin == "VEE")
							{
								//if (i == 1 || i == 3)
								if (i == 0 || i == 1)
								{
									_util->Wait_Sec(1e-3);		//ML 0.05		//0.3e-3
								}

								ret = smu[idx]->ReadCurrent("VEE", result[i]);
								CheckError(idx, ret, __LINE__);
							}

							if (Debug_Enable == true)
							{
								double volt_vcc = 0;
								double volt_vee = 0;
								ret = smu[idx]->ReadVoltage("VCC", volt_vcc);
								CheckError(idx, ret, __LINE__);
								ret = smu[idx]->ReadVoltage("VEE", volt_vee);
								CheckError(idx, ret, __LINE__);
							}
						}

						if (tf_TPCondition_exist(TPName[i], "Measure_Pin_1") == true)
						{
							Measure_Pin_1	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_1"));
							
							if (Measure_Pin_1 == "VCC")
							{
								ret = smu[idx]->ReadCurrent("VCC", result2[i]);
								CheckError(idx, ret, __LINE__);
							}

							if (Measure_Pin_1 == "VEE")
							{
								ret = smu[idx]->ReadCurrent("VEE", result2[i]);
								CheckError(idx, ret, __LINE__);
							}
						}

						if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
						{
							Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));

							if(!USE_SPI)
							{
								ret = RunVectorFile(idx, Vector_File_1);
								CheckError(idx, ret, __LINE__);
							}
							else
							{
								ret = RunSPI(idx, Vector_File_1);
								CheckError(idx, ret, __LINE__);
							}

							_util->Wait_Sec(Measure_Delay_s);

							if (Measure_Pin == "VCC")
							{
								ret = smu[idx]->ReadCurrent("VCC", result3[i]);
								CheckError(idx, ret, __LINE__);
							}

							if (Measure_Pin == "VEE")
							{
								ret = smu[idx]->ReadCurrent("VEE", result3[i]);
								CheckError(idx, ret, __LINE__);
							}

							if (Measure_Pin_1 == "VCC")
							{
								ret = smu[idx]->ReadCurrent("VCC", result4[i]);
								CheckError(idx, ret, __LINE__);
							}

							if (Measure_Pin_1 == "VEE")
							{
								ret = smu[idx]->ReadCurrent("VEE", result4[i]);
								CheckError(idx, ret, __LINE__);
							}

							result[i] = result[i] - result3[i];

							result2[i] = result2[i] - result4[i];
						}

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
						{
							Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
							
							_glob->Global_Result[idx, Global_Result_Index] = result[i];
						}	

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_1") == true)
						{
							Global_Result_Index_1 = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_1"));
							
							_glob->Global_Result[idx, Global_Result_Index_1] = result2[i];
						}	

						if (tf_TPCondition_exist(TPName[i], "Operation") == true)
						{
							String ^ Global_Result_Index_A = String::Empty;
							String ^ Global_Result_Index_B = String::Empty;

							int A = 0;
							int B = 0;

							Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

							if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_A") == true)
							{
								Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A")); 
							}

							if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_B") == true)
							{
								Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));			
							}				

							if (Operation == "-A")
							{
								A = _util->StrToInt(Global_Result_Index_A);

								result[i] = result[i] - _glob->Global_Result[idx, A];
							}

							if (Operation == "=")
							{
								A = _util->StrToInt(Global_Result_Index_A);

								result[i] = _glob->Global_Result[idx, A];
							}
							
							if (Operation == "A-B")
							{
								A = _util->StrToInt(Global_Result_Index_A);
								B = _util->StrToInt(Global_Result_Index_B);

								if (TPDispName[i]->StartsWith("Pd"))
								{
									result[i] = _glob->Global_Result[idx, A]*Drive_Vcc_V - _glob->Global_Result[idx, B]*-Drive_Vee_V;
								}
								else
								{
									result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
								}
							}

							if (Operation == "ABS(A-B)")
							{
								A = _util->StrToInt(Global_Result_Index_A);
								B = _util->StrToInt(Global_Result_Index_B);

								result[i] = Math::Abs(_glob->Global_Result[idx, A] - _glob->Global_Result[idx, B]);
							}

							if (Operation == "MAX[A]-MIN[B]")
							{
								double max = 0;
								double min = 0;

								array<String ^> ^ ArrStr = gcnew array<String ^>(0);
								array<String ^> ^ Separator = gcnew array<String ^>(1);
								Separator[0] = ",";

								ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

								for (int j=0; j<ArrStr->Length; j++)
								{
									if (j == 0)
									{
										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
									}
									else
									{
										if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
											max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
									}
								}

								ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);

								for (int j=0; j<ArrStr->Length; j++)
								{
									if (j == 0)
									{
										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
									}
									else
									{
										if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
											min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
									}
								}

								result[i] = max - min;
							}
						}

						// check retest
						max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
						min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));
						
						if   ((( result[i] > max_limit ) || ( result[i] < min_limit ))  && (retestCount < 3) && (i != 12)) 
						{
							retestCount++;
							goto RETEST;
						}else{
							retestCount = 0;
						}
					
						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);


					}
				}

				//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
				ret = dm[idx]->DPINOff("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff("SPE");
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(5e-3);

				ret = smu[idx]->ClampCurrent("VCC", 0.5);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->ClampCurrent("VEE", 0.5);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->DriveVoltage("VCC", 0);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(5e-3); //discharge cap

				ret = smu[idx]->DriveVoltage("VEE", 0);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(5e-3); //discharge cap
				ret = smu[idx]->OffSmuPin("VCC");
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OffSmuPin("VEE");
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
		}

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				ret = smu[idx]->OnSmuPin("VCC", true, false);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin("VEE", true, false);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
				CheckError(idx, ret, __LINE__);

				ret = OnOffFETGnd(idx, 1);
				CheckError(idx, ret, __LINE__);

				if(USE_SPI)
				{
					ret = OnOffSPI(idx, 0);
					CheckError(idx, ret, __LINE__);
				}

				ret = dm[idx]->DPINOn("FLTMUX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("MODE");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("WDX");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("WDY");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("RWN");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPD");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPC");
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPE");
				CheckError(idx, ret, __LINE__);

				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//Power down supplies
				//ret = smu[idx]->ClampCurrent("VCC", 0.5);
				//CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ClampCurrent("VEE", 0.5);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(5e-3);

				//ret = smu[idx]->DriveVoltage("VEE", 0);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->DriveVoltage("VCC", 0);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(5e-3); //discharge cap

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		return 0;
	}
	int TestProgram::seq_power_pd(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::power_pd), site);
	}

//	int TestProgram::seq_power_vee(Site ^ site)
//	{
//		int ret = 0;
//
//		//Get test name from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//		array<double> ^ result = gcnew array<double>(total_tp);
//		array<double> ^ result2 = gcnew array<double>(total_tp);
//		array<double> ^ result3 = gcnew array<double>(total_tp);
//		array<double> ^ result4 = gcnew array<double>(total_tp);
//		array<int> ^ Drive_WRN_V = gcnew array<int>(total_tp);
//		array<int> ^ Drive_PWR_SAVE = gcnew array<int>(total_tp);
//		array<int> ^ data_pg1 = gcnew array<int>(32);
//		array<int> ^ data_pg2 = gcnew array<int>(32);
//		array<int> ^ data_pg4 = gcnew array<int>(32);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//			result[i] = 0;
//			result2[i] = 0;
//			result3[i] = 0;
//			result4[i] = 0;
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//		double Clamp_Vee_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vee_Current_A"));
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//		double Measure_Delay_s	= 0;
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//		bool isCurrentTPBypassed = false;
//
//		double Input_Channel_Delay_s = 0;
//
//		String ^ Vector_File	= String::Empty;
//		String ^ Vector_File_1	= String::Empty;
//		String ^ Measure_Pin	= String::Empty;
//		String ^ Measure_Pin_1	= String::Empty;
//		int Global_Result_Index = 0;
//		int Global_Result_Index_1 = 0;
//		String ^ Operation		= String::Empty; 
//
//		double Drive_Vcc2_V		= 0;
//		double Drive_Vee2_V		= 0;
//		array<int> ^ On_SPI_Once = gcnew array<int> (_numOffset);
//
//		double vih;
//		double vil;
//		double voh; 
//		double vol;
//		double ioh;
//		double iol;
//		double vch;
//		double vcl;
//		double vt;
//		
//		int vector_engine_status = 0;
//
//		Stopwatch swatch;
//
//		array<bool>^ run_test = gcnew array<bool>(_numOffset);
//		IsRunTest(site, run_test);
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			ret = smu[idx]->OffSmuPin("VCC");
//			CheckError(idx, ret, __LINE__);
//			ret = smu[idx]->OffSmuPin("VEE");
//			CheckError(idx, ret, __LINE__);
//
//			ret = OnOffFETGnd(idx, 0);
//			CheckError(idx, ret, __LINE__);
//
//			ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
//			CheckError(idx, ret, __LINE__);
//		
//			ret = dm[idx]->DPINOff("FLTMUX");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("MODE");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("WDX");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("WDY");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("RWN");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("SPD");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("SPC");
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINOff("SPE");
//			CheckError(idx, ret, __LINE__);
//
//
//		}
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
//
//			On_SPI_Once[idx] = 0;
//
//			if(run_test[idx])
//			{
//				//IO setting
//			
//				//Setup Power supplies
//				//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->ClampCurrent("VCC", 0.5);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->DriveVoltage("VCC", 0);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->OnSmuPin("VCC", true, false);
//				//CheckError(idx, ret, __LINE__);
//
//				//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->ClampCurrent("VEE", 0.5);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->DriveVoltage("VEE", 0);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->OnSmuPin("VEE", true, false);
//				//CheckError(idx, ret, __LINE__);
//				//_util->Wait_Sec(0.001);
//
//				//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
//				//CheckError(idx, ret, __LINE__);
//
//				//ret = smu[idx]->OffSmuPin("VCC");
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->OffSmuPin("VEE");
//				//CheckError(idx, ret, __LINE__);
//
//				//ret = OnOffFETGnd(idx, 0);
//				//CheckError(idx, ret, __LINE__);
//
//				//ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
//				//CheckError(idx, ret, __LINE__);
//
//				vih = 2.5;
//				vil = 0.00;
//				voh = 0.75; 
//				vol = 0.75;
//				ioh = 0.002;
//				iol = 0.002;
//				vch = 6;
//				vcl = -0.1;
//				vt = 0;
//
//				ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//				CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOn("SPE");
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//				CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOn("SPD");
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//				CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOn("SPC");
//				CheckError(idx, ret, __LINE__);
//
//				//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
//				//ret = dm[idx]->DPINOff("FLTMUX");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("MODE");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("WDX");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("WDY");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("RWN");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("SPD");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("SPC");
//				//CheckError(idx, ret, __LINE__);
//				//ret = dm[idx]->DPINOff("SPE");
//				//CheckError(idx, ret, __LINE__);
//			}
//			else
//			{
//				ret = smu[idx]->OffSmuPin("VCC");
//				CheckError(idx, ret, __LINE__);
//
//				ret = smu[idx]->OffSmuPin("VEE");
//				CheckError(idx, ret, __LINE__);
//
//				ret = OnOffFETGnd(idx, 0);
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->DPINOff("FLTMUX");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("MODE");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("WDX");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("WDY");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("RWN");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("SPD");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("SPC");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("SPE");
//				CheckError(idx, ret, __LINE__);
//			}
//		}
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if(run_test[idx])
//			{
//				ret = OnOffFETGnd(idx, 1);
//				CheckError(idx, ret, __LINE__);
//
//				ret = smu[idx]->OnSmuPin("VCC", true, false);
//				CheckError(idx, ret, __LINE__);
//				ret = smu[idx]->OnSmuPin("VEE", true, false);
//				CheckError(idx, ret, __LINE__);
//
//				ret = SetupDigital(idx);
//				CheckError(idx, ret, __LINE__);
//				ret = DriveCBit(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//				ret = DriveMuxIO(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//
//				ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
//				CheckError(idx, ret, __LINE__);
//				ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
//				CheckError(idx, ret, __LINE__);
//
//				_util->Wait_Sec(On_Delay_s);
//
//				int retestCount = 0;
//				double max_limit = 0;
//				double min_limit = 0;
//
//				for (int i=0; i<total_tp; i++)
//				{
//				
//					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
//
//					if (isCurrentTPBypassed == false)
//					{
//RETEST:	
//						if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
//						{
//							NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
//
//							//ret = smu[idx]->ConfigurePLF("VEE", Power_Line_Freq);
//							//CheckError(idx, ret, __LINE__);
//						
//							ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
//							CheckError(idx, ret, __LINE__);
//
//							//ret = smu[idx]->ConfigurePLF("VCC", Power_Line_Freq);
//							//CheckError(idx, ret, __LINE__);
//							ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
//						{
//							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
//
//							ret = dm[idx]->DPINOn("SPE");
//							ret = dm[idx]->DPINOn("SPD");
//							ret = dm[idx]->DPINOn("SPC");
//
//							if(On_SPI_Once[idx] == 0)
//							{
//								if(USE_SPI)
//								{
//									ret = OnOffSPI(idx, 1);
//									CheckError(idx, ret, __LINE__);
//								}
//
//								ret = DriveDMPin2(idx, TPDispName[0]);
//								CheckError(idx, ret, __LINE__);
//								On_SPI_Once[idx] = 1;
//							}
//
//							if((TPDispName[i]->Contains("3p3") == true) || (TPDispName[i]->Contains("Icc_i^") == true) || (TPDispName[i]->Contains("Iee_i^") == true) ||
//								(TPDispName[i]->Contains("Icc_s^") == true) || (TPDispName[i]->Contains("Icc_s^") == true)) //follow Catalyst to remove pin loading for icc_s_3p3 & iee_s_3p3
//							{
//								ret = dm[idx]->DPINOn("SPE");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("SPD");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("SPC");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("RWN");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("WDX");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("WDY");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOff("FLTMUX");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOff("MODE");
//								CheckError(idx, ret, __LINE__);
//							}
//							else 
//							{
//								ret = dm[idx]->DPINOn("SPE");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("SPD");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("SPC");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("RWN");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("WDX");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("WDY");
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOff("FLTMUX");//Follow Catalyst's code
//								CheckError(idx, ret, __LINE__);
//								ret = dm[idx]->DPINOn("MODE");
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (tf_TPCondition_exist(TPName[i], "Drive_WRN_V") == true)
//							{
//								Drive_WRN_V[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_WRN_V");
//								ret = dm[idx]->DrivePin("RWN", Drive_WRN_V[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (tf_TPCondition_exist(TPName[i], "Drive_PWR_SAVE") == true)
//							{
//								Drive_PWR_SAVE[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_PWR_SAVE");
//								ret = dm[idx]->DrivePin("MODE", Drive_PWR_SAVE[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							//Set Icmpl to 0.5A before any register changes
//							ret = smu[idx]->ClampCurrent("VCC", 0.5);
//							CheckError(idx, ret, __LINE__);
//							//_util->Wait_Sec(0.001);
//
//							//Set Icmpl to 0.5A before any register changes
//							ret = smu[idx]->ClampCurrent("VEE", 0.5);
//							CheckError(idx, ret, __LINE__);
//							_util->Wait_Sec(0.001);
//
//							if(!USE_SPI)
//							{
//								ret = RunVectorFile(idx, Vector_File);
//								CheckError(idx, ret, __LINE__);
//							}
//							else
//							{
//								ret = RunSPI(idx, Vector_File);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							//ret = RunVectorFile(idx, Vector_File);
//							//CheckError(idx, ret, __LINE__);
//						}
//
//						////pg1
//						//ret = ReadVector(idx, "read_p1_reg0", data_pg1[0]);
//						//ret = ReadVector(idx, "read_p1_reg1", data_pg1[1]);
//						//ret = ReadVector(idx, "read_p1_reg2", data_pg1[2]);
//						//ret = ReadVector(idx, "read_p1_reg3", data_pg1[3]);
//						//ret = ReadVector(idx, "read_p1_reg4", data_pg1[4]);
//						//ret = ReadVector(idx, "read_p1_reg5", data_pg1[5]);
//						//ret = ReadVector(idx, "read_p1_reg6", data_pg1[6]);
//						//ret = ReadVector(idx, "read_p1_reg7", data_pg1[7]);
//						//ret = ReadVector(idx, "read_p1_reg8", data_pg1[8]);
//						//ret = ReadVector(idx, "read_p1_reg9", data_pg1[9]);
//						//ret = ReadVector(idx, "read_p1_reg10", data_pg1[10]);
//						//ret = ReadVector(idx, "read_p1_reg11", data_pg1[11]);
//						//ret = ReadVector(idx, "read_p1_reg12", data_pg1[12]);
//						//ret = ReadVector(idx, "read_p1_reg13", data_pg1[13]);
//						//ret = ReadVector(idx, "read_p1_reg14", data_pg1[14]);
//						//ret = ReadVector(idx, "read_p1_reg15", data_pg1[15]);
//						//ret = ReadVector(idx, "read_p1_reg16", data_pg1[16]);
//						//ret = ReadVector(idx, "read_p1_reg17", data_pg1[17]);
//						//ret = ReadVector(idx, "read_p1_reg18", data_pg1[18]);
//						//ret = ReadVector(idx, "read_p1_reg19", data_pg1[19]);
//						//ret = ReadVector(idx, "read_p1_reg20", data_pg1[20]);
//						//ret = ReadVector(idx, "read_p1_reg21", data_pg1[21]);
//						//ret = ReadVector(idx, "read_p1_reg22", data_pg1[22]);
//						//ret = ReadVector(idx, "read_p1_reg23", data_pg1[23]);
//						//ret = ReadVector(idx, "read_p1_reg24", data_pg1[24]);
//						//ret = ReadVector(idx, "read_p1_reg25", data_pg1[25]);
//						//ret = ReadVector(idx, "read_p1_reg26", data_pg1[26]);
//						//ret = ReadVector(idx, "read_p1_reg27", data_pg1[27]);
//						//ret = ReadVector(idx, "read_p1_reg28", data_pg1[28]);
//						//ret = ReadVector(idx, "read_p1_reg29", data_pg1[29]);
//						//ret = ReadVector(idx, "read_p1_reg30", data_pg1[30]);
//						//ret = ReadVector(idx, "read_p1_reg31", data_pg1[31]);
//						////pg2
//						//ret = ReadVector(idx, "read_p2_reg32", data_pg2[0]);
//						//ret = ReadVector(idx, "read_p2_reg33", data_pg2[1]);
//						//ret = ReadVector(idx, "read_p2_reg34", data_pg2[2]);
//						//ret = ReadVector(idx, "read_p2_reg38", data_pg2[6]);
//						//ret = ReadVector(idx, "read_p2_reg39", data_pg2[7]);
//						//ret = ReadVector(idx, "read_p2_reg40", data_pg2[8]);
//						//ret = ReadVector(idx, "read_p2_reg54", data_pg2[22]);
//						//ret = ReadVector(idx, "read_p2_reg56", data_pg2[24]);
//						//ret = ReadVector(idx, "read_p2_reg57", data_pg2[25]);
//						//ret = ReadVector(idx, "read_p2_reg58", data_pg2[26]);
//						//ret = ReadVector(idx, "read_p2_reg59", data_pg2[27]);
//						//ret = ReadVector(idx, "read_p2_reg60", data_pg2[28]);
//						//ret = ReadVector(idx, "read_p2_reg61", data_pg2[29]);
//						//ret = ReadVector(idx, "read_p2_reg62", data_pg2[30]);
//						//ret = ReadVector(idx, "read_p2_reg63", data_pg2[31]);
//						////pg4
//						//ret = RunVectorFile(idx, "write_p2_reg63_extregsp_enable_h");
//						//ret = ReadVector(idx, "read_p4_reg16", data_pg4[16]);
//						//ret = ReadVector(idx, "read_p4_reg17", data_pg4[17]);
//						//ret = ReadVector(idx, "read_p4_reg18", data_pg4[18]);
//						//ret = ReadVector(idx, "read_p4_reg25", data_pg4[25]);
//						//ret = ReadVector(idx, "read_p4_reg26", data_pg4[26]);
//						//ret = ReadVector(idx, "read_p4_reg27", data_pg4[27]);
//						//ret = ReadVector(idx, "read_p4_reg28", data_pg4[28]);
//						//ret = ReadVector(idx, "read_p4_reg29", data_pg4[29]);
//						//ret = ReadVector(idx, "read_p4_reg30", data_pg4[30]);
//						if (tf_TPCondition_exist(TPName[i], "Clamp_Vcc_Current_A") == true)
//						{
//							////Set Icmpl to 0.5A before any register changes
//							//ret = smu[idx]->ClampCurrent("VCC", 0.5);
//							//CheckError(idx, ret, __LINE__);
//							//_util->Wait_Sec(0.001);
//
//							Clamp_Vcc_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vcc_Current_A"));
//							ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Clamp_Vee_Current_A") == true)
//						{
//							////Set Icmpl to 0.5A before any register changes
//							//ret = smu[idx]->ClampCurrent("VEE", 0.5);
//							//CheckError(idx, ret, __LINE__);
//							//_util->Wait_Sec(0.001);
//
//							Clamp_Vee_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vee_Current_A"));
//							ret = smu[idx]->ClampCurrent("VEE", Clamp_Vee_Current_A);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Drive_Vcc2_V") == true)
//						{
//							Drive_Vcc2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc2_V"));
//							ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc2_V);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Drive_Vee2_V") == true)
//						{
//							Drive_Vee2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee2_V"));
//							ret = smu[idx]->DriveVoltage("VEE", Drive_Vee2_V);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
//						{
//							Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
//							_util->Wait_Sec(Measure_Delay_s);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Measure_Pin") == true)
//						{
//							Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));
//
//							//array<double> ^ tmpI = gcnew array<double>(1024);
//							//array<double> ^ tmpV = gcnew array<double>(1024);
//							//ret = smu[idx]->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);
//
//							//for (int z=0; z<1024; z++)
//							//{
//							//	_util->Wait_Sec(10e-6);
//							//	ret = smu[idx]->ReadCurrent("VEE", tmpI[z]);
//							//	ret = smu[idx]->ReadVoltage("VEE", tmpV[z]);
//							//}
//
//							//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//							
//							if (Measure_Pin == "VCC")
//							{
//								ret = smu[idx]->ReadCurrent("VCC", result[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (Measure_Pin == "VEE")
//							{
//								//if (i == 1 || i == 3)
//								if (i == 0 || i == 1)
//								{
//									//ret = smu[idx]->ConfigureOutputEnabled("VEE", false);
//									//ret = smu[idx]->ConfigureSamplingTime("VEE", 1, AM_CONST_PLC);
//									//CheckError(idx, ret, __LINE__);
//
//									//_util->Wait_Sec(0.2);
//									_util->Wait_Sec(0.05);
//								}
//
//								ret = smu[idx]->ReadCurrent("VEE", result[i]);
//								CheckError(idx, ret, __LINE__);
//								
//								//if (i == 1 || i == 3)
//								//{
//								//	array<double> ^ tmpI = gcnew array<double>(4096);
//								//	array<double> ^ tmpV = gcnew array<double>(4096);
//								//	ret = smu[idx]->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);
//
//								//	for (int z=0; z<4096; z++)
//								//	{
//								//		_util->Wait_Sec(100e-6);
//								//		ret = smu[idx]->ReadCurrent("VEE", tmpI[z]);
//								//		ret = smu[idx]->ReadVoltage("VEE", tmpV[z]);
//								//	}
//
//								//	ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//								//}
//
//								//double volt = 0;
//								//ret = smu[idx]->ReadVoltage("VEE", volt);
//								//CheckError(idx, ret, __LINE__);
//
//								//if (i == 1 || i == 3)
//								//{
//									//ret = smu[idx]->ConfigureOutputEnabled("VEE", true);
//									//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
//									//CheckError(idx, ret, __LINE__);
//								//}
//							}
//
//							if (Debug_Enable == true)
//							{
//								double volt_vcc = 0;
//								double volt_vee = 0;
//								ret = smu[idx]->ReadVoltage("VCC", volt_vcc);
//								CheckError(idx, ret, __LINE__);
//								ret = smu[idx]->ReadVoltage("VEE", volt_vee);
//								CheckError(idx, ret, __LINE__);
//							}
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Measure_Pin_1") == true)
//						{
//							Measure_Pin_1	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_1"));
//							
//							if (Measure_Pin_1 == "VCC")
//							{
//								ret = smu[idx]->ReadCurrent("VCC", result2[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (Measure_Pin_1 == "VEE")
//							{
//								ret = smu[idx]->ReadCurrent("VEE", result2[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
//						{
//							Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
//
//							if(!USE_SPI)
//							{
//								ret = RunVectorFile(idx, Vector_File_1);
//								CheckError(idx, ret, __LINE__);
//							}
//							else
//							{
//								ret = RunSPI(idx, Vector_File_1);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							_util->Wait_Sec(Measure_Delay_s);
//
//							if (Measure_Pin == "VCC")
//							{
//								ret = smu[idx]->ReadCurrent("VCC", result3[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (Measure_Pin == "VEE")
//							{
//								ret = smu[idx]->ReadCurrent("VEE", result3[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (Measure_Pin_1 == "VCC")
//							{
//								ret = smu[idx]->ReadCurrent("VCC", result4[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							if (Measure_Pin_1 == "VEE")
//							{
//								ret = smu[idx]->ReadCurrent("VEE", result4[i]);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							result[i] = result[i] - result3[i];
//
//							result2[i] = result2[i] - result4[i];
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
//						{
//							Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
//							
//							_glob->Global_Result[idx, Global_Result_Index] = result[i];
//						}	
//
//						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_1") == true)
//						{
//							Global_Result_Index_1 = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_1"));
//							
//							_glob->Global_Result[idx, Global_Result_Index_1] = result2[i];
//						}	
//
//						if (tf_TPCondition_exist(TPName[i], "Operation") == true)
//						{
//							String ^ Global_Result_Index_A = String::Empty;
//							String ^ Global_Result_Index_B = String::Empty;
//
//							int A = 0;
//							int B = 0;
//
//							Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));
//
//							if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_A") == true)
//							{
//								Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A")); 
//							}
//
//							if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_B") == true)
//							{
//								Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));			
//							}				
//
//							if (Operation == "-A")
//							{
//								A = _util->StrToInt(Global_Result_Index_A);
//
//								result[i] = result[i] - _glob->Global_Result[idx, A];
//							}
//
//							if (Operation == "=")
//							{
//								A = _util->StrToInt(Global_Result_Index_A);
//
//								result[i] = _glob->Global_Result[idx, A];
//							}
//							
//							if (Operation == "A-B")
//							{
//								A = _util->StrToInt(Global_Result_Index_A);
//								B = _util->StrToInt(Global_Result_Index_B);
//
//								if (TPDispName[i]->StartsWith("Pd"))
//								{
//									result[i] = _glob->Global_Result[idx, A]*Drive_Vcc_V - _glob->Global_Result[idx, B]*-Drive_Vee_V;
//								}
//								else
//								{
//									result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
//								}
//							}
//
//							if (Operation == "ABS(A-B)")
//							{
//								A = _util->StrToInt(Global_Result_Index_A);
//								B = _util->StrToInt(Global_Result_Index_B);
//
//								result[i] = Math::Abs(_glob->Global_Result[idx, A] - _glob->Global_Result[idx, B]);
//							}
//
//							if (Operation == "MAX[A]-MIN[B]")
//							{
//								double max = 0;
//								double min = 0;
//
//								array<String ^> ^ ArrStr = gcnew array<String ^>(0);
//								array<String ^> ^ Separator = gcnew array<String ^>(1);
//								Separator[0] = ",";
//
//								ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);
//
//								for (int j=0; j<ArrStr->Length; j++)
//								{
//									if (j == 0)
//									{
//										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//									}
//									else
//									{
//										if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
//											max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//									}
//								}
//
//								ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);
//
//								for (int j=0; j<ArrStr->Length; j++)
//								{
//									if (j == 0)
//									{
//										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//									}
//									else
//									{
//										if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
//											min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//									}
//								}
//
//								result[i] = max - min;
//							}
//						}
//
//						// check retest
//						max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
//						min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));
//						
//						if   ((( result[i] > max_limit ) || ( result[i] < min_limit ))  && (retestCount < 3) && (i != 12)) 
//						{
//							retestCount++;
//							goto RETEST;
//						}else{
//							retestCount = 0;
//						}
//					
//						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
//
//
//					}
//				}
//
//				//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
//				ret = dm[idx]->DPINOff("FLTMUX");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("MODE");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("WDX");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("WDY");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("RWN");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("SPD");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("SPC");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOff("SPE");
//				CheckError(idx, ret, __LINE__);
//
//				_util->Wait_Sec(5e-3);
//
//				ret = smu[idx]->ClampCurrent("VCC", 0.5);
//				CheckError(idx, ret, __LINE__);
//
//				ret = smu[idx]->ClampCurrent("VEE", 0.5);
//				CheckError(idx, ret, __LINE__);
//
//				ret = smu[idx]->DriveVoltage("VCC", 0);
//				CheckError(idx, ret, __LINE__);
//
//				_util->Wait_Sec(5e-3); //discharge cap
//
//				ret = smu[idx]->DriveVoltage("VEE", 0);
//				CheckError(idx, ret, __LINE__);
//
//				_util->Wait_Sec(5e-3); //discharge cap
//				ret = smu[idx]->OffSmuPin("VCC");
//				CheckError(idx, ret, __LINE__);
//				ret = smu[idx]->OffSmuPin("VEE");
//				CheckError(idx, ret, __LINE__);
//
//				ret = OnOffFETGnd(idx, 0);
//				CheckError(idx, ret, __LINE__);
//			}
//		}
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if(run_test[idx])
//			{
//				ret = smu[idx]->OnSmuPin("VCC", true, false);
//				CheckError(idx, ret, __LINE__);
//				ret = smu[idx]->OnSmuPin("VEE", true, false);
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
//				CheckError(idx, ret, __LINE__);
//
//				ret = OnOffFETGnd(idx, 1);
//				CheckError(idx, ret, __LINE__);
//
//				if(USE_SPI)
//				{
//					ret = OnOffSPI(idx, 0);
//					CheckError(idx, ret, __LINE__);
//				}
//
//				ret = dm[idx]->DPINOn("FLTMUX");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("MODE");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("WDX");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("WDY");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("RWN");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("SPD");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("SPC");
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("SPE");
//				CheckError(idx, ret, __LINE__);
//
//				ret = ResetDMPin(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//
//				//Power down supplies
//				//ret = smu[idx]->ClampCurrent("VCC", 0.5);
//				//CheckError(idx, ret, __LINE__);
//
//				//ret = smu[idx]->ClampCurrent("VEE", 0.5);
//				//CheckError(idx, ret, __LINE__);
//
//				//_util->Wait_Sec(5e-3);
//
//				//ret = smu[idx]->DriveVoltage("VEE", 0);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->DriveVoltage("VCC", 0);
//				//CheckError(idx, ret, __LINE__);
//
//				//_util->Wait_Sec(5e-3); //discharge cap
//
//				//IO setting
//				ret = ResetCBit(idx);
//				CheckError(idx, ret, __LINE__);
//				ret = ResetMuxIO(idx);
//				CheckError(idx, ret, __LINE__);
//			}
//		}
//
//		return 0;
//	}

	int TestProgram::seq_src_curr_meas_volt(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::src_curr_meas_volt), site);
	}
	int TestProgram::seq_amux_current1(Site ^ site) 
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::amux_current1), site);
	}
	int TestProgram::seq_rd2wr_bias(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rd2wr_bias), site);
	}
	int TestProgram::seq_dmux(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::dmux), site);
	}
	int TestProgram::seq_dgf(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::dgf), site);
	}
	int TestProgram::seq_dgt(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::dgt), site);
	}
	int TestProgram::seq_adc_ramp(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::adc_ramp), site);
	}
	int TestProgram::seq_ir_sup3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::ir_sup3_ttr), site);
	}
	int TestProgram::seq_ir_hds4_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::ir_hds4_ttr), site);
	}
	int TestProgram::seq_mrhv3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::mrhv3_ttr), site);
	}
	int TestProgram::seq_reader_cpp(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::reader_cpp), site);
	}
	int TestProgram::seq_autocal(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::autocal), site);
	}
	int TestProgram::seq_reader_vos_spd(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::reader_vos_spd), site);
	}
	int TestProgram::seq_reader_vocm(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::reader_vocm), site);
	}
	int TestProgram::seq_rout(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rout), site);
	}
	int TestProgram::seq_awg_input_meas(Site ^ site)
	{
		int result = 1;

		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				tf_SetResult_UUTOffset(TPName[0], result + (int)GetOffset(idx, TPDispName[0]), idx);
			}
		}
		
		return 0;
	}
	//Gain
	int TestProgram::seq_gain_sup3(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::gain_sup3), site);
	}
	int TestProgram::seq_gain_hds2(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::gain_hds2), site);
	}
	int TestProgram::seq_gain_hds_zdin2(Site ^ site)
	{		
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::gain_hds_zdin2), site);
	}
	int TestProgram::seq_gain_hds_vir_vor2(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::gain_hds_vir_vor2), site);
	}
	int TestProgram::seq_fhsgain_sup2(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhsgain_sup2), site);
	}
	int TestProgram::seq_fhsgain_spd(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhsgain_spd), site);
	}
	int TestProgram::seq_hi_spd_mux(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::hi_spd_mux), site);
	}
	int TestProgram::seq_lfp_ibias_vbias(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::lfp_ibias_vbias), site);
	}
	int TestProgram::seq_iw_step3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::iw_step3_ttr), site);
	}
	int TestProgram::seq_iw_supply3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::iw_supply3_ttr), site);
	}
//	int TestProgram::seq_ro(Site ^ site)
//	{
//		int ret = 0;
//
//		//Get test name from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//		array<double> ^ result = gcnew array<double>(total_tp);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//			result[i] = 0;
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//		double Input_Channel_Delay_s = 0;
//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
//
//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
//		//String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
//		String ^ Vector_File1	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
//		String ^ Vector_File	= "";
//
//		int step				= (int)(tf_TestItemCondition_Cast("step"));
//		array<double> ^ result_iwx		= gcnew array<double>(step);
//		array<double> ^ result_Viw_open = gcnew array<double>(step);
//
//		for (int i=0; i<step; i++)
//		{
//			result_iwx[i] = 0;
//			result_Viw_open[i] = 0;
//		}
//					
//		double vih;
//		double vil;
//		double voh; 
//		double vol;
//		double ioh;
//		double iol;
//		double vch;
//		double vcl;
//		double vt;
//
//		int vector_engine_status = 0;
//
//		Stopwatch swatch;
// 			
//		unsigned int moduleTypeP = 0;
//		unsigned int moduleTypeN = 0;	
//
//		array<bool>^ run_test = gcnew array<bool>(_numOffset);
//		IsRunTest(site, run_test);			
//					
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
//
//			if(run_test[idx])
//			{
//				//IO setting
//				ret = SetupDigital(idx);
//				CheckError(idx, ret, __LINE__);
//				ret = DriveCBit(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//				ret = DriveMuxIO(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//
//				//Setup Power supplies
//				//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->DriveVoltage("VCC", 0);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->OnSmuPin("VCC", true, false);
//				//CheckError(idx, ret, __LINE__);
//
//				//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->DriveVoltage("VEE", 0);
//				//CheckError(idx, ret, __LINE__);
//				//ret = smu[idx]->OnSmuPin("VEE", true, false);
//				//CheckError(idx, ret, __LINE__);
//				//_util->Wait_Sec(0.001);
//
//				ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
//				CheckError(idx, ret, __LINE__);
//				ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
//				CheckError(idx, ret, __LINE__);
//				//_util->Wait_Sec(On_Delay_s);
//
//				vih = 2.5;
//				vil = 0.00;
//				voh = 0.75; 
//				vol = 0.75;
//				ioh = 0.002;
//				iol = 0.002;
//				vch = 6;
//				vcl = -0.1;
//				vt = 0;
//
//				ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("SPE");
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("SPD");
//				CheckError(idx, ret, __LINE__);
//
//				ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//				CheckError(idx, ret, __LINE__);
//				ret = dm[idx]->DPINOn("SPC");
//				CheckError(idx, ret, __LINE__);
//
//				ret = DriveDMPin(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//
//				//Configure Input Delay
//				ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//				CheckError(idx, ret, __LINE__);
//				//_util->Wait_Sec(On_Delay_s);
//
//				// Check whether resource is SMU or DM
//				try
//				{
//					ret = smu[idx]->QueryModuleType(Test_Pin_P, moduleTypeP);
//					CheckError(idx, ret, __LINE__);
//				}
//				catch (Exception ^) //not a smu resource if exception occurs
//				{
//					moduleTypeP = DM_CONST_MODULE_TYPE;
//				}
//
//				try
//				{
//					ret = smu[idx]->QueryModuleType(Test_Pin_N, moduleTypeN);
//					CheckError(idx, ret, __LINE__);
//				}
//				catch (Exception ^) //not a smu resource if exception occurs
//				{
//					moduleTypeN = DM_CONST_MODULE_TYPE;
//				}
//
//				// Configure P
//				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
//				{
//					ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->DPINOn(Test_Pin_P);
//					CheckError(idx, ret, __LINE__);
//					_util->Wait_Sec(On_Delay_s);
//					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
//					CheckError(idx, ret, __LINE__);
//				}
//				else //smu
//				{
//					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
//					CheckError(idx, ret, __LINE__);
//					ret = smu[idx]->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
//					CheckError(idx, ret, __LINE__);
//					ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
//					CheckError(idx, ret, __LINE__);
//					ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
//					CheckError(idx, ret, __LINE__);
//					_util->Wait_Sec(On_Delay_s);
//					ret = smu[idx]->DriveCurrent(Test_Pin_P, Drive_Io_A);
//					CheckError(idx, ret, __LINE__);
//				}
//
//				// Configure N
//				if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
//				{
//					ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
//					CheckError(idx, ret, __LINE__);
//					ret = dm[idx]->DPINOn(Test_Pin_N);
//					CheckError(idx, ret, __LINE__);
//					_util->Wait_Sec(On_Delay_s);
//					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
//					CheckError(idx, ret, __LINE__);
//				}
//				else //smu
//				{
//					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
//					CheckError(idx, ret, __LINE__);
//					ret = smu[idx]->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
//					CheckError(idx, ret, __LINE__);
//					ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
//					CheckError(idx, ret, __LINE__);
//					ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
//					CheckError(idx, ret, __LINE__);
//					_util->Wait_Sec(On_Delay_s);
//					ret = smu[idx]->DriveCurrent(Test_Pin_N, Drive_Io_A);
//					CheckError(idx, ret, __LINE__);
//				}
//			}
//		}
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if(run_test[idx])
//			{
//				//if(!USE_SPI)
//				//{
//				//	ret = RunVectorFile(idx, Vector_File1);
//				//	CheckError(idx, ret, __LINE__);
//				//}
//				//else
//				//{
//				//	ret = OnOffSPI(idx, 1);
//				//	CheckError(idx, ret, __LINE__);
//				//	ret = RunSPI(idx, Vector_File1);
//				//	CheckError(idx, ret, __LINE__);
//				//}
//
//				ret = RunVectorFile(idx, Vector_File1);
//				CheckError(idx, ret, __LINE__);
//
//				for (int i=0; i<step; i++)
//				{
//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
//					{
//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
//												
//						//if(!USE_SPI) {
//						ret = RunVectorFile(idx, Vector_File);
//						CheckError(idx, ret, __LINE__);
//						//} else {
//						//ret = RunSPI(idx, Vector_File);
//						//CheckError(idx, ret, __LINE__);
//						//}
//					}
//
//					double diffp_V = 0;
//					double diffn_V = 0;
//
//					_util->Wait_Sec(Measure_Delay_s);
//
//					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
//					{
//						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
//						CheckError(idx, ret, __LINE__);
//
//						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
//						CheckError(idx, ret, __LINE__);
//					}
//					else
//					{
//						ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
//						CheckError(idx, ret, __LINE__);
//						ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
//						CheckError(idx, ret, __LINE__);
//					}
//
//					result_iwx[i] = (diffp_V - diffn_V) / CONST_Rw;
//				}
//			}
//		}
//
//		ret = Probe_Card_FET_Control(0, 0, 0, 0);
//
//		_util->Wait_Sec(On_Delay_s);
//		
//		int retestCount = 0;
//		double max_limit = 0;
//		double min_limit = 0;
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if(run_test[idx])
//			{
//RETEST:		
//				for (int i=0; i<step; i++)
//				{
//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
//					{
//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
//												
//						//if(!USE_SPI) 
//						//{
//							ret = RunVectorFile(idx, Vector_File);
//							CheckError(idx, ret, __LINE__);
//						//}
//						//else 
//						//{
//						//	ret = RunSPI(idx, Vector_File);
//						//	CheckError(idx, ret, __LINE__);
//						//}
//					}
//
//					double diffp_V = 0;
//					double diffn_V = 0;
//
//					_util->Wait_Sec(Measure_Delay_s);
//
//					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
//					{
//						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
//						CheckError(idx, ret, __LINE__);
//
//						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
//						CheckError(idx, ret, __LINE__);
//					}
//					else
//					{
//						ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
//						CheckError(idx, ret, __LINE__);
//						ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
//						CheckError(idx, ret, __LINE__);
//					}
//
//					result_Viw_open[i] = (diffp_V - diffn_V);
//				}
//
//				array<double> ^ result_Rout = gcnew array<double>(step);
//				array<double> ^ result_I1k  = gcnew array<double>(step);
//				double Rt = 50;
//				double I3 = result_iwx[1]; //use I3 value for WZ1 (50 Ohm)
//				double Is = I3 / (1 - (CONST_Rw/(CONST_Rw+Rt))); 
//
//				for (int i=0; i<step; i++)
//				{
//					result_I1k[i] = result_Viw_open[i] / (CONST_Rw + 1000);
//					result_Rout[i] = result_Viw_open[i] / (Is - result_I1k[i]);
//					
//					if ((result_Rout[i] < min_limit) || (result_Rout[i] > max_limit))
//					{
//						if (retestCount < TIMING_RESET_COUNT)
//						{
//							retestCount++;
//							goto RETEST;
//						}
//					}					
//
//					tf_SetResult_UUTOffset(TPName[i], result_Rout[i] + GetOffset(idx, TPDispName[i]), idx);
//				}
//
//			/////////////////////////////////
//				
//				if(USE_SPI) 
//				{
//					ret = OnOffSPI(idx, 0);
//					CheckError(idx, ret, __LINE__);
//				}
//				ret = ResetDMPin(idx, TPDispName[0]);
//				CheckError(idx, ret, __LINE__);
//			}
//		}
//
//		for(int idx=0; idx<_numOffset; idx++)
//		{
//			if(run_test[idx])
//			{
//				//Power down supplies
//				ret = smu[idx]->DriveVoltage("VEE", 0);
//				CheckError(idx, ret, __LINE__);
//				ret = smu[idx]->DriveVoltage("VCC", 0);
//				CheckError(idx, ret, __LINE__);
//
//				//IO setting
//				ret = ResetCBit(idx);
//				CheckError(idx, ret, __LINE__);
//				ret = ResetMuxIO(idx);
//				CheckError(idx, ret, __LINE__);
//			}
//		}
//
//		ret = Probe_Card_FET_Control(0, 1, 0, 0);
//
//		return 0;
//	}
	int TestProgram::seq_ro_ttr(Site ^ site)
	{
		int ret = 0;	

		/*****Get test name from techFlow*****/
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
		array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
		array<String ^> ^ Test_Pin_P = gcnew array<String ^>(HDSS);
		array<String ^> ^ Test_Pin_N = gcnew array<String ^>(HDSS);
		array<double> ^ result = gcnew array<double>(total_tp);
		

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
			result[i] = 0;
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		int step				= (int)(tf_TestItemCondition_Cast("step"));
		
		String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";
		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		array<double> ^ result_iwx		= gcnew array<double>(total_tp);
		array<double> ^ result_Viw_open = gcnew array<double>(total_tp);
		array<double> ^ result_Rout = gcnew array<double>(total_tp);
		array<double> ^ result_I1k  = gcnew array<double>(total_tp);

		for (int i=0; i<step; i++)
		{
			result_iwx[i] = 0;
			result_Viw_open[i] = 0;
		}

		int vector_engine_status = 0;
		Stopwatch swatch;

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			if(run_test[idx])
			{
				/*****Initialize*****/
				ret = writer_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

				//ret = DriveDMPin(idx, TPDispName[0]);
				//CheckError(idx, ret, __LINE__);

				for(int hsel=0; hsel<HDSS; hsel++)
				{
					Test_Pin_P[hsel]		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P_H" + hsel));
					Test_Pin_N[hsel]		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N_H" + hsel));	

					// Configure P
					ret = dm[idx]->Force(Test_Pin_P[hsel], DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P[hsel], DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P[hsel], 6, -1 * Math::Abs(Clamp_Vo_V));
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P[hsel], 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P[hsel], NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin_P[hsel]);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P[hsel], Drive_Io_A);
					CheckError(idx, ret, __LINE__);
					
					// Configure N
					ret = dm[idx]->Force(Test_Pin_N[hsel], DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N[hsel], DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N[hsel], 6, -1 * Math::Abs(Clamp_Vo_V));
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N[hsel], 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N[hsel], NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin_N[hsel]);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N[hsel], Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
				
				//Configure Power Supply
				ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
				CheckError(idx, ret, __LINE__);
			}
		}

		double diffpn_V		= 0;
		double diffp_V		= 0;
		double diffn_V		= 0;
		int loop			= 0;
		int param_index		= 0;
		String ^ Vector_File;

		/*****Start Test*****/
		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				for(int hsel=0; hsel<HDSS; hsel++)
				{
					//setting for hsel
					if(hsel==0)
					{
						param_index = 0;
						loop = step;
					}		
					else 
					{
						param_index = (total_tp/2);
						loop = param_index + step;
					}

					//set CBit & MUX
					ret = DriveCBit(idx, TPDispName[param_index]);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[param_index], 1);
					CheckError(idx, ret, __LINE__);

					//run vector for hsel
					Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = OnOffSPI(idx, 1);
						CheckError(idx, ret, __LINE__);
						ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
						CheckError(idx, ret, __LINE__);
					}
				
					//param loop
					for (int i=param_index; i<loop; i++)
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
													
							if(!USE_SPI) 
							{
								ret = RunVectorFile(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							} 
							else 
							{
								ret = RunSPI(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
						}

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
						CheckError(idx, ret, __LINE__);

						//polarity
						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
							diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
						else 
							diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

						diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

						result_iwx[i] = diffpn_V / CONST_Rw;
					}

					ret = Probe_Card_FET_Control(0, 0, 0, 0);
					_util->Wait_Sec(On_Delay_s);
					ret = DriveMuxIO(idx, TPDispName[param_index], 0);
					CheckError(idx, ret, __LINE__);
					
					int retestCount = 0;
					double max_limit = 0;
					double min_limit = 0;

RETEST:
					//param loop
					for (int i=param_index; i<loop; i++)
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
													
							if(!USE_SPI) 
							{
								ret = RunVectorFile(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
							else 
							{
								ret = RunSPI(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
						}

						_util->Wait_Sec(Measure_Delay_s);

						ret = dm[idx]->PMUMeasure(Test_Pin_P[hsel], DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_N[hsel], DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(idx, ret, __LINE__);

						result_Viw_open[i] = diffp_V - diffn_V;
					}

					double Rt = 50;
					double I3 = result_iwx[1]; //use I3 value for WZ1 (50 Ohm)	//ML 2935 use result_iwx[1]; which is 50 ohm 
					double Is = I3 / (1 - (CONST_Rw/(CONST_Rw+Rt))); 

					for (int i=param_index; i<loop; i++)
					{
						result_I1k[i] = result_Viw_open[i] / (CONST_Rw + 1000);
						result_Rout[i] = result_Viw_open[i] / (Is - result_I1k[i]);

						if ((result_Rout[i] < min_limit) || (result_Rout[i] > max_limit))
						{
							if (retestCount < TIMING_RESET_COUNT)
							{
								retestCount++;
								goto RETEST;
							}
						}

						tf_SetResult_UUTOffset(TPName[i], result_Rout[i] + GetOffset(idx, TPDispName[i]), idx);	
					}
				}
			}

			/*****Power down*****/	
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			for(int idx=0; idx<_numOffset; idx++)
			{
				if(run_test[idx])
				{
					ret = ResetDMPin(idx, TPDispName[0]);
					CheckError(idx, ret, __LINE__);

					////Power down supplies
					//ret = smu[idx]->DriveVoltage("VEE", 0);
					//CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveVoltage("VCC", 0);
					CheckError(idx, ret, __LINE__);

					//IO setting
					ret = ResetCBit(idx);
					CheckError(idx, ret, __LINE__);
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
				}
			}
		}

		ret = Probe_Card_FET_Control(0, 1, 0, 0);

		return 0;		
	}
	int TestProgram::seq_iw_unsel_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::iw_unsel_ttr), site);
	}
	int TestProgram::seq_osd_spd(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::osd_spd), site);
	}
	int TestProgram::seq_osa_step3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::osa_step3_ttr), site);
	}
	int TestProgram::seq_servo(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::servo), site);
	}
	int TestProgram::seq_acerase_mux(Site ^ site)
	{
		int result = 1;

		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				tf_SetResult_UUTOffset(TPName[0], result + (int)GetOffset(idx, TPDispName[0]), idx);
			}
		}
		
		return 0;
	}
	int TestProgram::seq_heater_sup_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_sup_ttr), site);
	}
	int TestProgram::seq_heater_servo(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_servo), site);
	}
	int TestProgram::seq_heater_slew2(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_slew2), site);
	}
	int TestProgram::seq_heater_power(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_power), site);
	}
	int TestProgram::seq_heater_blank(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_blank), site);
	}
	int TestProgram::seq_heater_rng_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_rng_ttr), site);
	}
	int TestProgram::seq_heater_rng(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_rng), site);
	}

	int TestProgram::seq_ifhs_bias_hds(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::ifhs_bias_hds), site);
	}
	int TestProgram::seq_vfhs_bias_hds4_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::vfhs_bias_hds4_ttr), site);
	}
	int TestProgram::seq_vfhsv4_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::vfhsv4_ttr), site);
	}
	int TestProgram::seq_ifhs_bias_sup_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::ifhs_bias_sup_ttr), site);
	}
	int TestProgram::seq_vfhs_bias_sup_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::vfhs_bias_sup_ttr), site);
	}
	int TestProgram::seq_fhs_func(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhs_func), site);
	}
	int TestProgram::seq_prox_diffmux(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::prox_diffmux), site);
	}
	int TestProgram::seq_prox_detect(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::prox_detect), site);
	}
	int TestProgram::seq_prox_dacs(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::prox_dacs), site);
	}
	int TestProgram::seq_fhs_dmux(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhs_dmux), site);
	}
	int TestProgram::seq_rbhv4_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rbhv4_ttr), site);
	}
	int TestProgram::seq_rbhi3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rbhi3_ttr), site);
	}
	int TestProgram::seq_rdbhv3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rdbhv3_ttr), site);
	}
	int TestProgram::seq_rdbhvc_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rdbhvc_ttr), site);
	}
	int TestProgram::seq_rdbhi_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::rdbhi_ttr), site);
	}
	int TestProgram::seq_wbhv3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::wbhv3_ttr), site);
	}
	int TestProgram::seq_wdbhv_ttr(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::wdbhv_ttr), site);
	}
	int TestProgram::seq_fhcr_ttr(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhcr_ttr), site);
	}
	int TestProgram::seq_sbhv(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::sbhv), site);
	}
	int TestProgram::seq_sbhi3_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::sbhi3_ttr), site);
	}
	int TestProgram::seq_hbhi_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::hbhi_ttr), site);
	}
	int TestProgram::seq_flt_wr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_wr), site);
	}
	int TestProgram::seq_flt_ht_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_ht_ttr), site);
	}
	int TestProgram::seq_fhs_flt_spd(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhs_flt_spd), site);
	}
	int TestProgram::seq_fhs_vtrip_ttr(Site ^ site)
	{
		return DoThreadWithoutVccVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhs_vtrip_ttr), site);
	}
	int TestProgram::seq_flt_fhs_vopen_short2_ttr(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_fhs_vopen_short2_ttr), site);
	}
	int TestProgram::seq_flt_ireader_open(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_ireader_open), site);
	}
	int TestProgram::seq_IDCcancelDAC(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::IDCcancelDAC), site);
	}
	int TestProgram::seq_sply_flt(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::sply_flt), site);
	}
	int TestProgram::seq_flt_fhs_iopen(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_fhs_iopen), site);
	}
	int TestProgram::seq_temp_flt(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::temp_flt), site);
	}
	int TestProgram::seq_dig_faults(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::dig_faults), site);
	}
	int TestProgram::seq_flt_reader_open(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_reader_open), site);
	}
	int TestProgram::seq_vlo_vee_sply_flt(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::vlo_vee_sply_flt), site);
	}
	int TestProgram::seq_iwth(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::iwth), site);
	}
	int TestProgram::seq_por_flt(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::por_flt), site);
	}
	int TestProgram::seq_fhs_dcdet_flt(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhs_dcdet_flt), site);
	}
	int TestProgram::seq_fhs_ishort(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::fhs_ishort), site);
	}
	int TestProgram::seq_wr_flt_timing(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::wr_flt_timing), site);
	}
	int TestProgram::seq_flt_timing(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_timing), site);
	}

	//temporary for dummy
	int TestProgram::seq_dummy(Site ^ site)
	{
		int ret = 0;

		int result = 1;

		//String ^ TPName = tf_TestParameter_Name(0);

		//tf_SetResult_UUTOffset(TPName, result + GetOffset(idx, TPDispName), idx);

		return ret;
	}
	//int TestProgram::seq_heater_rng_ttr(Site ^ site)
	//{
	//	return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::heater_rng_ttr), site);
	//}
	// Private Methods
	void TestProgram::gnds_cont(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;


		try 
		{

			//Get test name from techFlow
			String ^ TPName = tf_TestParameter_Name(0);
			String ^ TPDispName = tf_TestParameter_DisplayName(0);
			String ^ TIDispName = tf_TestItem_DisplayName();
			
			double result = 0.0;

			//if ((idx != ForceSingleSiteNumber) && SingleSiteTest)
			//{
			//	result = 999.99;
			//}else{
			
				int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
				double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
				double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
				double Clamp_Vcc_Current_A = (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
				double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
				double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
				bool Debug_Enable		= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
				double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

				double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
				double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

				double meas_curr = 0;

				int retest_count = 0;
				int GNDS_RESET_COUNT = 5;

				RETEST:

				ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
				CheckError(idx, ret, __LINE__);

				ret = Configure_GNDS_Mux(idx, NPLC);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(On_Delay_s);

				ret = smu[idx]->ClampVoltage("GND_MUX_SENSE", Clamp_Voltage_V);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->DriveCurrent("GND_MUX_SENSE", Drive_Current_A);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", result);
				CheckError(idx, ret, __LINE__);

				result = result / Drive_Current_A;

				double max_limit = (double)(tf_TPHighLimit_Cast(TPName));
				double min_limit = (double)(tf_TPLowLimit_Cast(TPName));

				if ((result < min_limit) || (result > max_limit))
				{
					if (retest_count < GNDS_RESET_COUNT)
					{
						retest_count++;
						goto RETEST;
					}
				}

				ret = smu[idx]->ClampVoltage("GND_MUX_SENSE", 1);
				CheckError(idx, ret, __LINE__);

				ret = smu[idx]->DriveCurrent("GND_MUX_SENSE", 0);
				CheckError(idx, ret, __LINE__);

			//}
			
			if (_glob->contact_fail[idx] == 0)
			{
				if ((result + GetOffset(idx, TPDispName)) < (double)(tf_TPLowLimit_Cast(TPName)))
				{
					_glob->contact_open_l_short_h[idx] = 1;
					_glob->contact_fail[idx] = 1;
				}

				if ((result + GetOffset(idx, TPDispName)) > (double)(tf_TPHighLimit_Cast(TPName)))
				{
					_glob->contact_open_l_short_h[idx] = 0;
					_glob->contact_fail[idx] = 1;
				}
			}

			tf_SetResult_UUTOffset(TPName, result + GetOffset(idx, TPDispName), idx);
RecContData(result, 0);

		} 
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::depmos_test(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			int i = 0;

			double inf_p = std::numeric_limits<double>::infinity();
			double inf_n = -inf_p;

			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
			double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Drive_Pin_P;
			String ^ Drive_Pin_N;
			String ^ Measure_Pin_P;
			String ^ Measure_Pin_N;

			double result = 0;

			ret = OnOffFETGnd(idx, 1);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff("SPE");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPD");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			unsigned int moduleType_DriveP = 0;
			unsigned int moduleType_DriveN = 0;
			unsigned int moduleType_MeasureP = 0;
			unsigned int moduleType_MeasureN = 0;
			
			double vp_ip = 0;
			double vn_ip = 0;
			double vp_in = 0;
			double vn_in = 0;

			double dep_n = 0;
			double dep_p = 0;
			double rmr_d = 0;
			double dep_d = 0;

			{
				double iforce_hi = 0;
				double iforce_lo = 0;
				double iforce_diff = 0;
		
				int c = 0;

				array<double>^ reading = gcnew array<double>(HDS*2);

				int retest_count = 0;
				int DEPMOS_RESET_COUNT = 1;

				array<double>^ max_limit = gcnew array<double>(3);
				array<double>^ min_limit = gcnew array<double>(3);

				int configure_once = 0;
				for (int i=0; i<HDS; i++)
				{
					Drive_Pin_P		= (String ^)(tf_TPCondition_Cast(TPName[i+(i*2)], "Drive_Pin_P"));
					Drive_Pin_N		= (String ^)(tf_TPCondition_Cast(TPName[i+(i*2)], "Drive_Pin_N"));
					Measure_Pin_P	= "MTX_SMU";
					Measure_Pin_N	= "MTX_SMU";
					
					double Drive_P = 0;
					double Drive_N = 0;

					configure_once = 0;

					retest_count = 0;
		RETEST:
					c = 0;
					for (int j=0; j<2; j++)
					{
						switch (j)
						{
							case 0:		// forward
								{
									Drive_P = Drive_Current_Hi_A;
									Drive_N = Drive_Current_Lo_A;
							
									break;
								}
							case 1:		// reverse
								{
									Drive_P = Drive_Current_Lo_A;
									Drive_N = Drive_Current_Hi_A;
							
									break;
								}
						}
					
						// Configure Force Mux
						ret = DriveMuxIO(idx, TPDispName[i+(i*2)], 0);
						CheckError(idx, ret, __LINE__);

						if (configure_once == 0)
						{
							/////////////////////////
							// Configure P
							ret = dm[idx]->Force(Drive_Pin_P, DM_CONST_FORCE_STATE_PMU);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_P, DM_CONST_DICV);
							CheckError(idx, ret, __LINE__);
							
							if (Clamp_Voltage_V < 0)
								ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_P, 0, Clamp_Voltage_V);
							else
								ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_P, Clamp_Voltage_V, 0);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_P, NPLC, DM_CONST_PLC);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->DPINOn(Drive_Pin_P);
							CheckError(idx, ret, __LINE__);
				
							//  Config meas MTX_Meas
							ret = smu[idx]->SetNPLC("MTX_SMU", NPLC);
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->ClampVoltage("MTX_SMU", Math::Abs(Clamp_Voltage_V));
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->OnSmuPin("MTX_SMU" , true, false);
							CheckError(idx, ret, __LINE__);
							
							/////////////////////////
							// Configure N

							ret = dm[idx]->Force(Drive_Pin_N, DM_CONST_FORCE_STATE_PMU);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_N, DM_CONST_DICV);
							CheckError(idx, ret, __LINE__);
							
							if (Clamp_Voltage_V < 0)
								ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_N, 0, Clamp_Voltage_V);
							else
								ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_N, Clamp_Voltage_V, 0);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_N, NPLC, DM_CONST_PLC);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->DPINOn(Drive_Pin_N);
							CheckError(idx, ret, __LINE__);

							configure_once = 1;
						}
							
						_util->Wait_Sec(On_Delay_s);

						// Drive P
						ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_P, Drive_P);
						CheckError(idx, ret, __LINE__);

						double tmp = 0;
						if (Debug_Enable == true)
						{
							ret = dm[idx]->PMUMeasure(Drive_Pin_P, DM_CONST_MEASURECURRENT, tmp);
							CheckError(idx, ret, __LINE__);
						}

						// Drive N
						ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_N, Drive_N);
						CheckError(idx, ret, __LINE__);

						if (Debug_Enable == true)
						{
							ret = dm[idx]->PMUMeasure(Drive_Pin_N, DM_CONST_MEASURECURRENT, tmp);
							CheckError(idx, ret, __LINE__);
						}
					
						_util->Wait_Sec(Measure_Delay_s);

						// Measure P
						{
							ret = DriveCBit(idx, TPDispName[i+(i*2)], 0);
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(On_Delay_s);

							ret = smu[idx]->ReadVoltage(Measure_Pin_P, reading[c]);  
							CheckError(idx, ret, __LINE__);

							ret = DriveCBit(idx, TPDispName[i+(i*2)], 1);
							CheckError(idx, ret, __LINE__);
						}

						//#ifdef USE_GNDS
						//double volt = 0;
						//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
						//CheckError(idx, ret, __LINE__);
						//reading[c] = reading[c] - volt;
						//#endif
						
						c++;								
						
						// Measure N
						{
							ret = DriveCBit(idx, TPDispName[i+(i*2)], 2);
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(On_Delay_s);
							
							ret = smu[idx]->ReadVoltage(Measure_Pin_N, reading[c]);
							CheckError(idx, ret, __LINE__);

							ret = DriveCBit(idx, TPDispName[i+(i*2)], 3);
							CheckError(idx, ret, __LINE__);
						}
						
						//#ifdef USE_GNDS
						//volt = 0;
						//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
						//CheckError(idx, ret, __LINE__);
						//reading[c] = reading[c] - volt;
						//#endif
						
						c++;
					}

					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
					
					vp_ip = reading[0];
					vn_ip = reading[1];
					vp_in = reading[2];
					vn_in = reading[3];

					iforce_hi = Drive_Current_Hi_A;
					iforce_lo = Drive_Current_Lo_A;
					iforce_diff = Math::Abs(Drive_Current_Hi_A - Drive_Current_Lo_A);	

					dep_n = ((vn_in * vp_ip / vp_in) - vn_ip) / (iforce_diff * (1 - (vp_ip / vp_in)));
					dep_p = -1 * (vp_in / (iforce_diff + (vn_in / dep_n)));

					rmr_d = (vp_ip - vn_ip) * dep_n / vn_ip;

					dep_d = CONST_Rr1 * rmr_d / (CONST_Rr1 - rmr_d);

					if (_util->IsInf(dep_p))
						dep_p = 1000;

					if (_util->IsInf(dep_n))
						dep_n = 1000;

					if (_util->IsInf(dep_d))
						dep_d = 1000;

					max_limit[0] = (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)]));
					min_limit[0] = (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)]));

					max_limit[1] = (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+1]));
					min_limit[1] = (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+1]));

					max_limit[2] = (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+2]));
					min_limit[2] = (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+2]));

					if (((dep_p < min_limit[0]) || (dep_p > max_limit[0])) ||
						((dep_n < min_limit[1]) || (dep_n > max_limit[1])) ||
						((dep_d < min_limit[2]) || (dep_d > max_limit[2])))
					{
						if (retest_count < DEPMOS_RESET_COUNT)
						{
							retest_count++;
							goto RETEST;
						}
					}

					tf_SetResult_UUTOffset(TPName[i+(2*i)], dep_p + GetOffset(idx, TPDispName[i+(2*i)]), idx);
					tf_SetResult_UUTOffset(TPName[i+(2*i)+1], dep_n + GetOffset(idx, TPDispName[i+(2*i)+1]), idx);
					tf_SetResult_UUTOffset(TPName[i+(2*i)+2], dep_d + GetOffset(idx, TPDispName[i+(2*i)+2]), idx);
RecContData(dep_p, i+ (2*i) + 13);
RecContData(dep_n, i+ (2*i) + 14);
RecContData(dep_d, i+ (2*i) + 15);

					if (_glob->contact_fail[idx] == 0)
					{
						if ((dep_p + GetOffset(idx, TPDispName[i+(2*i)])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)])))
						{
							_glob->contact_open_l_short_h[idx] = 1;
							_glob->contact_fail[idx] = 1;
							continue;
						}	
						
						if ((dep_p + GetOffset(idx, TPDispName[i+(2*i)])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)])))
						{
							_glob->contact_open_l_short_h[idx] = 0;
							_glob->contact_fail[idx] = 1;
							continue;
						}

						if ((dep_n + GetOffset(idx, TPDispName[i+(2*i)+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+1])))
						{
							_glob->contact_open_l_short_h[idx] = 1;
							_glob->contact_fail[idx] = 1;
							continue;
						}

						if ((dep_n + GetOffset(idx, TPDispName[i+(2*i)+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+1])))
						{
							_glob->contact_open_l_short_h[idx] = 0;
							_glob->contact_fail[idx] = 1;
							continue;
						}

						
						if ((dep_d + GetOffset(idx, TPDispName[i+(2*i)+2])) < (double)(tf_TPLowLimit_Cast(TPName[i+(2*i)+2])))
						{
							_glob->contact_open_l_short_h[idx] = 1;
							_glob->contact_fail[idx] = 1;
							continue;
						}

						if ((dep_d + GetOffset(idx, TPDispName[i+(2*i)+2])) > (double)(tf_TPHighLimit_Cast(TPName[i+(2*i)+2])))
						{
							_glob->contact_open_l_short_h[idx] = 0;
							_glob->contact_fail[idx] = 1;
							continue;
						}
					}
				}
				
				//power down
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
						
				ret = dm[idx]->ConfigurePMUVoltageLevel(Drive_Pin_N, 0);	
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLevel(Drive_Pin_P, 0);	
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			//ret = ResetDIOPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::vendor(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			int result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			//if (!USE_SPI)
			//{
				//Vendor ID
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[0], "Vector_File"));

					if (VectorSetNo->ContainsKey(Vector_File))
					{
						ret = dm[idx]->RunVector("DM_2", VectorSetNo[Vector_File]);
						//CheckError(idx, ret, __LINE__);
					}
					
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
						CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
							break;

						swatch.Stop();
					}
							
					if (vector_engine_status == 0)
					{
						ret = dm[idx]->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
						CheckError(idx, ret, __LINE__);

						ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
						CheckError(idx, ret, __LINE__);
						result = data & 0x01;		//2935 (data >> 6) & 0x3;
					}
					else
					{
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
						//result = -999;
					}

					tf_SetResult_UUTOffset(TPName[0], result + (int)GetOffset(idx, TPDispName[0]), idx);
				}

				//Channel for 2945 //Family ID
				{
					if (vector_engine_status == 0)
					{
						result = (data >> 1) & 0x03;		//2935 data & 0x3F;
					}
					else
					{
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
						//result = -999;
					}

					tf_SetResult_UUTOffset(TPName[1], result + (int)GetOffset(idx, TPDispName[1]), idx);
				}

				//Revision
				{								
					if (vector_engine_status == 0)
					{
						result = (data >> 3) & 0x02 ;	//2935 data & 0x3F; //294502E1 b4b3=0x2;  //2935 54 data & 0xF;
					}
					else
					{
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
						//result = -999;
					}

					tf_SetResult_UUTOffset(TPName[2], result + (int)GetOffset(idx, TPDispName[2]), idx);
				}

				//Generation for 2945 //FAB
				{							
					if (vector_engine_status == 0)
					{
						result = (data >> 5) & 0x07 ;	//2935 data & 0x3F; 2945 b7b6b5;   //2935 54TP result = data & 0xFF;
					}
					else
					{
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ " + Vector_File + " (line#" + __LINE__ + ")", ER_TIMEOUT);
						//result = -999;
					}

					tf_SetResult_UUTOffset(TPName[3], result + (int)GetOffset(idx, TPDispName[3]), idx);
				}
			//}
			//else
			//{
			//	{
			//		ret = OnOffSPI(idx, 1);
			//		CheckError(idx, ret, __LINE__);

			//		Vector_File = (String ^)(tf_TPCondition_Cast(TPName[0], "Vector_File"));
			//		ret = ReadSPI(idx, Vector_File, data);
			//		CheckError(idx, ret, __LINE__);
			//		
			//		result = data & 0x01;		//2935 (data >> 6) & 0x3;

			//		tf_SetResult_UUTOffset(TPName[0], result + (int)GetOffset(idx, TPDispName[0]), idx);
			//	}

			//	//Channel for 2945 //Family ID
			//	{
			//		result = (data >> 1) & 0x03;		//2935 data & 0x3F;

			//		tf_SetResult_UUTOffset(TPName[1], result + (int)GetOffset(idx, TPDispName[1]), idx);
			//	}

			//	//Device Rev
			//	{		
			//		result = (data >> 3) & 0x02 ;	//2935 data & 0x3F; //294502E1 b4b3=0x2;  //2935 54 data & 0xF;

			//		tf_SetResult_UUTOffset(TPName[2], result + (int)GetOffset(idx, TPDispName[2]), idx);
			//	}

			//	//Generation for 2945 //FAB
			//	{					
			//		result = (data >> 5) & 0x07 ;	//2935 data & 0x3F; 2945 b7b6b5;   //2935 54TP result = data & 0xFF;

			//		tf_SetResult_UUTOffset(TPName[3], result + (int)GetOffset(idx, TPDispName[3]), idx);
			//		ret = OnOffSPI(idx, 0);
			//		CheckError(idx, ret, __LINE__);
			//	}
			//}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			
			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		} 
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::vcc_cont(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			bool isCurrentTPBypassed	= false; 
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Drive_Current_A	= 0;
			double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Test_Pin		= String::Empty;

			double meas_curr = 0;

			ret = InitPowerSupplies(idx); //to discharge cap
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->Reset("AM_0");
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->Reset("AM_1");
			//CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(0.001);

			ret = smu[idx]->OffSmuPin("VCC");
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->OffSmuPin("VEE");
			CheckError(idx, ret, __LINE__);

			ret = OnOffCbit(idx, CBIT_VCC_FORWARD, 0);
			CheckError(idx, ret, __LINE__);
			//ret = OnOffCbit(idx, CBIT_VEE_FORWARD, 0);
			//CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(0.01);

			int i = 0;

			for (i=0; i<total_tp; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					Drive_Current_A = (double)(tf_TPCondition_Cast(TPName[0], "Drive_Current_A"));

#ifdef AM430E_SUPPLY_CONT
					ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0);
					CheckError(idx, ret, __LINE__);

					if (Test_Pin == "VCC")
					{
						Test_Pin = "MTX_SMU";
					}
					else
					{
						Test_Pin = "MTX_SMU_2";
					}
#endif

					ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					
					ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
					CheckError(idx, ret, __LINE__);

					ret = smu[idx]->DriveCurrent(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					ret = smu[idx]->OnSmuPin(Test_Pin, true, false);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);

#ifndef AM430E_SUPPLY_CONT
					if (Drive_Current_A < 0)
						ret = smu[idx]->DriveCurrent(Test_Pin, Math::Abs(Drive_Current_A));
					else
						ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
#else
						ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
#endif

					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage(Test_Pin, result);
					CheckError(idx, ret, __LINE__);

#ifndef AM430E_SUPPLY_CONT
					if (Drive_Current_A < 0)
						result = -1 * result;
#endif

					if (Test_Pin == "VEE")
						result = -1 * result;

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result, i+11); 

					if (Debug_Enable == true)
					{
						ret = smu[idx]->ReadCurrent(Test_Pin, result);
						CheckError(idx, ret, __LINE__);
					}

					ret = smu[idx]->DriveCurrent(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					//_util->Wait_Sec(On_Delay_s);

					//ret = smu[idx]->OffSmuPin(Test_Pin);
					//CheckError(idx, ret, __LINE__);

#ifdef AM430E_SUPPLY_CONT
					ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
					CheckError(idx, ret, __LINE__);
#endif

					if (_glob->contact_fail[idx] == 0)
					{
						if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
						{
							_glob->contact_open_l_short_h[idx] = 1;
							_glob->contact_fail[idx] = 1;
							continue;
						}

						if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
						{
							_glob->contact_open_l_short_h[idx] = 0;
							_glob->contact_fail[idx] = 1;
							continue;
						}
					}
				}
			}

			ret = OnOffCbit(idx, CBIT_VCC_FORWARD, 1);
			CheckError(idx, ret, __LINE__);
			//ret = OnOffCbit(idx, CBIT_VEE_FORWARD, 1);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->OnSmuPin("VCC", true, false);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->OnSmuPin("VEE", true, false);
			CheckError(idx, ret, __LINE__);

			//ret = InitPowerSupplies(idx);
			//CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::hsd_cont(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			int i = 0;
			for (i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			bool Debug_Enable		= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Drive_Current_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double Clamp_Voltage_V	= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Test_Pin			= String::Empty;

			double meas_curr = 0;

			//IO setting
			//ret = SetupDigital(idx);
			//CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power Supplies Setup
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = DriveDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			for (i=0; i<total_tp; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Clamp_Voltage_V < 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
					else 
						ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOn(Test_Pin);
					CheckError(idx, ret, __LINE__);
				}
			}

			_util->Wait_Sec(On_Delay_s);

			for (i=0; i<total_tp; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
					CheckError(idx, ret, __LINE__);
				}
			}

			_util->Wait_Sec(Measure_Delay_s);

			for (i=0; i<total_tp; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result, i + 1);

					if (Debug_Enable == true)
					{
						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, meas_curr);
						CheckError(idx, ret, __LINE__);
					}

					if (_glob->contact_fail[idx] == 0)
					{
						if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
						{
							_glob->contact_open_l_short_h[idx] = 0;
							_glob->contact_fail[idx] = 1;
							continue;
						}

						if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
						{
							_glob->contact_open_l_short_h[idx] = 1;
							_glob->contact_fail[idx] = 1;
							continue;
						}
					}
				}
			}

			for (i=0; i<total_tp; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOff(Test_Pin);
					CheckError(idx, ret, __LINE__);
				}
			}
			
			//IO setting
			//ret = ResetDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}

	}
	void TestProgram::analog_rd_cont(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			double rdp = 0.0;
			double rdn = 0.0;

			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
			double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Drive_Pin_Hi		= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_Hi"));
			String ^ Drive_Pin_Lo		= (String ^)(tf_TestItemCondition_Cast("Drive_Pin_Lo"));
			String ^ Measure_Pin_Hi		= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_Hi"));
			String ^ Measure_Pin_Lo		= (String ^)(tf_TestItemCondition_Cast("Measure_Pin_Lo"));

			unsigned int moduleType_DriveHi = 0;
			unsigned int moduleType_DriveLo = 0;
			unsigned int moduleType_MeasureHi = 0;
			unsigned int moduleType_MeasureLo = 0;

			double meas_curr = 0;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);

			//Power Supplies Setup
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->DPINOff("SPE");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPD");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp/2; i++) //for every depmos measurement for RDxP/N pair, we get 2 results
			{
				TPName[i] = tf_TestParameter_Name(i);

				ret = DriveCBit(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);

				ret = DriveCBit(idx, TPDispName[i+1]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i+1]);
				CheckError(idx, ret, __LINE__);

				// Check whether resource is SMU or DM
				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin_Hi, moduleType_DriveHi);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveHi = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin_Lo, moduleType_DriveLo);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveLo = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin_Hi, moduleType_MeasureHi);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureHi = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin_Lo, moduleType_MeasureLo);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureLo = DM_CONST_MODULE_TYPE;
				}

				// Configure Hi
				if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_Hi, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_Hi_A > 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_Hi, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOn(Drive_Pin_Hi);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Drive_Pin_Hi, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin_Hi, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin_Hi != Drive_Pin_Hi)
				{
					if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin_Hi, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_Hi_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin_Hi, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin_Hi, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin_Hi);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin_Hi, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin_Hi, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin_Hi, false, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				// Configure Lo
				if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_Lo, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_Lo_A > 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_Lo, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Drive_Pin_Lo);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Drive_Pin_Lo, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin_Lo, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin_Lo != Drive_Pin_Lo)
				{
					if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin_Lo, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_Lo_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin_Lo, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin_Lo, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin_Lo);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin_Lo, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin_Lo, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin_Lo, false, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				_util->Wait_Sec(On_Delay_s);

				// Drive Hi
				if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, Drive_Current_Hi_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin_Hi, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, Drive_Current_Hi_A);
					CheckError(idx, ret, __LINE__);
				}

				// Drive Lo
				if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, Drive_Current_Lo_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin_Lo, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, Drive_Current_Lo_A);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				// Measure

				if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin_Hi, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin_Hi, result);
					CheckError(idx, ret, __LINE__);
				}

				tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result, i + 9);
				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin_Lo, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin_Lo, result);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
				}

				tf_SetResult_UUTOffset(TPName[i+1], result + GetOffset(idx, TPDispName[i+1]), idx);
RecContData(result, i+1+9);

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);
		
			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::mux_cont_diff(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
			double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Drive_Pin_Hi		= String::Empty;
			String ^ Drive_Pin_Lo		= String::Empty;
			String ^ Measure_Pin_Hi		= String::Empty;
			String ^ Measure_Pin_Lo		= String::Empty;
			
			unsigned int moduleType_DriveHi = 0;
			unsigned int moduleType_DriveLo = 0;
			unsigned int moduleType_MeasureHi = 0;
			unsigned int moduleType_MeasureLo = 0;

			double meas_curr = 0;

			//IO setting
			//ret = SetupDigital(idx);
			//CheckError(idx, ret, __LINE__);
			
			//Power Supplies Setup
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff("SPE");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPD");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPC");
			CheckError(idx, ret, __LINE__);

			//ret = DriveDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			for (int i=0; i<total_tp; i=i+2) //for every measurement for P/N pair, we get 2 results
			{
				TPName[i] = tf_TestParameter_Name(i);

				ret = DriveCBit(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);

				Drive_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Hi"));
				Drive_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Lo"));
				Measure_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Hi"));
				Measure_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Lo"));
			
				// Check whether resource is SMU or DM
				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin_Hi, moduleType_DriveHi);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveHi = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin_Lo, moduleType_DriveLo);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveLo = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin_Hi, moduleType_MeasureHi);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureHi = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin_Lo, moduleType_MeasureLo);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureLo = DM_CONST_MODULE_TYPE;
				}

				// Configure Hi
				if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_Hi, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_Hi_A > 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Hi, 0, Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_Hi, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Drive_Pin_Hi);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Drive_Pin_Hi, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin_Hi, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin_Hi != Drive_Pin_Hi)
				{
					if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin_Hi, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_Hi_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin_Hi, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin_Hi, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin_Hi);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->SetBandwidth(Measure_Pin_Hi, 1);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin_Hi, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin_Hi, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin_Hi, false, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				// Configure Lo
				if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_Lo, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_Lo_A > 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_Lo, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Drive_Pin_Lo);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->SetBandwidth(Drive_Pin_Lo, 1);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ConfigureSamplingTime(Drive_Pin_Lo, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin_Lo, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin_Lo != Drive_Pin_Lo)
				{
					if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin_Lo, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_Lo_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin_Lo, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin_Lo, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin_Lo);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->SetBandwidth(Measure_Pin_Lo, 1);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin_Lo, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin_Lo, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin_Lo, false, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				_util->Wait_Sec(On_Delay_s);

				// Drive Hi
				if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, Drive_Current_Hi_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin_Hi, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, Drive_Current_Hi_A);
					CheckError(idx, ret, __LINE__);
				}

				// Drive Lo
				if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, Drive_Current_Lo_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin_Lo, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, Drive_Current_Lo_A);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				// Measure

				if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin_Hi, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin_Hi, result);
					CheckError(idx, ret, __LINE__);
				}

				tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result, i+19 );
				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}

				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
				ret = DriveCBit(idx, TPDispName[i+1]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i+1]);
				CheckError(idx, ret, __LINE__);
		
				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin_Lo, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin_Lo, result);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
				}

				tf_SetResult_UUTOffset(TPName[i+1], result + GetOffset(idx, TPDispName[i+1]), idx);
RecContData(result, i+1+19);


				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}

				result = 0;
			}

			//ret = ResetDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		
			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::mux_cont_se_kelvin(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;
			double Drive_Current_A	= 0.01;		//ML can't be 0

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Drive_Pin		= String::Empty;
			String ^ Measure_Pin	= String::Empty;
			
			unsigned int moduleType_Drive = 0;
			unsigned int moduleType_Measure = 0;

			double meas_curr = 0;

			//ret = SetupDigital(idx);
			//CheckError(idx, ret, __LINE__);
			//ret = DriveDIOPin(TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			
			//Power Supplies Setup
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff("SPE");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPD");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPC");
			CheckError(idx, ret, __LINE__);

			//ret = DriveDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			//Drive_Current_A = (2/CONST_RhNom)*0.9;	//ML mask due to fail to get reading if enable

			for (int i=0; i<total_tp; i++) //for every measurement for P/N pair, we get 2 results
			{
				TPName[i] = tf_TestParameter_Name(i);

				ret = DriveCBit(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);
				
				String ^ Drive_Pin		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin"));
				String ^ Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));
			
				// Check whether resource is SMU or DM
				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin, moduleType_Drive);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_Drive = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin, moduleType_Measure);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_Measure = DM_CONST_MODULE_TYPE;
				}

				// Configure Hi
				if (moduleType_Drive == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_A >= 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin, 0, Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Drive_Pin);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Measure_Pin, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin != Drive_Pin)
				{
					if (moduleType_Measure == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin, true, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				_util->Wait_Sec(On_Delay_s);

				// Drive 
				if (moduleType_Drive == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin, Drive_Current_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						double res1 = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Drive_Pin, DM_CONST_MEASUREVOLTAGE, res1);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin, Drive_Current_A);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				// Measure

				if (moduleType_Measure == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin, result);
					CheckError(idx, ret, __LINE__);
				}
				
				// Power down
				if (moduleType_Drive == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin, 0);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin, 0);
					CheckError(idx, ret, __LINE__);
				}

				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);

				tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result, i+23);
				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}

				result = 0;
			}

			//ret = ResetDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::analog_fhs_cont(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
			double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));

			String ^ Drive_Pin_Hi		= String::Empty;
			String ^ Drive_Pin_Lo		= String::Empty;
			String ^ Measure_Pin_Hi		= String::Empty;
			String ^ Measure_Pin_Lo		= String::Empty;

			String ^ Drive_DIO			= String::Empty;
			
			unsigned int moduleType_DriveHi = 0;
			unsigned int moduleType_DriveLo = 0;
			unsigned int moduleType_MeasureHi = 0;
			unsigned int moduleType_MeasureLo = 0;

			double meas_curr = 0;

			//IO setting
			//ret = SetupDigital(idx);
			//CheckError(idx, ret, __LINE__);
			//ret = DriveDIOPin(TPDispName[0], 0);
			//CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power Supplies Setup
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff("SPE");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPD");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("SPC");
			CheckError(idx, ret, __LINE__);

			//ret = DriveDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			//
			//_util->Wait_Sec(On_Delay_s);

			for (int i=0; i<total_tp; i=i+2) //for every measurement for P/N pair, we get 2 results
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					ret = DriveCBit(idx, TPDispName[i]);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[i]);
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[i+1]);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[i+1]);
					CheckError(idx, ret, __LINE__);
				}

				Drive_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Hi"));
				Drive_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Drive_Pin_Lo"));
				Measure_Pin_Hi		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Hi"));
				Measure_Pin_Lo		= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_Lo"));
			
				// Check whether resource is SMU or DM
				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin_Hi, moduleType_DriveHi);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveHi = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Drive_Pin_Lo, moduleType_DriveLo);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_DriveLo = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin_Hi, moduleType_MeasureHi);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureHi = DM_CONST_MODULE_TYPE;
				}

				try
				{
					ret = smu[idx]->QueryModuleType(Measure_Pin_Lo, moduleType_MeasureLo);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType_MeasureLo = DM_CONST_MODULE_TYPE;
				}

				// Configure Hi
				if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_Hi, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_Hi_A > 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_Hi, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Drive_Pin_Hi);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Drive_Pin_Hi, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin_Hi, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin_Hi, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin_Hi != Drive_Pin_Hi)
				{
					if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin_Hi, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin_Hi, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_Hi_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Hi, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin_Hi, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin_Hi, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin_Hi);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin_Hi, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin_Hi, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin_Hi, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin_Hi, false, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				// Configure Lo
				if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Drive_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_Lo, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					if (Drive_Current_Lo_A > 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
					else
						ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_Lo, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Drive_Pin_Lo);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Drive_Pin_Lo, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Drive_Pin_Lo, Math::Abs(Clamp_Voltage_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Drive_Pin_Lo, false, false);
					CheckError(idx, ret, __LINE__);
				}

				if (Measure_Pin_Lo != Drive_Pin_Lo)
				{
					if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Measure_Pin_Lo, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Measure_Pin_Lo, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						
						if (Drive_Current_Lo_A > 0)
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V), 0);
						else
							ret = dm[idx]->ConfigurePMUVoltageLimit(Measure_Pin_Lo, 0, -1 * Math::Abs(Clamp_Voltage_V));

						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Measure_Pin_Lo, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Measure_Pin_Lo, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Measure_Pin_Lo);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ConfigureSamplingTime(Measure_Pin_Lo, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Measure_Pin_Lo, Math::Abs(Clamp_Voltage_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Measure_Pin_Lo, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Measure_Pin_Lo, false, false);
						CheckError(idx, ret, __LINE__);
					}
				}

				_util->Wait_Sec(On_Delay_s);

				// Drive Hi
				if (moduleType_DriveHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, Drive_Current_Hi_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin_Hi, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, Drive_Current_Hi_A);
					CheckError(idx, ret, __LINE__);
				}

				// Drive Lo
				if (moduleType_DriveLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, Drive_Current_Lo_A);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double res = 0;
						ret = dm[idx]->PMUMeasure(Drive_Pin_Lo, DM_CONST_MEASURECURRENT, res);
						CheckError(idx, ret, __LINE__);
					}
				}
				else //smu
				{
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, Drive_Current_Lo_A);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);

				// Measure

				if (moduleType_MeasureHi == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin_Hi, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin_Hi, result);
					CheckError(idx, ret, __LINE__);
				}

				tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
RecContData(result,i+27);
				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (moduleType_MeasureLo == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Measure_Pin_Lo, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ReadVoltage(Measure_Pin_Lo, result);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Hi, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Drive_Pin_Lo, 0);
					CheckError(idx, ret, __LINE__);
				}

				tf_SetResult_UUTOffset(TPName[i+1], result + GetOffset(idx, TPDispName[i+1]), idx);
RecContData(result, i+27+1);
				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i+1])) < (double)(tf_TPLowLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h[idx] = 1;
						_glob->contact_fail[idx] = 1;
					}
				}

				if (_glob->contact_fail[idx] == 0)
				{
					if ((result + GetOffset(idx, TPDispName[i+1])) > (double)(tf_TPHighLimit_Cast(TPName[i+1])))
					{
						_glob->contact_open_l_short_h[idx] = 0;
						_glob->contact_fail[idx] = 1;
					}
				}

				{
					ret = ResetCBit(idx);
					CheckError(idx, ret, __LINE__);
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
				}

				result = 0;
			}

			//ret = ResetDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::input_leakage(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));
			double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));

			String ^ Test_Pin			= String::Empty;

			double meas_volt = 0;

			//IO setting
			//ret = SetupDigital(idx);
			//CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power Supplies Setup
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = DriveDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			//
			//_util->Wait_Sec(On_Delay_s);

			int i = 0;

			for (i=0; i<total_tp-1; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Current_A);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOn(Test_Pin);
					CheckError(idx, ret, __LINE__);
				}
			}

			_util->Wait_Sec(On_Delay_s);

			for (i=0; i<total_tp-1; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, Drive_Voltage_V);
					CheckError(idx, ret, __LINE__);
				}
			}

			_util->Wait_Sec(Measure_Delay_s);

			double flag = 0.0;

			for (i=0; i<total_tp-1; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
					CheckError(idx, ret, __LINE__);

					if (((result + GetOffset(idx, TPDispName[i])) < (double)(tf_TPLowLimit_Cast(TPName[i]))) || ((result + GetOffset(idx, TPDispName[i])) > (double)(tf_TPHighLimit_Cast(TPName[i]))))
						flag = 1;	
				
					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);

					if (Debug_Enable == true)
					{
						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, meas_volt);
						CheckError(idx, ret, __LINE__);
					}
				}
			}

			tf_SetResult_UUTOffset(TPName[total_tp-1], flag, idx);
				
			for (i=0; i<total_tp-1; i++)
			{
				TPName[i] = tf_TestParameter_Name(i);

				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);
				}
			}

			//IO setting
			//ret = ResetDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::vcc_leakage(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{		
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double result = 0.0;

			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Clamp_Current_A  = (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
			double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

			String ^ Test_Pin			= String::Empty;

			double meas_voltage = 0;

			ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampCurrent("VCC", Clamp_Current_A);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);
	
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Current_A);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Voltage_V);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			////debug
			//array<double>^ data = gcnew array<double>(1000);
			//for(int z=0; z<1000; z++)
			//{
			//	ret = smu[idx]->ReadCurrent("VCC", data[z]);
			//	//_util->Wait_Sec(Measure_Delay_s);
			//}
			////debug

			ret = smu[idx]->ReadCurrent("VCC", result);
			CheckError(idx, ret, __LINE__);

			tf_SetResult_UUTOffset(TPName[0], result + GetOffset(idx, TPDispName[0]), idx);
			//tf_SetResult_UUTOffset(TPName[2], result + GetOffset(idx, TPDispName[2]), idx);
			tf_SetResult_UUTOffset(TPName[1], result + GetOffset(idx, TPDispName[1]), idx);

			if (Debug_Enable == true)
			{
				ret = smu[idx]->ReadVoltage("VCC", result);
				CheckError(idx, ret, __LINE__);
			}

			ret = smu[idx]->ClampCurrent("VCC", 10e-3);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			//VEE

			//ret = smu[idx]->DriveVoltage("VEE", Drive_Voltage_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(Measure_Delay_s);

			//ret = smu[idx]->ReadCurrent("VEE", result);
			//CheckError(idx, ret, __LINE__);

			//result = -1 * result;

			//tf_SetResult_UUTOffset(TPName[1], result + GetOffset(idx, TPDispName[1]), idx);
			//tf_SetResult_UUTOffset(TPName[3], result + GetOffset(idx, TPDispName[3]), idx);

			//if (Debug_Enable == true)
			//{
			//	ret = smu[idx]->ReadVoltage("VEE", result);
			//	CheckError(idx, ret, __LINE__);
			//}

			//ret = smu[idx]->ClampCurrent("VEE", 10e-3);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", 100e-3); //reduce spkies
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampCurrent("VCC", 100e-3);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampCurrent("VCC", 0.5);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ClampCurrent("VEE", 0.5);
			//CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			//Off
			//ret = smu[idx]->OffSmuPin("VEE");
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OffSmuPin("VCC");
			//CheckError(idx, ret, __LINE__);

			//IO setting
			//ret = ResetDMPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			//ret = ResetCBit(idx);
			//CheckError(idx, ret, __LINE__);
			//ret = ResetMuxIO(idx);
			//CheckError(idx, ret, __LINE__);

		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}



	//
	void TestProgram::serial_pwrup(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_20"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_20"][idx];

			int result				= 0;

			int Total_Fail_Count = 0;
	
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);
			
			
			//ret = smu[idx]->DriveVoltage("VCC", 0);		// Power down device
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);


			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
				
			//ret = OnOffSPI(idx, 0);		//ML add in 
			//CheckError(idx, ret, __LINE__);
			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->AcquireVectorFailCount("DM_2", result);
			CheckError(idx, ret, __LINE__);

			if (Debug_Enable == true)
			{
				int First_Fail_Vector_Count = 0;
				if (result > 0)
				{
					ret = dm[idx]->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
					CheckError(idx, ret, __LINE__);
				}
			}

			Total_Fail_Count = result;

			if (Total_Fail_Count == 0)
				Total_Fail_Count = 1;
			else
				Total_Fail_Count = 0;

			tf_SetResult_UUTOffset(TPName[0], Total_Fail_Count + (int)GetOffset(idx, TPDispName[0]), idx);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			
			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::serial_ck_brd(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));		//new in 2945
			String ^ Vector_File_2	= (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));		//new in 2945		
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][idx];

			int result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);
			ret = OnOffSPI(idx, 0);
			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			ret = RunVectorFile(idx, Vector_File_1);
			CheckError(idx, ret, __LINE__);

			ret = RunVectorFile(idx, Vector_File_2);
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				{
					if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V"))
					{
						Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
						ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V"))
					{
						Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));
						ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);
					}
					
					//Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					//ret = RunVectorFile(idx, Vector_File);
					//CheckError(idx, ret, __LINE__);

					ret = dm[idx]->AcquireVectorFailCount("DM_2", result);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						int First_Fail_Vector_Count = 0;
						if (result > 0)
						{
							ret = dm[idx]->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
							CheckError(idx, ret, __LINE__);
						}
					}

					if (result == 0)
						result = 1;
					else
						result = 0;

					tf_SetResult_UUTOffset(TPName[i], result + (int)GetOffset(idx, TPDispName[i]), idx);
				
				}
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			
			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

    void TestProgram::por(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][testSite];

			int result				= 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;
			int data = 0;
			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File);	
					CheckError(idx, ret, __LINE__);
				}			
			
			for (int i=0; i<total_tp; i++)
			{
				{
					if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V"))
					{
						Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
						ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V"))
					{
						Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));
						ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);
					}
					
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = OnOffSPI(idx, 1);
						CheckError(idx, ret, __LINE__);
						ret = RunSPI(idx,Vector_File);	
						CheckError(idx, ret, __LINE__);
					}			

					ret = dm[idx]->AcquireVectorFailCount("DM_2", result);
					CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						int First_Fail_Vector_Count = 0;
						if (result > 0)
						{
							ret = dm[idx]->AcquireChannelFirstFailVectorCount("SPD", First_Fail_Vector_Count);
							CheckError(idx, ret, __LINE__);
						}
					}

					if (result == 0)
						result = 1;
					else
						result = 0;

					tf_SetResult_UUTOffset(TPName[i], result + (int)GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::serial_ck_brd_level(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
			String ^ Vector_File_2	= (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));	//		
			String ^ Vector_File_3	= (String ^)(tf_TestItemCondition_Cast("Vector_File_3"));	//		

			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_100"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_100"][idx];

			double IO_Level_V = (double)(tf_TestItemCondition_Cast("IO_Level_V"));

			int result = 0;
			int final_result = 0; //
			double vih = 2.5;
			double vil = 0.00;
			double voh = 0.75; 
			double vol = 0.75;
			double ioh = 0.002;
			double iol = 0.002;
			double vch = 6;
			double vcl = -0.1;
			double vt = 0;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			ret += DriveCBit(idx, TPDispName[0]);
			ret += DriveMuxIO(idx, TPDispName[0]);
			
			ret += smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);

			vih = IO_Level_V;
			vil = 0.0;
			voh = IO_Level_V/2/2; //Since we have input termination on (50-ohm to GND), Voh will be halved
			vol = IO_Level_V/2/2;
			vt  = 0.0;

			ret += dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPE");

			ret += dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPD");

			ret += dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPC");

			ret += DriveDMPin(idx, TPDispName[0]);

			//Configure Input Delay
			ret += dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s); 

			ret += RunVectorFile(idx, "write_default_reg");

			//init_sif_tool + setup
			ret += RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			//Run checker board test
			ret = RunVectorFile(idx, Vector_File_1); CheckError(idx, ret, __LINE__);
			result=0; ret = dm[idx]->AcquireVectorFailCount("DM_2", result); final_result += result;
			ret = RunVectorFile(idx, Vector_File_2); CheckError(idx, ret, __LINE__);
			result=0; ret = dm[idx]->AcquireVectorFailCount("DM_2", result); final_result += result;
			ret = RunVectorFile(idx, Vector_File_3); CheckError(idx, ret, __LINE__);
			result=0; ret = dm[idx]->AcquireVectorFailCount("DM_2", result); final_result += result;

int my_data1 = 0; ret = WriteSPI(idx,1,1,0x55); ret = ReadVector(idx,"read_p1_reg1", my_data1);
int my_data2 = 0; ret = WriteSPI(idx,1,2,0xAA); ret = ReadVector(idx,"read_p1_reg2", my_data2);
int my_data3 = 0; ret = WriteSPI(idx,1,3,0x55); ret = ReadVector(idx,"read_p1_reg3", my_data3);
int my_data4 = 0; ret = WriteSPI(idx,1,4,0xAA); ret = ReadVector(idx,"read_p1_reg4", my_data4);
int my_data5 = 0; ret = WriteSPI(idx,1,5,0x55); ret = ReadVector(idx,"read_p1_reg5", my_data5);
int my_data6 = 0; ret = WriteSPI(idx,1,6,0xAA); ret = ReadVector(idx,"read_p1_reg6", my_data6);
int my_data7 = 0; ret = WriteSPI(idx,1,7,0x55); ret = ReadVector(idx,"read_p1_reg7", my_data7);
int my_data8 = 0; ret = WriteSPI(idx,1,8,0xAA); ret = ReadVector(idx,"read_p1_reg8", my_data8);

			for (int i=0; i<total_tp; i++)
			{				
				if (final_result == 0)
					result = 1;
				else
					result = final_result+2;	// making sure if test fail, this will display fail count and always be starting from 2

			   tf_SetResult_UUTOffset(TPName[i], result + (int)GetOffset(idx, TPDispName[i]), idx);		
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = Digital_Init_State(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::dig_vol_voh(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Drive_Current_A  = 0;
			
			int Global_Result_Index = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			int Drive_WRN_V			= 0;
			String ^ Test_Pin		= String::Empty;
			String ^ Vector_File_Prev = String::Empty;

			double result			= 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 1, 0); //Enable active load 
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0);  
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//Write DEFAULT registers 
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			//init_sif_tool
			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			ret = Configure_GNDS_Mux(idx, NPLC);
			CheckError(idx, ret, __LINE__);
			
			for (int i=0; i<total_tp; i++)
			{
				{
					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin")); 
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
					Drive_WRN_V = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WRN_V"));
					Drive_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Current_A"));

					if (Vector_File != Vector_File_Prev)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);

						Vector_File_Prev = Vector_File;
					}

					ret = dm[idx]->DrivePin("RWN", Drive_WRN_V);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOff(Test_Pin);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, DM_CONST_VMAX, DM_CONST_VMIN);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
					
					double volt = 0;
					//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
					ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt); 
					CheckError(idx, ret, __LINE__);
					result = result - volt;

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

						_glob->Global_Result[idx, Global_Result_Index] = result;
					}

					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_VECTOR);	
					CheckError(idx, ret, __LINE__);
				}
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			
			//IO setting
			ret = Digital_Init_State(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::input_current(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File1	= String::Empty;
			double Clamp_Io_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Io_Current_A"));
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			String ^ Test_Pin		= String::Empty;
			double Drive_Io_V		= 0;
			int Drive_WRN_V			= 0;

			double result			= 0;

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			//Must use vector for ion_current to set last level to VOL
			//Write DEFAULT registers 

			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			
			//init_sif_tool
			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);
			
			if (tf_TestItemCondition_exist("Vector_File1"))
			{
				Vector_File1 = (String ^)(tf_TestItemCondition_Cast("Vector_File1"));
				ret = RunVectorFile(idx, Vector_File1);
			}

			if (tf_TestItemCondition_exist("Drive_WRN_V"))
			{
				Drive_WRN_V = (int)(tf_TestItemCondition_Cast("Drive_WRN_V"));
				ret = dm[idx]->DrivePin("RWN", Drive_WRN_V);
				CheckError(idx, ret, __LINE__);
			}

			Dictionary <String ^, int> ^ Test_Pin_Configured = gcnew Dictionary <String ^ , int>; // key is Test Pin

			for (int i=0; i<total_tp; i++)
			{
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File"))
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}

					Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					Drive_Io_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_V"));

					if (Test_Pin_Configured->ContainsKey(Test_Pin) == false)
					{
						ret = dm[idx]->DPINOff(Test_Pin);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Test_Pin);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(On_Delay_s);

						Test_Pin_Configured->Add(Test_Pin, 1);
					}

					double volt = 0;
					ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
					CheckError(idx, ret, __LINE__);
					Drive_Io_V = Drive_Io_V + volt + 0.01; // readjust for correlation //0.11V is the IR dropped along SPD path as measured using DMM.

					ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, Drive_Io_V);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			ret = Digital_Init_State(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::writer_in2(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));

			double Drive_WDX_V		= (double)(tf_TestItemCondition_Cast("Drive_WDX_V"));
			double Drive_WDY_V		= (double)(tf_TestItemCondition_Cast("Drive_WDY_V"));
			double Clamp_WDX_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_WDX_Current_A"));
			double Clamp_WDY_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_WDY_Current_A"));

			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double result			= 0;

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			//Write DEFAULT registers 

			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, "write_p1_reg7_mode_sleep");	//2935: write_p1_reg9_mode_sleep
				CheckError(idx, ret, __LINE__);
			//}
			//else
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, "write_default_reg");
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, "write_p1_reg7_mode_sleep");	//2935: write_p1_reg9_mode_sleep
			//	CheckError(idx, ret, __LINE__);
			//}

			ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("WDX", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("WDY", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("WDX", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("WDY", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange("WDX", Clamp_WDX_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange("WDY", Clamp_WDY_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("WDX", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("WDY", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDY");
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUVoltageLevel("WDX", Drive_WDX_V);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("WDY", Drive_WDY_V);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);
			ret = dm[idx]->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, result);
			CheckError(idx, ret, __LINE__);

			tf_SetResult_UUTOffset(TPName[0], result + GetOffset(idx, TPDispName[0]), idx);

			//Rwd_in^Rd!WD!S
			//ret = dm[idx]->DrivePin("RWN", 1);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(Measure_Delay_s);

			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, "write_p1_reg7_mode_active");	//2935 write_p1_reg9_mode_active
				CheckError(idx, ret, __LINE__);
			//}
			//else
			//{
			//	ret = RunSPI(idx, "write_p1_reg7_mode_active");		//2935 write_p1_reg9_mode_active
			//	CheckError(idx, ret, __LINE__);
			//}

			double current_WDY_read2 = 0;
			double Voltage_WDY2 = 0;
			double Voltage_WDX2 = 0;

			_util->Wait_Sec(Measure_Delay_s);
			ret = dm[idx]->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, current_WDY_read2);
			CheckError(idx, ret, __LINE__);
		
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 5);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin("MTX_SMU", false, false);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			ret = smu[idx]->ReadVoltage("MTX_SMU", Voltage_WDY2);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0], 1);	//ML not 0 
			CheckError(idx, ret, __LINE__); 
			_util->Wait_Sec(On_Delay_s);

			ret = smu[idx]->ReadVoltage("MTX_SMU", Voltage_WDX2);
			CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->PMUMeasure("WDY", DM_CONST_MEASUREVOLTAGE, Voltage_WDY);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->PMUMeasure("WDX", DM_CONST_MEASUREVOLTAGE, Voltage_WDX);
			//CheckError(idx, ret, __LINE__);

			result = (Voltage_WDY2 - Voltage_WDX2)/current_WDY_read2;

			tf_SetResult_UUTOffset(TPName[1], result + GetOffset(idx, TPDispName[1]), idx);

			//Rwd_in^Wt!WD!S

			ret = dm[idx]->DrivePin("RWN", 0);	//2935 is 1
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			double Current_WDY = 0;
			double Voltage_WDY = 0;
			double Voltage_WDX = 0;

			ret = dm[idx]->PMUMeasure("WDY", DM_CONST_MEASURECURRENT, Current_WDY);
			CheckError(idx, ret, __LINE__);

			//
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 5);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin("MTX_SMU", false, false);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			ret = smu[idx]->ReadVoltage("MTX_SMU", Voltage_WDY);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0], 1);
			CheckError(idx, ret, __LINE__); 
			_util->Wait_Sec(On_Delay_s);

			ret = smu[idx]->ReadVoltage("MTX_SMU", Voltage_WDX);
			CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->PMUMeasure("WDY", DM_CONST_MEASUREVOLTAGE, Voltage_WDY);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->PMUMeasure("WDX", DM_CONST_MEASUREVOLTAGE, Voltage_WDX);
			//CheckError(idx, ret, __LINE__);

			result = (Voltage_WDY - Voltage_WDX)/Current_WDY;

			tf_SetResult_UUTOffset(TPName[2], result + GetOffset(idx, TPDispName[2]), idx);	

			ret = dm[idx]->ConfigurePMUVoltageLevel("WDX", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("WDY", 0);
			CheckError(idx, ret, __LINE__);
			
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = Digital_Init_State(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::vit_vhys_func(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Clamp_RWN_Current_A = (double)(tf_TestItemCondition_Cast("Clamp_RWN_Current_A"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			int max_step = 0;
			double voltage = 0;
			double p1_point = 0;
			double diffp_V = 0;
			double diffn_V = 0;

			array<double> ^ Drive_RWN_Start_V = gcnew array<double>(total_tp);
			array<double> ^ Drive_RWN_Stop_V = gcnew array<double>(total_tp);
			array<double> ^ Drive_RWN_Step_V = gcnew array<double>(total_tp);
			array<double> ^ MinLimit = gcnew array<double>(total_tp);
			array<double> ^ MaxLimit = gcnew array<double>(total_tp);
			array<double> ^ Vth = gcnew array<double>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result_p1 = gcnew array<double>(total_tp);
			array<double> ^ result_p2 = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				Drive_RWN_Start_V[i] = 0;
				Drive_RWN_Stop_V[i] = 0;
				Drive_RWN_Step_V[i] = 0;
				MinLimit[i] = 0;
				MaxLimit[i] = 0;
				Vth[i] = 0;
				result[i] = 0;
				result_p1[i] = 0;
				result_p2[i] = 0;
			}

			ret = dm[idx]->DPINOff("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("W0X_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("W0X_F", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff("W0Y_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("W0Y_F", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUSamplingTime("RWN", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("W0X_F", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("W0Y_F", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUOutputFunction("RWN", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("W0X_F", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("W0Y_F", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLimitRange("RWN", Clamp_RWN_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("W0X_F", 6, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("W0Y_F", 6, -2);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLevel("RWN", 1.5);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("W0X_F", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("W0Y_F", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("W0X_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("W0Y_F");
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			double gnds_volt = 0;
			ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, gnds_volt);
			CheckError(idx, ret, __LINE__);
					
			for (int i=0; i<total_tp; i++)
			{
				bool isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
				
				if (!isCurrentTPBypassed)
				{
					Drive_RWN_Start_V[i]	= (double)(tf_TPCondition_Cast(TPName[i],"Drive_RWN_Start_V"));
					Drive_RWN_Stop_V[i]		= (double)(tf_TPCondition_Cast(TPName[i],"Drive_RWN_Stop_V"));
					Drive_RWN_Step_V[i]		= (double)(tf_TPCondition_Cast(TPName[i],"Drive_RWN_Step_V"));
					Vth[i]					= (double)(tf_TPCondition_Cast(TPName[i],"Vth"));
					MinLimit[i]				= (double)(tf_TestParameter_MinLimit(TPName[i]));
					MaxLimit[i]				= (double)(tf_TestParameter_MaxLimit(TPName[i]));

					result[i] = 999;

					//VIH - Step Up
					if (Drive_RWN_Start_V[i] < Drive_RWN_Stop_V[i])
					{
						Drive_RWN_Step_V[i] = Math::Abs(Drive_RWN_Step_V[i]);

						if (MinLimit[i] < Drive_RWN_Start_V[i])
							Drive_RWN_Start_V[i] = MinLimit[i];

						p1_point = MinLimit[i];
						Drive_RWN_Stop_V[i] = MaxLimit[i];
					}

					//VIL - Step Down
					else if (Drive_RWN_Start_V[i] > Drive_RWN_Stop_V[i])
					{
						Drive_RWN_Step_V[i] = Math::Abs(Drive_RWN_Step_V[i]) * -1;

						if (MaxLimit[i] > Drive_RWN_Start_V[i] )
							Drive_RWN_Start_V[i] = MaxLimit[i];

						p1_point = MaxLimit[i];
						Drive_RWN_Stop_V[i] = MinLimit[i];
					}
					else 
						//return ER_INVALID_SETTING; //ret = -1; //return error
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": ER_INVALID_SETTING @ line#" + __LINE__, ER_INVALID_SETTING);

					max_step = (int)(Math::Abs((Drive_RWN_Start_V[i] - Drive_RWN_Stop_V[i]) / Drive_RWN_Step_V[i]));	

					if ((Drive_RWN_Start_V[i] == Drive_RWN_Stop_V[i]) || (max_step == 0))
						//return ER_INVALID_SETTING; //ret = -1; //return error
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": ER_INVALID_SETTING @ line#" + __LINE__, ER_INVALID_SETTING);

					voltage = Drive_RWN_Start_V[i];
					int step = 0;

					while((Drive_RWN_Start_V[i] != Drive_RWN_Stop_V[i]) && (step <= max_step))
					{
						if (Drive_RWN_Step_V[i] > 0) //step up
							ret = dm[idx]->ConfigurePMUVoltageLevel("RWN", voltage - 0.15 + gnds_volt);
						else //step down
							ret = dm[idx]->ConfigurePMUVoltageLevel("RWN", voltage + 0.15 + gnds_volt);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);

						if ((voltage < (p1_point + (Math::Abs(Drive_RWN_Step_V[i])/2))) && (voltage > (p1_point - Math::Abs((Drive_RWN_Step_V[i])/2))))
						{
							_util->Wait_Sec(Measure_Delay_s);

							ret = dm[idx]->PMUMeasure("W0X_F", DM_CONST_MEASUREVOLTAGE, diffp_V);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->PMUMeasure("W0Y_F", DM_CONST_MEASUREVOLTAGE, diffn_V);
							CheckError(idx, ret, __LINE__);
							
							result_p1[i] = Math::Abs(diffp_V - diffn_V);
						}
						 
						voltage = voltage + Drive_RWN_Step_V[i];
						step++;
					}

					if (voltage != Drive_RWN_Stop_V[i]) 
					{ 
						/* just safety resetup at point2 step input voltage, */
						/* to cover more die to passs within specs, specially edge die */
					    
						if (Drive_RWN_Step_V[i] > 0) 
							ret = dm[idx]->ConfigurePMUVoltageLevel("RWN", Drive_RWN_Stop_V[i] - 0.15 + gnds_volt);
						else
							ret = dm[idx]->ConfigurePMUVoltageLevel("RWN", Drive_RWN_Stop_V[i] + 0.15 + gnds_volt);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUVoltageLevel("RWN", Drive_RWN_Stop_V[i] + gnds_volt);
						CheckError(idx, ret, __LINE__);
					}

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure("W0X_F", DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->PMUMeasure("W0Y_F", DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(idx, ret, __LINE__);

					result_p2[i] = Math::Abs(diffp_V - diffn_V);

					if(Drive_RWN_Step_V[i] <  0)	//ML change from > to <
					{
						if (result_p1[i] <= Vth[i] && result_p2[i] >= Vth[i])
							result[i] = MinLimit[i] + ((MaxLimit[i] - MinLimit[i]) / 2);
						else 
						{
							if (result_p1[i] < Vth[i])
								result[i] = -10;
							else if(result_p2[i] > Vth[i])
								result[i] = 10;
							else 
								result[i] = 1e38; //unexpected
						}
					}

					else 
					{
						if (result_p1[i] >= Vth[i] && result_p2[i] <= Vth[i])
							result[i] = MinLimit[i] + ((MaxLimit[i] - MinLimit[i]) / 2);
						else 
						{
							if (result_p1[i] < Vth[i])
							{
								result[i] = -10;
//_util->SampleRes("vit_vhys",Vth[i]);

							}else if (result_p2[i] > Vth[i])
								result[i] = 10;
							else 
								result[i] = 999; //unexpected
						}
					}
		
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/////////////////////////////////

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = Digital_Init_State(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::digfunc(Object^ object)
	{

		
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

					/*JL: CBit to connect RWN and FLTMux to DM. May need to connect FLTMux to TMU.
				  2 vector files: write_data, write_dig_faults
			
			*/
		
		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File = gcnew array<String ^>(total_tp);
			//array<double> ^ result = gcnew array<double>(total_tp);
			int i;
			for (i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				//result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double Input_Channel_Delay_Dig = 0;

			//String ^ Vector_File	= String::Empty;

			//String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			int temp= 0;
			int result= 0;
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_DIG"))
				Input_Channel_Delay_Dig = calfactor["INPUT_CHANNEL_DELAY_DIG"][idx];		
			//Input_Channel_Delay_s = 0;
			/*****Initialize*****/
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("MODE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("MODE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("MODE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("MODE");
			CheckError(idx, ret, __LINE__);
			//Configure Input Delay
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			////Configure Power Supply
			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			int reg_val2, reg_val;


    		for (i=0; i<total_tp; i++)
    		{
    			Vector_File[i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
    		}
					

			/*****Start Test*****/
			for (i=0; i<total_tp; i++)
			{
		
				//run vector for hsel
				if(i==0||i==1)
				{
					ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
					ret = RunVectorFile(idx, "write_default_reg");
					ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_Dig);
					ret = RunVectorFile(idx, "write_dig_func");
					//_util->Wait_Sec(2e-3);
				}
				if(Vector_File[i] == "all")
				{
					

					CheckError(idx, ret, __LINE__);
					for(int j=1; j<3; j++)
					{
						ret = RunVectorFile(idx, Vector_File[j]);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->AcquireVectorFailCount("DM_2", temp);
						CheckError(idx, ret, __LINE__);
						//ret = dm[idx]->AcquireChannelFirstFailVectorCount("SPD", temp);
						//CheckError(idx, ret, __LINE__);
						result += temp;
					}
					//ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
					for(int j=3; j<total_tp; j++)
    				{

						ret = RunVectorFile(idx, Vector_File[j]);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->AcquireVectorFailCount("DM_2", temp);
						CheckError(idx, ret, __LINE__);
						result += temp;
					}
				}
				else
				{
					//ret = dm[idx]->ConfigureInputChannelDelay("SPD", -2e-7);
					//ret = RunVectorFile(idx, "write_dig_func");
					//CheckError(idx, ret, __LINE__);
					//if(Vector_File[i] == "h_dac_decode_8")
					//{
							//OnOffSPI(idx, 1);
						//ret = RunVectorFile(idx, "write_dig_func");
						//ret = RunVectorFile(idx, Vector_File[i]);
						
						//			ret = WriteSPI(idx, 3, 8, 0x02);
						//ret = ReadReg(idx, 3, 4, reg_val);
						//ret = ReadReg(idx, 3, 5, reg_val2);
					//}else{
					//if(Vector_File[i] == "h_dac_decode_0"){
					//	ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
					//	ret = RunVectorFile(idx, "write_default_reg");
					//}
					ret = RunVectorFile(idx, Vector_File[i]);
					CheckError(idx, ret, __LINE__);
					//}
					ret = dm[idx]->AcquireVectorFailCount("DM_2", result);
					CheckError(idx, ret, __LINE__);

				}
				tf_SetResult_UUTOffset(TPName[i], result + (int)GetOffset(idx, TPDispName[i]), idx);
				
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::dietemp_i(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
			String ^ Vector_File_2	= (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));
			String ^ Meas_Pin	= (String ^)(tf_TestItemCondition_Cast("Meas_Pin"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(8192);
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleTypeP = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Meas_Pin, moduleTypeP);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeP = DM_CONST_MODULE_TYPE;
			}

			// Check and setup the DM/SMU
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Meas_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Meas_Pin, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Meas_Pin, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Meas_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Meas_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Meas_Pin);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Meas_Pin, 0);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Meas_Pin, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Meas_Pin, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Meas_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Meas_Pin, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Meas_Pin, 0);
				CheckError(idx, ret, __LINE__);
			}

			{
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(0.000008);//8us delay as stated in datasheet pg65

				if(!USE_SPI)
				{
					ret = ReadVector(idx, Vector_File_1, data);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = ReadSPI(idx, Vector_File_1, data);
					CheckError(idx, ret, __LINE__);
				}
				
				result = 0.92 * data - 40.45;

				tf_SetResult_UUTOffset(TPName[0], result + GetOffset(idx, TPDispName[0]), idx);

			//analog die temp, read out from FLTMUX
			
			double a_temp = 0;
			double a_temp_volt=0;

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File_2);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File_2);
				CheckError(idx, ret, __LINE__);
			}

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
			{
					ret = dm[idx]->PMUMeasure(Meas_Pin, DM_CONST_MEASUREVOLTAGE, a_temp);
			}
			else
			{
					ret = smu[idx]->ReadVoltage(Meas_Pin, a_temp);
			}

			a_temp_volt = a_temp * 1;
			a_temp = (a_temp_volt * 184) - 131.7;

			tf_SetResult_UUTOffset(TPName[1], a_temp_volt + GetOffset(idx, TPDispName[1]), idx);
			tf_SetResult_UUTOffset(TPName[2], a_temp + GetOffset(idx, TPDispName[2]), idx);

			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::src_curr_meas_volt(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= String::Empty;
			double Clamp_Vo_Voltage_V = 0;
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			String ^ Test_Pin		= String::Empty;

			double result			= 0;
			double Drive_Io_A		= 0;

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			if(USE_SPI)		//ML - if enable this, retest from 2nd time onwards will fail.
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
			}

			ret = Configure_GNDS_Mux(idx, NPLC);
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				{
					if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
					{
						Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
						Drive_Io_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_A"));
						Clamp_Vo_Voltage_V = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vo_Voltage_V"));
					
						ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
					
						if (Clamp_Vo_Voltage_V < 0)
								ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Vo_Voltage_V);
						else 
							ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_Voltage_V, 0);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Test_Pin);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
					{
						NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
						ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_Io_A") == true)
					{
						Drive_Io_A = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Io_A"));

						ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
						CheckError(idx, ret, __LINE__);
					}

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);

					/*if (TPName[i]->Contains("VINPBias") == true)
					{*/
						double volt = 0;
						//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
						CheckError(idx, ret, __LINE__);
						result = result - volt;
					//}

					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					if (tf_TPCondition_exist(TPName[i], "Operation") == true)
					{
						String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

						if (Operation == "ABS")
						{
							result = Math::Abs(result);
						}
					}

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			//ret = Digital_Init_State(idx);
			//CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::amux_current1(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			String ^ Vector_File	= String::Empty;
			double Clamp_Io_Current_A = 0;
			double Input_Channel_Delay_s = 0;
			bool isCurrentTPBypassed = false;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

			String ^ Test_Pin		= String::Empty;
			double Drive_Vo_V		= 0;

			double result			= 0;

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg/2, -1 * Vswg/2, Fswg, 0);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(1e-3);
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
			}

			ret = RunSPI(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

				if (isCurrentTPBypassed == false)
				{
					if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
					{
						Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
						Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));
						Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));
					
						ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
						CheckError(idx, ret, __LINE__);
					
						ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->DPINOn(Test_Pin);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);
					}

					if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
					{
						NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
						ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Clamp_Io_Current_A") == true)
					{
						Clamp_Io_Current_A = (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Io_Current_A"));

						ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_Current_A);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_Vo_V") == true)
					{
						Drive_Vo_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vo_V"));

						ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

						if (!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					if (tf_TPCondition_exist(TPName[i], "Operation") == true)
					{
						String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

						if (Operation == "ABS")
						{
							result = Math::Abs(result);
						}
						else if (Operation == "CUSTOM")
						{
							result = Math::Abs(0.0003 / result) - 1;
						}
					}

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			//ret = Digital_Init_State(idx);
			//CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::rd2wr_bias(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

	  try 
	  {		
		  //Get test param from techFlow
		  int total_tp = (int)tf_TPCount();
		  array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		  array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		  for (int i=0; i<total_tp; i++)
		  {
			  TPDispName[i] = tf_TestParameter_DisplayName(i);
			  TPName[i] = tf_TestParameter_Name(i);
		  }

		  String ^ TIDispName = tf_TestItem_DisplayName();
  		
		  //Get test condition from techFlow
		  int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
		  double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
		  double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
		  double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
		  //double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
		  //double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
		  double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
		  double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
		  double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
		  Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
		  //double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));//
		  //double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));//
		  double Input_Channel_Delay_s = 0;
		  double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
		  int SPD_Channel			= _glob->SPD_Channel_Number;
		  String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));//rd2wr_bias
  		
		  if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			  Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
  				
		  double vih;
		  double vil;
		  double voh; 
		  double vol;
		  double ioh;
		  double iol;
		  double vch;
		  double vcl;
		  double vt;
  		
		  //IO setting
			  ret = SetupDigital(idx);
			  CheckError(idx, ret, __LINE__);
			  ret = DriveCBit(idx, TPDispName[0]);
			  CheckError(idx, ret, __LINE__);
			  ret = DriveMuxIO(idx, TPDispName[0]);
			  CheckError(idx, ret, __LINE__);

			  ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			  CheckError(idx, ret, __LINE__);
			  //ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			  //CheckError(idx, ret, __LINE__);
  		
		  ret = DriveDMPin(idx, TPDispName[0]);
		  CheckError(idx, ret, __LINE__);

		  vih = 2.5;
		  vil = 0.00;
		  voh = 0.75; 
		  vol = 0.75;
		  ioh = 0.002;
		  iol = 0.002;
		  vch = 6;
		  vcl = -0.1;
		  vt = 0;
  		
		  ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINOn("SPE");
		  CheckError(idx, ret, __LINE__);

		  ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINOn("SPD");
		  CheckError(idx, ret, __LINE__);

		  ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINOn("SPC");
		  CheckError(idx, ret, __LINE__);
  		
		  ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINOn("RWN");
		  CheckError(idx, ret, __LINE__);

		  ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		  CheckError(idx, ret, __LINE__);
		  ret = dm[idx]->DPINOn("SYNC");
		  CheckError(idx, ret, __LINE__);

		  //Configure Input Delay
		  ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		  CheckError(idx, ret, __LINE__);
  		
		  //JL: run Vector file to initialize the test
			  //if(!USE_SPI)
			  //{
				 // ret = RunVectorFile(idx, "write_default_reg");
				 // CheckError(idx, ret, __LINE__);
			  //}
			  //else
			  //{
				 // ret = OnOffSPI(idx, 1);
				 // CheckError(idx, ret, __LINE__);
				 // ret = RunSPI(idx, "write_default_reg");
				 // CheckError(idx, ret, __LINE__);
			  //}		

			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);

		  /////////////////////////////////////
		  double voh_flt = 0.5;
		  double tmu_start_hysteresis = 0.02;
		  double tmu_stop_hysteresis = 0.02;
		  double tmu_start_threshold = voh_flt;
		  double tmu_stop_threshold = voh_flt;
  		
		  int number_of_samples = 1;
		  double tmu_timeout = 10e-3; 
		  int returned_sample_count = 0;
		  array<double> ^ sampled_result = gcnew array<double>(number_of_samples);

		  //TMU start on SYNC pos slope, stop on FLTMUX pos slope
		  ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		  ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		  _util->Wait_Sec(Measure_Delay_s);
  		
		  ret = RunVectorFile(idx, Vector_File);
		  CheckError(idx, ret, __LINE__);

		  for(int i = 0; i < total_tp; i++)
		  {
			  Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
			  switch(i)
			  {
				  case 0: //Param 0		
					  ret = WriteSPI(idx, 2, 11, 0x80); //DMUX_EN, pg2_reg11[7]=1
					  ret = WriteSPI(idx, 3, 11, 0x10); //Disable Reader bias timer, pg3_reg11[4] = 1; After time-out, state machine provides fast recovery to active Read mode (35 ns).
					  //set DMUX Rdr_Read, MUX[6:0] = 44 = 010_1100b 
					  ret = WriteSPI(idx, 1, 15, 0x6c);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
					  ret = WriteSPI(idx, 3, 13, 0x00);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0

  //47s add to cheat TMU
					ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
					_util->Wait_Sec(0.1e-3);	//ml after direct pxi upgrade
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

					  break;
				  case 1: //Param 1
					  ret = WriteSPI(idx, 3, 11, 0x00); //Disable Reader bias timer, pg3_reg11[4] = 0; After time-out, state machine provides slow recovery to active Read mode (460 ns).

					  break;
				  case 2: //Param 2
					  //set DMUX Rdr_HoldBiasTimer_Response, MUX[6:0] = 48 = 011_0000b 
					  ret = WriteSPI(idx, 1, 15, 0x70);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
					  ret = WriteSPI(idx, 3, 13, 0x00);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
  					
					  //change TMU start to neg slope of SYNC
					  ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
					  _util->Wait_Sec(0.1e-3);		//ML _util->Wait_Sec(Measure_Delay_s);
			  }

			  ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			  _util->Wait_Sec(0.1e-3);	//ml after direct pxi upgrade
			  //vector file rd2wr_bias:
			  //default RWN=1, SYNC=1 for 50us, then RWN=0 for 300us & and SYNC=0 1us after RWN=0
			  ret = RunVectorFile(idx, Vector_File);
			  CheckError(idx, ret, __LINE__);
			  ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
  			
			  tf_SetResult_UUTOffset(TPName[i], sampled_result[0] + GetOffset(idx, TPDispName[i]), idx);	
		  }
		  /////////////////////////////////////

			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);

			  ret = Digital_Init_State(idx);
			  CheckError(idx, ret, __LINE__);
			  ret = ResetDMPin(idx, TPDispName[0]);
			  CheckError(idx, ret, __LINE__);

			  //Power down supplies
			  //ret = smu[idx]->DriveVoltage("VEE", 0);
			  //CheckError(idx, ret, __LINE__);
			  ret = smu[idx]->DriveVoltage("VCC", 0);
			  CheckError(idx, ret, __LINE__);

			  //IO setting
			  ret = ResetCBit(idx);
			  CheckError(idx, ret, __LINE__);
			  ret = ResetMuxIO(idx);
			  CheckError(idx, ret, __LINE__);
		  }
		  catch (Exception^ ex) 
		  {
			  d->Exception = ex;
			  d->ErrorCode = ret;
		  }		
	}
//	void TestProgram::dmux(Object^ object) //JL: New test		//half way modify
//	{
//		TestProgramData^ d = (TestProgramData^)object;
//
//		Site^ site = d->t_site;
//		int idx = d->UutOffsetIndex;
//		
//		int ret = 0;
//		
//		try 
//		{
//		//Get test name from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//		double Input_Channel_Delay_s = 0;
//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
//
//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
//				
//		double vih;
//		double vil;
//		double voh; 
//		double vol;
//		double ioh;
//		double iol;
//		double vch;
//		double vcl;
//		double vt;
//
//		double tmu_start_threshold = 0;
//		double tmu_stop_threshold = 0;
//		double tmu_start_hysteresis = 0;
//		double tmu_stop_hysteresis = 0;
//		int number_of_samples = 10;
//		double tmu_timeout = 10e-3; //JL: changed from 10e-3
//		int returned_sample_count = 0;
//		array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
//		array<double> ^ sampled_result1 = gcnew array<double>(1);
//		//IO setting
//		ret = SetupDigital(idx);
//		CheckError(idx, ret, __LINE__);
//		ret = DriveCBit(idx, TPDispName[0]);
//		CheckError(idx, ret, __LINE__);
//		ret = DriveMuxIO(idx, TPDispName[0]);
//		CheckError(idx, ret, __LINE__);
//
//		//Setup Power supplies
//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//		//ret = smu[idx]->DriveVoltage("VCC", 0);
//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
//
//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
//		//ret = smu[idx]->DriveVoltage("VEE", 0);
//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
//		//_util->Wait_Sec(0.001);
//
//			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
//			CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
//			//CheckError(idx, ret, __LINE__);
//			//_util->Wait_Sec(On_Delay_s);
//
//		vih = 2.5;
//		vil = 0.00;
//		voh = 0.75; 
//		vol = 0.75;
//		ioh = 0.002;
//		iol = 0.002;
//		vch = 6;
//		vcl = -0.1;
//		vt = 0;
//
//		ret = DriveDMPin(idx, TPDispName[0]);
//		CheckError(idx, ret, __LINE__);
//
//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINOn("SPE");
//		CheckError(idx, ret, __LINE__);
//
//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINOn("SPD");
//		CheckError(idx, ret, __LINE__);
//
//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINOn("SPC");
//		CheckError(idx, ret, __LINE__);
//
//		ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(idx, ret, __LINE__);
//		ret = dm[idx]->DPINOn("RWN");
//		CheckError(idx, ret, __LINE__);
//
//		//ret = dm[idx]->DPINOff("FLTMUX");
//		//ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
//		//ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
//		//ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
//		//ret = dm[idx]->ConfigurePMUVoltageLimit("FLTMUX", 6, -2);
//		//ret = dm[idx]->ConfigurePMUCurrentLevel("FLTMUX", 0);
//		//ret = dm[idx]->DPINOn("FLTMUX");
//
//		//Configure Input Delay
//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//		_util->Wait_Sec(On_Delay_s);
//
//		//Write DEFAULT registers 
//		ret = RunVectorFile(idx, "write_default_reg");
//		CheckError(idx, ret, __LINE__);
//
//		//ret = RunVectorFile(idx, "write_dmux_init");	//ML added
//		//CheckError(idx, ret, __LINE__);
//
//		ret = OnOffSPI(idx, 1);
//		CheckError(idx, ret, __LINE__);
//		
//		/////////////////////////////////////////////////////////////////
//		int pin_val = 0;
//
//		//ret = OnOffSPI(idx, 1);
//
//		tmu_start_hysteresis = 0.02;
//		tmu_stop_hysteresis = 0.02;	
//
//		double voh_flt = 0.6;	
//		int retest_count;
//
//		tmu_start_threshold = voh_flt;
//		tmu_stop_threshold = voh_flt;
//		
//		//ML mask as put in dmux_init above
//		ret = WriteSPI(idx, 2, 11, 0x80); //DMUX_EN
//		ret = WriteSPI(idx, 2, 13, 0x91); //WRTPWRSAVE, set bit0, default bit4=1, bit7=1
//		
//		// - Param 0 - ReaderClock_Div16
//
//		//configure FLTMUX to TMU Start & Stop
//		ret = OnOffCbit(idx, 18, 1); //TMU start - connect to FLTMUX
//		ret = OnOffCbit(idx, 19, 1); //TMU stop - connect to FLTMUX
//
//		ret = OnOffSPI(idx, 0);
//		CheckError(idx, ret, __LINE__);	
//		ret = RunVectorFile(idx, "write_ReaderClock");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = WriteSPI(idx, 3, 7, 0x2); //RWTestCtl
//		//ret = WriteSPI(idx, 3, 9, 0x40);//RWTestA, bit6=1
//		////MUX[6:0] = 30 = 001_1110b
//		//ret = WriteSPI(idx, 1, 15, 0x5e);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//ret = WriteSPI(idx, 3, 13, 0);   //Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//			
//		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//		_util->Wait_Sec(Measure_Delay_s);
//
//		retest_count=0;
//		do
//		{		
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(Measure_Delay_s);
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		
//
//			for(int i=0; i<returned_sample_count; i++)
//			{
//				if(sampled_result[i] > 60.79e-9  && sampled_result[i] < 10.2e-8)
//				{
//					tf_SetResult_UUTOffset(TPName[0], (1/sampled_result[i]) + GetOffset(idx, TPDispName[0]), idx); //JL: in Mhz
//					retest_count = 99;
//					break;
//				}
//			}
//			retest_count++;
//			if(retest_count == 10) //return failed result after 10 unsuccessful retries
//				tf_SetResult_UUTOffset(TPName[0], (1/sampled_result[0]) + GetOffset(idx, TPDispName[0]), idx);
//						
//		}
//		while(retest_count <10);
//
//		// - Param 1 - WriterClock_Div16
//
//		ret = RunVectorFile(idx, "write_WriterClock");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = WriteSPI(idx, 3, 7, 0x2); //RWTestCtl	//added by Sidi		ret = WriteSPI(idx, 3, 7, 0x2); 
//		//ret = WriteSPI(idx, 3, 9, 0x20);//RWTestA, bit5=1
//		////MUX[6:0] = 33 = 010_0001b
//		//ret = WriteSPI(idx, 1, 15, 0x61);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//ret = WriteSPI(idx, 3, 13, 0x0 );   //Bit7 = 0 + Mux[6]       + Bit[5:0] = 0   //sidi added
//		_util->Wait_Sec(Measure_Delay_s);
//
//		retest_count=0;
//		do
//		{		
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(0.2e-3);	//ML Measure_Delay_s
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		
//
//			for(int i=0; i<returned_sample_count; i++)
//			{
//				if(sampled_result[i] > 30.3e-9  && sampled_result[i] < 5.128e-8)
//				{
//					tf_SetResult_UUTOffset(TPName[1], (1/sampled_result[i]) + GetOffset(idx, TPDispName[1]), idx); //JL: in Mhz
//					retest_count = 99;
//					break;
//				}
//			}
//			retest_count++;
//			if(retest_count == 10) //return failed result after 10 unsuccessful retries
//				tf_SetResult_UUTOffset(TPName[1], (1/sampled_result[0]) + GetOffset(idx, TPDispName[1]), idx);
//						
//		}
//		while(retest_count <10);
//
//		// - Param 2 - AuxClock_Div16
//		ret = RunVectorFile(idx, "write_AuxClock");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = WriteSPI(idx, 3, 9, 0x10);//RWTestA, bit4=1
//		////MUX[6:0] = 36 = 010_0100b
//		//ret = WriteSPI(idx, 1, 15, 0x64);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		_util->Wait_Sec(Measure_Delay_s);
//		
//		retest_count=0;
//		do
//		{		
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(Measure_Delay_s);
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		
//
//			for(int i=0; i<returned_sample_count; i++)
//			{
//				if(sampled_result[i] > 60.79e-9  && sampled_result[i] < 10.2e-8)
//				{
//					tf_SetResult_UUTOffset(TPName[2], (1/sampled_result[i]) + GetOffset(idx, TPDispName[2]), idx); //JL: in Mhz
//					retest_count = 99;
//					break;
//				}
//			}
//			retest_count++;
//			if(retest_count == 10) //return failed result after 10 unsuccessful retries
//				tf_SetResult_UUTOffset(TPName[2], (1/sampled_result[0]) + GetOffset(idx, TPDispName[2]), idx);
//						
//		}
//		while(retest_count <10);
//
//		// - Param 3 - MaskGeneralFaults_Initiate
//		ret = RunVectorFile(idx, "write_MaskGeneralFaults_Initiate");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = WriteSPI(idx, 3, 7, 0);//RWTestCtl
//		//ret = WriteSPI(idx, 3, 9, 0);//RWTestA
//		////MUX[6:0] = 19 = 001_0011b
//		//ret = WriteSPI(idx, 1, 15, 0x53);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//
//		//configure RWN to TMU Start
//		ret = OnOffCbit(idx, 18, 0); //TMU start - disconnect FLTMUX
//		ret = OnOffCbit(idx, 21, 1); //TMU start - connect RWN
//		
//		number_of_samples=1;
//
//		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//
//		_util->Wait_Sec(Measure_Delay_s);
//		retest_count = 0;
//		sampled_result[0] = 0;
//		do
//		{
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(0.1e-3);	//ML
//
//			ret = RunVectorFile(idx, Vector_File);
//
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//
//			if(ret)			
//				ret = 0;
//			retest_count++;			
//		}
//		while((sampled_result[0] <10e-9 || sampled_result[0] > 50e-9) && retest_count <10);
// 
//		tf_SetResult_UUTOffset(TPName[3], sampled_result[0] + GetOffset(idx, TPDispName[3]), idx);
//
//		// - Param 4 - MaskFaults_General		
//		//MUX[6:0] = 20 = 001_0100b
//		ret = OnOffSPI(idx, 0);
//		CheckError(idx, ret, __LINE__);	
//		ret = RunVectorFile(idx, "write_MaskFaults_General");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = WriteSPI(idx, 1, 15, 0x54);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//_util->Wait_Sec(Measure_Delay_s);
//		
//		sampled_result[0] = 0;
//		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		_util->Wait_Sec(0.1e-3);	//ML
//		ret = RunVectorFile(idx, Vector_File);
//	
//		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult_UUTOffset(TPName[4], sampled_result[0] + GetOffset(idx, TPDispName[4]), idx);
//		
//		// - Param 5 - MaskHeaterFaults_Initiate
//		ret = RunVectorFile(idx, "write_MaskHeaterFaults_Initiate");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = OnOffSPI(idx, 1);
//		//ret = WriteSPI(idx, 1, 13, 0); //WHEAT=0; disable heater in write mode
//		//ret = WriteSPI(idx, 1, 12, 0xbc); //RHEAT=VHT_RD=188=0xbc
//		////Default value of pg1_reg14 = 0x2); PDAC_VDACN = 0; Dynamic fly-height mode = heater voltage mode.
//		//ret = WriteSPI(idx, 1, 7, 0x33); //HEATER_ENABLE (DFHEN) = HEATER_ON (1); bit5 = 1; Dynamic fly-height enable. Default bit 0,1,4 are set.
//		//ret = WriteSPI(idx, 2, 9, 0x21); //POWERRANGE=1, bit5. Default bit 0 is set.
//		//ret = WriteSPI(idx, 2, 14, 0x20); //HEATER_BLANK="DFHWRDELN"=1, bit5. Default all 0.		
//		////MUX[6:0] = 21 = 001_0101b
//		//ret = WriteSPI(idx, 1, 15, 0x55);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//
//		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//		_util->Wait_Sec(Measure_Delay_s);
//
//		sampled_result[0] = 0;
//		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		_util->Wait_Sec(0.1e-3);	//ML
//		
//		ret = RunVectorFile(idx, "write_dmux");
//
//		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult_UUTOffset(TPName[5], sampled_result[0] + GetOffset(idx, TPDispName[5]), idx);
//		
//		// - Param 6 - MaskFaults_Heater
//		//MUX[6:0] = 22 = 001_0110b
//		ret = OnOffSPI(idx, 0);		//ML
//		CheckError(idx, ret, __LINE__);	
//		ret = RunVectorFile(idx, "write_MaskFaults_Heater");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = WriteSPI(idx, 1, 15, 0x56);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//_util->Wait_Sec(Measure_Delay_s);
//		
//		sampled_result[0] = 0;
//		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		_util->Wait_Sec(0.1e-3);	//ML
//		
//		ret = RunVectorFile(idx, "write_dmux");
//
//		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult_UUTOffset(TPName[6], sampled_result[0] + GetOffset(idx, TPDispName[6]), idx);
//		
//		// - Param 7-10 - WtoRRec bit check
//		//MUX[6:0] = 43 = 010_1011b Rdr_Squelch
//		ret = OnOffSPI(idx, 1);		//ML add in
//		ret = WriteSPI(idx, 1, 15, 0x6b);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//	
//		for(int i=0; i<4; i++)
//		{
//			//permute W2RREC values from 0-3
//			int reg_dat = (i & 0x6) << 2;
//			ret = WriteSPI(idx, 2, 8, reg_dat); //Write to Read recovery time
//			_util->Wait_Sec(Measure_Delay_s);
//			ret = OnOffSPI(idx, 0);	//ML add
//
//			sampled_result[0] = 0;
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(0.1e-3);	//ML
//			
//			ret = RunVectorFile(idx, "write_dmux");
//			
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			tf_SetResult_UUTOffset(TPName[7 + i], sampled_result[0] + GetOffset(idx, TPDispName[7 + i]), idx);			
//		}
//		
//		// - Param 11 - Fault_Detect_LowVCCSupply pulse_width
//		ret = OnOffSPI(idx, 0);	//ML add
//		ret = RunVectorFile(idx, "write_Fault_Detect_LowVCC_Pulse");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = OnOffSPI(idx, 1);  //enable SPI
//		//ret = WriteSPI(idx, 1, 10, 0xfd); //enable Supply Flt, bit 1 = 0
//		//ret = WriteSPI(idx, 3, 11, 0xc0);  //wrong - ret = WriteSPI(idx, 3, 1, 0xc0);
//		//
//		////MUX[6:0] = 64 = 100_0000b 
//		//ret = WriteSPI(idx, 1, 15, 0x40);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//ret = WriteSPI(idx, 3, 13, 0x40);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//
//		//ret = OnOffSPI(idx, 0);  //disable SPI
//		ret = RunVectorFile(idx, "write_rwn0"); //set RWN=1
//		ret = dm[idx]->ReadPin("FLTMUX", pin_val);
//		ret = dm[idx]->ReadPin("RWN", pin_val);
//
//		//ret = OnOffSPI(idx, 1);  //enable SPI
//
//		//ret = WriteSPI(idx, 3, 7, 21); //RWTestCtl
//		//ret = WriteSPI(idx, 3, 9, 0xff);//RWTestA
//		//ret = WriteSPI(idx, 3, 10, 0x20);//RWTestB bit[6:4] = TestMode_SupplyFault[2:0]
//
//		ret = OnOffCbit(idx, 21, 0); //TMU start - disconnect RWN
//		ret = OnOffCbit(idx, 18, 1); //TMU start - connect to FLTMUX
//
//		//ret = OnOffSPI(idx, 0);
//		ret = dm[idx]->ReadPin("FLTMUX", pin_val);
//		ret = dm[idx]->ReadPin("RWN", pin_val);
//
//		//JL: TMU start on FLTMUX positive, stop on FLTMUX negative. Reuse same setting as previous tests.
//		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//
//		//tmu_timeout = 60e-3;
//		_util->Wait_Sec(Measure_Delay_s);
//		retest_count = 0;
//		do
//		{
//			sampled_result[0] = 0;
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(0.1e-3);	//ML
//					
//			ret = RunVectorFile(idx,"write_fault_sply_pulse");//takes 37ms
//
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			if(ret)
//			{
//				ret = 0;
//				retest_count++;
//			}
//			else
//				break;		
//		}
//		while(retest_count <10);
//		tf_SetResult_UUTOffset(TPName[11], sampled_result[0] + GetOffset(idx, TPDispName[11]), idx);
//		
//		// - Param 12 - Fault_Detect_LowVEESupply pulse_width
//		//MUX[6:0] = 65 = 100_0001b 
//		ret = RunVectorFile(idx, "write_Fault_Detect_LowVEE_Pulse");	//ML added
//		CheckError(idx, ret, __LINE__);
//
//		//ret = OnOffSPI(idx, 1);  //enable SPI
//		//ret = WriteSPI(idx, 1, 15, 0x41);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//ret = WriteSPI(idx, 3, 13, 0x40);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//		//
//		//ret = WriteSPI(idx, 3, 7, 22); //RWTestCtl
//		//ret = WriteSPI(idx, 3, 9, 0xff);//RWTestA
//		//ret = WriteSPI(idx, 3, 10, 0x40);//RWTestB bit[6:4] = TestMode_SupplyFault[2:0]
//
//		//ret = OnOffSPI(idx, 0);  //off SPI
//		_util->Wait_Sec(Measure_Delay_s);
//
//		sampled_result[0] = 0;
//		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		_util->Wait_Sec(0.1e-3);	//ML
//				
//		ret = RunVectorFile(idx, "write_fault_sply_pulse");
//
//		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult_UUTOffset(TPName[12], sampled_result[0] + GetOffset(idx, TPDispName[12]), idx);
//
//		//ML - Param 13 - MskFltsHtr_PostCal
//		ret = OnOffCbit(idx, 18, 0); //TMU start - disconnect FLTMUX
//		ret = OnOffCbit(idx, 19, 1); //TMU stop - connect FLTMUX	//ML 
//		ret = OnOffCbit(idx, 22, 1); //TMU start - connect SPE
//		_util->Wait_Sec(Measure_Delay_s);
// 
//		ret = RunVectorFile(idx, "write_MskFltsHtr_PostCal");		//ML with write_default_reg content
//
//		number_of_samples=1;
//
//		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//
//		_util->Wait_Sec(Measure_Delay_s);
//
//		sampled_result[0] = 0;
//		retest_count = 0;
//		tmu_timeout = 10e-3;
//		do
//		{
//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(0.1e-3);	//ML add
//			
//			//ML mask
//			////ret = WriteSPI(idx, 1, 15, 0x80); //CALIBRATIONCMD bit7=1. default all 0.
//			//ret = WriteSPI(idx, 1, 7, 0x11);  // sleep2read sidi add
//			//ret = WriteSPI(idx, 1, 7, 0x13);  // sleep2read  sidi add per lpr file
//			//ret = WriteSPI(idx, 1, 15, 0xD6); // CALIBRATIONCMD bit7=1. default all 0. ;; old = 80
//			
//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			if(ret)
//			{
//				ret = 0;
//				retest_count++;
//			}
//			else
//				break;	
//		}
//		while(retest_count < 10);
//
//		tf_SetResult_UUTOffset(TPName[13], sampled_result[0] + GetOffset(idx, TPDispName[13]), idx);
//
//		///////////////////////////////////////
//		// - Param 13 - MskFltsHtr_PostCal
//		
//		////Write Default regs, then enable DMUX - JL: skipped, restore only registers touched above
//		//ret = OnOffSPI(idx, 0); 
//		//ret = RunVectorFile(idx, "write_MskFltsHtr_PostCal");		//ML with write_default_reg content
//		//ret = OnOffSPI(idx, 1);  //enable SPI
//		//ret = WriteSPI(idx, 2, 11, 0x80);
//
//		//////JL: from param 5
//		////ret = WriteSPI(idx, 1, 13, 0); 
//		////ret = WriteSPI(idx, 1, 12, 0); 	
//		////ret = WriteSPI(idx, 2, 9, 0); 
//		////ret = WriteSPI(idx, 2, 14, 0); 	
//		//////JL: from param 7-10
//		////ret = WriteSPI(idx, 2, 8, 0); 
//		//////JL: from param 11
//		////ret = WriteSPI(idx, 1, 10, 0xff); //disable all flt
//		////JL: from param 12
//		////ret = WriteSPI(idx, 3, 7, 0); //RWTestCtl
//		////ret = WriteSPI(idx, 3, 9, 0);//RWTestA
//		////ret = WriteSPI(idx, 3, 10, 0);//RWTestB
//		//
//		////MUX[6:0] = 22 = 001_0110b
//		//ret = WriteSPI(idx, 1, 15, 0x56);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		//ret = WriteSPI(idx, 3, 13, 0); // sidi added 
//		//ret = WriteSPI(idx, 2, 13, 0x10); //MRRNGOVERRIDE bit7=0; default bit4=1, bit7=1
//		//ret = WriteSPI(idx, 1, 7, 0x13); //idle mode. bit1=0, bit0=1. default 0, 1, 4 are set // slepN	//ML why?
//		//ret = WriteSPI(idx, 1, 7, 0x11); //idle mode. bit1=0, bit0=1. default 0, 1, 4 are set
//		
////		ret = OnOffCbit(idx, 18, 0); //TMU start - disconnect FLTMUX
////		ret = OnOffCbit(idx, 19, 1); //TMU stop - connect FLTMUX	//ML 
////		ret = OnOffCbit(idx, 22, 1); //TMU start - connect SPE
////		_util->Wait_Sec(Measure_Delay_s);
////
////		//SPE positive is used for TMU start		
//////		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//////		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
////		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
////		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
////
////		_util->Wait_Sec(Measure_Delay_s);
////
////		sampled_result[0] = 0;
////		retest_count = 0;
////		tmu_timeout = 10e-3;
////		do
////		{
////			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
////			_util->Wait_Sec(0.1e-3);	//ML add
////			
////			//ML mask
////			////ret = WriteSPI(idx, 1, 15, 0x80); //CALIBRATIONCMD bit7=1. default all 0.
////			//ret = WriteSPI(idx, 1, 7, 0x11);  // sleep2read sidi add
////			//ret = WriteSPI(idx, 1, 7, 0x13);  // sleep2read  sidi add per lpr file
////			//ret = WriteSPI(idx, 1, 15, 0xD6); // CALIBRATIONCMD bit7=1. default all 0. ;; old = 80
////			
////			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
////			if(ret)
////			{
////				ret = 0;
////				retest_count++;
////			}
////			else
////				break;	
////		}
////		while(retest_count < 10);
////
////		tf_SetResult_UUTOffset(TPName[13], sampled_result[0] + GetOffset(idx, TPDispName[13]), idx);
//		
//			//if(USE_SPI)
//			//{
//				ret = OnOffSPI(idx, 0);
//				CheckError(idx, ret, __LINE__);
//			//}
//		/////////////////////////////////////////////////////////////////
//			ret = ResetDMPin(idx, TPDispName[0]);
//			CheckError(idx, ret, __LINE__);
//
//			//Power down supplies
//			//ret = smu[idx]->DriveVoltage("VEE", 0);
//			//CheckError(idx, ret, __LINE__);
//			ret = smu[idx]->DriveVoltage("VCC", 0);
//			CheckError(idx, ret, __LINE__);
//
//			//IO setting
//			ret = ResetCBit(idx);
//			CheckError(idx, ret, __LINE__);
//			ret = ResetMuxIO(idx);
//			CheckError(idx, ret, __LINE__);
//		}
//		catch (Exception^ ex) 
//		{
//			d->Exception = ex;
//			d->ErrorCode = ret;
//		}		
//	}
	void TestProgram::dmux(Object^ object) //JL: New test
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;
		
		int ret = 0;
		
		try 
		{
		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double Input_Channel_Delay_s = 0;
		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
				
		double vih;
		double vil;
		double voh; 
		double vol;
		double ioh;
		double iol;
		double vch;
		double vcl;
		double vt;

		double tmu_start_threshold = 0;
		double tmu_stop_threshold = 0;
		double tmu_start_hysteresis = 0;
		double tmu_stop_hysteresis = 0;
		int number_of_samples = 10;
		double tmu_timeout = 10e-3; //JL: changed from 10e-3
		int returned_sample_count = 0;
		array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
		array<double> ^ sampled_result1 = gcnew array<double>(1);
		//IO setting
		ret = SetupDigital(idx);
		CheckError(idx, ret, __LINE__);
		ret = DriveCBit(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);
		ret = DriveMuxIO(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);

		//Setup Power supplies
		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
		//ret = smu[idx]->DriveVoltage("VCC", 0);
		//ret = smu[idx]->OnSmuPin("VCC", true, false);

		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
		//ret = smu[idx]->DriveVoltage("VEE", 0);
		//ret = smu[idx]->OnSmuPin("VEE", true, false);
		//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

		vih = 2.5;
		vil = 0.00;
		voh = 0.75; 
		vol = 0.75;
		ioh = 0.002;
		iol = 0.002;
		vch = 6;
		vcl = -0.1;
		vt = 0;

		ret = DriveDMPin(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SPE");
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SPD");
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SPC");
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("RWN");
		CheckError(idx, ret, __LINE__);

		//ret = dm[idx]->DPINOff("FLTMUX");
		//ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
		//ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
		//ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
		//ret = dm[idx]->ConfigurePMUVoltageLimit("FLTMUX", 6, -2);
		//ret = dm[idx]->ConfigurePMUCurrentLevel("FLTMUX", 0);
		//ret = dm[idx]->DPINOn("FLTMUX");

		//Configure Input Delay
		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		_util->Wait_Sec(On_Delay_s);

		//Write DEFAULT registers 
		ret = RunVectorFile(idx, "write_default_reg");
		CheckError(idx, ret, __LINE__);

		ret = RunVectorFile(idx, "write_dmux_init");	//ML added
		CheckError(idx, ret, __LINE__);

		ret = OnOffSPI(idx, 1);
		CheckError(idx, ret, __LINE__);
		
		/////////////////////////////////////////////////////////////////
		int pin_val = 0;

		//ret = OnOffSPI(idx, 1);

		tmu_start_hysteresis = 0.02;
		tmu_stop_hysteresis = 0.02;	

		double voh_flt = 0.5;	//orig is 0.6
		int retest_count;

		tmu_start_threshold = voh_flt;
		tmu_stop_threshold = voh_flt;
		
		//ML mask and replace by dmux_init
		//ret = WriteSPI(idx, 2, 11, 0x80); //DMUX_EN
		//ret = WriteSPI(idx, 2, 13, 0x91); //WRTPWRSAVE, set bit0, default bit4=1, bit7=1
		
		// - Param 0 - ReaderClock_Div16
		ret = OnOffSPI(idx, 0);
		ret = RunVectorFile(idx, "write_ReaderClock");
		CheckError(idx, ret, __LINE__);

		//configure FLTMUX to TMU Start & Stop
		ret = OnOffCbit(idx, 18, 1); //TMU start - connect to FLTMUX
		ret = OnOffCbit(idx, 19, 1); //TMU stop - connect to FLTMUX
		
		//ret = WriteSPI(idx, 3, 7, 0x2); //RWTestCtl
		//ret = WriteSPI(idx, 3, 9, 0x40);//RWTestA, bit6=1
		////MUX[6:0] = 30 = 001_1110b
		//ret = WriteSPI(idx, 1, 15, 0x5e);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		//ret = WriteSPI(idx, 3, 13, 0);   //Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
			
		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		_util->Wait_Sec(Measure_Delay_s);

		retest_count=0;
		do
		{		
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(Measure_Delay_s);
			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		

			for(int i=0; i<returned_sample_count; i++)
			{
				if(sampled_result[i] > 60.79e-9  && sampled_result[i] < 10.2e-8)
				{
					tf_SetResult_UUTOffset(TPName[0], (1/sampled_result[i]) + GetOffset(idx, TPDispName[0]), idx); //JL: in Mhz
					retest_count = 99;
					break;
				}
			}
			retest_count++;
			if(retest_count == 10) //return failed result after 10 unsuccessful retries
				tf_SetResult_UUTOffset(TPName[0], (1/sampled_result[0]) + GetOffset(idx, TPDispName[0]), idx);
						
		}
		while(retest_count <10);

		// - Param 1 - WriterClock_Div16
		ret = RunVectorFile(idx, "write_WriterClock");
		CheckError(idx, ret, __LINE__);

		//ret = WriteSPI(idx, 3, 7, 0x2); //RWTestCtl	//added by Sidi		ret = WriteSPI(idx, 3, 7, 0x2); 
		//ret = WriteSPI(idx, 3, 9, 0x20);//RWTestA, bit5=1
		////MUX[6:0] = 33 = 010_0001b
		//ret = WriteSPI(idx, 1, 15, 0x61);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		//ret = WriteSPI(idx, 3, 13, 0x0 );   //Bit7 = 0 + Mux[6]       + Bit[5:0] = 0   //sidi added
		_util->Wait_Sec(Measure_Delay_s);

		retest_count=0;
		do
		{		
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(Measure_Delay_s);
			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		

			for(int i=0; i<returned_sample_count; i++)
			{
				if(sampled_result[i] > 30.3e-9  && sampled_result[i] < 5.128e-8)
				{
					tf_SetResult_UUTOffset(TPName[1], (1/sampled_result[i]) + GetOffset(idx, TPDispName[1]), idx); //JL: in Mhz
					retest_count = 99;
					break;
				}
			}
			retest_count++;
			if(retest_count == 10) //return failed result after 10 unsuccessful retries
				tf_SetResult_UUTOffset(TPName[1], (1/sampled_result[0]) + GetOffset(idx, TPDispName[1]), idx);
						
		}
		while(retest_count <10);

		// - Param 2 - AuxClock_Div16
		ret = RunVectorFile(idx, "write_AuxClock");
		CheckError(idx, ret, __LINE__);

		//ret = WriteSPI(idx, 3, 9, 0x10);//RWTestA, bit4=1
		////MUX[6:0] = 36 = 010_0100b
		//ret = WriteSPI(idx, 1, 15, 0x64);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		_util->Wait_Sec(Measure_Delay_s);
		
		retest_count=0;
		do
		{		
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(Measure_Delay_s);
			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		

			for(int i=0; i<returned_sample_count; i++)
			{
				if(sampled_result[i] > 60.79e-9  && sampled_result[i] < 10.2e-8)
				{
					tf_SetResult_UUTOffset(TPName[2], (1/sampled_result[i]) + GetOffset(idx, TPDispName[2]), idx); //JL: in Mhz
					retest_count = 99;
					break;
				}
			}
			retest_count++;
			if(retest_count == 10) //return failed result after 10 unsuccessful retries
				tf_SetResult_UUTOffset(TPName[2], (1/sampled_result[0]) + GetOffset(idx, TPDispName[2]), idx);
						
		}
		while(retest_count <10);

		// - Param 3 - MaskGeneralFaults_Initiate
		ret = RunVectorFile(idx, "write_MaskGeneralFaults_Initiate");
		CheckError(idx, ret, __LINE__);

		//ret = WriteSPI(idx, 3, 7, 0);//RWTestCtl
		//ret = WriteSPI(idx, 3, 9, 0);//RWTestA
		////MUX[6:0] = 19 = 001_0011b
		//ret = WriteSPI(idx, 1, 15, 0x53);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]

		//configure RWN to TMU Start
		ret = OnOffCbit(idx, 18, 0); //TMU start - disconnect FLTMUX
		ret = OnOffCbit(idx, 21, 1); //TMU start - connect RWN
		
		number_of_samples=1;

		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);

		_util->Wait_Sec(Measure_Delay_s);
		retest_count = 0;
		sampled_result[0] = 0;
		do
		{
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(0.1e-3);	//ML
			ret = RunVectorFile(idx, Vector_File);

			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

			if(ret)			
				ret = 0;
			retest_count++;			
		}
		while((sampled_result[0] <10e-9 || sampled_result[0] > 50e-9) && retest_count <10);
 
		tf_SetResult_UUTOffset(TPName[3], sampled_result[0] + GetOffset(idx, TPDispName[3]), idx);

		// - Param 4 - MaskFaults_General- ML vector not working, revert to writespi method	
		//ret = RunVectorFile(idx, "write_MaskFaults_General");
		//CheckError(idx, ret, __LINE__);

		////MUX[6:0] = 20 = 001_0100b
		ret = OnOffSPI(idx, 1);	//ML add
		ret = WriteSPI(idx, 1, 15, 0x54);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		_util->Wait_Sec(Measure_Delay_s);
		
		sampled_result[0] = 0;
		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		_util->Wait_Sec(0.1e-3);	//ML
		ret = RunVectorFile(idx, Vector_File);
	
		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
		tf_SetResult_UUTOffset(TPName[4], sampled_result[0] + GetOffset(idx, TPDispName[4]), idx);
		
		// - Param 5 - MaskHeaterFaults_Initiate
		ret = OnOffSPI(idx, 0);
		ret = RunVectorFile(idx, "write_MaskHeaterFaults_Initiate");
		CheckError(idx, ret, __LINE__);

		//ret = OnOffSPI(idx, 1);
		//ret = WriteSPI(idx, 1, 13, 0); //WHEAT=0; disable heater in write mode
		//ret = WriteSPI(idx, 1, 12, 0xbc); //RHEAT=VHT_RD=188=0xbc
		////Default value of pg1_reg14 = 0x2); PDAC_VDACN = 0; Dynamic fly-height mode = heater voltage mode.
		//ret = WriteSPI(idx, 1, 7, 0x33); //HEATER_ENABLE (DFHEN) = HEATER_ON (1); bit5 = 1; Dynamic fly-height enable. Default bit 0,1,4 are set.
		//ret = WriteSPI(idx, 2, 9, 0x21); //POWERRANGE=1, bit5. Default bit 0 is set.
		//ret = WriteSPI(idx, 2, 14, 0x20); //HEATER_BLANK="DFHWRDELN"=1, bit5. Default all 0.		
		////MUX[6:0] = 21 = 001_0101b
		//ret = WriteSPI(idx, 1, 15, 0x55);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]

		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		_util->Wait_Sec(Measure_Delay_s);

		sampled_result[0] = 0;
		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		_util->Wait_Sec(0.1e-3);	//ML
		ret = RunVectorFile(idx, "write_dmux");

		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
		tf_SetResult_UUTOffset(TPName[5], sampled_result[0] + GetOffset(idx, TPDispName[5]), idx);
		
		// - Param 6 - MaskFaults_Heater
		ret = RunVectorFile(idx, "write_MaskFaults_Heater");
		CheckError(idx, ret, __LINE__);

		////MUX[6:0] = 22 = 001_0110b
		//ret = WriteSPI(idx, 1, 15, 0x56);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		_util->Wait_Sec(Measure_Delay_s);
		
		sampled_result[0] = 0;
		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		_util->Wait_Sec(0.1e-3);	//ML

		ret = RunVectorFile(idx, "write_dmux");

		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
		tf_SetResult_UUTOffset(TPName[6], sampled_result[0] + GetOffset(idx, TPDispName[6]), idx);
		
		// - Param 7-10 - WtoRRec bit check
		//MUX[6:0] = 43 = 010_1011b Rdr_Squelch
		ret = OnOffSPI(idx, 1);
		ret = WriteSPI(idx, 1, 15, 0x6b);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
	
		for(int i=0; i<4; i++)
		{
			//permute W2RREC values from 0-3
			int reg_dat = (i & 0x6) << 2;
			ret = WriteSPI(idx, 2, 8, reg_dat); //Write to Read recovery time
			_util->Wait_Sec(Measure_Delay_s);

			sampled_result[0] = 0;
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(0.1e-3);	//ML

			ret = RunVectorFile(idx, "write_dmux");
			
			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
			tf_SetResult_UUTOffset(TPName[7 + i], sampled_result[0] + GetOffset(idx, TPDispName[7 + i]), idx);			
		}
		
		// - Param 11 - Fault_Detect_LowVCCSupply pulse_width - ML use vector
		ret = OnOffSPI(idx, 0);		//ML - must hv, else will fail
		ret = RunVectorFile(idx, "write_Fault_Detect_LowVCC_Pulse");
		CheckError(idx, ret, __LINE__);

		//ret = OnOffSPI(idx, 1);  //enable SPI
		//ret = WriteSPI(idx, 1, 10, 0xfd); //enable Supply Flt, bit 1 = 0
		//ret = WriteSPI(idx, 3, 11, 0xc0);  //wrong - ret = WriteSPI(idx, 3, 1, 0xc0);
		//
		////MUX[6:0] = 64 = 100_0000b 
		//ret = WriteSPI(idx, 1, 15, 0x40);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		//ret = WriteSPI(idx, 3, 13, 0x40);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0

		//ret = OnOffSPI(idx, 0);  //disable SPI
		ret = RunVectorFile(idx, "write_rwn0"); //set RWN=1
		ret = dm[idx]->ReadPin("FLTMUX", pin_val);
		ret = dm[idx]->ReadPin("RWN", pin_val);

		//ret = OnOffSPI(idx, 1);  //enable SPI

		//ret = WriteSPI(idx, 3, 7, 21); //RWTestCtl
		//ret = WriteSPI(idx, 3, 9, 0xff);//RWTestA
		//ret = WriteSPI(idx, 3, 10, 0x20);//RWTestB bit[6:4] = TestMode_SupplyFault[2:0]

		ret = OnOffCbit(idx, 21, 0); //TMU start - disconnect RWN
		ret = OnOffCbit(idx, 18, 1); //TMU start - connect to FLTMUX

		//ret = OnOffSPI(idx, 0);
		ret = dm[idx]->ReadPin("FLTMUX", pin_val);
		ret = dm[idx]->ReadPin("RWN", pin_val);

		//JL: TMU start on FLTMUX positive, stop on FLTMUX negative. Reuse same setting as previous tests.
		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);

		//tmu_timeout = 60e-3;
		_util->Wait_Sec(Measure_Delay_s);
		retest_count = 0;
		do
		{
			sampled_result[0] = 0;
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(0.1e-3);	//ML

			ret = RunVectorFile(idx,"write_fault_sply_pulse");//takes 37ms

			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
			if(ret)
			{
				ret = 0;
				retest_count++;
			}
			else
				break;		
		}
		while(retest_count <10);
		tf_SetResult_UUTOffset(TPName[11], sampled_result[0] + GetOffset(idx, TPDispName[11]), idx);
		
		// - Param 12 - Fault_Detect_LowVEESupply pulse_width - ML use vector method
		//MUX[6:0] = 65 = 100_0001b 
		ret = RunVectorFile(idx, "write_Fault_Detect_LowVEE_Pulse");
		CheckError(idx, ret, __LINE__);

		//ret = OnOffSPI(idx, 1);  //enable SPI
		//ret = WriteSPI(idx, 1, 15, 0x41);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		//ret = WriteSPI(idx, 3, 13, 0x40);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
		//
		//ret = WriteSPI(idx, 3, 7, 22); //RWTestCtl
		//ret = WriteSPI(idx, 3, 9, 0xff);//RWTestA
		//ret = WriteSPI(idx, 3, 10, 0x40);//RWTestB bit[6:4] = TestMode_SupplyFault[2:0]

		//ret = OnOffSPI(idx, 0);  //off SPI
		_util->Wait_Sec(Measure_Delay_s);

		sampled_result[0] = 0;
		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		_util->Wait_Sec(0.1e-3);	//ML

		ret = RunVectorFile(idx, "write_fault_sply_pulse");

		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
		tf_SetResult_UUTOffset(TPName[12], sampled_result[0] + GetOffset(idx, TPDispName[12]), idx);
		
		// - Param 13 - MskFltsHtr_PostCal
		
		//Write Default regs, then enable DMUX - JL: skipped, restore only registers touched above
		ret = OnOffSPI(idx, 0); 
		ret = RunVectorFile(idx, "write_MskFltsHtr_PostCal");		//include write_default_reg
		//ret = OnOffSPI(idx, 1);  //enable SPI
		//ret = WriteSPI(idx, 2, 11, 0x80);

		//////JL: from param 5
		////ret = WriteSPI(idx, 1, 13, 0); 
		////ret = WriteSPI(idx, 1, 12, 0); 	
		////ret = WriteSPI(idx, 2, 9, 0); 
		////ret = WriteSPI(idx, 2, 14, 0); 	
		//////JL: from param 7-10
		////ret = WriteSPI(idx, 2, 8, 0); 
		//////JL: from param 11
		////ret = WriteSPI(idx, 1, 10, 0xff); //disable all flt
		////JL: from param 12
		////ret = WriteSPI(idx, 3, 7, 0); //RWTestCtl
		////ret = WriteSPI(idx, 3, 9, 0);//RWTestA
		////ret = WriteSPI(idx, 3, 10, 0);//RWTestB
		//
		////MUX[6:0] = 22 = 001_0110b
		//ret = WriteSPI(idx, 1, 15, 0x56);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
		//ret = WriteSPI(idx, 3, 13, 0); // sidi added 
		//ret = WriteSPI(idx, 2, 13, 0x10); //MRRNGOVERRIDE bit7=0; default bit4=1, bit7=1
		//ret = WriteSPI(idx, 1, 7, 0x13); //idle mode. bit1=0, bit0=1. default 0, 1, 4 are set // slepN	//ML why?
		//ret = WriteSPI(idx, 1, 7, 0x11); //idle mode. bit1=0, bit0=1. default 0, 1, 4 are set
		
		ret = OnOffCbit(idx, 18, 0); //TMU start - disconnect FLTMUX
		ret = OnOffCbit(idx, 19, 1); //TMU stop - connect FLTMUX	//ML 
		ret = OnOffCbit(idx, 22, 1); //TMU start - connect SPE
		_util->Wait_Sec(Measure_Delay_s);

		//SPE positive is used for TMU start		
//		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);

		_util->Wait_Sec(Measure_Delay_s);

		sampled_result[0] = 0;
		retest_count = 0;
		tmu_timeout = 10e-3;
		do
		{
			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(0.1e-3);	//ML

            ret = RunVectorFile(idx, "write_MskFltsHtr_sleep2rd");  

			////ret = WriteSPI(idx, 1, 15, 0x80); //CALIBRATIONCMD bit7=1. default all 0.
			//ret = WriteSPI(idx, 1, 7, 0x11);  // sleep2read sidi add
			//ret = WriteSPI(idx, 1, 7, 0x13);  // sleep2read  sidi add per lpr file
			//ret = WriteSPI(idx, 1, 15, 0xD6); // CALIBRATIONCMD bit7=1. default all 0. ;; old = 80
			
			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
			if(ret)
			{
				ret = 0;
				retest_count++;
			}
			else
				break;	
		}
		while(retest_count < 10);

		tf_SetResult_UUTOffset(TPName[13], sampled_result[0] + GetOffset(idx, TPDispName[13]), idx);
		
			//if(USE_SPI)
			//{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			//}
		/////////////////////////////////////////////////////////////////
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::dgf(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{			
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			String ^ Vector_File	= String::Empty;
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			double tmu_start_threshold = 0;
			double tmu_stop_threshold = 0;
			double tmu_start_hysteresis = 0;
			double tmu_stop_hysteresis = 0;
			int number_of_samples = 0;
			double tmu_timeout = 0;
			int returned_sample_count = 0;
			array<double> ^ sampled_result;
			
			int vector_engine_status = 0;

			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			//Write DEFAULT registers 
			
			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);

				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
			}
	
			array<double> ^ Target = gcnew array<double>(total_tp);
			array<double> ^ Actual = gcnew array<double>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				Target[i] = 0;
				Actual[i] = 0;
				result[i] = 0;
			}

			tmu_start_threshold = 0.5;
			tmu_stop_threshold = 0.5;
			tmu_start_hysteresis = 0.02;//0.2;
			tmu_stop_hysteresis = 0.02;//0.2;
			number_of_samples = 10;
			tmu_timeout = 10e-3;

			double res_tmp = 0;

			sampled_result = gcnew array<double>(number_of_samples);

			for (int i=0; i<total_tp; i++)
			{
				if (TPName[i]->Contains("Target"))
				{
					Target[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));

					result[i] = Target[i];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (TPName[i]->Contains("Min") == true ||
					TPName[i]->Contains("Max") == true)
				{
					Target[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}

					ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
					CheckError(idx, ret, __LINE__);
					ret = tm[idx]->ArmSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, number_of_samples, TM_CONST_SOFTWARE_ARM, TM_CONST_SLOPE_POSITIVE, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, tmu_timeout, 0);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
					ret = tm[idx]->RetrieveResultsSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, 0, returned_sample_count, sampled_result);
			
					if (ret)
					{
						result[i] = 999;
						ret = 0;
					}
					else
					{
						int count = returned_sample_count;
						double temp = 0;
						res_tmp = 0;
						for (int k=0; k<returned_sample_count; k++)
						{
							if (sampled_result[k] > 0)
							{
								temp = (1 / sampled_result[k]) * 256;
								if (Math::Abs(Target[i] - temp)/Target[i] < 0.1) 
									res_tmp += sampled_result[k];
								else
									count--;
							}
							else
								count--;
						}

						if (count > 0)
						{
							res_tmp = res_tmp / count;

							//res_tmp = 1 / (res_tmp * 2); //convert to freq, 50% DC
							res_tmp = 1 / (res_tmp); //convert to freq, 50% DC

							result[i] = res_tmp * 256;
						}
						else
						{
							result[i] = 999;
						}					
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

				}
				else if (TPName[i]->StartsWith("dFdg") == true)
				{
					if (result[i-1] != 999)
					{
						result[i] = (result[i-1] / result[i-2] - 1) * 100;
					}
					else
					{
						result[i] = 999;
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}

					ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
					CheckError(idx, ret, __LINE__);
					ret = tm[idx]->ArmSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, number_of_samples, TM_CONST_SOFTWARE_ARM, TM_CONST_SLOPE_POSITIVE, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, tmu_timeout, 0);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
					ret = tm[idx]->RetrieveResultsSingleInput("TM_CH", TM_CONST_STOP_CHANNEL, 0, returned_sample_count, sampled_result);

					if (ret)
					{
						result[i] = 999;
						ret = 0;
					}
					else
					{
						int count = returned_sample_count;
						double temp = 0;
						res_tmp = 0;
						for (int k=0; k<returned_sample_count; k++)
						{
							if (sampled_result[k] > 0)
							{
								temp = (1 / sampled_result[k]) * 256;
								if (Math::Abs(result[i-1] - temp)/result[i-1] < 0.1) 
									res_tmp += sampled_result[k];
								else
									count--;
							}
							else
								count--;
						}

						if (count > 0)
						{
							res_tmp = res_tmp / count;

							//res_tmp = 1 / (res_tmp * 2); //convert to freq, 50% DC
							res_tmp = 1 / (res_tmp); //convert to freq, 50% DC

							result[i] = res_tmp * 256;
						}
						else
						{
							result[i] = 999;
						}	
					}
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					
				}
			}	

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::dgt(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;
		
		try 
		{	
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			String ^ Vector_File	= String::Empty;
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			double tmu_start_threshold = 0;
			double tmu_stop_threshold = 0;
			double tmu_start_hysteresis = 0;
			double tmu_stop_hysteresis = 0;
			int number_of_samples = 1;
			double tmu_timeout = 10e-3;
			int returned_sample_count = 0;
			array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
			
			int vector_engine_status = 0;

			Stopwatch swatch;				

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			_util->Wait_Sec(On_Delay_s);

			//Write DEFAULT registers 
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
				result[i] = 0;

			tmu_start_hysteresis = 0.02;
			tmu_stop_hysteresis = 0.02;	

			double voh_flt = 0.6;	//ML ori 0.6		
			
			//if (Test != TEST_IF4600_PKG)	//ML remove
				voh_flt = 0.45; //0.4;

			double res_tmp = 0;
			int retest_count = 0;
			int cbit_tmustart_rwn = 1; //JL: flag to indicate currently RWN is connected to TMU Start.

			for (int i=0; i<total_tp; i++)
			{			
				if(i == 0)//JL: param0 only - Wtr_RunDataOscilator
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
					
					ret = RunVectorFile(idx, Vector_File); //JL: RWN low (writer active), then high (writer off)
					CheckError(idx, ret, __LINE__);
					tmu_start_threshold = voh_flt * 0.2;
					tmu_stop_threshold = voh_flt * 0.8;

					retest_count = 0;
	 
					do{
						//JL: set up TMU to measure the timing between writer off to degauss oscillator enabled.
						ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
						CheckError(idx, ret, __LINE__);
						ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(0.1e-3);		//TTR 500us to 100us

						ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(0.1e-3);	//ML  50e-6
						
						ret = RunVectorFile(idx, "write_dgt"); //JL: run pattern; starts with RWN low (writer active), then high (writer off)
						CheckError(idx, ret, __LINE__);
						
						ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

						if(ret)
						{
							ret = 0;
							retest_count++;
						}
						else
							break;
					}
					while(retest_count < 10);
					
					
					if(retest_count >= 10) //JL: if error occur
					{
						result[i] = 999;
						ret = 0;
					}
					else
						result[i] = sampled_result[0] + 6e-9;	//ML 2935 result[i] = result[i] + 6e-9;
					
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i>0 && i <=24) //JL: MUX = (DegaussDuration_Pulse) to measure the programmable degauss time after writer is turned off
				{                       //    Permute for all degauss time setting from 0-7; 10ns - 80ns in 10ns increment.
										//    1. Set the target degauss time = just grab param condition Target's value directly.
										//    2. Measure FLTMUX (muxed to show degauss time) pulse width.
										//    3. Calculate the % deviation between measured value to target value.
					if (TPName[i]->Contains("Target")) //JL: step 1
					{
						result[i] = (double)(tf_TPCondition_Cast(TPName[i], "Target"));
						 
						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}				
					else if (TPName[i]->Contains("Pulse"))//JL: step 2; dtgx_Pulse - measure FLTMUX pulse width from rising to falling
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
						//JL: program Mux (only one time in the first vector)) & Degauss Time (changed every vector)
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						
						if(cbit_tmustart_rwn == 1)
						{
							OnOffCbit(idx, 21,0);//JL: Disconnect RWN from TMU Start			
							OnOffCbit(idx, 18,1);//JL: Connect FLTMUX to TMU Start
							cbit_tmustart_rwn = 0;
						}
						
						tmu_start_threshold = 0.3; //JL: voh_flt / 2;
						tmu_stop_threshold = 0.36; //JL: voh_flt / 2;
						
						retest_count = 0;

						do
						{
							ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
							CheckError(idx, ret, __LINE__);
							ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(0.1e-3);		//TTR 500us to 100us	0.1e-3
							ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(0.1e-3);	//ML
							
							ret = RunVectorFile(idx, "write_dgt"); //JL: run pattern; starts with RWN low (writer active), then high (writer off)
							CheckError(idx, ret, __LINE__);
							
							ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

							if(ret)
							{
								ret = 0;
								retest_count++;
							}
							else
								break;
						}
						while(retest_count < 10);
						
						if(retest_count >= 10)
						{
							result[i] = 999;
							ret = 0;
						}
						else
							result[i] = sampled_result[0];

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						
					}
					else//JL: step 3
					{
						if (result[i-1] != 999)					
							result[i] = (result[i-1] / result[i-2] - 1) * 100;					
						else					
							result[i] = 999;					

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
				}
				else if (i >=25 && i<= 32)
				{
					//JL: MUX = (Wtr_EnWriteData)
					//    measure the time from RWN going high (writer off) to FLTMUX (EnWriteData signal) going low.
					
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
					//JL: program Mux (only one time in the first vector)) & Degauss Time (changed every vector)
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					
					if(cbit_tmustart_rwn == 0)
					{
						OnOffCbit(idx, 18,0);//JL: Disconnect FLTMUX from TMU Start
						OnOffCbit(idx, 21,1);//JL: Connect RWN to TMU Start	
						cbit_tmustart_rwn = 1;
					}
					
					tmu_start_threshold = 0.4; //JL: voh_flt / 2;
					tmu_stop_threshold = 0.98; //JL: voh_flt / 2;
					
					retest_count = 0;

					do
					{
						ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
						CheckError(idx, ret, __LINE__);
						ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(0.1e-3);		//TTR 500us to 100us
						ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(0.1e-3);	//ML
						
						ret = RunVectorFile(idx, "write_dgt"); //JL: run pattern; starts with RWN low (writer active), then high (writer off)
						CheckError(idx, ret, __LINE__);
						
						ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

						if(ret)
						{
							ret = 0;
							retest_count++;
						}
						else
							break;
					}
					while(retest_count < 10);
					
					if(retest_count >= 10)
					{
						result[i] = 999;
						ret = 0;
					}
					else
						result[i] = sampled_result[0]-result[0]+1e-9;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if(i >=33 && i <= 36)
				{	//JL: MUX = (Wtr_ReaderDegaussDone)
					//    measure the delay of reader activation when RWN changes from 0 to 1.
					//    from RWN going high to FLTMUX (ReaderDegaussDone) going high
					
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
					//JL: program Mux (only one time in the first vector)) & DEGAUSSW2RDLY Degauss write-to-read delay (changed every vector)
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					
					tmu_start_threshold = 0.3; //JL: voh_flt / 2;
					tmu_stop_threshold = 0.3; //JL: voh_flt / 2;
					
					retest_count = 0;

					do
					{
						ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
						CheckError(idx, ret, __LINE__);
						ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(0.1e-3);		//TTR 500us to 100us
						ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(0.1e-3);	//ML
						
						ret = RunVectorFile(idx, "write_dgt"); //JL: run pattern; starts with RWN low (writer active), then high (writer off)
						CheckError(idx, ret, __LINE__);
						
						ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

						if(ret)
						{
							if(i==33)
								break;
							ret = 0;
							retest_count++;
						}
						else
							break;
					}
					while(retest_count < 10);
					
					if(i!=33 && retest_count >= 10)
					{
						result[i] = 999;
						ret = 0;
					}
					else if(i == 33 && ret)
						result[i] = 0; //JL: expect no pulse for DEGAUSSW2RDLY=0, TMU will timeout.
					else
						result[i] = sampled_result[0];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if(i=37) 
				{
					//JL: verify DEGAUSSW2RDLY Degauss write-to-read delay
					//    Make sure DEGAUSSW2RDLY = 01 (100% Degauss time delay) gives >10ns write-to-read delay compared to DEGAUSSW2RDLY = 00 (0% delay)
					if(result[34] > (result[33]+10e-9))
						result[i] = 1;
					
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}	
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::adc_ramp(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;
	
		//JL: 
		// pins default state: RWN=1, SYNC=0
		// cbit: RWN, SYNC, FLTMUX
		// vector file: write_adc_time	
		try 
		{			

		//Get test name from techFlow
		int total_tp = (int)tf_TPCount();
		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

		for (int i=0; i<total_tp; i++)
		{
			TPDispName[i] = tf_TestParameter_DisplayName(i);
			TPName[i] = tf_TestParameter_Name(i);
		}

		String ^ TIDispName = tf_TestItem_DisplayName();

		//Get test condition from techFlow
		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
		double Input_Channel_Delay_s = 0;
		double Input_Channel_Delay_norm_s = 0;
		bool isCurrentTPBypassed = false;
		//Debug_Enable = true;

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][idx];

		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
			Input_Channel_Delay_norm_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

		double _Input_Channel_Delay_s = 0;
				
		double vih;
        double vil;
        double voh; 
        double vol;
        double ioh;
		double iol;
        double vch;
        double vcl;
		double vt;
		
		int vector_engine_status = 0;
		int data = 0;

		Stopwatch swatch;

		//IO setting
		ret = SetupDigital(idx);
		CheckError(idx, ret, __LINE__);
		ret = DriveCBit(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);
		ret = DriveMuxIO(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);
		
		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
		CheckError(idx, ret, __LINE__);
		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
		//CheckError(idx, ret, __LINE__);
		//_util->Wait_Sec(On_Delay_s);
		
		vih = 2.5;
        vil = 0.00;
        voh = 0.75; 
        vol = 0.75;
        ioh = 0.002;
		iol = 0.002;
        vch = 6;
        vcl = -0.1;
		vt = 0;

		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SPE");
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SPD");
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SPC");
		CheckError(idx, ret, __LINE__);

		ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->DPINOn("SYNC");
		CheckError(idx, ret, __LINE__);

		//ret += dm->DPINOff("FLTMUX");
		//CheckError(idx, ret, __LINE__);
		//ret += dm->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
		//CheckError(idx, ret, __LINE__);
		//ret += dm->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
		//CheckError(idx, ret, __LINE__);
		////for measuring current
		////ret += dm->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
		////ret += dm->ConfigurePMUCurrentLimitRange("FLTMUX", 0.002);
		////ret += dm->ConfigurePMUVoltageLevel("FLTMUX", 0);
		////for measuring voltage
		//ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
		//CheckError(idx, ret, __LINE__);
		//ret = dm[idx]->ConfigurePMUVoltageLimit("FLTMUX", 2, -2);
		//CheckError(idx, ret, __LINE__);
		//ret = dm[idx]->ConfigurePMUCurrentLevel("FLTMUX", 0);
		//CheckError(idx, ret, __LINE__);
		//ret = dm[idx]->DPINOn("FLTMUX");
		//CheckError(idx, ret, __LINE__);
		
		ret = DriveDMPin(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
		CheckError(idx, ret, __LINE__);


		if(!USE_SPI)
		{
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
		}
		else
		{
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);

			ret = RunSPI(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
		}
		////////////////////////////////////////////

		//mode=idle, pg1_reg7 = 0001_0001
		ret = WriteSPI(idx, 1, 7, 0x11);			
		//DMUX=62 (CR_ADC_Enable), pg1_reg15 bit7=0, bit6=DMUXAMUXN=1, bit5:0=MUX[5:0]=11_1110 ; pg3_reg13[6]=MUX[6]=0
		ret = WriteSPI(idx, 1, 15, 0x7e);
		ret = WriteSPI(idx, 3, 13, 0x00);
		//DMUX_EN, pg2_reg11[7]=1
		ret = WriteSPI(idx, 2, 11, 0x80);
		ret = OnOffSPI(idx, 0);

		//measures time from SYNC pos slope to FLTMUX neg slope. RWN=1 by default.
		double voh_flt = 0.6;
		double tmu_start_hysteresis = 0.02;
		double tmu_stop_hysteresis = 0.02;
		double tmu_start_threshold = voh_flt;
		double tmu_stop_threshold = voh_flt;

		int number_of_samples = 1;
		double tmu_timeout = 10e-3; 
		int returned_sample_count = 0;
		array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
		int read_reg=0;

		Stopwatch timer;

		//param 1 - adc_time: measures the time from writing to DigOn=1 (SYNC) to ADC completed (FLTMUX - CR_ADC_Enable-> 0)
		ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
		CheckError(idx, ret, __LINE__);
		ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
		CheckError(idx, ret, __LINE__);
		_util->Wait_Sec(Measure_Delay_s);
				
		ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
		CheckError(idx, ret, __LINE__);
		//mode=active DigOn=1 (ADC on), pg1_reg7 = 0001_1011
		ret = RunVectorFile(idx, "write_adc_time");
		CheckError(idx, ret, __LINE__);

		ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		

		tf_SetResult_UUTOffset(TPName[1], sampled_result[0] + GetOffset(idx, TPDispName[1]), idx); 
		
		//param 0 - ramp_cal - calibration
		ret = OnOffSPI(idx, 1);
		//DMUX_EN, pg2_reg11[7]=0
		ret = WriteSPI(idx, 2, 11, 0x00);		
		//RWTESTCTL, pg3_reg7=1 
		ret = WriteSPI(idx, 3, 7, 0x01);
		//RWTESTA, pg3_reg9=48=0x30
		ret = WriteSPI(idx, 3, 9, 0x30);
		//RWTESTB, pg3_reg10=165=0xa5
		ret = WriteSPI(idx, 3, 10, 0xa5);
		//AMUX=36 (VN15Test), pg1_reg15 bit7=0, bit6=DMUXAMUXN=0, bit5:0=MUX[5:0]=10_0100 ; pg3_reg13[6]=MUX[6]=0
		ret = WriteSPI(idx, 1, 15, 0x24);
		ret = WriteSPI(idx, 3, 13, 0x00);

		//connect FLTMUX to MTX_SMU, Set CBit=42 (D_Sx_MTX_IN0_OUT6) to enable IN0:OUT6
		ret = OnOffCbit(idx, 42, 1);		
		//enable FLT_MEAS_F, CBit=11 (FLT_MEAS_SEL)
		ret = OnOffCbit(idx, 11, 1);

		//drive FLTMUX to 0		
		
		ret = dm[idx]->DPINOff("FLTMUX");
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
		CheckError(idx, ret, __LINE__);		
		ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", 0.025);
		CheckError(idx, ret, __LINE__);
		ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", 0);
		CheckError(idx, ret, __LINE__);		
		ret = dm[idx]->DPINOn("FLTMUX");
		CheckError(idx, ret, __LINE__);

		ret = smu[idx]->OffSmuPin("MTX_SMU");
		CheckError(idx, ret, __LINE__);
		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
		CheckError(idx, ret, __LINE__);
		ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
		CheckError(idx, ret, __LINE__);
		ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
		CheckError(idx, ret, __LINE__);
		ret = smu[idx]->OnSmuPin("MTX_SMU", false, false);
		CheckError(idx, ret, __LINE__);

		if(!ADC_cal_status)//run calibration once. 
		{
			array<double> ^ meas_v = gcnew array<double>(100);
			double ave_v = 0;

			//SMU is driving 0 to FLTMUX currently			
			//measures FLTMUX, takes average of 100 meter readings.
			_util->Wait_Sec(Measure_Delay_s);
			/*
			JL: Note - remove ReadVoltageWithAverage(), result is off on test program 47S
			ret = smu[idx]->ReadVoltageWithAverage("MTX_SMU", 100, ave_v, meas_v);
			CheckError(idx, ret, __LINE__);*/
			ret = smu[idx]->ReadVoltage("MTX_SMU", ave_v);
			
			//set the DC offset to the ave. of the meter measurement.
			offset_cal = -ave_v;
			
			//drive constant 1.87088V to FLTMUX
			//ret = smu[idx]->DriveVoltage("MTX_SMU", 1.87088 + offset_cal);
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", 1.87088 + offset_cal);

			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);
			//measures FLTMUX, takes average of 100 meter readings.
			/*
			JL: Note - remove ReadVoltageWithAverage(), result is off on test program 47S
			ret = smu[idx]->ReadVoltageWithAverage("MTX_SMU", 100, ave_v, meas_v);			
			CheckError(idx, ret, __LINE__);*/
			ret = smu[idx]->ReadVoltage("MTX_SMU", ave_v);
			
			//calculate the amp ratio: devide original ideal amplitude (1.87088V)by ave. of 100 measurements of FLTMUX
			ramp_cal = 1.87088/ave_v;
			
			//if (Debug_Enable == true)
			//{
			//	sbl->AppendLine("--------------------------calibration----------------------------------");
			//	sbl->AppendLine("voltage measured at 0V, offset_cal = "+offset_cal);
			//	sbl->AppendLine("voltage at 1.87088V = "+ave_v);
			//	sbl->AppendLine("ramp_cal = 1.87088/ave_v = "+ramp_cal);

			//	//For debug, always enter the calibration section;
			//	//thus, will not set ADC_cal_status.
			//}
			//else 
				ADC_cal_status = 1;
		}
		
		tf_SetResult_UUTOffset(TPName[0], ramp_cal + GetOffset(idx, TPDispName[0]), idx); 
		
		//Gather voltage data	
		const int ADC_OFFSET_STEPS_MAX = 500;
		const int ADC_SAMPLES = 2240;
		const int ADC_CODES_MAX = 256;
		const double ADC_CONV_TIME = 192/20e6;
		
		double ADC_ramp_min = 5.04e-3*(1-8)+0.5;
		double ADC_ramp_max = 5.04e-3*(256+16)+0.5;
		double ADC_ramp_range = ADC_ramp_max - ADC_ramp_min;
		//double v_step = ADC_ramp_range/53759;
		
		array<int> ^ adc_offset_data = gcnew array<int>(ADC_OFFSET_STEPS_MAX);
		array<int> ^ adc_data = gcnew array<int>(ADC_SAMPLES);		
		array<int> ^ hist = gcnew array<int>(ADC_CODES_MAX);
		array<double> ^ wcc = gcnew array<double>(ADC_CODES_MAX);
		array<double> ^ wccr = gcnew array<double>(ADC_CODES_MAX);
		array<double> ^ wcc_v = gcnew array<double>(ADC_CODES_MAX);
		array<double> ^ wcc_s = gcnew array<double>(ADC_CODES_MAX);
		array<double> ^ inl = gcnew array<double>(ADC_CODES_MAX);
		array<double> ^ sparkle = gcnew array<double>(ADC_SAMPLES);	
		array<double> ^ accur = gcnew array<double>(ADC_CODES_MAX);
				
		int i=0;
		String ^ temp_s = "";
		int Global_Result_Index = 0;
		
		//init arrays
		for(i=0; i<ADC_CODES_MAX; i++) // to 256
		{
			hist[i]=0;
			adc_offset_data[i] = 0;
			wcc[i] = 0;
			wccr[i] = 0;
			wcc_v[i] = 0;
			wcc_s[i] = 0;
			sparkle[i] = 0;
			inl[i] = 0;
			accur[i] = 0;
		}
		for(; i<ADC_OFFSET_STEPS_MAX; i++) // to 500
		{
			adc_offset_data[i] = 0;
			adc_data[i] = 0;
			sparkle[i] = 0;
		}
		for(;i<ADC_SAMPLES; i++) // to 2240
		{
			adc_data[i] = 0;
			sparkle[i] = 0;
		}
		
		//**adc_offset: Drive static level voltage to FLTMUX, measure the ADC. For 40 times with different voltage levels.
		//if (Debug_Enable == true)
		//{
		//	sbl->AppendLine("");

		//	errorMsg = "Capturing adc_offset_data " + UutOffsetIndex + "String::Format("{0,4}   {1,7}   {2,6}   {3}", "i", "drive_v", "meas_v", "adc_offset_data") ";

		//	sbl->AppendLine(errorMsg);

		//	//sbl->AppendLine("-----------------------------------------------------------------------");
		//	//sbl->AppendLine("Capturing adc_offset_data");
		//	//sbl->AppendLine(String::Format("{0,4}   {1,7}   {2,6}   {3}", "i", "drive_v", "meas_v", "adc_offset_data"));			
		//}

		const int ADC_OFFSET_STEPS = 41;
		array<double> ^ adc_offset_levels = gcnew array<double>(ADC_OFFSET_STEPS);
		
		double v=0, meas_v=0;
		timer.Reset();
		timer.Start();
		for(i=0; i<ADC_OFFSET_STEPS; i++)
		{
			adc_offset_levels[i] = (((40+i)*0.001) + 0.5)/ADC_ramp_max;//(((ADC_OFFSET_START=40+x*ADC_OFFSET_RES=1)*1e-3)+ADC_REF_Ideal=0.5)/ADC_ramp_max
			//ret = smu[idx]->DriveVoltage("MTX_SMU", adc_offset_levels[i] * 1.87088 * ramp_cal  + offset_cal);			
			v = adc_offset_levels[i] * 1.87088 * ramp_cal  + offset_cal;			
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", v);
			//_util->Wait_Sec(Measure_Delay_s);
			 
			//DigOn (pg1_reg7[3])=1, pg1_reg7 = 0001_1011
			ret = WriteSPI(idx, 1, 7, 0x1b);				
			//_util->Wait_Sec(8e-6); //wait 8us.
			
			ret = ReadReg(idx, 1, 11, adc_offset_data[i]); //read ADC
			
			//if (Debug_Enable == true)
			//{
			//	ret = smu[idx]->ReadVoltage("MTX_SMU", meas_v);
			//	sbl->AppendLine(String::Format("{0,4}   {1,-6:0.0000}    {2,-6:0.0000}   0x{3,-2:x}({4,3})", i, v, meas_v, adc_offset_data[i], adc_offset_data[i]));
			//}
		}
		timer.Stop();
		
		//**adc_ramp: linear function, offset=c, high limit=1.87088
		//if (Debug_Enable == true)
		//{			
		//	sbl->AppendLine("time taken for adc_offset_data = " + timer.Elapsed.TotalSeconds + "s");			
		//	sbl->AppendLine("");
		//	sbl->AppendLine("-----------------------------------------------------------------------");
		//	sbl->AppendLine("Capturing adc_data");
		//	sbl->AppendLine(String::Format("{0,4}   {1,7}   {2,6}   {3}", "i", "drive_v", "meas_v", "adc_data"));
		//	
		//}
		const int ADC_RAMP_STEPS= ADC_SAMPLES + 1;		
		array<double> ^ adc_ramp_levels = gcnew array<double>(ADC_RAMP_STEPS);
		const double c = ADC_ramp_min/ADC_ramp_max;

		timer.Reset();
		timer.Start();
		for(i=0; i<ADC_SAMPLES; i++)
		{
			adc_ramp_levels[i] = c + (1-c)/ADC_RAMP_STEPS * (i+1);
			v = adc_ramp_levels[i] * 1.87088 * ramp_cal  + offset_cal;
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", v);
			//_util->Wait_Sec(Measure_Delay_s);
			
			//DigOn (pg1_reg7[3])=1, pg1_reg7 = 0001_1011
			ret = WriteSPI(idx, 1, 7, 0x1b);	
			//_util->Wait_Sec(8e-6); //wait 8us.
			ret = ReadReg(idx, 1, 11, adc_data[i]); //read ADC

			//if (Debug_Enable == true)
			//{
			//	ret = smu[idx]->ReadVoltage("MTX_SMU", meas_v);
			//	sbl->AppendLine(String::Format("{0,4}   {1,-6:0.0000}    {2,-6:0.0000}   0x{3,-2:x}({4,3})", i, v, meas_v, adc_data[i], adc_data[i]));
			//}
		}

		timer.Stop();
		//if (Debug_Enable == true)
		//{
		//	sb->AppendLine("time taken for adc_data = " + timer.Elapsed.TotalSeconds + "s");			
		//	sb->AppendLine("");
		//}

		ret = smu[idx]->OffSmuPin("MTX_SMU");
		CheckError(idx, ret, __LINE__);
		
		//**calculate histogram with adc_offset_data
		for(i=0; i<ADC_OFFSET_STEPS; i++)
		{
			hist[adc_offset_data[i]]++;
			wcc[adc_offset_data[i]]+= (double)i;
		}
		//Find the range of ADC - where ADC codes in histogram are non-zero
		int offset_start=0;
		int offset_stop=0;
		int first_valid_code=0;
		int debug;
		i=0;
		while(offset_start == 0 || offset_stop == 0)
		{
			debug = i;
			if (hist[i]!=0 && offset_start==0)
			  offset_start=i;
			if (hist[i]==0 && offset_start!=0)
			  offset_stop=i;
			i++;
			if(i>=ADC_CODES_MAX)
				break;
		}
		//find 1st valid code with histogram count > 3, and not the last code.		
		i=offset_start+1;
		while (i<offset_stop-1 && first_valid_code==0)
		{
			debug = i;
			if (hist[i]>3 && hist[i+1]>1)
				first_valid_code=i;
			i++;
			if(i>=ADC_CODES_MAX)
				break;
		}
		wcc[first_valid_code]/=(float) hist[first_valid_code];
		wcc_v[first_valid_code]=(40+wcc[first_valid_code])*1e-3+0.5;//from Catalyst (ADC_OFFSET_START+(ADC_OFFSET_RES*wcc[first_valid_code]))*1e-3+ADC_REF_Ideal;
		//clear arrays
		for(i=0; i<ADC_CODES_MAX; i++) //(i=offset_start; i<=offset_stop; i++)
		{
			hist[i]=0;
			wcc[i]=0;
		}
		
		//**calculate histogram with adc_data	
		//if (Debug_Enable == true)
		//{			
		//	sbl->AppendLine("-----------------------------------------------------------------------");
		//	sbl->AppendLine("building histogram with adc_data");
		//	sbl->AppendLine("hist[adc_data[i]]++");
		//	sbl->AppendLine("wcc[adc_data[i]]+= (double)i");
		//	sbl->AppendLine(String::Format("{0,4}   {1,9}   {2,9}   {3,9}","i", "adc_data", "hist", "wcc"));				
		//}		
		for(i=0; i<ADC_SAMPLES; i++)
		{
			hist[adc_data[i]]++;
			wcc[adc_data[i]]+= (double)i;
			//if (Debug_Enable == true)
			//{
			//	//sw->Write("i="+i+" adc_offset_data[i]="+adc_data[i]+" hist="+hist[adc_data[i]]+" wcc="+wcc[adc_data[i]]+Environment::NewLine);
			//	sbl->AppendLine(String::Format("{0,4}   0x{1,-2:x}({2,3})   {3,9:0.0000}   {4,9:0.0000}   ", i, adc_data[i], adc_data[i], hist[adc_data[i]], wcc[adc_data[i]]));
			//}
		}
		
		//Find average histogram value omitting end points
		//Also tally total and consecutive missed codes
		int missing_codes = 0, miss_count = 0, max_consec = 0;
		double hist_avg = 0;
		
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			if(hist[i]==0)
			{
				missing_codes++;
				miss_count++;
				if(miss_count>max_consec)
					max_consec=miss_count;
			}
			else
				miss_count=0;
			
			hist_avg+= (double) hist[i];	
		}
		hist_avg/=ADC_CODES_MAX-2;
		
		//param 2 - number of missing codes overall
		tf_SetResult_UUTOffset(TPName[2], (int)(missing_codes + GetOffset(idx, TPDispName[2])), idx);
		
		//param 3 - max number of consecutive missing codes
		tf_SetResult_UUTOffset(TPName[3], (int)(max_consec + GetOffset(idx, TPDispName[3])), idx);
		
		//building weighted code center array
		//if (Debug_Enable == true)
		//{			
		//	sbl->AppendLine("-----------------------------------------------------------------------");
		//	sbl->AppendLine("building weighted code center array, wcc");	
		//	sbl->AppendLine(String::Format("{0,9}   {1,6}   {2,9}   {3}","i","hist","wcc","wcc/hist (if hist >0)"));
		//}	
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			temp_s = String::Format("0x{0,-2:x}({1,3})   {2,6}   {3,9:0.0000}   ", i, i, hist[i],  wcc[i]);
			if(hist[i]!=0)
			{
				wcc[i]/=(double) hist[i];	
				temp_s += String::Format("{0,9:0.0000}",wcc[i]);
			}
			//if (Debug_Enable == true)	
			//	sbl->AppendLine(temp_s);
		}
		
		//Remove ramp overdrive offset from weighted code centers
		//ignore zeroes (missing codes)
		int codes = 0;
		double mult_xy = 0, mult_xx = 0, sum_x = 0, sum_y = 0;
		double wcc_slope = 0, wcc_offset = 0;
		
		codes = ADC_CODES_MAX - missing_codes - 2;
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			if(wcc[i]!=0)
			{
				sum_x += i;
				mult_xy += (i*wcc[i]);
				mult_xx += (i*i);
				sum_y += wcc[i];
			}
		}
		wcc_slope = (codes*mult_xy - sum_x*sum_y)/(codes*mult_xx - sum_x*sum_x);
		wcc_offset = (sum_y/codes) - (wcc_slope * (sum_x/codes));
		//if (Debug_Enable == true)
		//{
		//	sbl->AppendLine("");
		//	sbl->AppendLine("wcc_slope = " + wcc_slope);
		//	sbl->AppendLine("wcc_offset = " + wcc_offset);
		//	sbl->AppendLine("");
		//}
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			if (wcc[i]!=0) 
				wcc_s[i]=wcc[i]-wcc_offset;
		}
			
		//Calculate sparkle array and locate max and min
		int look_back = 0, look_forward = 0;
		double sparkle_max = -1000, sparkle_min = 1000;
		int sparkle_max_data = 0, sparkle_min_data = 0, had_sparkle = 0;
		
		for (i=1; i<ADC_SAMPLES-1; i++)
		{
			look_back = adc_data[i]-adc_data[i-1];
			look_forward = adc_data[i]-adc_data[i+1];
			if (abs(look_back)>2 && abs(look_forward)>2)
			{
			  sparkle[i]=(look_back+look_forward)/2.0;
			  if (sparkle[i]>sparkle_max)
			  {
				sparkle_max=sparkle[i];
				sparkle_max_data=i;
				had_sparkle=1;
			  }
			  if (sparkle[i]<sparkle_min)
			  {
				sparkle_min=sparkle[i];
				sparkle_min_data=i;
				had_sparkle=1;
			  }
			}
		}
				
		//Find nearest code center for sparkle min and max if any exist
		//First find boundary code centers
		//Then choose the code whose center is closest
		int sparkle_min_bin = 0, sparkle_max_bin = 0;
  
		if(had_sparkle)
		{
			for (i=1; i<ADC_CODES_MAX-2; i++)
			{
			  if (sparkle_min_bin && sparkle_max_bin) 
				break;  //Stop looking if both have been found 
			  if (sparkle_min_data>=wcc[i] && sparkle_min_data<=wcc[i+1])
				if (fabs(sparkle_min_data-wcc[i])<fabs(sparkle_min_data-wcc[i+1]))
				  sparkle_min_bin=i;
				else
				  sparkle_min_bin=i+1;
			  if (sparkle_max_data>=wcc[i] && sparkle_max_data<=wcc[i+1])
				if (fabs(sparkle_max_data-wcc[i])<fabs(sparkle_max_data-wcc[i+1]))
				  sparkle_max_bin=i;
				else
				  sparkle_max_bin=i+1;
			}
			//Above loop will miss a min at full scale output
			//By default, it catches a max at zero scale output
			if (!sparkle_min_bin && sparkle_min_data>2500/2) //JL: ADC_SAMPLES_MAX=2500
			  sparkle_min_bin=ADC_CODES_MAX-1; //min occurred during full scale output
		}
		else
			sparkle_min=sparkle_max=0.0;   //No sparkles, clear these variables
		
		//param 4 - sparkle_max_bin
		tf_SetResult_UUTOffset(TPName[4], (int)(sparkle_max_bin + GetOffset(idx, TPDispName[4])), idx);
		
		//param 5 - sparkle_max
		tf_SetResult_UUTOffset(TPName[5], sparkle_max + GetOffset(idx, TPDispName[5]), idx);
		
		//param 6 - sparkle_min_bin
		tf_SetResult_UUTOffset(TPName[6], (int)(sparkle_min_bin + GetOffset(idx, TPDispName[6])), idx);
		
		//param 7 - sparkle_min
		tf_SetResult_UUTOffset(TPName[7], sparkle_min + GetOffset(idx, TPDispName[7]), idx);
		
		// Multiply weighted code centers reference by histogram average
		// Find INL error by subtracting reference from actual code centers, ignore missing codes
		// Convert INL error from code counts to LSBs
		// Find INL extremes
		double inl_min_val = 1000, inl_max_val = -1000;
		int inl_min_bin = 0, inl_max_bin = 0;
		
		//if (Debug_Enable == true)
		//{			
		//	sbl->AppendLine("-----------------------------------------------------------------------");
		//	sbl->AppendLine("Calculating INL. (hist_avg = " + hist_avg + "); if (wcc[i]!=0) inl[i]=(wcc_s[i]-wccr[i])/hist_avg");
		//	sbl->AppendLine(String::Format("{0,9}   {1,6}   {2,6}   {3,6}   {4,6}   {5}","i", "wcc", "wcc_s", "wccr", "inl", "inl_min_val/inl_max_val"));				
		//}
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			wccr[i]=i*hist_avg;
			temp_s = String::Format("0x{0,-2:x}({1,3})   {2,9:0.0000}   {3,9:0.0000}   {4,9:0.0000}   ", i, i, wcc[i], wcc_s[i], wccr[i]);
			if (wcc[i]!=0)
			{
				inl[i]=((wcc_s[i]-wccr[i])/hist_avg);
				if (Debug_Enable == true)
					temp_s += String::Format("{0,6:0.0000}   ", inl[i]);
				if(inl[i]<inl_min_val)
				{
					inl_min_val=inl[i];
					inl_min_bin=i;
					temp_s +=  String::Format("{0,11:0.0000} ", "min");
				}
				if(inl[i]>inl_max_val)
				{
					inl_max_val=inl[i];
					inl_max_bin=i;
					temp_s +=  String::Format("{0,11:0.0000} ", "max");
				}
			}
			else //for debug only
			{
				if (Debug_Enable == true)
					temp_s += String::Format("{0,6:0.0000}   ", inl[i]);
			}
			//if (Debug_Enable == true)
			//	sbl->AppendLine(temp_s);
		}
		
		//param 8 - min INL location
		tf_SetResult_UUTOffset(TPName[8], (int)(inl_min_bin + GetOffset(idx, TPDispName[8])), idx);
		
		//param 9 - min INL value
		tf_SetResult_UUTOffset(TPName[9], inl_min_val + GetOffset(idx, TPDispName[9]), idx);
		
		//param 10 - max INL location
		tf_SetResult_UUTOffset(TPName[10], (int)(inl_max_bin + GetOffset(idx, TPDispName[10])), idx);
		
		//param 11 - max INL value
		tf_SetResult_UUTOffset(TPName[11], inl_max_val + GetOffset(idx, TPDispName[11]), idx);
		
		double ADC_ramp_slew = (ADC_ramp_range/53759)*2.5e6; //(ADC_ramp_range/(ramp_size-1))*ADC_RAMP_FS
		
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			wcc_v[i]=wcc_v[first_valid_code]+((wcc[i]-wcc[first_valid_code])*(ADC_ramp_slew*ADC_CONV_TIME));
		}
    
		//Calculate code center voltage ramp slope and offset, ignore missing codes
		//Also calculate accuracy and search for min/max
		int gain_codes = 0;
		double accur_max_val = -1000, accur_min_val = 1000;
		int accur_max_bin = 0, accur_min_bin = 0;
		double accur1_max_val = -1000, accur1_min_val = 1000;
		int accur1_max_bin = 0, accur1_min_bin = 0;
		
		mult_xy=mult_xx=sum_x=sum_y=0;
		
		for (i=1; i<(ADC_CODES_MAX-1); i++)
		{
			if(wcc[i]!=0)
			{
				gain_codes++;
				sum_x   += i;
				mult_xy += (i * wcc_v[i]);
				mult_xx += (i * i);
				sum_y   += wcc_v[i];
				
				accur[i]=wcc_v[i]-(0.00504*i+0.5); //ADC_LSB_Ideal=0.00504, ADC_REF_Ideal=0.5
				if (accur[i]>accur_max_val)
				{
					accur_max_val=accur[i];
					accur_max_bin=i;
				}
				if (accur[i]<accur_min_val)
				{
					accur_min_val=accur[i];
					accur_min_bin=i;
				}
				if (i>=20 && i<=180)  //600mV - 1.4V
				{
					if (accur[i]>accur1_max_val)
					{
						accur1_max_val=accur[i];
						accur1_max_bin=i;
					}
					if (accur[i]<accur1_min_val)
					{
						accur1_min_val=accur[i];
						accur1_min_bin=i;
					}
				}
			}
		}
		//param 12 - adc_slope		
		double adc_slope = (gain_codes*mult_xy - sum_x*sum_y)/(gain_codes*mult_xx - sum_x*sum_x);;
		tf_SetResult_UUTOffset(TPName[12], adc_slope + GetOffset(idx, TPDispName[12]), idx);

        if (tf_TPCondition_exist(TPName[12], "Global_Result_Index") == true)
        {
             int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[12], "Global_Result_Index"));
                    _glob->Global_Result[idx, Global_Result_Index] = adc_slope;
        }
		
		//param 13 - adc_offset
		double adc_offset = (sum_y/gain_codes) - (adc_slope * (sum_x/gain_codes)) - 0.5;
		tf_SetResult_UUTOffset(TPName[13], adc_offset + GetOffset(idx, TPDispName[13]), idx);

        if (tf_TPCondition_exist(TPName[13], "Global_Result_Index") == true)
        {
             int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[13], "Global_Result_Index"));
                    _glob->Global_Result[idx, Global_Result_Index] = adc_offset;
        }

		double adc_range = 0.00504*ADC_CODES_MAX;  //(ADC_LSB_Ideal*ADC_CODES+ADC_REF_Ideal)-ADC_REF_Ideal
		
		//param 14 - accur_min_bin
		tf_SetResult_UUTOffset(TPName[14], (int)(accur_min_bin + GetOffset(idx, TPDispName[14])), idx);
		
		//param 15 - accur_min_val/adc_range
		tf_SetResult_UUTOffset(TPName[15], (accur_min_val/adc_range) + GetOffset(idx, TPDispName[15]), idx);
		
		//param 16 - accur_max_bin
		tf_SetResult_UUTOffset(TPName[16], (int)(accur_max_bin + GetOffset(idx, TPDispName[16])), idx);
		
		//param 17 - accur_max_val/adc_range
		tf_SetResult_UUTOffset(TPName[17], (accur_max_val/adc_range) + GetOffset(idx, TPDispName[17]), idx);
		
		//param 18 - accur1_min_bin
		tf_SetResult_UUTOffset(TPName[18], (int)(accur1_min_bin + GetOffset(idx, TPDispName[18])), idx);
		
		//param 19 - accur1_min_val/adc_range
		tf_SetResult_UUTOffset(TPName[19], (accur1_min_val/adc_range) + GetOffset(idx, TPDispName[19]), idx);
		
		//param 20 - accur1_max_bin
		tf_SetResult_UUTOffset(TPName[20], (int)(accur1_max_bin + GetOffset(idx, TPDispName[20])), idx);
		
		//param 21 - accur1_max_val/adc_range
		tf_SetResult_UUTOffset(TPName[21], (accur1_max_val/adc_range) + GetOffset(idx, TPDispName[21]), idx);
		
		ret = OnOffSPI(idx, 0); 
		////////////////////////////////////////////
		ret = ResetDMPin(idx, TPDispName[0]);
		CheckError(idx, ret, __LINE__);

		//Power down supplies
		//ret = smu[idx]->DriveVoltage("VEE", 0);
		//CheckError(idx, ret, __LINE__);
		ret = smu[idx]->DriveVoltage("VCC", 0);
		CheckError(idx, ret, __LINE__);

		//IO setting
		ret = ResetCBit(idx);
		CheckError(idx, ret, __LINE__);
		ret = ResetMuxIO(idx);
		CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
//	power
//	void TestProgram::power(Object^ object)
//	{
//		TestProgramData^ d = (TestProgramData^)object;
//
//		Site^ site = d->t_site;
//		int idx = d->UutOffsetIndex;
//
//		int ret = 0;
//
//		try 
//		{
//			//Get test name from techFlow
//			int total_tp = (int)tf_TPCount();
//			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//			array<double> ^ result = gcnew array<double>(total_tp);
//			array<double> ^ result2 = gcnew array<double>(total_tp);
//			array<double> ^ result3 = gcnew array<double>(total_tp);
//			array<double> ^ result4 = gcnew array<double>(total_tp);
//			array<int> ^ Drive_WRN_V = gcnew array<int>(total_tp);
//			array<int> ^ Drive_PWR_SAVE = gcnew array<int>(total_tp);
//			array<int> ^ data_pg1 = gcnew array<int>(32);
//			array<int> ^ data_pg2 = gcnew array<int>(32);
//			array<int> ^ data_pg4 = gcnew array<int>(32);
//
//			for (int i=0; i<total_tp; i++)
//			{
//				TPDispName[i] = tf_TestParameter_DisplayName(i);
//				TPName[i] = tf_TestParameter_Name(i);
//				result[i] = 0;
//				result2[i] = 0;
//				result3[i] = 0;
//				result4[i] = 0;
//			}
//
//			String ^ TIDispName = tf_TestItem_DisplayName();
//
//			//Get test condition from techFlow
//			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//			double Clamp_Vee_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vee_Current_A"));
//			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//			double Measure_Delay_s	= 0;
//			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
//			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//			bool isCurrentTPBypassed = false;
//
//			double Input_Channel_Delay_s = 0;
//
//			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
//
//			String ^ Vector_File	= String::Empty;
//			String ^ Vector_File_1	= String::Empty;
//			String ^ Measure_Pin	= String::Empty;
//			String ^ Measure_Pin_1	= String::Empty;
//			int Global_Result_Index = 0;
//			int Global_Result_Index_1 = 0;
//			String ^ Operation		= String::Empty; 
//
//			double Drive_Vcc2_V		= 0;
//			double Drive_Vee2_V		= 0;
//			int On_SPI_Once			= 0;
//
//			double vih;
//			double vil;
//			double voh; 
//			double vol;
//			double ioh;
//			double iol;
//			double vch;
//			double vcl;
//			double vt;
//			
//			int vector_engine_status = 0;
//
//			Stopwatch swatch;
//
//			//IO setting
//			ret = SetupDigital(idx);
//			CheckError(idx, ret, __LINE__);
//			ret = DriveCBit(idx, TPDispName[0]);
//			CheckError(idx, ret, __LINE__);
//			ret = DriveMuxIO(idx, TPDispName[0]);
//			CheckError(idx, ret, __LINE__);
//			
//			//Setup Power supplies
//			//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->ClampCurrent("VCC", 0.5);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->DriveVoltage("VCC", 0);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->OnSmuPin("VCC", true, false);
//			//CheckError(idx, ret, __LINE__);
//
//			//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->ClampCurrent("VEE", 0.5);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->DriveVoltage("VEE", 0);
//			//CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->OnSmuPin("VEE", true, false);
//			//CheckError(idx, ret, __LINE__);
//			//_util->Wait_Sec(0.001);
//
//			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
//			CheckError(idx, ret, __LINE__);
//			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
//			//CheckError(idx, ret, __LINE__);
//
//			_util->Wait_Sec(On_Delay_s);
//
//			vih = 2.5;
//			vil = 0.00;
//			voh = 0.75; 
//			vol = 0.75;
//			ioh = 0.002;
//			iol = 0.002;
//			vch = 6;
//			vcl = -0.1;
//			vt = 0;
//
//			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//			CheckError(idx, ret, __LINE__);
//			//ret = dm[idx]->DPINOn("SPE");
//			CheckError(idx, ret, __LINE__);
//
//			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//			CheckError(idx, ret, __LINE__);
//			//ret = dm[idx]->DPINOn("SPD");
//			CheckError(idx, ret, __LINE__);
//
//			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//			CheckError(idx, ret, __LINE__);
//			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//			CheckError(idx, ret, __LINE__);
//			//ret = dm[idx]->DPINOn("SPC");
//			CheckError(idx, ret, __LINE__);
//
//			//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
//			ret = dm[idx]->DPINOff("FLTMUX");
//			ret = dm[idx]->DPINOff("MODE");
//			ret = dm[idx]->DPINOff("WDX");
//			ret = dm[idx]->DPINOff("WDY");
//			ret = dm[idx]->DPINOff("RWN");
//			ret = dm[idx]->DPINOff("SPD");
//			ret = dm[idx]->DPINOff("SPC");
//			ret = dm[idx]->DPINOff("SPE");
////total_tp
//			for (int i=0; i<total_tp; i++)
//			{
//				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
//
//				if (isCurrentTPBypassed == false)
//				{
//					
//					if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
//					{
//						NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));
//
//						//ret = smu[idx]->ConfigurePLF("VEE", Power_Line_Freq);
//						//CheckError(idx, ret, __LINE__);
//						ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
//						CheckError(idx, ret, __LINE__);
//
//						//ret = smu[idx]->ConfigurePLF("VCC", Power_Line_Freq);
//						//CheckError(idx, ret, __LINE__);
//						ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//						CheckError(idx, ret, __LINE__);
//					}
//					
//
//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
//					{
//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
//
//						ret = dm[idx]->DPINOn("SPE");
//						ret = dm[idx]->DPINOn("SPD");
//						ret = dm[idx]->DPINOn("SPC");
//
//						if(On_SPI_Once == 0)
//						{
//							if(USE_SPI)
//							{
//								ret = OnOffSPI(idx, 1);
//								CheckError(idx, ret, __LINE__);
//							}
//
//							ret = DriveDMPin2(idx, TPDispName[0]);
//							CheckError(idx, ret, __LINE__);
//							On_SPI_Once = 1;
//						}
//
//						if((TPDispName[i]->Contains("3p3") == true) || (TPDispName[i]->Contains("Icc_i^") == true) || (TPDispName[i]->Contains("Iee_i^") == true) ||
//							(TPDispName[i]->Contains("Icc_s^") == true) || (TPDispName[i]->Contains("Icc_s^") == true)) //follow Catalyst to remove pin loading for icc_s_3p3 & iee_s_3p3
//						{
//							ret = dm[idx]->DPINOn("SPE");
//							ret = dm[idx]->DPINOn("SPD");
//							ret = dm[idx]->DPINOn("SPC");
//							ret = dm[idx]->DPINOn("RWN");
//							ret = dm[idx]->DPINOn("WDX");
//							ret = dm[idx]->DPINOn("WDY");
//							ret = dm[idx]->DPINOff("FLTMUX");
//							ret = dm[idx]->DPINOff("MODE");
//						}
//						else 
//						{
//							ret = dm[idx]->DPINOn("SPE");
//							ret = dm[idx]->DPINOn("SPD");
//							ret = dm[idx]->DPINOn("SPC");
//							ret = dm[idx]->DPINOn("RWN");
//							ret = dm[idx]->DPINOn("WDX");
//							ret = dm[idx]->DPINOn("WDY");
//							ret = dm[idx]->DPINOff("FLTMUX");//Follow Catalyst's code
//							ret = dm[idx]->DPINOn("MODE");
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Drive_WRN_V") == true)
//						{
//							Drive_WRN_V[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_WRN_V");
//							ret = dm[idx]->DrivePin("RWN", Drive_WRN_V[i]);
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Drive_PWR_SAVE") == true)
//						{
//							Drive_PWR_SAVE[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_PWR_SAVE");
//							ret = dm[idx]->DrivePin("MODE", Drive_PWR_SAVE[i]);
//						}
//
//						//Set Icmpl to 0.5A before any register changes
//						ret = smu[idx]->ClampCurrent("VCC", 0.5);
//						CheckError(idx, ret, __LINE__);
//						//_util->Wait_Sec(0.001);
//
//						//Set Icmpl to 0.5A before any register changes
//						ret = smu[idx]->ClampCurrent("VEE", 0.5);
//						CheckError(idx, ret, __LINE__);
//						_util->Wait_Sec(0.001);
//
//						//if(!USE_SPI)
//						//{
//							ret = RunVectorFile(idx, Vector_File);
//							CheckError(idx, ret, __LINE__);
//						//}
//						//else
//						//{
//						//	ret = RunSPI(idx, Vector_File);
//						//	CheckError(idx, ret, __LINE__);
//						//}
//
//						//ret = RunVectorFile(idx, Vector_File);
//						//CheckError(idx, ret, __LINE__);
//					}
//
//					////pg1
//					//ret = ReadVector(idx, "read_p1_reg0", data_pg1[0]);
//					//ret = ReadVector(idx, "read_p1_reg1", data_pg1[1]);
//					//ret = ReadVector(idx, "read_p1_reg2", data_pg1[2]);
//					//ret = ReadVector(idx, "read_p1_reg3", data_pg1[3]);
//					//ret = ReadVector(idx, "read_p1_reg4", data_pg1[4]);
//					//ret = ReadVector(idx, "read_p1_reg5", data_pg1[5]);
//					//ret = ReadVector(idx, "read_p1_reg6", data_pg1[6]);
//					//ret = ReadVector(idx, "read_p1_reg7", data_pg1[7]);
//					//ret = ReadVector(idx, "read_p1_reg8", data_pg1[8]);
//					//ret = ReadVector(idx, "read_p1_reg9", data_pg1[9]);
//					//ret = ReadVector(idx, "read_p1_reg10", data_pg1[10]);
//					//ret = ReadVector(idx, "read_p1_reg11", data_pg1[11]);
//					//ret = ReadVector(idx, "read_p1_reg12", data_pg1[12]);
//					//ret = ReadVector(idx, "read_p1_reg13", data_pg1[13]);
//					//ret = ReadVector(idx, "read_p1_reg14", data_pg1[14]);
//					//ret = ReadVector(idx, "read_p1_reg15", data_pg1[15]);
//					//ret = ReadVector(idx, "read_p1_reg16", data_pg1[16]);
//					//ret = ReadVector(idx, "read_p1_reg17", data_pg1[17]);
//					//ret = ReadVector(idx, "read_p1_reg18", data_pg1[18]);
//					//ret = ReadVector(idx, "read_p1_reg19", data_pg1[19]);
//					//ret = ReadVector(idx, "read_p1_reg20", data_pg1[20]);
//					//ret = ReadVector(idx, "read_p1_reg21", data_pg1[21]);
//					//ret = ReadVector(idx, "read_p1_reg22", data_pg1[22]);
//					//ret = ReadVector(idx, "read_p1_reg23", data_pg1[23]);
//					//ret = ReadVector(idx, "read_p1_reg24", data_pg1[24]);
//					//ret = ReadVector(idx, "read_p1_reg25", data_pg1[25]);
//					//ret = ReadVector(idx, "read_p1_reg26", data_pg1[26]);
//					//ret = ReadVector(idx, "read_p1_reg27", data_pg1[27]);
//					//ret = ReadVector(idx, "read_p1_reg28", data_pg1[28]);
//					//ret = ReadVector(idx, "read_p1_reg29", data_pg1[29]);
//					//ret = ReadVector(idx, "read_p1_reg30", data_pg1[30]);
//					//ret = ReadVector(idx, "read_p1_reg31", data_pg1[31]);
//					////pg2
//					//ret = ReadVector(idx, "read_p2_reg32", data_pg2[0]);
//					//ret = ReadVector(idx, "read_p2_reg33", data_pg2[1]);
//					//ret = ReadVector(idx, "read_p2_reg34", data_pg2[2]);
//					//ret = ReadVector(idx, "read_p2_reg38", data_pg2[6]);
//					//ret = ReadVector(idx, "read_p2_reg39", data_pg2[7]);
//					//ret = ReadVector(idx, "read_p2_reg40", data_pg2[8]);
//					//ret = ReadVector(idx, "read_p2_reg54", data_pg2[22]);
//					//ret = ReadVector(idx, "read_p2_reg56", data_pg2[24]);
//					//ret = ReadVector(idx, "read_p2_reg57", data_pg2[25]);
//					//ret = ReadVector(idx, "read_p2_reg58", data_pg2[26]);
//					//ret = ReadVector(idx, "read_p2_reg59", data_pg2[27]);
//					//ret = ReadVector(idx, "read_p2_reg60", data_pg2[28]);
//					//ret = ReadVector(idx, "read_p2_reg61", data_pg2[29]);
//					//ret = ReadVector(idx, "read_p2_reg62", data_pg2[30]);
//					//ret = ReadVector(idx, "read_p2_reg63", data_pg2[31]);
//					////pg4
//					//ret = RunVectorFile(idx, "write_p2_reg63_extregsp_enable_h");
//					//ret = ReadVector(idx, "read_p4_reg16", data_pg4[16]);
//					//ret = ReadVector(idx, "read_p4_reg17", data_pg4[17]);
//					//ret = ReadVector(idx, "read_p4_reg18", data_pg4[18]);
//					//ret = ReadVector(idx, "read_p4_reg25", data_pg4[25]);
//					//ret = ReadVector(idx, "read_p4_reg26", data_pg4[26]);
//					//ret = ReadVector(idx, "read_p4_reg27", data_pg4[27]);
//					//ret = ReadVector(idx, "read_p4_reg28", data_pg4[28]);
//					//ret = ReadVector(idx, "read_p4_reg29", data_pg4[29]);
//					//ret = ReadVector(idx, "read_p4_reg30", data_pg4[30]);
//
//					if (tf_TPCondition_exist(TPName[i], "Clamp_Vcc_Current_A") == true)
//					{
//						////Set Icmpl to 0.5A before any register changes
//						//ret = smu[idx]->ClampCurrent("VCC", 0.5);
//						//CheckError(idx, ret, __LINE__);
//						//_util->Wait_Sec(0.001);
//
//						Clamp_Vcc_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vcc_Current_A"));
//						ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//						CheckError(idx, ret, __LINE__);
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Clamp_Vee_Current_A") == true)
//					{
//						////Set Icmpl to 0.5A before any register changes
//						//ret = smu[idx]->ClampCurrent("VEE", 0.5);
//						//CheckError(idx, ret, __LINE__);
//						//_util->Wait_Sec(0.001);
//
//						Clamp_Vee_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vee_Current_A"));
//						ret = smu[idx]->ClampCurrent("VEE", Clamp_Vee_Current_A);
//						CheckError(idx, ret, __LINE__);
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Drive_Vcc2_V") == true)
//					{
//						Drive_Vcc2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc2_V"));
//						ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc2_V);
//						CheckError(idx, ret, __LINE__);
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Drive_Vee2_V") == true)
//					{
//						Drive_Vee2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee2_V"));
//						ret = smu[idx]->DriveVoltage("VEE", Drive_Vee2_V);
//						CheckError(idx, ret, __LINE__);
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
//					{
//						Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
//						_util->Wait_Sec(Measure_Delay_s);
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Measure_Pin") == true)
//					{
//						Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));
//
//						//array<double> ^ tmpI = gcnew array<double>(1024);
//						//array<double> ^ tmpV = gcnew array<double>(1024);
//						//ret = smu[idx]->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);
//
//						//for (int z=0; z<1024; z++)
//						//{
//						//	_util->Wait_Sec(10e-6);
//						//	ret = smu[idx]->ReadCurrent("VEE", tmpI[z]);
//						//	ret = smu[idx]->ReadVoltage("VEE", tmpV[z]);
//						//}
//
//						//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//						
//						if (Measure_Pin == "VCC")
//						{
//							ret = smu[idx]->ReadCurrent("VCC", result[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (Measure_Pin == "VEE")
//						{
//							//if (i == 1 || i == 3 || i == 11)
//							//{
//							//	//ret = smu[idx]->ConfigureOutputEnabled("VEE", false);
//							//	//ret = smu[idx]->ConfigureSamplingTime("VEE", 1, AM_CONST_PLC);
//							//	//CheckError(idx, ret, __LINE__);
//
//							//	_util->Wait_Sec(0.05);
//							//}
//
//							ret = smu[idx]->ReadCurrent("VEE", result[i]);
//							CheckError(idx, ret, __LINE__);
//							
//							//if (i == 1 || i == 3)
//							//{
//							//	array<double> ^ tmpI = gcnew array<double>(4096);
//							//	array<double> ^ tmpV = gcnew array<double>(4096);
//							//	ret = smu[idx]->ConfigureSamplingTime("VEE", 0.001, AM_CONST_PLC);
//
//							//	for (int z=0; z<4096; z++)
//							//	{
//							//		_util->Wait_Sec(100e-6);
//							//		ret = smu[idx]->ReadCurrent("VEE", tmpI[z]);
//							//		ret = smu[idx]->ReadVoltage("VEE", tmpV[z]);
//							//	}
//
//							//	ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
//							//}
//
//							//double volt = 0;
//							//ret = smu[idx]->ReadVoltage("VEE", volt);
//							//CheckError(idx, ret, __LINE__);
//
//							//if (i == 1 || i == 3)
//							//{
//								//ret = smu[idx]->ConfigureOutputEnabled("VEE", true);
//								//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
//								//CheckError(idx, ret, __LINE__);
//							//}
//						}
//
//						if (Debug_Enable == true)
//						{
//							double volt_vcc = 0;
//							double volt_vee = 0;
//							ret = smu[idx]->ReadVoltage("VCC", volt_vcc);
//							CheckError(idx, ret, __LINE__);
//							ret = smu[idx]->ReadVoltage("VEE", volt_vee);
//							CheckError(idx, ret, __LINE__);
//						}
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Measure_Pin_1") == true)
//					{
//						Measure_Pin_1	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_1"));
//						
//						if (Measure_Pin_1 == "VCC")
//						{
//							ret = smu[idx]->ReadCurrent("VCC", result2[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (Measure_Pin_1 == "VEE")
//						{
//							ret = smu[idx]->ReadCurrent("VEE", result2[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
//					{
//						Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
//
//						//if(!USE_SPI)
//						//{
//							ret = RunVectorFile(idx, Vector_File_1);
//							CheckError(idx, ret, __LINE__);
//						//}
//						//else
//						//{
//						//	ret = RunSPI(idx, Vector_File_1);
//						//	CheckError(idx, ret, __LINE__);
//						//}
//
//						_util->Wait_Sec(Measure_Delay_s);
//
//						if (Measure_Pin == "VCC")
//						{
//							ret = smu[idx]->ReadCurrent("VCC", result3[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (Measure_Pin == "VEE")
//						{
//							ret = smu[idx]->ReadCurrent("VEE", result3[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (Measure_Pin_1 == "VCC")
//						{
//							ret = smu[idx]->ReadCurrent("VCC", result4[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						if (Measure_Pin_1 == "VEE")
//						{
//							ret = smu[idx]->ReadCurrent("VEE", result4[i]);
//							CheckError(idx, ret, __LINE__);
//						}
//
//						result[i] = result[i] - result3[i];
//
//						result2[i] = result2[i] - result4[i];
//					}
//
//					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
//					{
//						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
//						
//						_glob->Global_Result[idx, Global_Result_Index] = result[i];
//					}	
//
//					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_1") == true)
//					{
//						Global_Result_Index_1 = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_1"));
//						
//						_glob->Global_Result[idx, Global_Result_Index_1] = result2[i];
//					}	
//
//					if (tf_TPCondition_exist(TPName[i], "Operation") == true)
//					{
//						String ^ Global_Result_Index_A = String::Empty;
//						String ^ Global_Result_Index_B = String::Empty;
//
//						int A = 0;
//						int B = 0;
//
//						Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));
//
//						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_A") == true)
//						{
//							Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A")); 
//						}
//
//						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_B") == true)
//						{
//							Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));			
//						}				
//
//						if (Operation == "-A")
//						{
//							A = _util->StrToInt(Global_Result_Index_A);
//
//							result[i] = result[i] - _glob->Global_Result[idx, A];
//
//							//2945 - add to update Icc_FHS starts
//							if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
//							{
//							
//							Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
//						
//								_glob->Global_Result[idx, Global_Result_Index] = result[i];
//							}	 //end
//						}
//
//						if (Operation == "=")
//						{
//							A = _util->StrToInt(Global_Result_Index_A);
//
//							result[i] = _glob->Global_Result[idx, A];
//						}
//						
//						if (Operation == "A-B")
//						{
//							A = _util->StrToInt(Global_Result_Index_A);
//							B = _util->StrToInt(Global_Result_Index_B);
//
//							if (TPDispName[i]->StartsWith("Pd"))
//							{
//								result[i] = _glob->Global_Result[idx, A]*Drive_Vcc_V - _glob->Global_Result[idx, B]*-Drive_Vee_V;
//							}
//							else
//							{
//								result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
//							}
//						}
//
//						if (Operation == "FHSA-B")
//						{
//							
//							String ^ Global_Result_IndexFHSA = String::Empty;
//							String ^ Global_Result_IndexFHSB = String::Empty;
//						
//							A = _util->StrToInt(Global_Result_Index_A);
//							B = _util->StrToInt(Global_Result_Index_B);
//
//							if (TPDispName[i]->StartsWith("Pd"))
//							{
//								result[i] = _glob->Global_Result[idx, A]*Drive_Vcc_V - _glob->Global_Result[idx, B]*-Drive_Vee_V;
//							}
//							else
//							{
//								result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
//							}
//						}  // for 2945 FHS 
//
//						if (Operation == "ABS(A-B)")
//						{
//							A = _util->StrToInt(Global_Result_Index_A);
//							B = _util->StrToInt(Global_Result_Index_B);
//
//							result[i] = Math::Abs(_glob->Global_Result[idx, A] - _glob->Global_Result[idx, B]);
//						}
//
//						if (Operation == "MAX[A]-MIN[B]")
//						{
//							double max = 0;
//							double min = 0;
//
//							array<String ^> ^ ArrStr = gcnew array<String ^>(0);
//							array<String ^> ^ Separator = gcnew array<String ^>(1);
//							Separator[0] = ",";
//
//							ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);
//
//							for (int j=0; j<ArrStr->Length; j++)
//							{
//								if (j == 0)
//								{
//									max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//								}
//								else
//								{
//									if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
//										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//								}
//							}
//
//							ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);
//
//							for (int j=0; j<ArrStr->Length; j++)
//							{
//								if (j == 0)
//								{
//									min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//								}
//								else
//								{
//									if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
//										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
//								}
//							}
//
//							result[i] = max - min;
//						}
//					}
//
//					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
//				}
//			}
//			if(USE_SPI)
//			{
//				ret = OnOffSPI(idx, 0);
//				CheckError(idx, ret, __LINE__);
//			}
//
//			ret = ResetDMPin(idx, TPDispName[0]);
//			CheckError(idx, ret, __LINE__);
//
//			//Power down supplies
//			ret = smu[idx]->ClampCurrent("VCC", 0.5);
//			CheckError(idx, ret, __LINE__);
//
//			ret = smu[idx]->ClampCurrent("VEE", 0.5);
//			CheckError(idx, ret, __LINE__);
//
//			_util->Wait_Sec(5e-3);
//
//			//ret = smu[idx]->DriveVoltage("VEE", 0);
//			//CheckError(idx, ret, __LINE__);
//			ret = smu[idx]->DriveVoltage("VCC", 0);
//			CheckError(idx, ret, __LINE__);
//			_util->Wait_Sec(5e-3); //discharge cap
//
//			//IO setting
//			ret = ResetCBit(idx);
//			CheckError(idx, ret, __LINE__);
//			ret = ResetMuxIO(idx);
//			CheckError(idx, ret, __LINE__);
//		}
//		catch (Exception^ ex) 
//		{
//			d->Exception = ex;
//			d->ErrorCode = ret;
//		}	
//	}

	void TestProgram::power(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result2 = gcnew array<double>(total_tp);
			array<double> ^ result3 = gcnew array<double>(total_tp);
			array<double> ^ result4 = gcnew array<double>(total_tp);
			array<int> ^ Drive_WRN_V = gcnew array<int>(total_tp);
			array<int> ^ Drive_PWR_SAVE = gcnew array<int>(total_tp);
			array<int> ^ data_pg1 = gcnew array<int>(32);
			array<int> ^ data_pg2 = gcnew array<int>(32);
			array<int> ^ data_pg4 = gcnew array<int>(32);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				result2[i] = 0;
				result3[i] = 0;
				result4[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double Clamp_Vee_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vee_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= 0;
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			bool isCurrentTPBypassed = false;

			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			String ^ Vector_File	= String::Empty;
			String ^ Vector_File_1	= String::Empty;
			String ^ Measure_Pin	= String::Empty;
			String ^ Measure_Pin_1	= String::Empty;
			int Global_Result_Index = 0;
			int Global_Result_Index_1 = 0;
			String ^ Operation		= String::Empty; 

			double Drive_Vcc2_V		= 0;
			double Drive_Vee2_V		= 0;
			int On_SPI_Once			= 0;

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);

			////vih = 1.8;	vil = 0;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
			//vih = 1.8;	vil = 1.3;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
			//ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_DIO);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePEAttribute("WDX", 0, 0, 0, 0);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->SetPinDirection("WDX", DM_CONST_DIR_OUTPUT);
			//CheckError(idx, ret, __LINE__);

			//vih = 1.8;	vil = 1.3;	voh = 0.75;	vol = 0.75;	ioh = 0;	iol = 0;	vch = 6;	vcl = -2;	vt = voh;
			//ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_DIO);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePEAttribute("WDY", 0, 0, 0, 0);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->SetPinDirection("WDY", DM_CONST_DIR_OUTPUT);
			//CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", 0.5);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", 0.5);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Follow Catalyst to remove pin loading during sleep test for icc_s & iee_s. 
			ret = dm[idx]->DPINOff("FLTMUX");
			ret = dm[idx]->DPINOff("MODE");
			ret = dm[idx]->DPINOff("WDX");
			ret = dm[idx]->DPINOff("WDY");
			ret = dm[idx]->DPINOff("RWN");
			ret = dm[idx]->DPINOff("SPD");
			ret = dm[idx]->DPINOff("SPC");
			ret = dm[idx]->DPINOff("SPE");
//total_tp
			for (int i=0; i<total_tp; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

				if (isCurrentTPBypassed == false)
				{
					
					if (tf_TPCondition_exist(TPName[i], "NPLC") == true)
					{
						NPLC = (double)(tf_TPCondition_Cast(TPName[i], "NPLC"));

						ret = smu[idx]->ConfigureSamplingTime("VEE", NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);

						ret = smu[idx]->ConfigureSamplingTime("VCC", NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
					}
					

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

						ret = dm[idx]->DPINOn("SPE");
						ret = dm[idx]->DPINOn("SPD");
						ret = dm[idx]->DPINOn("SPC");

						if(On_SPI_Once == 0)
						{
							if(USE_SPI)
							{
								ret = OnOffSPI(idx, 1);
								CheckError(idx, ret, __LINE__);
							}

							ret = DriveDMPin2(idx, TPDispName[0]);
							CheckError(idx, ret, __LINE__);
							On_SPI_Once = 1;
						}

						if((TPDispName[i]->Contains("3p3") == true) || (TPDispName[i]->Contains("Icc_i^") == true) || (TPDispName[i]->Contains("Iee_i^") == true) ||
							(TPDispName[i]->Contains("Icc_s^") == true) || (TPDispName[i]->Contains("Iee_s^") == true)) //follow Catalyst to remove pin loading for icc_s_3p3 & iee_s_3p3
						{
							ret = dm[idx]->DPINOn("SPE");
							ret = dm[idx]->DPINOn("SPD");
							ret = dm[idx]->DPINOn("SPC");
							ret = dm[idx]->DPINOn("RWN");
							ret = dm[idx]->DPINOn("WDX");
							ret = dm[idx]->DPINOn("WDY");
							ret = dm[idx]->DPINOff("FLTMUX");
							ret = dm[idx]->DPINOff("MODE");
						}
						else 
						{
							ret = dm[idx]->DPINOn("SPE");
							ret = dm[idx]->DPINOn("SPD");
							ret = dm[idx]->DPINOn("SPC");
							ret = dm[idx]->DPINOn("RWN");
							ret = dm[idx]->DPINOn("WDX");
							ret = dm[idx]->DPINOn("WDY");
							ret = dm[idx]->DPINOff("FLTMUX");//Follow Catalyst's code
							ret = dm[idx]->DPINOn("MODE");
						}

						//Set Icmpl to 0.5A before any register changes
						ret = smu[idx]->ClampCurrent("VCC", 0.5);
						CheckError(idx, ret, __LINE__);

						//Set Icmpl to 0.5A before any register changes
						ret = smu[idx]->ClampCurrent("VEE", 0.5);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(0.001);

						//if(!USE_SPI)
						//{
						//	ret = RunVectorFile(idx, Vector_File);
						//	CheckError(idx, ret, __LINE__);
						//}
						//else
						//{
						//	ret = RunSPI(idx, Vector_File);
						//	CheckError(idx, ret, __LINE__);
						//}
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_WRN_V") == true)
					{
						Drive_WRN_V[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_WRN_V");
						ret = dm[idx]->DrivePin("RWN", Drive_WRN_V[i]);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_PWR_SAVE") == true)
					{
						Drive_PWR_SAVE[i] = (int)tf_TPCondition_Cast(TPName[i], "Drive_PWR_SAVE");
						ret = dm[idx]->DrivePin("MODE", Drive_PWR_SAVE[i]);
					}

					////pg1
					//ret = ReadSPI(idx, "read_p1_reg0", data_pg1[0]);
					//ret = ReadSPI(idx, "read_p1_reg1", data_pg1[1]);
					//ret = ReadSPI(idx, "read_p1_reg2", data_pg1[2]);
					//ret = ReadSPI(idx, "read_p1_reg3", data_pg1[3]);
					//ret = ReadSPI(idx, "read_p1_reg4", data_pg1[4]);
					//ret = ReadSPI(idx, "read_p1_reg5", data_pg1[5]);
					//ret = ReadSPI(idx, "read_p1_reg6", data_pg1[6]);
					//ret = ReadSPI(idx, "read_p1_reg7", data_pg1[7]);
					//ret = ReadSPI(idx, "read_p1_reg8", data_pg1[8]);
					//ret = ReadSPI(idx, "read_p1_reg9", data_pg1[9]);
					//ret = ReadSPI(idx, "read_p1_reg10", data_pg1[10]);
					//ret = ReadSPI(idx, "read_p1_reg11", data_pg1[11]);
					//ret = ReadSPI(idx, "read_p1_reg12", data_pg1[12]);
					//ret = ReadSPI(idx, "read_p1_reg13", data_pg1[13]);
					//ret = ReadSPI(idx, "read_p1_reg14", data_pg1[14]);
					//ret = ReadSPI(idx, "read_p1_reg15", data_pg1[15]);
					//ret = ReadSPI(idx, "read_p1_reg16", data_pg1[16]);
					//ret = ReadSPI(idx, "read_p1_reg17", data_pg1[17]);
					//ret = ReadSPI(idx, "read_p1_reg18", data_pg1[18]);
					//ret = ReadSPI(idx, "read_p1_reg19", data_pg1[19]);
					//ret = ReadSPI(idx, "read_p1_reg20", data_pg1[20]);
					//ret = ReadSPI(idx, "read_p1_reg21", data_pg1[21]);
					//ret = ReadSPI(idx, "read_p1_reg22", data_pg1[22]);
					//ret = ReadSPI(idx, "read_p1_reg23", data_pg1[23]);
					//ret = ReadSPI(idx, "read_p1_reg24", data_pg1[24]);
					//ret = ReadSPI(idx, "read_p1_reg25", data_pg1[25]);
					//ret = ReadSPI(idx, "read_p1_reg26", data_pg1[26]);
					//ret = ReadSPI(idx, "read_p1_reg27", data_pg1[27]);
					//ret = ReadSPI(idx, "read_p1_reg28", data_pg1[28]);
					//ret = ReadSPI(idx, "read_p1_reg29", data_pg1[29]);
					//ret = ReadSPI(idx, "read_p1_reg30", data_pg1[30]);
					//ret = ReadSPI(idx, "read_p1_reg31", data_pg1[31]);
					////pg2
					//ret = ReadSPI(idx, "read_p2_reg32", data_pg2[0]);
					//ret = ReadSPI(idx, "read_p2_reg33", data_pg2[1]);
					//ret = ReadSPI(idx, "read_p2_reg34", data_pg2[2]);
					//ret = ReadSPI(idx, "read_p2_reg38", data_pg2[6]);
					//ret = ReadSPI(idx, "read_p2_reg39", data_pg2[7]);
					//ret = ReadSPI(idx, "read_p2_reg40", data_pg2[8]);
					//ret = ReadSPI(idx, "read_p2_reg54", data_pg2[22]);
					//ret = ReadSPI(idx, "read_p2_reg56", data_pg2[24]);
					//ret = ReadSPI(idx, "read_p2_reg57", data_pg2[25]);
					//ret = ReadSPI(idx, "read_p2_reg58", data_pg2[26]);
					//ret = ReadSPI(idx, "read_p2_reg59", data_pg2[27]);
					//ret = ReadSPI(idx, "read_p2_reg60", data_pg2[28]);
					//ret = ReadSPI(idx, "read_p2_reg61", data_pg2[29]);
					//ret = ReadSPI(idx, "read_p2_reg62", data_pg2[30]);
					//ret = ReadSPI(idx, "read_p2_reg63", data_pg2[31]);
					//
					//ret = RunSPI(idx, "write_p2_reg63_extregsp_enable_h");
					//CheckError(idx, ret, __LINE__);

					////pg4
					//ret = ReadSPI(idx, "read_p2_reg32", data_pg4[0]);
					//ret = ReadSPI(idx, "read_p2_reg33", data_pg4[1]);
					//ret = ReadSPI(idx, "read_p2_reg34", data_pg4[2]);
					//ret = ReadSPI(idx, "read_p2_reg38", data_pg4[6]);
					//ret = ReadSPI(idx, "read_p2_reg39", data_pg4[7]);
					//ret = ReadSPI(idx, "read_p2_reg40", data_pg4[8]);
					//ret = ReadSPI(idx, "read_p2_reg54", data_pg4[22]);
					//ret = ReadSPI(idx, "read_p2_reg56", data_pg4[24]);
					//ret = ReadSPI(idx, "read_p2_reg57", data_pg4[25]);
					//ret = ReadSPI(idx, "read_p2_reg58", data_pg4[26]);
					//ret = ReadSPI(idx, "read_p2_reg59", data_pg4[27]);
					//ret = ReadSPI(idx, "read_p2_reg60", data_pg4[28]);
					//ret = ReadSPI(idx, "read_p2_reg61", data_pg4[29]);
					//ret = ReadSPI(idx, "read_p2_reg62", data_pg4[30]);
					//ret = ReadSPI(idx, "read_p2_reg63", data_pg4[31]);

					if (tf_TPCondition_exist(TPName[i], "Clamp_Vcc_Current_A") == true)
					{
						Clamp_Vcc_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vcc_Current_A"));
						ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Clamp_Vee_Current_A") == true)
					{
						Clamp_Vee_Current_A	= (double)(tf_TPCondition_Cast(TPName[i], "Clamp_Vee_Current_A"));
						ret = smu[idx]->ClampCurrent("VEE", Clamp_Vee_Current_A);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_Vcc2_V") == true)
					{
						Drive_Vcc2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc2_V"));
						ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc2_V);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Drive_Vee2_V") == true)
					{
						Drive_Vee2_V	= (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee2_V"));
						ret = smu[idx]->DriveVoltage("VEE", Drive_Vee2_V);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					//special for icc_s_3p3
					if(TPDispName[i]->Contains("3p3") == true)
					{
						ret = dm[idx]->DPINOff("SPD");
						CheckError(idx, ret, __LINE__);

						double spdvoltage = 0.75;
						double spdrange = 0.0002;
						//configure PMU
						ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction("SPD", DM_CONST_DVCI);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUCurrentLimitRange("SPD", spdrange);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUVoltageLevel("SPD", spdvoltage);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime("SPD", NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->DPINOn("SPD");
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
					{
						Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
						_util->Wait_Sec(Measure_Delay_s);
					}

					if (tf_TPCondition_exist(TPName[i], "Measure_Pin") == true)
					{
						Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));

						if (Measure_Pin == "VCC")
						{
							ret = smu[idx]->ReadCurrent("VCC", result[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (Measure_Pin == "VEE")
						{
							ret = smu[idx]->ReadCurrent("VEE", result[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (Debug_Enable == true)
						{
							double volt_vcc = 0;
							double volt_vee = 0;
							ret = smu[idx]->ReadVoltage("VCC", volt_vcc);
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->ReadVoltage("VEE", volt_vee);
							CheckError(idx, ret, __LINE__);
						}
					}

					//special for icc_s_3p3
					if(TPDispName[i]->Contains("3p3") == true)
					{
						ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Measure_Pin_1") == true)
					{
						Measure_Pin_1	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin_1"));
						
						if (Measure_Pin_1 == "VCC")
						{
							ret = smu[idx]->ReadCurrent("VCC", result2[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (Measure_Pin_1 == "VEE")
						{
							ret = smu[idx]->ReadCurrent("VEE", result2[i]);
							CheckError(idx, ret, __LINE__);
						}
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
					{
						Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));

						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File_1);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File_1);
							CheckError(idx, ret, __LINE__);
						}

						_util->Wait_Sec(Measure_Delay_s);

						if (Measure_Pin == "VCC")
						{
							ret = smu[idx]->ReadCurrent("VCC", result3[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (Measure_Pin == "VEE")
						{
							ret = smu[idx]->ReadCurrent("VEE", result3[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (Measure_Pin_1 == "VCC")
						{
							ret = smu[idx]->ReadCurrent("VCC", result4[i]);
							CheckError(idx, ret, __LINE__);
						}

						if (Measure_Pin_1 == "VEE")
						{
							ret = smu[idx]->ReadCurrent("VEE", result4[i]);
							CheckError(idx, ret, __LINE__);
						}

						result[i] = result[i] - result3[i];

						result2[i] = result2[i] - result4[i];
					}

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}	

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_1") == true)
					{
						Global_Result_Index_1 = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_1"));
						
						_glob->Global_Result[idx, Global_Result_Index_1] = result2[i];
					}	

					if (tf_TPCondition_exist(TPName[i], "Operation") == true)
					{
						String ^ Global_Result_Index_A = String::Empty;
						String ^ Global_Result_Index_B = String::Empty;

						int A = 0;
						int B = 0;

						Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_A") == true)
						{
							Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A")); 
						}

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_B") == true)
						{
							Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));			
						}				

						if (Operation == "-A")
						{
							A = _util->StrToInt(Global_Result_Index_A);

							result[i] = result[i] - _glob->Global_Result[idx, A];
						}

						if (Operation == "=")
						{
							A = _util->StrToInt(Global_Result_Index_A);

							result[i] = _glob->Global_Result[idx, A];
						}
						
						if (Operation == "A-B")
						{
							A = _util->StrToInt(Global_Result_Index_A);
							B = _util->StrToInt(Global_Result_Index_B);

							if (TPDispName[i]->StartsWith("Pd"))
							{
								result[i] = _glob->Global_Result[idx, A]*Drive_Vcc_V - _glob->Global_Result[idx, B]*-Drive_Vee_V;
							}
							else
							{
								result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
							}
						}

						if (Operation == "ABS(A-B)")
						{
							A = _util->StrToInt(Global_Result_Index_A);
							B = _util->StrToInt(Global_Result_Index_B);

							result[i] = Math::Abs(_glob->Global_Result[idx, A] - _glob->Global_Result[idx, B]);
						}

						if (Operation == "MAX[A]-MIN[B]")
						{
							double max = 0;
							double min = 0;

							array<String ^> ^ ArrStr = gcnew array<String ^>(0);
							array<String ^> ^ Separator = gcnew array<String ^>(1);
							Separator[0] = ",";

							ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							result[i] = max - min;
						}
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			ret = smu[idx]->ClampCurrent("VCC", 0.5);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampCurrent("VEE", 0.5);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(5e-3);

			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(5e-3); //discharge cap

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}	
	}
	void TestProgram::power_pd(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result2 = gcnew array<double>(total_tp);
			array<double> ^ result3 = gcnew array<double>(total_tp);
			array<double> ^ result4 = gcnew array<double>(total_tp);
			array<int> ^ Drive_WRN_V = gcnew array<int>(total_tp);
			array<int> ^ Drive_PWR_SAVE = gcnew array<int>(total_tp);
			array<int> ^ data_pg1 = gcnew array<int>(32);
			array<int> ^ data_pg2 = gcnew array<int>(32);
			array<int> ^ data_pg4 = gcnew array<int>(32);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				result2[i] = 0;
				result3[i] = 0;
				result4[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			bool isCurrentTPBypassed = false;

			int Global_Result_Index = 0;
			int Global_Result_Index_1 = 0;
			String ^ Operation		= String::Empty; 

		
			for (int i=0; i<total_tp; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

				if (isCurrentTPBypassed == false)
				{

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}	

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_1") == true)
					{
						Global_Result_Index_1 = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_1"));
						
						_glob->Global_Result[idx, Global_Result_Index_1] = result2[i];
					}	

					if (tf_TPCondition_exist(TPName[i], "Operation") == true)
					{
						String ^ Global_Result_Index_A = String::Empty;
						String ^ Global_Result_Index_B = String::Empty;

						int A = 0;
						int B = 0;

						Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_A") == true)
						{
							Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A")); 
						}

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_B") == true)
						{
							Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));			
						}				

						if (Operation == "-A")
						{
							A = _util->StrToInt(Global_Result_Index_A);

							result[i] = result[i] - _glob->Global_Result[idx, A];
						}

						if (Operation == "=")
						{
							A = _util->StrToInt(Global_Result_Index_A);

							result[i] = _glob->Global_Result[idx, A];
						}
						
						if (Operation == "A-B")
						{
							A = _util->StrToInt(Global_Result_Index_A);
							B = _util->StrToInt(Global_Result_Index_B);

							if (TPDispName[i]->StartsWith("Pd"))
							{
								result[i] = _glob->Global_Result[idx, A]*Drive_Vcc_V - _glob->Global_Result[idx, B]*-Drive_Vee_V;
							}
							else
							{
								result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
							}
						}

						if (Operation == "ABS(A-B)")
						{
							A = _util->StrToInt(Global_Result_Index_A);
							B = _util->StrToInt(Global_Result_Index_B);

							result[i] = Math::Abs(_glob->Global_Result[idx, A] - _glob->Global_Result[idx, B]);
						}

						if (Operation == "MAX[A]-MIN[B]")
						{
							double max = 0;
							double min = 0;

							array<String ^> ^ ArrStr = gcnew array<String ^>(0);
							array<String ^> ^ Separator = gcnew array<String ^>(1);
							Separator[0] = ",";

							ArrStr = Global_Result_Index_A->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (max < _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										max = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							ArrStr = Global_Result_Index_B->Split(Separator, StringSplitOptions::None);

							for (int j=0; j<ArrStr->Length; j++)
							{
								if (j == 0)
								{
									min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
								else
								{
									if (min > _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])])
										min = _glob->Global_Result[idx, _util->StrToInt(ArrStr[j])];
								}
							}

							result[i] = max - min;
						}
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}	
	}

	//trim
	void TestProgram::mux_offset(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
			String ^ Vector_File_2  = (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			double result1 = 0;
			double result2 = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			/*ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);*/

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleType = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin, moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType = DM_CONST_MODULE_TYPE;
			}

			double gnds_volt = 0.0;
			ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, gnds_volt);

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				OnOffCbit(idx, 11,1);
				OnOffCbit(idx, 42,1);

				ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			//if(!USE_SPI) 
			//{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, "write_default_reg");
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result1);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = smu[idx]->ReadVoltage(Test_Pin, result1);
				CheckError(idx, ret, __LINE__);
			}

			//Unbuffered muxoffset

			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, Vector_File_1);
				CheckError(idx, ret, __LINE__);
			//}
			//else 
			//{
			//	ret = RunSPI(idx, Vector_File_1);
			//	CheckError(idx, ret, __LINE__);
			//}

			_util->Wait_Sec(Measure_Delay_s);

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result2);
				CheckError(idx, ret, __LINE__);
			}
			else
			{

				 
				ret = smu[idx]->ReadVoltage(Test_Pin, result2);
				CheckError(idx, ret, __LINE__);
			}

			//
			_glob->mux_offset[idx] = result1 - result2;
			tf_SetResult_UUTOffset(TPName[0], _glob->mux_offset[idx] + GetOffset(idx, TPDispName[0]), idx);

			//Clean up
			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, Vector_File_2);
				CheckError(idx, ret, __LINE__);
			//}
			//else
			//{
			//	ret = RunSPI(idx, Vector_File_2);
			//	CheckError(idx, ret, __LINE__);
			//}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}		

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			if(0)
			{
				//debugcode 
				ofstream myfile;
				myfile.open("C://Aemulus/Debug/muxoffset.txt",  std::ofstream::out | std::ofstream::app);
				myfile << idx << "\t" << _glob->mux_offset[idx] << "\n" ;
				myfile.close();
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::pre_vref_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
			double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result	= 0;
			int result_dac	= 0;
			double Gnds_val = 0.0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;
		
			ResetCBit(idx);
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			// readlockbit
			ret = readlockbit(idx);
			CheckError(idx, ret, __LINE__);

			//if(!USE_SPI) {
				ret = RunVectorFile(idx, "write_trim_readfuse");
				CheckError(idx, ret, __LINE__);
				ret = ReadVector(idx, "read_p3_reg5", data);	//read_p2_reg49
				CheckError(idx, ret, __LINE__);
			//} else {
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, "write_trim_readfuse");
			//	CheckError(idx, ret, __LINE__);
			//	ret = ReadSPI(idx, "read_p3_reg5", data);	//read_p2_reg49
			//	CheckError(idx, ret, __LINE__);
			//}

			result_dac = (data >> 4) & 15;
			
			if (result_dac != 0)
			{
				_glob->FuseBlown[idx] = 1;
			}
			
			_glob->vref_blown_fuse[idx] = result_dac;
			tf_SetResult_UUTOffset(TPName[0], result_dac + (int)GetOffset(idx, TPDispName[0]), idx);

			//measure initial vref

			//if(!USE_SPI) {
				ret = RunVectorFile(idx, "write_trim_readmux_vref");
				CheckError(idx, ret, __LINE__);
			//} else {
			//	ret = RunSPI(idx, "write_trim_readmux_vref");
			//	CheckError(idx, ret, __LINE__);
			//}

			String ^ Test_Pin = "";
			
			ret = Configure_GNDS_Mux(idx, 0.01);
			ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", Gnds_val);
		
			if (0)
			{// pmu measure
				Test_Pin = "FLTMUX";
				ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
				CheckError(idx, ret, __LINE__);
				
				if (Clamp_Voltage_V < 0)
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
				else 
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);
				CheckError(idx, ret, __LINE__);
				
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff(Test_Pin);
				CheckError(idx, ret, __LINE__);
			
			}else{
				//smu measure vref
				OnOffCbit(idx, 11,1);
				OnOffCbit(idx, 42,1);

				Test_Pin = "MTX_SMU";
				ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetBandwidth(Test_Pin, 1);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);
				
				_util->Wait_Sec(Measure_Delay_s);
				ret = smu[idx]->ReadVoltage(Test_Pin, result);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OffSmuPin(Test_Pin);
				CheckError(idx, ret, __LINE__);
			}			
					
			
			result = result - Gnds_val - TRIM_COMP - _glob->mux_offset[idx];
			tf_SetResult_UUTOffset(TPName[1], result + GetOffset(idx, TPDispName[1]), idx);

			//yield result
			if (TIDispName->Contains("verify"))
			{
				int yield = _glob->vref_fuse_toblow[idx] - _glob->vref_blown_fuse[idx];

				if ((_glob->FuseBlown[idx]) || (yield == 0))
				{
					ret = tf_SetResult_UUTOffset(TPName[2], 0 + (int)GetOffset(idx, TPDispName[2]), idx);
					CheckError(idx, ret, __LINE__);
				}else{
					
					ret = tf_SetResult_UUTOffset(TPName[2], 1 + (int)GetOffset(idx, TPDispName[2]), idx);
					CheckError(idx, ret, __LINE__);
				}
			}else{
				_glob->vref_blown_fuse[idx]	= result_dac;
				_glob->vref_pre[idx]			= result;
		
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::sim_vref_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
			double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			_glob->Vref_Target			= (double)(tf_TestItemCondition_Cast("Target"));
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result = 0;
			array<double>^ result_arr = gcnew array<double>(16);

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;
			
			if (((_glob->vref_blown_fuse[idx] == 0) && (_glob->trimlock[idx] == 0)) || (ForceBlowFuseSim))
			{	
			Stopwatch swatch;
		
			ResetCBit(idx);
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			/*ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			*///ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			String ^ Test_Pin = "MTX_SMU";
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
			

				//smu measure vref
				OnOffCbit(idx, 11, 1);
				OnOffCbit(idx, 42,1);

				Test_Pin = "MTX_SMU";
				ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetBandwidth(Test_Pin, Bandwidth);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);

				double Gnds_val = 0.0;

				ret = Configure_GNDS_Mux(idx, 0.01);

				// setup to sweep measure vref
				if(!USE_SPI) 
				{
					ret = RunVectorFile(idx, "write_trim_readmux_vref");
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				} else 
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_trim_readmux_vref");
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}
				
				// create vector array on the fly for to sweep trim fuse setting
				array<int>^ vec_arr = gcnew array<int>(37); // rw bit
				array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
				int dat_bit = 0;
			
				int dac_sweep	= 0;
				int dac			= _glob->TrimReg[VREF, FUSEDAC];
				int max_dac		= (dac / 2) - 1;
				int min_dac		= max_dac + 1;
				
				for (int i = 0; i < 2; i++ )
				{
					switch(i)
					{
						case 0: //max
							dac_sweep = max_dac;
							break;
						case 1: //min
							dac_sweep = min_dac;
							break;
					}
					
					dat_bit = (dac_sweep << _glob->TrimReg[VREF,BIT]);// & 16);

					if(!USE_SPI) 
					{
						vec_arr = make_vector(0, _glob->TrimReg[VREF,PG], _glob->TrimReg[VREF,REG], dat_bit); // rw, pg, reg, dat
						ret = dm[idx]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
						CheckError(idx, ret, __LINE__);
						ret = RunVectorArray(idx, _glob->VectorArrSetNo);
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = WriteSPI(idx, _glob->TrimReg[VREF,PG]-1, _glob->TrimReg[VREF,REG], dat_bit);
						CheckError(idx, ret, __LINE__);
					}

					//_util->Wait_Sec(0.1);
					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", Gnds_val);
					
					ret = smu[idx]->ReadVoltage(Test_Pin, result_arr[i]);
					CheckError(idx, ret, __LINE__);

					result_arr[i] = result_arr[i] - TRIM_COMP - Gnds_val;
				
				}
				
				// find best fuses value
				double vref_max		= result_arr[0];
				double vref_min		= result_arr[1];
				double lsb			= 0.0 ;
				int fuse_dac		= 0;
				int target_dac = 0;
				double target_result = 0;
				double target_result_dac = 0;
				
				//check for max/min out
				if ((_glob->Vref_Target < vref_max) && ( _glob->Vref_Target > vref_min))
				{
					double vref_lsb = 5.2e-3;

					fuse_dac = _util->find_est_range(vref_min, vref_max, _glob->Vref_Target, _glob->TrimReg[VREF,FUSEDAC], lsb, NORM);
								
					// sweep_range to verify 

					ret = find_target(idx, fuse_dac ,lsb ,target_dac, target_result, Measure_Delay_s, _glob->TrimReg[VREF,FUSEDAC], VREF, NORM);
					CheckError(idx, ret, __LINE__);

					CorrectDac(target_dac, _glob->TrimReg[VREF,FUSE]);
					
					tf_SetResult_UUTOffset(TPName[0], target_dac + (int)GetOffset(idx, TPDispName[0]), idx);
					tf_SetResult_UUTOffset(TPName[1], target_result + GetOffset(idx, TPDispName[1]), idx);
				}
				else if(_glob->Vref_Target > vref_max) // Max Out
				{
					target_dac = max_dac;			
					tf_SetResult_UUTOffset(TPName[0], max_dac + (int)GetOffset(idx, TPDispName[0]), idx);
					tf_SetResult_UUTOffset(TPName[1], vref_max + GetOffset(idx, TPDispName[1]), idx);

				}
				else if(_glob->Vref_Target < vref_min) // Max Out
				{
					target_dac = min_dac;
					tf_SetResult_UUTOffset(TPName[0], min_dac + (int)GetOffset(idx, TPDispName[0]), idx);
					tf_SetResult_UUTOffset(TPName[1], vref_min + GetOffset(idx, TPDispName[1]), idx);
				}

				// blow fuse seq
				if ( _glob->FuseBlown[idx] == 0 )
				{
					ret = blow_fuse(idx, VREF, target_dac);
					CheckError(idx, ret, __LINE__);
					_glob->vref_fuse_toblow[idx] = target_dac;
				}
				
			
		
			if(USE_SPI) {
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = smu[idx]->OffSmuPin(Test_Pin);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);

			}
			else
			{
				tf_SetResult_UUTOffset(TPName[0], 0 + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], _glob->vref_pre[idx] + GetOffset(idx, TPDispName[1]), idx);
			}


		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::sim_vref_trim_sweep(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			int debug = 1;
			
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
			double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			_glob->Vref_Target			= (double)(tf_TestItemCondition_Cast("Target"));
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result = 0;
			array<double>^ result_arr = gcnew array<double>(16);

			double vih;
			double vil;
			double voh;
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;
		
			ResetCBit(idx);
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin("VCC", true, false);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin("VEE", true, false);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(0.001);

		/*	ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);*/

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			double Gnds_val = 0.0;

			ret = Configure_GNDS_Mux(idx, 0.01);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			
			if (((_glob->vref_blown_fuse[idx] == 0) && (_glob->trimlock[idx] != 0)) || (ForceBlowFuseSim))
			{

				// setup to sweep measure vref

				if(!USE_SPI) {
					ret = RunVectorFile(idx, "write_trim_readmux_vref");
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				} else {
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_trim_readmux_vref");
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}
				
				ofstream myfile;
				
				if (debug)
				{
					myfile.open("C://Aemulus/Debug/vref_sweep_test.txt");
				}	
				// create vector array on the fly for to sweep trim fuse setting
				array<int>^ vec_arr = gcnew array<int>(37); // rw bit
				array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
				int dat_bit = 0;
							
				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", Gnds_val);

				for (int i = 0; i < _glob->TrimReg[VREF,FUSEDAC]; i++ )
				{
					dat_bit = (i >> _glob->TrimReg[VREF,BIT]);// & 16);
				
					if(!USE_SPI) {
						vec_arr = make_vector(0, _glob->TrimReg[VREF,PG], _glob->TrimReg[VREF,REG], dat_bit); // rw, pg, reg, dat
						ret = dm[idx]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
						CheckError(idx, ret, __LINE__);
						ret = RunVectorArray(idx, _glob->VectorArrSetNo);
						CheckError(idx, ret, __LINE__);
					} else {
						ret = WriteSPI(idx, _glob->TrimReg[VREF,PG]-1, _glob->TrimReg[VREF,REG], dat_bit);
					}

					String ^ Test_Pin = "";
			
				if (0)
				{// pmu measure
					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
					CheckError(idx, ret, __LINE__);
					
					if (Clamp_Voltage_V < 0)
						ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
					else 
						ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);
					CheckError(idx, ret, __LINE__);
					
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOff(Test_Pin);
					CheckError(idx, ret, __LINE__);
				
				}
				else
				{
					//smu measure vref
					OnOffCbit(idx, 11, 1);
					OnOffCbit(idx, 42,1);

					Test_Pin = "MTX_SMU";
					ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->SetBandwidth(Test_Pin, 1);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);
					ret = smu[idx]->ReadVoltage(Test_Pin, result_arr[i]);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OffSmuPin(Test_Pin);
					CheckError(idx, ret, __LINE__);
				}		

				result_arr[i] = result_arr[i] - TRIM_COMP - Gnds_val;

					if (debug)
					{
						myfile << i << "\t" << result_arr[i] << "\n";
					}
				}
					if(debug)
					{
						myfile.close();
					}
				// find best fuses value
				double vref_target	= _glob->Vref_Target ;
				double vref_lsb		=  5.2e-3;
				int fuse_count		= 4;

				int fuse_dac = _util->find_closest(result_arr, vref_target);

				// blow fuse seq
				if ( _glob->FuseBlown[idx] == 0 )
				{
					ret = blow_fuse(idx, VREF, fuse_dac);
					CheckError(idx, ret, __LINE__);
					_glob->vref_fuse_toblow[idx] = fuse_dac;
				}
			
				tf_SetResult_UUTOffset(TPName[0], fuse_dac + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], result_arr[fuse_dac] + GetOffset(idx, TPDispName[1]), idx);
			
			}else{
				tf_SetResult_UUTOffset(TPName[0], 0 + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], _glob->vref_pre[idx] + GetOffset(idx, TPDispName[1]), idx);
			}
			
			if(USE_SPI) {
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::pre_iabs_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			
			double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
			double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));
			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			
			double Input_Channel_Delay_s = 0;
			
			String ^ Vector_File	= String::Empty;
			double result			= 0;
			int result_dac			= 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			array<int>^ HistoryRam = gcnew array<int>(8192);	
			int vector_engine_status = 0;
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			//ret = DriveDIOPin(TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			/*ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);*/

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
					
			// setup read iabs fuse status
			if(!USE_SPI) {
			ret = RunVectorFile(idx, "write_trim_readfuse");
			CheckError(idx, ret, __LINE__);
			ret = ReadVector(idx, "read_p3_reg4", data);	//read_p2_reg48
			CheckError(idx, ret, __LINE__);
			} else {
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);
			ret = RunSPI(idx, "write_trim_readfuse");
			CheckError(idx, ret, __LINE__);
			ret = ReadSPI(idx, "read_p3_reg4", data);	//read_p2_reg48
			CheckError(idx, ret, __LINE__);
			}

			result_dac = (data >> 0) & 0x3F;
			if (result_dac != 0)
			{
				_glob->FuseBlown[idx] = 1;
			}
			
			_glob->iabs_blown_fuse[idx] = result_dac;
				
			tf_SetResult_UUTOffset(TPName[0], result_dac + (int)GetOffset(idx, TPDispName[0]), idx);
			
			// setup read iabs 
			if(!USE_SPI) {
			ret = RunVectorFile(idx, "write_trim_readmux_iabs");
			CheckError(idx, ret, __LINE__);
			} else {
			//ret = OnOffSPI(idx, 1);
			//CheckError(idx, ret, __LINE__);
			ret = RunSPI(idx, "write_trim_readmux_iabs");
			CheckError(idx, ret, __LINE__);
			}
			
			if(0)
			{	// PMU measure Iabs	
				ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
				CheckError(idx, ret, __LINE__);
				
				ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin,Clamp_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, Drive_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff(Test_Pin);
				CheckError(idx, ret, __LINE__);
			
			}
			else
			{
				// SMU measure Iabs
				Test_Pin = "MTX_SMU";
			
				OnOffCbit(idx, 11, 1);
				OnOffCbit(idx, 42, 1);

				Test_Pin = "MTX_SMU";
				//ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->SetBandwidth(Test_Pin, 1);
				//CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampCurrent(Test_Pin, Clamp_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveVoltage(Test_Pin, Drive_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);
			
				ret = smu[idx]->ReadCurrent(Test_Pin, result);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OffSmuPin(Test_Pin);
				CheckError(idx, ret, __LINE__);
			}
				
			tf_SetResult_UUTOffset(TPName[1], -result + GetOffset(idx, TPDispName[1]), idx); 

			// verify result
			if (TIDispName->Contains("verify"))
			{
				int yield = _glob->iabs_fuse_toblow[idx] - _glob->iabs_blown_fuse[idx];
				
				if ((_glob->FuseBlown[idx]) || (yield == 0))
				{
					ret = tf_SetResult_UUTOffset(TPName[2], 0 + (int)GetOffset(idx, TPDispName[2]), idx);
				}
				else
				{
					ret = tf_SetResult_UUTOffset(TPName[2], 1 + (int)GetOffset(idx, TPDispName[2]), idx);
				}

			}
			else 
			{
				_glob->iabs_blown_fuse[idx] = result_dac;
				_glob->iabs_pre[idx] = -result;
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			//ret = Digital_Init_State(idx);
			//CheckError(idx, ret, __LINE__);
			//ret = ResetDIOPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			//ret = ResetMuxIO(idx);
			//CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::sim_iabs_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
			double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			_glob->Iabs_Target			= (double)(tf_TestItemCondition_Cast("Target"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result = 0;
			array<double>^ result_arr = gcnew array<double>(64);

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;
			
			if (((_glob->iabs_blown_fuse[idx] == 0) && (_glob->trimlock[idx] == 0))  || (ForceBlowFuseSim))
			{
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

		/*	ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
		*/	//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
			
			String ^ Test_Pin = "MTX_SMU";
			
			OnOffCbit(idx, 11, 1);
			OnOffCbit(idx, 42, 1);

			//ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->SetBandwidth(Test_Pin, 1);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampCurrent(Test_Pin, Clamp_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage(Test_Pin, Drive_Voltage_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
			CheckError(idx, ret, __LINE__);
			
		
				
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, "write_trim_readmux_iabs");
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_trim_readmux_iabs");
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}
				
				array<int>^ vec_arr = gcnew array<int>(37); // rw bit
				array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
			
				int dac			= 64;
				int fuse_count	= 6;
				int max_dac		= (dac / 2) - 1;
				int min_dac		= max_dac + 1;
				int dat_bit = 0;
				int dac_sweep	= 0;
			
				// create vector array on the fly for to sweep trim fuse setting
				for (int i = 0; i < 2; i++ )
				{

					switch(i)
					{
						case 0: //max
							dac_sweep = max_dac;
							break;
						case 1: //min
							dac_sweep = min_dac;
							break;
					}

						dat_bit = (dac_sweep << _glob->TrimReg[IABS,BIT]);// & 16);
						if(!USE_SPI) 
						{
							vec_arr = make_vector(0, _glob->TrimReg[IABS,PG], _glob->TrimReg[IABS,REG], dat_bit); // rw, pg, reg, dat
							ret = dm[idx]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
							CheckError(idx, ret, __LINE__);
							ret = RunVectorArray(idx, _glob->VectorArrSetNo);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = WriteSPI(idx, _glob->TrimReg[IABS,PG]-1, _glob->TrimReg[IABS,REG], dat_bit);
							CheckError(idx, ret, __LINE__);
						}
						// SMU measure Iabs
			
						_util->Wait_Sec(Measure_Delay_s);	
						ret = smu[idx]->ReadCurrent(Test_Pin, result);
						CheckError(idx, ret, __LINE__);

						result_arr[i] = - result;
				}
				
				double iabs_max			= result_arr[0];
				double iabs_min			= result_arr[1];

				double lsb				= 0.0 ;
				int fuse_dac			= 0;
				int target_dac			= 0;
				double target_result	= 0;
				double target_result_dac = 0;
				
				//check for max/min out
				if ((_glob->Iabs_Target < iabs_max) && ( _glob->Iabs_Target > iabs_min))
				{

					fuse_dac = _util->find_est_range(iabs_min,iabs_max,_glob->Iabs_Target,dac, lsb, NORM);
					// sweep_range to verify 
					ret = find_target(idx, fuse_dac ,lsb ,target_dac, target_result, Measure_Delay_s, _glob->TrimReg[IABS, FUSEDAC], IABS, NORM);
					CheckError(idx, ret, __LINE__);

					CorrectDac(target_dac, _glob->TrimReg[IABS,FUSE]);
			
				}
				else if(_glob->Iabs_Target > iabs_max) // Max Out
				{
					target_dac = max_dac;
					target_result = iabs_max;
				}
				else if(_glob->Iabs_Target < iabs_min) // Min Out
				{
					target_dac = min_dac;
					target_result = iabs_min;
				}
			
				tf_SetResult_UUTOffset(TPName[0], target_dac + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], target_result + GetOffset(idx, TPDispName[1]), idx);

				// blowfuseseq

				if ( _glob->FuseBlown[idx] == 0 )
				{
					blow_fuse(idx, IABS, target_dac);
					_glob->iabs_fuse_toblow[idx] = target_dac;
				}
				
			
			ret = smu[idx]->OffSmuPin(Test_Pin);
			CheckError(idx, ret, __LINE__);

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			//ret = ResetDIOPin(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);

			}
			else
			{
				tf_SetResult_UUTOffset(TPName[0], 0 + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], _glob->iabs_pre[idx] + GetOffset(idx, TPDispName[1]), idx);
			}
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::sim_iabs_trim_sweep(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Clamp_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Current_A"));
			double Drive_Voltage_V	= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));

			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			_glob->Iabs_Target			= (double)(tf_TestItemCondition_Cast("Target"));
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result = 0;
			array<double>^ result_arr = gcnew array<double>(64);

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;
		
			ResetCBit(idx);

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

		/*	ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
		*/	//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
				
			if  (((_glob->iabs_blown_fuse[idx] == 0) && (_glob->trimlock[idx] == 0)) || (ForceBlowFuseSim))
			{

				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, "write_trim_readmux_iabs");
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_trim_readmux_iabs");
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}

				array<int>^ vec_arr = gcnew array<int>(37); // rw bit
				array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
			
				ofstream myfile;
				if(Debug_Enable)
				{
					myfile.open("C://Aemulus/Debug/iabs_trim_test.txt");
				}
				String ^ Test_Pin = "MTX_SMU";
			
				OnOffCbit(idx, 11, 1);
				OnOffCbit(idx, 42, 1);

				ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetBandwidth(Test_Pin, 1);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetNPLC(Test_Pin, 0.01);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampCurrent(Test_Pin, Clamp_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveVoltage(Test_Pin, Drive_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);
				// create vector array on the fly for to sweep trim fuse setting

				int dat_bit = 0;
			
				for (int i = 0; i < _glob->TrimReg[IABS,FUSEDAC]; i++ )
				{
					dat_bit = (i >> _glob->TrimReg[IABS,BIT]);// & 16);

					if(!USE_SPI) 
					{		
						vec_arr = make_vector(0, _glob->TrimReg[IABS,PG], _glob->TrimReg[IABS,REG], dat_bit); // rw, pg, reg, dat
						ret = dm[idx]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
						CheckError(idx, ret, __LINE__);
						ret = RunVectorArray(idx, _glob->VectorArrSetNo);
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = WriteSPI(idx, _glob->TrimReg[IABS,PG]-1, _glob->TrimReg[IABS,REG], dat_bit);
						CheckError(idx, ret, __LINE__);
					}

					_util->Wait_Sec(Measure_Delay_s);
					ret = smu[idx]->ReadCurrent(Test_Pin, result);
					CheckError(idx, ret, __LINE__);

					result_arr[i] = - result/ 1e-6;
					
					if(Debug_Enable)
					{
						myfile << i << "\t" << result_arr[i] << "\n";
					}
					result_arr[i] = - result;
					
				}
				if(Debug_Enable)
				{
					myfile.close();
				}
				// get closest reading
				int fuse_dac = 0;
				fuse_dac = _util->find_closest(result_arr, _glob->Iabs_Target);
				
				// blowfuseseq
				if ( _glob->FuseBlown[idx] == 0 )
				{
					blow_fuse(idx, IABS, fuse_dac);
					_glob->iabs_blown_fuse[idx] = fuse_dac;
				}
				
				ret = tf_SetResult_UUTOffset(TPName[0], fuse_dac + (int)GetOffset(idx, TPDispName[0]), idx);
				CheckError(idx, ret, __LINE__);
				ret = tf_SetResult_UUTOffset(TPName[1], result_arr[fuse_dac] + GetOffset(idx, TPDispName[1]), idx);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				tf_SetResult_UUTOffset(TPName[0], 0 + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], _glob->iabs_pre[idx] + GetOffset(idx, TPDispName[1]), idx);
			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = smu[idx]->OffSmuPin("MTX_SMU");
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::pre_atemp_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
			double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Test_Pin			= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			
			double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			_glob->Atemp_Target			= (double)(tf_TestItemCondition_Cast("Target"));	

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result	= 0;
			int result_dac	= 0;

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			int vector_engine_status = 0;
			String ^ Vector_File = String::Empty;
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			/*ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			*///ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			// setup read atemp fuse status

			double Gnds_val = 0.0;

			ret = Configure_GNDS_Mux(idx, 0.01);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_trim_readfuse");
				CheckError(idx, ret, __LINE__);
				ret = ReadVector(idx, "read_p3_reg5", data);	//read_p2_reg49
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_trim_readfuse");
				CheckError(idx, ret, __LINE__);
				ret = ReadSPI(idx, "read_p3_reg5", data);	//read_p2_reg49
				CheckError(idx, ret, __LINE__);
			}
			result_dac = (data >> 0) & 0xF;
			if (result_dac != 0)
			{
				_glob->FuseBlown[idx] = 1;
			}
			
			_glob->atemp_blown_fuse[idx] = result_dac;
			
			tf_SetResult_UUTOffset(TPName[0], result_dac + (int)GetOffset(idx, TPDispName[0]), idx);
			
			//measure initial atemp
			if(!USE_SPI) 
			{
				ret = RunVectorFile(idx, "write_trim_readmux_atemp");
				CheckError(idx, ret, __LINE__);
			}
			else 
			{
				ret = RunSPI(idx, "write_trim_readmux_atemp");
				CheckError(idx, ret, __LINE__);
			}	

			ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", Gnds_val);
			CheckError(idx, ret, __LINE__);

			if (0)
			{
				// pmu measure
				ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePowerLineFrequency(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSense(Test_Pin, DM_CONST_LOCAL);
				CheckError(idx, ret, __LINE__);
				
				if (Clamp_Voltage_V < 0)
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, 0, Clamp_Voltage_V);
				else 
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Voltage_V, 0);
				CheckError(idx, ret, __LINE__);
				
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOff(Test_Pin);
				CheckError(idx, ret, __LINE__);
			
			}
			else
			{
				//smu measure atemp
				ret = OnOffCbit(idx, 11, 1);
				CheckError(idx, ret, __LINE__);
				ret = OnOffCbit(idx, 42, 1);
				CheckError(idx, ret, __LINE__);

				Test_Pin = "MTX_SMU";
				//ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->SetBandwidth(Test_Pin, 1);
				//CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);
				ret = smu[idx]->ReadVoltage(Test_Pin, result);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OffSmuPin(Test_Pin);
				CheckError(idx, ret, __LINE__);
			}
			
			// result and calculation
			double atemp_V  = result - Gnds_val - TRIM_COMP - _glob->mux_offset[idx]; // Compensate value
			double atemp_offset = 131.7/184.0;	//2935 131.7/182.5;
			double atemp_step = 1/184.0;		//2935 182.5;
			double atemp_raw = (atemp_V - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
			double atemp_target = _glob->Atemp_Target;

			tf_SetResult_UUTOffset(TPName[1], atemp_V + GetOffset(idx, TPDispName[1]), idx);
			tf_SetResult_UUTOffset(TPName[2], atemp_raw + GetOffset(idx, TPDispName[2]), idx);
			tf_SetResult_UUTOffset(TPName[3], atemp_target + GetOffset(idx, TPDispName[3]), idx);
			tf_SetResult_UUTOffset(TPName[4], abs(atemp_target-atemp_raw) + GetOffset(idx, TPDispName[4]), idx);

			// verify result
			if (TIDispName->Contains("verify"))
			{	
				int yield = _glob->atemp_fuse_toblow[idx] - _glob->atemp_blown_fuse[idx];
				
				if ((_glob->FuseBlown[idx]) || (yield == 0))
				{ 
					tf_SetResult_UUTOffset(TPName[5], 0 + (int)GetOffset(idx, TPDispName[5]), idx);
				}
				else
				{
					tf_SetResult_UUTOffset(TPName[5], 1 + (int)GetOffset(idx, TPDispName[5]), idx);
				}
			}
			else 
			{
				_glob->atemp_blown_fuse[idx] = result_dac;
				_glob->atemp_pre[idx] = atemp_raw;
			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::sim_atemp_trim_sweep(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
			double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s			= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			_glob->Atemp_Target			= (double)(tf_TestItemCondition_Cast("Target"));
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result = 0;
			array<double>^ result_arr = gcnew array<double>(16);
			array<double>^ atemp_raw_arr = gcnew array<double>(16);
			array<double>^atemp_V_arr = gcnew array<double>(16);
			
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;
		
			ResetCBit(idx);
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

	/*		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
	*/		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			// calculation constant
			double atemp_offset = 131.7/184.0;		//2935 is 131.7/182.5;
			double atemp_step = 1/184.0;			//2935 is 1/182.5;
				

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			double Gnds_val = 0.0;

			ret = Configure_GNDS_Mux(idx, 0.01);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			
			String ^ Test_Pin = "MTX_SMU";
				
			if (((_glob->atemp_blown_fuse[idx] == 0) && (_glob->trimlock[idx] == 0)) || (ForceBlowFuseSim))
			{

				// setup testfuse
				if(!USE_SPI) 
				{
					ret = RunVectorFile(idx, "write_trim_readmux_atemp");
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				} 
				else 
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_trim_readmux_atemp");
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, "write_enable_testfuse");
					CheckError(idx, ret, __LINE__);
				}

				array<int>^ vec_arr = gcnew array<int>(37); // rw bit
				array<int>^ vec1_arr = gcnew array<int>(37); // rw bit

				ofstream myfile;

				if(Debug_Enable)
				{
					myfile.open("C://Aemulus/Debug/atemp_trim_sweep.txt");
				}
				// create vector array on the fly for to sweep trim fuse setting
				int dat_bit = 0;

				//Setup measurement resource
				ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetBandwidth(Test_Pin, 1);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);
				
				OnOffCbit(idx, 11, 1);
				OnOffCbit(idx, 42, 1);

				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", Gnds_val);

				// Sweep measurement
				for (int i = 0; i < _glob->TrimReg[ATEMP,FUSEDAC]; i++ )
				{
					dat_bit = (i << _glob->TrimReg[ATEMP,BIT]) & 0xF0;
					if(!USE_SPI) 
					{
						vec_arr = make_vector( 0, _glob->TrimReg[ATEMP,PG], _glob->TrimReg[ATEMP,REG], dat_bit); // rw, pg, reg, dat
						ret = dm[idx]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
						CheckError(idx, ret, __LINE__);
						ret = RunVectorArray(idx, _glob->VectorArrSetNo);
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = WriteSPI(idx, _glob->TrimReg[ATEMP,PG]-1, _glob->TrimReg[ATEMP,REG], dat_bit);
					}

					//smu measure
					_util->Wait_Sec(Measure_Delay_s);
					ret = smu[idx]->ReadVoltage(Test_Pin, result);
					CheckError(idx, ret, __LINE__);

					atemp_V_arr[i]  = result - Gnds_val - _glob->mux_offset[idx]; // Compensate value
					atemp_raw_arr[i] = (atemp_V_arr[i] - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
				
					if(Debug_Enable)
					{
						myfile <<  i << "\t" << result <<"\t" << atemp_raw_arr[i] << "\n";
					}
				}
				if(Debug_Enable)
				{		
					myfile.close();
				}

				// find best fuses value
				int fuse_dac = _util->find_closest(atemp_raw_arr, _glob->Atemp_Target);

				// blow fuse seq
				if ( _glob->FuseBlown[idx] == 0 )
				{
					ret = blow_fuse(idx, ATEMP, fuse_dac);
					CheckError(idx, ret, __LINE__);
					_glob->atemp_blown_fuse[idx] = fuse_dac;
				}
				
				// Parse result

				tf_SetResult_UUTOffset(TPName[0], fuse_dac + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], atemp_raw_arr[fuse_dac] + GetOffset(idx, TPDispName[1]), idx);
			
			}
			else
			{
				int res = 0;
				tf_SetResult_UUTOffset(TPName[0], res, idx);
				tf_SetResult_UUTOffset(TPName[1], _glob->atemp_pre[idx], idx);
			}

			
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			// Off meas pin
			ret = smu[idx]->OffSmuPin(Test_Pin);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::sim_atemp_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{	
		
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			
			double Clamp_Voltage_V		= (double)(tf_TestItemCondition_Cast("Clamp_Voltage_V"));
			double Drive_Current_A		= (double)(tf_TestItemCondition_Cast("Drive_Current_A"));
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Target				= (double)(tf_TestItemCondition_Cast("Target"));
			double Input_Channel_Delay_s = 0;
			_glob->Atemp_Target			= (double)(tf_TestItemCondition_Cast("Target"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			double result					= 0;
			array<double>^ result_arr		= gcnew array<double>(16);

			array<double>^ atemp_raw_arr	= gcnew array<double>(2);
			array<double>^ atemp_V_arr		= gcnew array<double>(2);

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			double atemp_offset = 131.7/184.0;	//2935 is 131.7/182.5;
			double atemp_step = 1/184.0;	//2935 is 1/182.5;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;
			
			if (((_glob->atemp_blown_fuse[idx] == 0) && (_glob->trimlock[idx] == 0))  || (ForceBlowFuseSim))
			{

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

		/*	ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
		*/	//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			//smu measure vref
			ret = OnOffCbit(idx, 11, 1);
			CheckError(idx, ret, __LINE__);
			ret = OnOffCbit(idx, 42, 1);
			CheckError(idx, ret, __LINE__);

			String ^ Test_Pin = "MTX_SMU";
			ret = smu[idx]->ConfigurePLF(Test_Pin, Power_Line_Freq);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->SetBandwidth(Test_Pin, 1);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->SetNPLC(Test_Pin, NPLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage(Test_Pin, Clamp_Voltage_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
			CheckError(idx, ret, __LINE__);

			double Gnds_val = 0.0;

			ret = Configure_GNDS_Mux(idx, 0.01);

			// setup to sweep measure vref

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_trim_readmux_atemp");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, "write_enable_testfuse");
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_trim_readmux_atemp");
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_enable_testfuse");
				CheckError(idx, ret, __LINE__);
			}

			// create vector array on the fly for to sweep trim fuse setting
			array<int>^ vec_arr = gcnew array<int>(37); // rw bit
			array<int>^ vec1_arr = gcnew array<int>(37); // rw bit
			int dat_bit = 0;
		
			int dac_sweep	= 0;
			int dac			= _glob->TrimReg[ATEMP, FUSEDAC];
			int min_dac		= (dac / 2) - 1;
			int max_dac		= min_dac + 1;
			
			ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", Gnds_val);

				for (int i = 0; i < 2; i++ )
				{
					switch(i)
					{
						case 0: //max
							dac_sweep = max_dac;
							break;
						case 1: //min
							dac_sweep = min_dac;
							break;
					}
					
					dat_bit = (dac_sweep << _glob->TrimReg[ATEMP,BIT]);// & 16);
					
					if(!USE_SPI) 
					{
						vec_arr = make_vector( 0, _glob->TrimReg[ATEMP,PG], _glob->TrimReg[ATEMP,REG], dat_bit); // rw, pg, reg, dat
						ret = dm[idx]->DPINVecLoadArray("DM_2",0, 2, 0, _glob->VectorArrSetNo, 36, vec_arr, vec1_arr);
						CheckError(idx, ret, __LINE__);
						ret = RunVectorArray(idx, _glob->VectorArrSetNo);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = WriteSPI(idx, _glob->TrimReg[ATEMP,PG]-1, _glob->TrimReg[ATEMP,REG], dat_bit);
						CheckError(idx, ret, __LINE__);
					}

					_util->Wait_Sec(Measure_Delay_s);
					ret = smu[idx]->ReadVoltage(Test_Pin, result);
					CheckError(idx, ret, __LINE__);

					atemp_V_arr[i]  = result - Gnds_val - _glob->mux_offset[idx]; // Compensate value
					atemp_raw_arr[i] = (atemp_V_arr[i] - atemp_offset)/atemp_step ;     // atemp_myx - atemp_offset / atemp_step
				}
				// find best fuses value

				double atemp_max		= atemp_raw_arr[0];
				double atemp_min		= atemp_raw_arr[1];
				double lsb				= 0.0 ;
				int fuse_dac			= 0;
				int target_dac			= 0;
				double target_result	= 0;
				double target_result_dac = 0;
				double target_raw_result = 0; 
				
				//check for max/min out
				if ((_glob->Atemp_Target < atemp_max) && ( _glob->Atemp_Target > atemp_min))
				{
					fuse_dac = _util->find_est_range(atemp_min, atemp_max, _glob->Atemp_Target, _glob->TrimReg[ATEMP,FUSEDAC], lsb, INV);
						// sweep_range to verify 
					ret = find_target(idx, fuse_dac ,lsb ,target_dac, target_result, Measure_Delay_s, _glob->TrimReg[ATEMP,FUSEDAC], ATEMP, INV);
					CheckError(idx, ret, __LINE__);
					
					CorrectDac(target_dac, _glob->TrimReg[ATEMP,FUSE]);
					target_raw_result = (target_result - atemp_offset)/atemp_step ;

				}
				else if(_glob->Atemp_Target > atemp_max) // Max Out
				{	
					target_dac		= max_dac;
					target_result = ( atemp_max * atemp_step ) +  atemp_offset; 
					target_raw_result = atemp_max;
					
				
				}
				else if(_glob->Atemp_Target < atemp_min) // Min Out
				{
					target_dac		= min_dac;
					target_result = ( atemp_min * atemp_step ) +  atemp_offset; 
					target_raw_result = atemp_min;
					
				}
				tf_SetResult_UUTOffset(TPName[0], target_dac + (int)GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[1], target_raw_result + GetOffset(idx, TPDispName[1]), idx);
			
				// blowfuse seq
				if ( _glob->FuseBlown[idx] == 0 )
				{
					ret = blow_fuse(idx, ATEMP, target_dac);
					CheckError(idx, ret, __LINE__);
					_glob->atemp_fuse_toblow[idx] = target_dac;
				}

			
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = smu[idx]->OffSmuPin(Test_Pin);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);

			}
			else
			{
				int res = 0;
				tf_SetResult_UUTOffset(TPName[0], res, idx);
				tf_SetResult_UUTOffset(TPName[1], _glob->atemp_pre[idx], idx );
			}
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::htslope(Object^ object) //JL: New test
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("HTR0_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("HTR0_F", DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("HTR0_F", NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("HTR0_F", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("HTR0_F", Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("HTR0_F", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("HTR0_F");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("HTR1_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("HTR1_F", DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("HTR1_F", NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("HTR1_F", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("HTR1_F", Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("HTR1_F", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("HTR1_F");
			CheckError(idx, ret, __LINE__);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
		
			//JL: run Vector file to initialize the test		
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			int reg_val = 0;
			
			//param 0: read_fuse_status("htslopeMode",num_fuses=3);
			// JL: ROTestCtl (pg3,_reg8) = 2, read ROTestA(pg3_reg4)[6:4] 
			ret = WriteSPI(idx, 3, 8, 0x02);
			ret = ReadReg(idx, 3, 4, reg_val);
			reg_val = (reg_val >> 4) & 0x07;
			tf_SetResult_UUTOffset(TPName[0], (int)(reg_val + GetOffset(idx, TPDispName[0])), idx);
			
			//param 1: "read_fuse_status("htslopeH0",1);
			// JL: ROTestCtl (pg3,_reg8) = 3, read ROTestB(pg3_reg5)[0] 
			ret = WriteSPI(idx, 3, 8, 0x03);
			ret = ReadReg(idx, 3, 5, reg_val);
			reg_val &=0x1;
			tf_SetResult_UUTOffset(TPName[1], reg_val + GetOffset(idx, TPDispName[1]), idx);
			
			//param 2: read_fuse_status("htslopeH1",1);
			// JL: ROTestCtl (pg3,_reg8) = 3, read ROTestB(pg3_reg5)[1] 
			ret = WriteSPI(idx, 3, 8, 0x03);
			ret = ReadReg(idx, 3, 5, reg_val);
			reg_val = (reg_val >> 1) & 0x02;
			tf_SetResult_UUTOffset(TPName[2], reg_val + GetOffset(idx, TPDispName[2]), idx);
			
			//param 3, 4:
			//meas_ht_slope(MAX_HDS, ht_slope, get_default(HEATER_MODE),0);
			//for(hd=0; hd<HDS; hd++) test ht_slope[hd];
			array<int> ^ ht_trim_dac = {
				  16,      /* DAC =  0.256V */
				  32,      /* DAC =  0.512V */
				  64,      /* DAC =  1.024V */
				  128,     /* DAC =  2.048V */
				  129,     /* DAC =  2.064V */
				  130,     /* DAC =  2.080V */
				  132,     /* DAC =  2.112V */
				  136,     /* DAC =  2.176V */
				  198,     /* DAC =  3.168V */
				  255      /* DAC =  4.080V */
			};
			array<double> ^ ht_trim = gcnew array<double>(10); 
			array<String ^> ^ heater_pin = {"HTR0_F", "HTR1_F"};
			double result = 0;
			double slope = 0;
			double ht_trim_offset = 0;
			
			//modeconfig=00; pg1_reg7[7:6] . default bit4=1, bit1:0=11. Heater enable, bit5=1
			ret = WriteSPI(idx, 1, 7, 0x33);
			//RHEAT = 0, pg1_reg12
			ret = WriteSPI(idx, 1, 12, 0x00);		
			//Heater_mode, pg1_reg14[0] = 0, default bit1=1
			ret = WriteSPI(idx, 1, 14, 0x02);
			
			for(int hd = 0; hd < 2; hd++)
			{
				//HSEL = hd, pg1_reg1[3:0]
				reg_val = 0xc0 | hd;
				ret = WriteSPI(idx, 1, 1, reg_val);
				
				for(int step = 0; step < 10; step++)
				{
					ret = WriteSPI(idx, 1, 12, ht_trim_dac[step]);	//RHeat
					ret = dm[idx]->PMUMeasure(heater_pin[hd], DM_CONST_MEASUREVOLTAGE, ht_trim[step]);
					
				}
				_util->line_fit(ht_trim_dac, ht_trim, 10, slope, ht_trim_offset);
				tf_SetResult_UUTOffset(TPName[3 + hd], slope + GetOffset(idx, TPDispName[3 + hd]), idx);
			}
			//RHEAT = 0, pg1_reg12
			ret = WriteSPI(idx, 1, 12, 0x00);	
			
			if(USE_SPI) {
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::htr(Object^ object) //JL: New test
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{			
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
								
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("HTR0_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("HTR0_F", DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("HTR0_F", NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("HTR0_F", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("HTR0_F", Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("HTR0_F", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("HTR0_F");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("HTR1_F");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("HTR1_F", DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("HTR1_F", NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("HTR1_F", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("HTR1_F", Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("HTR1_F", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("HTR1_F");
			CheckError(idx, ret, __LINE__);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
		
			//JL: run Vector file to initialize the test		
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			int reg_val = 0;
			
			//param 0
			//ROTestCtl=2
			ret = WriteSPI(idx, 3, 8, 0x02); 
			//Read ROTestA[3:0], return result to param
			ret = ReadReg(idx, 3, 4, reg_val);
			reg_val &= 0x0f;
			
			tf_SetResult_UUTOffset(TPName[0], (int) (reg_val + GetOffset(idx, TPDispName[0])), idx);
			
			//param 1
			double target = 10e-3; //10mA
			double htrIcal = 0;
			double i_lvl = 0;
			
			i_lvl = target*0.34 + target;
			
			//idle mode, pg1_reg7[1]=0
			ret = WriteSPI(idx, 1, 7, 0x11);
			//mask all faults
			ret = WriteSPI(idx, 1, 10, 0xff);
			ret = WriteSPI(idx, 3, 11, 0xc0);
			//AMUX=29 (HeaterTestCurrentCal), pg1_reg15 bit7=0, bit6=DMUXAMUXN=0, bit5:0=MUX[5:0]=01_1101 ; pg3_reg13[6]=MUX[6]=0
			//Select Amux: FOS Fault Test Mode
			ret = WriteSPI(idx, 1, 15, 0x1d);
			ret = WriteSPI(idx, 3, 13, 0x00);
			//FuseTestSel, pg3_reg6[1:0] = 0
			ret = WriteSPI(idx, 3, 6, 0x00);
			//FuseTest, pg2_reg9[1] = 0, default bit0=1
			ret = WriteSPI(idx, 2, 9, 0x01);
			
			ret = dm[idx]->DPINOff("FLTMUX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", i_lvl);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("FLTMUX", i_lvl);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("FLTMUX");
			CheckError(idx, ret, __LINE__);
			
			_util->Wait_Sec(1e-3);
			dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, htrIcal);
			htrIcal *= -1;
			
			tf_SetResult_UUTOffset(TPName[1], htrIcal + GetOffset(idx, TPDispName[1]), idx);
			
			if(USE_SPI) {
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::sim_htr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{			
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double Clamp_Current_A  = (double)(tf_TestItemCondition_Cast("Clamp_Current_A")); //JL: value = 5e-5
			double Drive_Voltage_V		= (double)(tf_TestItemCondition_Cast("Drive_Voltage_V"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
								
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("FLTMUX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePowerLineFrequency("FLTMUX", Power_Line_Freq);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSense("FLTMUX", DM_CONST_LOCAL);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", Clamp_Current_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", Drive_Voltage_V);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("FLTMUX");
			CheckError(idx, ret, __LINE__);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
		
			//JL: run Vector file to initialize the test		
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			array<double> ^ Level = gcnew array<double>(16);
			int Htr_trim = 0;
			double diff = 0;
			double min_diff = 1000;
			int diff_num = 0;
			
			//idle mode, pg1_reg7[1]=0
			ret = WriteSPI(idx, 1, 7, 0x11);
			//mask all faults
			ret = WriteSPI(idx, 1, 10, 0xff);
			ret = WriteSPI(idx, 3, 11, 0xc0);
			//AMUX=29 (HeaterTestCurrentCal), pg1_reg15 bit7=0, bit6=DMUXAMUXN=0, bit5:0=MUX[5:0]=01_1101 ; pg3_reg13[6]=MUX[6]=0
			//Select Amux: FOS Fault Test Mode
			ret = WriteSPI(idx, 1, 15, 0x1d);
			ret = WriteSPI(idx, 3, 13, 0x00);
			//FuseTestSel, pg3_reg6[1:0] = 3
			ret = WriteSPI(idx, 3, 6, 0x03);
			//FuseTest, pg2_reg9[1] = 1, default bit0=1
			ret = WriteSPI(idx, 2, 9, 0x03);
			
			int reg_val=0;
			for(int dac=0; dac<16 ; dac++) //permute all values of FHTrml
			{			
				//FHTRML, pg3_reg1[3:0]
				ret = WriteSPI(idx, 3, 1, dac);

				ret = ReadReg(idx, 3, 1, reg_val);


				_util->Wait_Sec(100e-6);			
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, Level[dac]);		
				Level[dac] *= -1;

				//find the closest "dac" value where Level[dac] is closest to the target 10mA.
				diff = fabs(0.01 - Level[dac]);
				if(diff == min_diff && Level[dac] > Level[diff_num])
					diff_num = dac;
				if(diff < min_diff)
				{
					min_diff = diff;
					diff_num = dac; 
				}
			}
			Htr_trim = diff_num;
			
			tf_SetResult_UUTOffset(TPName[0], (int)(Htr_trim + GetOffset(idx, TPDispName[0])), idx);
			
			if(Htr_trim - 1 >= 0)
				tf_SetResult_UUTOffset(TPName[1], Level[Htr_trim-1] + GetOffset(idx, TPDispName[1]), idx);
			else
				tf_SetResult_UUTOffset(TPName[1], 0 + GetOffset(idx, TPDispName[1]), idx);
			
			tf_SetResult_UUTOffset(TPName[2], Level[Htr_trim] + GetOffset(idx, TPDispName[2]), idx);
			
			if(Htr_trim + 1 < 16)
				tf_SetResult_UUTOffset(TPName[3], Level[Htr_trim+1] + GetOffset(idx, TPDispName[3]), idx);
			else
				tf_SetResult_UUTOffset(TPName[3], 0 + GetOffset(idx, TPDispName[3]), idx);
			
			if(USE_SPI) {
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	//void TestProgram::drheat(Object^ object)	//heater_rng_ttr as example
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp				= (int)tf_TPCount();
	//		array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);	
	//		array<String ^> ^ Test_Pin = gcnew array<String ^>(HDSS);			
	//		array<double> ^ result		= gcnew array<double>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i]	= tf_TestParameter_DisplayName(i);
	//			TPName[i]		= tf_TestParameter_Name(i);
	//			result[i]		= 0;
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		bool isCurrentTPBypassed= false;
	//		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel				= _glob->SPD_Channel_Number;

	//		String ^ Test_Pin_0			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_0"));
	//		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
	//		
	//		//String ^ Test_Pin_1			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_1"));
	//		//double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));	//ML remove
	//		//double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));

	//		//String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
	//		String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
	//		String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
	//		String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
	//		
	//		String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";
	//		
	//		int vector_engine_status = 0;
	//		Stopwatch swatch;
	//		
	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

	//		/*****Initialize*****/
	//		for(int hsel=0; hsel<HDSS; hsel++)
	//			Test_Pin[hsel] = (String ^)(tf_TestItemCondition_Cast("Test_Pin_H" + hsel));

	//		//if(Debug_Enable == true)
	//			ret = heater_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Power Supply
	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);

	//		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Configure FLTMUX  -- change from test_pin_0 to test_pin
	//		ret = dm[idx]->Force(Test_Pin_0, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_0, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_0, Clamp_Vo_V, -2); 	//0 or -2?
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_0, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_0, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_0);
	//		CheckError(idx, ret, __LINE__);			

	//		double RhNom		= 100.0; //follow catalyst RH+RH1
	//		int reading_adc		= 0; 
	//		double diffpn_V		= 0;
	//		int loop			= 0;
	//		int param_index		= 0;
	//		int data			= 0;
	//		double val = 0;
	//		double result_vht_hd = 0;	//array<double> ^ result_vht_hd	= gcnew array<double>(5);
	//		double result_vht_mux = 0; 	//array<double> ^ result_vht_mux = gcnew array<double>(5);
	//		int result_adc = 0; 		//array<double> ^ result_adc	= gcnew array<double>(5);
	//		
	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);			

	//		/*****Start Test*****/
	//		for(int hsel=0; hsel<HDSS; hsel++)
	//		{
	//			//setting for hsel
	//			if(hsel==0)
	//			{
	//				param_index = 0;
	//				loop = (total_tp/2) + 1;;
	//			}		
	//			else 
	//			{
	//				param_index = (total_tp/2) + 1;
	//				loop = total_tp;
	//			}

	//			//set CBit & MUX
	//			ret = DriveCBit(idx, TPDispName[param_index]);
	//			CheckError(idx, ret, __LINE__);
	//			ret = DriveMuxIO(idx, TPDispName[param_index]);
	//			CheckError(idx, ret, __LINE__);

	//			//run vector for hsel
	//			Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
	//			//if(!USE_SPI)
	//			//{
	//				ret = RunVectorFile(idx, Vector_File_Init);	
	//				CheckError(idx, ret, __LINE__);
	//				ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
	//				CheckError(idx, ret, __LINE__);
	//			//}
	//			//else
	//			//{
	//			//	ret = OnOffSPI(idx, 1);
	//			//	CheckError(idx, ret, __LINE__);
	//			//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
	//			//	CheckError(idx, ret, __LINE__);
	//			//}

	//			//Measure FLTMUX pin
	//			ret = dm[idx]->PMUMeasure(Test_Pin_0, DM_CONST_MEASUREVOLTAGE, result_vht_mux);
	//			CheckError(idx, ret, __LINE__);

	//			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
	//			ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);
	//			CheckError(idx, ret, __LINE__);
	//			
	//			ret = smu[idx]->Measure("MTX_SMU", 1, result_vht_hd); 
	//			CheckError(idx, ret, __LINE__);			

	//			result_vht_hd = result_vht_hd - val;	//result_vht_hd[i] = result_vht_hd[i] - val;
	//			result_vht_mux = result_vht_mux;	//result_vht_mux[i] = result_vht_mux[i]*-1		
	//				
	//			// setup to get digital reading from adc	
	//			//if(!USE_SPI) 
	//			//{
	//				ret = RunVectorFile(idx, Vector_File_ADC);
	//				CheckError(idx, ret, __LINE__);
	//				ret = ReadVector(idx, Vector_File_ReadADC, result_adc);
	//				CheckError(idx, ret, __LINE__);
	//			//} 
	//			//else 
	//			//{
	//			//	ret = RunSPI(idx, Vector_File_ADC);
	//			//	CheckError(idx, ret, __LINE__);
	//			//	ret = ReadSPI(idx, Vector_File_ReadADC, result_adc);
	//			//	CheckError(idx, ret, __LINE__);
	//			//}	

	//			//result_adc = (double)reading_adc;		//result_adc[i] = (double)reading_adc;

	//			// Calculation 	
	//			double result_rpar = 0;
	//			result_rpar = (result_vht_mux - result_vht_hd) / 0.01;
	//			double result_drheat = 0;
	//			result_drheat = (0.505 * result_adc) + 50.6 - result_rpar;

	//			result[0+param_index] = result_vht_hd;
	//			result[1+param_index] = result_vht_mux;
	//			result[2+param_index] = result_rpar;
	//			result[3+param_index] = (result_drheat / RhNom - 1.0) ;

	//			if(hsel==0)//special case because number of hsel0 param != hsel1 param
	//				result[4+param_index] = RhNom;
	//		
	//			for (int i=param_index; i<loop; i++)
	//			{
	//				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

	//				if (isCurrentTPBypassed == false)
	//				{
	//					if (_util->IsInf(result[i]) == false)
	//						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//					else
	//						tf_SetResult_UUTOffset(TPName[i], INVALID_RESULT + GetOffset(idx, TPDispName[i]), idx);
	//				}			
	//			}				
	//		}
	//		
	//		if(USE_SPI) 
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		ret = dm[idx]->DrivePin("RWN", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);

	//		if(Debug_Enable == true)
	//		{
	//			ret = ResetDMPin(idx, TPDispName[0]);
	//			CheckError(idx, ret, __LINE__);

	//			//IO setting
	//			ret = ResetCBit(idx);
	//			CheckError(idx, ret, __LINE__);
	//			ret = ResetMuxIO(idx);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//	}

	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::drheat(Object^ object)	
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);	
			array<String ^> ^ Test_Pin = gcnew array<String ^>(HDSS);					
			array<double> ^ result		= gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;

			String ^ Test_Pin_0			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_0"));
			double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			
			//String ^ Test_Pin_1			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_1"));
			//double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));	//ML remove
			//double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));

			//String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
			String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
			String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
			String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			
			int vector_engine_status = 0;
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			/*****Initialize*****/
			for(int hsel=0; hsel<HDSS; hsel++) {
				Test_Pin[hsel] = (String ^)(tf_TestItemCondition_Cast("Test_Pin_H" + hsel));

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
					
			unsigned int moduleType  = 0;
			// Check whether resource is SMU or DM for all Test Pin
			// DVCI pin (FLTMUX)
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_0, moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType = DM_CONST_MODULE_TYPE;
			}

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_0, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_0, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_0, Clamp_Vo_V, -2);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_0, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_0, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_0);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_0, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_0, Clamp_Vo_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_0, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_0, false, false);
				CheckError(idx, ret, __LINE__);
			}
			
			// DICV pin (Heater)
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin[hsel], moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType = DM_CONST_MODULE_TYPE;
			}

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin[hsel], DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin[hsel], DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin[hsel], Clamp_Vo_V, -2); //
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin[hsel], 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin[hsel], NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin[hsel]);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin[hsel], NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin[hsel], Clamp_Vo_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin[hsel], 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin[hsel], false, false);
				CheckError(idx, ret, __LINE__);
			}
		 }			
			double RhNom		= 100.0; //follow catalyst RH+RH1
			int reading_adc		= 0; 
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			int data			= 0;
			double val = 0;
			double result_vht_hd = 0;	//array<double> ^ result_vht_hd	= gcnew array<double>(5);
			double result_vht_mux = 0; 	//array<double> ^ result_vht_mux = gcnew array<double>(5);
			int result_adc = 0; 		//array<double> ^ result_adc	= gcnew array<double>(5);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);			

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 1;;
				}		
				else 
				{
					param_index = (total_tp/2) + 1;
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
					
				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

				ret = Configure_GNDS_Mux(idx, NPLC);
				CheckError(idx, ret, __LINE__);
				
				unsigned int moduleType  = 0;
				// Measure FLTMUX pin
				//if (moduleType == DM_CONST_MODULE_TYPE) //dm
				//{
					ret = dm[idx]->PMUMeasure(Test_Pin_0, DM_CONST_MEASUREVOLTAGE, result_vht_mux);	//DM_CONST_MEASURECURRENT
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
					//ret = smu[idx]->ReadVoltage(Test_Pin_0,  result_vht_mux);	//result_vht_mux = result_vht_mux	//ReadCurrent
					//CheckError(idx, ret, __LINE__);
				//}

				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(idx, ret, __LINE__);
				
				// Measure Heater pin
				//if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Test_Pin[hsel], DM_CONST_MEASUREVOLTAGE, result_vht_hd);	//result_vht_hd = result_vht_hd
					CheckError(idx, ret, __LINE__);
				}
				//else
				//{
				//	ret = smu[idx]->ReadVoltage(Test_Pin[hsel],  result_vht_hd);
				//	CheckError(idx, ret, __LINE__);
				//}

				result_vht_hd = result_vht_hd - val;	//result_vht_hd[i] = result_vht_hd[i] - val;
				result_vht_mux = result_vht_mux;	//result_vht_mux[i] = result_vht_mux[i]*-1
			
				// setup to get digital reading from adc	
				//if(!USE_SPI) 
				//{
					ret = RunVectorFile(idx, Vector_File_ADC);
					CheckError(idx, ret, __LINE__);
					//ret = ReadVector(idx, Vector_File_ReadADC, result_adc);
					//CheckError(idx, ret, __LINE__);

					ret = OnOffSPI(idx, 1);
					ret = ReadReg(idx, 1, 11, result_adc);
					CheckError(idx, ret, __LINE__);
					ret = OnOffSPI(idx, 0);

				//} 
				//else 
				//{
				//	ret = RunSPI(idx, Vector_File_ADC);
				//	CheckError(idx, ret, __LINE__);
				//	ret = ReadSPI(idx, Vector_File_ReadADC, result_adc);
				//	CheckError(idx, ret, __LINE__);
				//}	
					
				//result_adc = (double)reading_adc;		//result_adc[i] = (double)reading_adc;

				// Calculation 	
				double result_rpar = 0;
				result_rpar = (result_vht_mux - result_vht_hd) / 0.01;
				double result_drheat = 0;
				result_drheat = (0.505 * result_adc) + 50.6 - result_rpar;

				result[0+param_index] = result_vht_hd;
				result[1+param_index] = result_vht_mux;
				result[2+param_index] = result_rpar;
				result[3+param_index] = (result_drheat / RhNom - 1.0) ;
				
				if(hsel==0)//special case because number of hsel0 param != hsel1 param				
					result[4+param_index] = RhNom;
			
				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						if (_util->IsInf(result[i]) == false)
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						else
							tf_SetResult_UUTOffset(TPName[i], INVALID_RESULT + GetOffset(idx, TPDispName[i]), idx);
					}			
				}				
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::testPass_trim(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
		
			int result = 0;
			int c = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);
			
			int vector_engine_status = 0;

			String ^ Vector_File = String::Empty;

			int data = 0;

			Stopwatch swatch;
		
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);m

			//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			if(USE_SPI) {
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
			}

			// 4 stage process
			for (int i = 0; i < 4; i++)
			{	
				if (i == 1)
				{
					// blow testpass/trimlock fuse			
					if ((_glob->GoodDIE[idx]) &&  !TIByPassed)
					{
						ret = blow_testlockfuse(idx);
						CheckError(idx, ret, __LINE__);
					}
					
				}		
				if (i != 2)
				{

					if(!USE_SPI) {
						ret = RunVectorFile(idx, "write_p2_reg63_extregsp_disable_l");
						CheckError(idx, ret, __LINE__);
						ret = ReadVector(idx, "read_p2_reg57", data);
						CheckError(idx, ret, __LINE__);
					} else {
						ret = RunSPI(idx, "write_p2_reg63_extregsp_disable_l");
						CheckError(idx, ret, __LINE__);
						ret = ReadSPI(idx, "read_p2_reg57", data);
						CheckError(idx, ret, __LINE__);
					}

					// read testpass fuse
					_glob->testpass[idx] = (data >> 0) & 0x1;
					tf_SetResult_UUTOffset(TPName[i], _glob->testpass[idx], idx); 
				
				}
				if (i == 2)
				{
					// 1. read lock bit
					if(!USE_SPI) {
						ret = RunVectorFile(idx, "write_trimlock_init");
						CheckError(idx, ret, __LINE__);
						ret = ReadVector(idx, "read_p2_reg48", data);
						CheckError(idx, ret, __LINE__);
					} else {
						ret = RunSPI(idx, "write_trimlock_init");
						CheckError(idx, ret, __LINE__);
						ret = ReadSPI(idx, "read_p2_reg48", data);
						CheckError(idx, ret, __LINE__);
					}

					_glob->trimlock[idx] = (data >> 7) & 0x1;
					tf_SetResult_UUTOffset(TPName[i], _glob->trimlock[idx], idx); 
				}
			}

			if(USE_SPI) {
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
		//	ret = smu[idx]->DriveVoltage("VCC", 0);
		//	CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	//reader
	void TestProgram::ir_sup3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Vector_File;
			String ^ Vector_File_1;

			String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	
			int vector_engine_status = 0;
			Stopwatch swatch;

			/*****Initialize*****/
			ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			//if(Debug_Enable == true)
			//{
				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			//}

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0], 1);//MUX to DiffAmp
			CheckError(idx, ret, __LINE__);	

			int hsel		= 0;
			double diffpn_V = 0;
			int data		= 0;
			int data1		= 0;
			array<int>^ HistoryRam = gcnew array<int>(256);	

			/*****Start Test*****/
			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
					Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(On_Delay_s);

				if (i == 0)   //2935 if (i == 0 || i == 8)
				{
					//if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);

						ret = ReadVector(idx, Vector_File_1, data);
						CheckError(idx, ret, __LINE__);

						//if (vector_engine_status == 0)
						//{
						//	ret = dm[idx]->ReadHistoryRam("DM_2", VectorLineCount[Vector_File_1], 0, VectorSetNo[Vector_File_1], HistoryRam);
						//	CheckError(idx, ret, __LINE__);

						//	ret = GetDataByteFromHistoryRam(Vector_File_1, HistoryRam, data, SPD_Channel);
						//	CheckError(idx, ret, __LINE__);

						//	result[i] = (data >> 7) & 0x1;
						//}
						//else
						//	result[i] = INVALID_RESULT;
					}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);

					//	ret = RunSPI(idx, Vector_File);
					//	CheckError(idx, ret, __LINE__);

					//	ret = ReadSPI(idx, Vector_File_1, data);
					//	CheckError(idx, ret, __LINE__);
					//}

					////IR
					//if (TPName[i]->Contains("dIMR") == true)
					//	result[i] = (data >> 7) & 0x1;
					////VR
					//else 
					//	result[i] = data & 0x3F;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == 1)
				{
						if (vector_engine_status == 0)
						{
							ret = dm[idx]->ReadHistoryRam("DM_2", VectorLineCount[Vector_File_1], 0, VectorSetNo[Vector_File_1], HistoryRam);
							CheckError(idx, ret, __LINE__);

							ret = GetDataByteFromHistoryRam(Vector_File_1, HistoryRam, data, SPD_Channel);
							CheckError(idx, ret, __LINE__);

							result[i] = (data >> 7) & 0x1;
						}
						else
							result[i] = INVALID_RESULT;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == 2)		//change sequence due to calling diff registers
				{
					//ret = RunVectorFile(idx, Vector_File);
					//CheckError(idx, ret, __LINE__);

					ret = ReadVector(idx, Vector_File_1, data1);
					CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
						{
							ret = dm[idx]->ReadHistoryRam("DM_2", VectorLineCount[Vector_File_1], 0, VectorSetNo[Vector_File_1], HistoryRam);
							CheckError(idx, ret, __LINE__);

							ret = GetDataByteFromHistoryRam(Vector_File_1, HistoryRam, data1, SPD_Channel);
							CheckError(idx, ret, __LINE__);

							result[i] = data1 & 0x40; //data of bit6 =1
						}
						else
							result[i] = INVALID_RESULT;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == 7)	 //2935 else if (i == 7 || i == 13)
				{
					double min	= 0;
					double max	= 0;
					int start	= 0;
					int end		= 0;

					//IR
					if (TPName[i]->Contains("dIMR") == true)
					{
						start = 3; // start from the 4th until 7th parameter only
						end = 6;
					}
					//VR
					//else 
					//{
					//	start = 9; // start from the 10th until 13th parameter only
					//	end = 13;
					//}
						
					for(int k=start; k<end; k++) 
					{
						if(k == start)
						{
							min = max = result[k]; 
						}
						else
						{
							if(result[k] > max)
								max = result[k];

							if(result[k] < min)
								min = result[k];
						}		
					}

					result[i] = max - min;
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}

				else
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						
						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

					//IR
					if (TPName[i]->Contains("dIMR") == true)
						result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]) / CONST_Rr1;
					//VR
					else
						result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::ir_hds4_ttr(Object^ object)
		{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;
		
			int ret = 0;

		try 
		{			
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ resultp = gcnew array<double>(total_tp);
			array<double> ^ resultpn = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				resultp[i] = 0;
				resultpn[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			array<int>^ HistoryRam = gcnew array<int>(256);
			int vector_engine_status = 0;
			int data = 0;
			Stopwatch swatch;

			/*****Initialize*****/
			//if(Debug_Enable == true)
			//{
				ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);
				
				/*ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);*/
			//}

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);

			//run default reg
			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
			}

			double diffp_V	= 0;
			double diffpn_V = 0;
			double volt		= 0;
			int irz_worst	= 0;
			int loop		= 0;
			int param_index = 0;
			String ^ Vector_File;
			array<String ^> ^ Vector_File_Zin;
			array<double> ^ result_irz; 

		/*****Start Test*****/
		for(int hsel=0; hsel<HDSS; hsel++)
		{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index],1);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

				//param loop
				for (int i=param_index; i<loop; i++)
				{
					if (TPName[i]->Contains("Ibias") == true)
					{
						int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));
						result[i] = resultp[Result_Index + param_index] - (resultpn[Result_Index + param_index])/2;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
				
					//common mode - VR
					else if (TPName[i]->Contains("Vbias") == true)
					{
						int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));
						result[i] = resultp[Result_Index + param_index] - (resultpn[Result_Index + param_index])/2;

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
				
				//Zin_K - IR
					else if (TPName[i]->Contains("Zin_K") == true)
					{
						int READERINPUTZ = (int)(tf_TPCondition_Cast(TPName[i], "READERINPUTZ"));
						Vector_File_Zin = gcnew array<String ^>(READERINPUTZ); 
						result_irz = gcnew array<double>(READERINPUTZ);

						double h0_lim_max = (double)(tf_TPHighLimit_Cast(TPName[i-1])); //Acquire previous test's high limit
						double h0_lim_min = (double)(tf_TPLowLimit_Cast(TPName[i-1])); //Acquire previous test's low limit
						double h0_lim_mid = (h0_lim_max + h0_lim_min) / 2;

						for (int k=0; k<READERINPUTZ; k++)
						{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_" + k));

						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else 
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
						CheckError(idx, ret, __LINE__);

						//polarity
						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
							diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
						else 
							diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

						result_irz[k] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]) / CONST_Rr1;
					}

					for(int k=1; k<READERINPUTZ; k++) 
						{
						if(Math::Abs(result_irz[k]-h0_lim_mid) > Math::Abs(result_irz[irz_worst]-h0_lim_mid))
							irz_worst = k;
						}
					
					result[i] = irz_worst; //display the worst index

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
					
				else if (TPName[i]->Contains("Zin") == true)
				{
					result[i] = result_irz[irz_worst];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				
				//steps K
				else
				{
					if(TPName[i]->Contains("dIMR") == true)
					{	
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
						}
							if(!USE_SPI)
							{
								ret = RunVectorFile(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
							else
							{
								ret = RunSPI(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}

							//only do for first step & last step
							if((TPName[i]->Contains("K15") == true) || (TPName[i]->Contains("K76") == true))		//2935 if((TPName[i]->Contains("K12") == true) || (TPName[i]->Contains("K21") == true))
							{
								//connect N to GNDS 
								ret = ResetMuxIO(idx);
								CheckError(idx, ret, __LINE__);
								ret = DriveMuxIO(idx, TPDispName[param_index], 2);
								CheckError(idx, ret, __LINE__);

								_util->Wait_Sec(Measure_Delay_s);

								ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
								CheckError(idx, ret, __LINE__);

								//polarity
								if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
									diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
								else 
									diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;

								resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];

								//connect PN to diffAmp
								ret = ResetMuxIO(idx);
								CheckError(idx, ret, __LINE__);
								ret = DriveMuxIO(idx, TPDispName[param_index], 1);
								CheckError(idx, ret, __LINE__);
							}

							_util->Wait_Sec(Measure_Delay_s);

							ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
							CheckError(idx, ret, __LINE__);
							
							//polarity
							if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
								diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
							else 
								diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

							resultpn[i] = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];
							result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]) / CONST_Rr1;					
							
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

							int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
							_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}

					//VR
					else
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
						}

						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}

						//only do for first step & last step
						if((TPName[i]->Contains("K0") == true) || (TPName[i]->Contains("K252") == true))	 //2935 K63
						{
							//connect N to GNDS
							ret = ResetMuxIO(idx);
							CheckError(idx, ret, __LINE__);
							ret = DriveMuxIO(idx, TPDispName[param_index],2);
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(On_Delay_s);

							ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
							CheckError(idx, ret, __LINE__);

							//polarity
							if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
								diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
							else 
								diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;

							//connect PN to diffAmp
							ret = ResetMuxIO(idx);
							CheckError(idx, ret, __LINE__);
							ret = DriveMuxIO(idx, TPDispName[param_index],1);
							CheckError(idx, ret, __LINE__);
						}

						_util->Wait_Sec(On_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
						CheckError(idx, ret, __LINE__);

						//polarity
						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
							diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
						else 
							diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
				
						result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);
						resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
						resultpn[i] = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
		
						int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}
				}	
			}
		}				
				
		/*****Power down*****/
		if(USE_SPI)
		{
			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);
		}

		//Power down supplies
		//ret = smu[idx]->DriveVoltage("VEE", 0);
		//CheckError(idx, ret, __LINE__);
		ret = smu[idx]->DriveVoltage("VCC", 0);
		CheckError(idx, ret, __LINE__);

		if(Debug_Enable == true)
			{
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}	
	//void TestProgram::mrhv3_ttr(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		/*****Get test name from techFlow*****/
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
	//		array<double> ^ result = gcnew array<double>(total_tp);
	//		array<double> ^ resultp = gcnew array<double>(total_tp);
	//		array<double> ^ resultpn = gcnew array<double>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//			result[i] = 0;
	//			resultp[i] = 0;
	//			resultpn[i] = 0;
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		/*****Get test condition from techFlow*****/
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

	//		int vector_engine_status = 0;
	//		Stopwatch swatch;

	//		/*****Initialize*****/
	//		//if(Debug_Enable == true)
	//		//{
	//		//	ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

	//		//	/*ret = DriveDMPin(idx, TPDispName[0]);
	//		//	CheckError(idx, ret, __LINE__);*/
	//		//}

	//		ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);	//ML - don't mask, else fail readings

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		//CheckError(idx, ret, __LINE__);

	//		//Configure Power Supply
	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);

	//		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampVoltage("MTX_SMU", 1);
	//		CheckError(idx, ret, __LINE__);
	//	
	//		double diffp_V = 0;
	//		double diffpn_V = 0;//differential
	//		int loop		= 0;
	//		int param_index	= 0;
	//		String ^ Vector_File;
	//		
	//		/*****Start Test*****/
	//		for(int hsel=0; hsel<HDSS; hsel++)
	//		{
	//			//setting for hsel
	//			if(hsel==0)
	//			{
	//				param_index = 0;
	//				loop = (total_tp/2);
	//			}		
	//			else 
	//			{
	//				param_index = (total_tp/2);
	//				loop = total_tp;
	//			}

	//			//set CBit & MUX
	//			ret = DriveCBit(idx, TPDispName[param_index]);
	//			CheckError(idx, ret, __LINE__);
	//			ret = DriveMuxIO(idx, TPDispName[param_index]);
	//			CheckError(idx, ret, __LINE__);
	//			ret = Configure_GNDS_Mux(idx, NPLC);
	//			CheckError(idx, ret, __LINE__);

	//			//run vector for hsel
	//			Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
	//			//Must use vector method due to special vectors
	//			ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
	//			CheckError(idx, ret, __LINE__);
	//			
	//			//param loop
	//			for (int i=param_index; i<loop; i++)
	//			{
	//				if (TPName[i]->Contains("VMR") == true)
	//				{
	//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//					{
	//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	//						ret = RunVectorFile(idx, Vector_File);
	//						CheckError(idx, ret, __LINE__);							

	//						//connect N to GNDS
	//						ret = ResetMuxIO(idx);
	//						CheckError(idx, ret, __LINE__);
	//						ret = DriveMuxIO(idx, TPDispName[param_index],0);
	//						CheckError(idx, ret, __LINE__);

	//						_util->Wait_Sec(On_Delay_s);

	//						ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
	//						CheckError(idx, ret, __LINE__);

	//						//connect PN to diffAmp
	//						ret = ResetMuxIO(idx);
	//						CheckError(idx, ret, __LINE__);
	//						ret = DriveMuxIO(idx, TPDispName[param_index],1);
	//						CheckError(idx, ret, __LINE__);

	//						_util->Wait_Sec(On_Delay_s);

	//						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//						CheckError(idx, ret, __LINE__);

	//						//polarity
	//						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
	//						{
	//							diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
	//							diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
	//						}
	//						else 
	//						{
	//							diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;
	//							diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
	//						}

	//						result[i] = diffp_V - (Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]))/2;
	//						resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];

	//						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

	//					}
	//					else
	//					{
	//						int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

	//						result[i] = resultp[Result_Index + param_index] - (resultpn[Result_Index + param_index])/2;		

	//						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//					}
	//				}

	//				else if (TPName[i]->Contains("IMR") == true)
	//				{
	//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//					{
	//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	//					
	//						ret = RunVectorFile(idx, Vector_File);
	//						CheckError(idx, ret, __LINE__);
	//					}

	//					//connect N to GNDS
	//					ret = ResetMuxIO(idx);
	//					CheckError(idx, ret, __LINE__);
	//					ret = DriveMuxIO(idx, TPDispName[param_index],0);
	//					CheckError(idx, ret, __LINE__);

	//					_util->Wait_Sec(On_Delay_s);

	//					ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
	//					CheckError(idx, ret, __LINE__);
	//		
	//					//connect PN to diffAmp
	//					ret = ResetMuxIO(idx);
	//					CheckError(idx, ret, __LINE__);
	//					ret = DriveMuxIO(idx, TPDispName[param_index],1);
	//					CheckError(idx, ret, __LINE__);

	//					_util->Wait_Sec(On_Delay_s);

	//					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//					CheckError(idx, ret, __LINE__);
	//					
	//					//polarity
	//					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
	//					{
	//						diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
	//						diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
	//					}
	//					else 
	//					{
	//						diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;
	//						diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
	//					}

	//					result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]) / CONST_Rr1;
	//					resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
	//					resultpn[i] = diffpn_V;

	//					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//				}
	//			}
	//		}

	//		/*****Power down*****/
	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		if(Debug_Enable == true)
	//		{
	//			ret = ResetDMPin(idx, TPDispName[0]);
	//			CheckError(idx, ret, __LINE__);

	//			//IO setting
	//			ret = ResetCBit(idx);
	//			CheckError(idx, ret, __LINE__);
	//			ret = ResetMuxIO(idx);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//	}

	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}		
	//}
	void TestProgram::mrhv3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ resultp = gcnew array<double>(total_tp);
			array<double> ^ resultpn = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				resultp[i] = 0;
				resultpn[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;

			/*****Initialize*****/
			//if(Debug_Enable == true)
			//{
			    ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			//}

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			//ret = DriveDIOPin(TPDispName[0]);
			//CheckError(ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 1);
			CheckError(idx, ret, __LINE__);
		
			double diffp_V = 0;
			double diffpn_V = 0;//differential
			int loop		= 0;
			int param_index	= 0;
			String ^ Vector_File;
			
			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = Configure_GNDS_Mux(idx, NPLC);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//Must use vector method due to special vectors
				ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
				CheckError(idx, ret, __LINE__);
				
				//param loop
				for (int i=param_index; i<loop; i++)
				{
					if (TPName[i]->Contains("VMR") == true)
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);							

							//connect N to GNDS
							ret = ResetMuxIO(idx);
							CheckError(idx, ret, __LINE__);
							ret = DriveMuxIO(idx, TPDispName[param_index],0);
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(On_Delay_s);

							ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
							CheckError(idx, ret, __LINE__);

							//connect PN to diffAmp
							ret = ResetMuxIO(idx);
							CheckError(idx, ret, __LINE__);
							ret = DriveMuxIO(idx, TPDispName[param_index],1);
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(On_Delay_s);

							ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
							CheckError(idx, ret, __LINE__);

							//polarity
							if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
							{
								diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
								diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
							}
							else 
							{
								diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;
								diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
							}

							result[i] = diffp_V - (Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]))/2;
							resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];

							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

						}
						else
						{
							int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

							result[i] = resultp[Result_Index + param_index] - (resultpn[Result_Index + param_index])/2;		

							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						}
					}

					else if (TPName[i]->Contains("IMR") == true)
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
						
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}

						//connect N to GNDS
						ret = ResetMuxIO(idx);
						CheckError(idx, ret, __LINE__);
						ret = DriveMuxIO(idx, TPDispName[param_index],0);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
						CheckError(idx, ret, __LINE__);
			
						//connect PN to diffAmp
						ret = ResetMuxIO(idx);
						CheckError(idx, ret, __LINE__);
						ret = DriveMuxIO(idx, TPDispName[param_index],1);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(On_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
						CheckError(idx, ret, __LINE__);
						
						//polarity
						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						{
							diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
							diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
						}
						else 
						{
							diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;
							diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
						}

						result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]) / CONST_Rr1;
						resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
						resultpn[i] = diffpn_V;

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
				}
			}

			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	//void TestProgram::mrhv3_ttr(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		/*****Get test name from techFlow*****/
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
	//		array<double> ^ result = gcnew array<double>(total_tp);
	//		array<double> ^ resultp = gcnew array<double>(total_tp);
	//		array<double> ^ resultpn = gcnew array<double>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//			result[i] = 0;
	//			resultp[i] = 0;
	//			resultpn[i] = 0;
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		/*****Get test condition from techFlow*****/
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		String ^ Test_Pin_PN = "GRP2_DIFF_SENSE";

	//		int vector_engine_status = 0;
	//		Stopwatch swatch;

	//		/*****Initialize*****/
	//		if(Debug_Enable == true)
	//		{
	//			ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

	//			/*ret = DriveDMPin(idx, TPDispName[0]);
	//			CheckError(idx, ret, __LINE__);*/
	//		}

	//		//Configure Power Supply
	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);

	//		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampVoltage("MTX_SMU", 1);
	//		CheckError(idx, ret, __LINE__);
	//	
	//		double diffp_V = 0;
	//		double diffpn_V = 0;//differential
	//		int loop		= 0;
	//		int param_index	= 0;
	//		String ^ Vector_File;
	//		
	//		/*****Start Test*****/
	//		for(int hsel=0; hsel<HDSS; hsel++)
	//		{
	//			//setting for hsel
	//			if(hsel==0)
	//			{
	//				param_index = 0;
	//				loop = (total_tp/2);
	//			}		
	//			else 
	//			{
	//				param_index = (total_tp/2);
	//				loop = total_tp;
	//			}

	//			//set CBit & MUX
	//			ret = DriveCBit(idx, TPDispName[param_index]);
	//			CheckError(idx, ret, __LINE__);
	//			ret = DriveMuxIO(idx, TPDispName[param_index]);
	//			CheckError(idx, ret, __LINE__);
	//			ret = Configure_GNDS_Mux(idx, NPLC);
	//			CheckError(idx, ret, __LINE__);

	//			//run vector for hsel
	//			Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
	//			//Must use vector method due to special vectors
	//			ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
	//			CheckError(idx, ret, __LINE__);
	//			
	//			//param loop
	//			for (int i=param_index; i<loop; i++)
	//			{
	//				if (TPName[i]->Contains("VMR") == true)
	//				{
	//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//					{
	//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	//						ret = RunVectorFile(idx, Vector_File);
	//						CheckError(idx, ret, __LINE__);							

	//						//connect N to GNDS
	//						ret = ResetMuxIO(idx);
	//						CheckError(idx, ret, __LINE__);
	//						ret = DriveMuxIO(idx, TPDispName[param_index],0);
	//						CheckError(idx, ret, __LINE__);

	//						_util->Wait_Sec(On_Delay_s);

	//						ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
	//						CheckError(idx, ret, __LINE__);

	//						//connect PN to diffAmp
	//						ret = ResetMuxIO(idx);
	//						CheckError(idx, ret, __LINE__);
	//						ret = DriveMuxIO(idx, TPDispName[param_index],1);
	//						CheckError(idx, ret, __LINE__);

	//						_util->Wait_Sec(On_Delay_s);

	//						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//						CheckError(idx, ret, __LINE__);

	//						//polarity
	//						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
	//						{
	//							diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
	//							diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
	//						}
	//						else 
	//						{
	//							diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;
	//							diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
	//						}

	//						result[i] = diffp_V - (Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]))/2;
	//						resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];

	//						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

	//					}
	//					else
	//					{
	//						int Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Result_Index"));

	//						result[i] = resultp[Result_Index + param_index] - (resultpn[Result_Index + param_index])/2;		

	//						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//					}
	//				}

	//				else if (TPName[i]->Contains("IMR") == true)
	//				{
	//					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//					{
	//						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	//					
	//						ret = RunVectorFile(idx, Vector_File);
	//						CheckError(idx, ret, __LINE__);
	//					}

	//					//connect N to GNDS
	//					ret = ResetMuxIO(idx);
	//					CheckError(idx, ret, __LINE__);
	//					ret = DriveMuxIO(idx, TPDispName[param_index],0);
	//					CheckError(idx, ret, __LINE__);

	//					_util->Wait_Sec(On_Delay_s);

	//					ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
	//					CheckError(idx, ret, __LINE__);
	//		
	//					//connect PN to diffAmp
	//					ret = ResetMuxIO(idx);
	//					CheckError(idx, ret, __LINE__);
	//					ret = DriveMuxIO(idx, TPDispName[param_index],1);
	//					CheckError(idx, ret, __LINE__);

	//					_util->Wait_Sec(On_Delay_s);

	//					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//					CheckError(idx, ret, __LINE__);
	//					
	//					//polarity
	//					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
	//					{
	//						diffp_V = _glob->PolRD_DUT[hsel, idx]*diffp_V;
	//						diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
	//					}
	//					else 
	//					{
	//						diffp_V = _glob->PolRD_PROBE[hsel, idx]*diffp_V;
	//						diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;
	//					}

	//					result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]) / CONST_Rr1;
	//					resultp[i] = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
	//					resultpn[i] = diffpn_V;

	//					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//				}
	//			}
	//		}

	//		/*****Power down*****/
	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		if(Debug_Enable == true)
	//		{
	//			ret = ResetDMPin(idx, TPDispName[0]);
	//			CheckError(idx, ret, __LINE__);

	//			//IO setting
	//			ret = ResetCBit(idx);
	//			CheckError(idx, ret, __LINE__);
	//			ret = ResetMuxIO(idx);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//	}

	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}		
	//}
	void TestProgram::reader_cpp(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			////Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleTypeP = 0;
			unsigned int moduleTypeN = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_P, moduleTypeP);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeP = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_N, moduleTypeN);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeN = DM_CONST_MODULE_TYPE;
			}

			// Configure P
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_P);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_N);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			////init
			//if(!USE_SPI) 
			//{
			//	ret = RunVectorFile(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}			
			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

	//added by ML
			double diffp_V_imr = 0;
			double diffn_V_imr = 0;
			double imr = 0;

			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
			ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V_imr);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V_imr);
			CheckError(idx, ret, __LINE__);
			}
			else
			{
			ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V_imr);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V_imr);
			CheckError(idx, ret, __LINE__);
			}
					
			imr = Math::Abs(diffp_V_imr - diffn_V_imr) / CONST_Rr1;
					
	//

			for (int i=0; i<total_tp; i++)	//total_tp
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				}

				_util->Wait_Sec(On_Delay_s);

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						//if(!USE_SPI) 
						//{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						//}
						//else 
						//{
						//	ret = OnOffSPI(idx, 1);
						//	CheckError(idx, ret, __LINE__);
						//	ret = RunSPI(idx, Vector_File);
						//	CheckError(idx, ret, __LINE__);
						//}			
					}
					_util->Wait_Sec(Measure_Delay_s);

					double diffp_V = 0;
					double diffn_V = 0;

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
						CheckError(idx, ret, __LINE__);
					}
					
					result[i] = (Math::Abs(diffp_V - diffn_V) / CONST_Rr1) / imr;	

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::autocal(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<int> ^ result = gcnew array<int>(total_tp);
			
			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed	= false; 
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Vector_File_Wr	= String::Empty;
			String ^ Vector_File_Rd	= String::Empty;
			String ^ Vector_File_Rd2	= String::Empty;
			int Mask_Bit = 0;
			int Shift_Bit = 0;
			int Global_Result_Index = 0;		//for rbhv test

			String ^ Vector_File_Rd_1	= String::Empty;
			int Mask_Bit_1 = 0;
			int Shift_Bit_1 = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			///////////////////////////////////
			int reg_val, reg_val2, data;
			for (int i=0; i<total_tp; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
				if (isCurrentTPBypassed == false)
				{
					Vector_File_Wr = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_Wr");
					Vector_File_Rd = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_Rd");
					
					//Vector_File_Rd2 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_Rd2");
					//Mask_Bit = (int)tf_TPCondition_Cast(TPName[i], "Mask_Bit");
					//Shift_Bit = (int)tf_TPCondition_Cast(TPName[i], "Shift_Bit");

					//if(!USE_SPI) 
					//{
						ret = RunVectorFile(idx, Vector_File_Wr);
						CheckError(idx, ret, __LINE__);

						ret = ReadVector(idx, Vector_File_Rd, reg_val);
						CheckError(idx, ret, __LINE__);

					//} 
					//else 
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx, Vector_File_Wr);
					//	CheckError(idx, ret, __LINE__);
					//}

					//_util->Wait_Sec(Measure_Delay_s);

					///*int data = 0;

					//if(!USE_SPI) 
					//{
					//	ret = ReadVector(idx, Vector_File_Rd, data);
					//	CheckError(idx, ret, __LINE__);
					//}
					//else 
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = ReadSPI(idx, Vector_File_Rd, data);
					//	CheckError(idx, ret, __LINE__);
					//}

					//OnOffSPI(idx, 1);
					if (TPName[i]->Contains("Reset") == true)
					{
						_util->Wait_Sec(1e-6);
						////p2_reg13[5:3]=0 MRRNG
						OnOffSPI(idx, 1);
						ReadReg(idx, 2,13,reg_val);
						//ret = ReadVector(idx, Vector_File_Rd, data);	
						////ret = ReadSPI(idx, Vector_File_Rd, data);	
						//result[i] = (reg_val & 0x7) >> 4;	//result[i] = data & 0x38;
						result[i] = ((reg_val & 0x38) >> 3) & 0xF;
					}
					if (TPName[i]->Contains("Success") == true)		//working & pass
					{
						ReadReg(idx, 1,15,reg_val);
						//verify Calibrationcmd=1 (bit7)
						reg_val = (reg_val & 0x80) >> 7;
						ReadReg(idx, 2,13,reg_val2);
						//verify CalibrationSuccess=0 (bit6)
						reg_val2 = (reg_val2 & 0x40) >> 6;

						if(reg_val == 0 && reg_val2 == 1)
							result[i] = 1;
						else
							result[i] = 0;

					}
					if (TPName[i]->Contains("AutoCalResult") == true)
					{
					//ReadReg(1,15,reg_val);
					////verify Calibrationcmd=1 (bit7)
					//reg_val = (reg_val & 0x80) >> 7;
					//ReadReg(2,13,reg_val2);
					////verify CalibrationSuccess=0 (bit6)
					//reg_val2 = (reg_val & 0x40) >> 6;

					//if(reg_val == 0 && reg_val2 == 1)
					//	result[i] = 1;
					//else
					//	result[i] = 0;

                    //p2_reg13[5:3]=0 MRRNG
                    ReadReg(idx, 2,13,reg_val);
                    result[i] = (reg_val & 0x38) >> 3;		//result[i] = reg_val & 0x38;
					//need to write p3_reg8 with 0x6 before read p3_reg5
					
					WriteSPI(idx, 3, 8, 0x06);
                    ReadReg(idx, 3,5,reg_val2);		//added for rbhv test
                    reg_val2 = (reg_val2 & 0xf0) >> 4;
					}

                    if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
                    {
                          int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
                          _glob->Global_Result[idx, Global_Result_Index] = (double)reg_val2;
                    }

					OnOffSPI(idx, 0);
					tf_SetResult_UUTOffset(TPName[i], result[i] + (int)GetOffset(idx, TPDispName[i]), idx);
				}
			}
			
			///////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::reader_vos_spd(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleTypeP = 0;
			unsigned int moduleTypeN = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_P, moduleTypeP);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeP = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_N, moduleTypeN);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeN = DM_CONST_MODULE_TYPE;
			}

			// Configure P
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_P);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_P, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_N);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_N, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			if(!USE_SPI) 
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			double diffp_V = 0;
			double diffn_V = 0;

			for (int i=0; i<total_tp; i++)
			{
				//ret = DriveDMPin(idx, TPDispName[i]);

				if (TPName[i]->Contains("Wt"))
				{
					ret = DriveDMPin(idx, TPDispName[35]);
				}
			
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					if(!USE_SPI) {
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					} else {
					ret = RunSPI(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					}
				}

				//_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm	//ML to check further, 2935 use DriveCBIT
				{
					//ret = OnOffCbit(idx, 39, 1); //for RDP
					//_util->Wait_Sec(Measure_Delay_s);
					//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					//ret = OnOffCbit(idx, 39, 0); //for RDP

					//ret = OnOffCbit(idx, 40, 1); //for RDN
					//_util->Wait_Sec(Measure_Delay_s);
					//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					//ret = OnOffCbit(idx, 40, 0); //for RDN

					ret = DriveCBit(idx, TPDispName[0], 1); //for RDP
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 0); //for RDP
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 2); //for RDN
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 0); //for RDN
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					//ret = OnOffCbit(idx, 39, 1); //for RDP
					//_util->Wait_Sec(Measure_Delay_s);
					//ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
					//ret = OnOffCbit(idx, 39, 0); //for RDP

					//ret = OnOffCbit(idx, 40, 1); //for RDN
					//_util->Wait_Sec(Measure_Delay_s);
					//ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
					//ret = OnOffCbit(idx, 40, 0); //for RDN

					ret = DriveCBit(idx, TPDispName[0], 1); //for RDP
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 0); //for RDP
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 2); //for RDN
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);
					ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 0); //for RDN
					CheckError(idx, ret, __LINE__);
				}
				
				result[i] = diffn_V - diffp_V;  //diffp_V - diffn_V;  //ML pls check 2945 need to get -ve - +ve

				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::reader_vocm(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ resultp = gcnew array<double>(total_tp);
			array<double> ^ resultn = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				resultp[i] = 0;
				resultn[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			int Drive_RWn			= 1;		//2935 is 0

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleTypeP = 0;
			unsigned int moduleTypeN = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_P, moduleTypeP);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeP = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_N, moduleTypeN);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeN = DM_CONST_MODULE_TYPE;
			}

			// Configure P
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_P);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_P, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_N);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_N, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}

			//init
			if(!USE_SPI) 
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			ret = Configure_GNDS_Mux(idx, NPLC);
			CheckError(idx, ret, __LINE__);

			double diffp_V = 0;
			double diffn_V = 0;

			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}
				}

				if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
				{
					Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
				}else{
					Measure_Delay_s = 0;
				}
				
				if (tf_TPCondition_exist(TPName[i], "Drive_RWn") == true)
				{
					Drive_RWn = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWn"));

					ret = dm[idx]->DrivePin("RWN", Drive_RWn);
				}

				//_util->Wait_Sec(Measure_Delay_s);

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = DriveCBit(idx, TPDispName[0], 1); //for RDP
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(idx, ret, __LINE__);

					//ret = DriveCBit(idx, TPDispName[0], 0); //for RDP
					//CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 2); //for RDN
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(idx, ret, __LINE__);

					//ret = DriveCBit(idx, TPDispName[0], 0); //for RDN
					//if (ret < 0 ) return ret;
				}
				else
				{
					ret = DriveCBit(idx, TPDispName[0], 1); //for RDP
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(idx, ret, __LINE__);

					//ret = DriveCBit(idx, TPDispName[0], 0); //for RDP
					//CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 2); //for RDN
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);
					ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(idx, ret, __LINE__);

					//ret = DriveCBit(idx, TPDispName[0], 0); //for RDN
					//CheckError(idx, ret, __LINE__);
				}
			
				double volt = 0;
				//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
				CheckError(idx, ret, __LINE__);				

				diffp_V = diffp_V - volt;
				diffn_V = diffn_V - volt;
				
				resultp[i] = diffp_V;
				resultn[i] = diffn_V;

				if (i == 0 || i == 1)
				{	
					//vocm_rd = (active_rd_p + active_rd_n)/2;
					//vocm_wr = (active_wr_p + active_wr_n)/2;
					result[i] = (resultp[i] + resultn[i]) / 2;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == 2)
				{
					//dvocm = vocm_rd - vocm_wr;
					result[i] = result[0] - result[1];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == 3)
				{
					//dvocm_ts = vocm_rd - ((sleep_rd_p + sleep_rd_n)/2);
					result[i] = result[0] - ((resultp[i] + resultn[i]) / 2);

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == 4)
				{
					tf_SetResult_UUTOffset(TPName[i], resultp[i] + GetOffset(idx, TPDispName[i]), idx);
					tf_SetResult_UUTOffset(TPName[i + 1], resultn[i] + GetOffset(idx, TPDispName[i]), idx);

					break;
				}
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::rout(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
			String ^ Meas_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Meas_Pin_P"));
			String ^ Meas_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Meas_Pin_N"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//ret = DriveMuxIO(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->DrivePin("GND_MUX_RST_N", 0); //reset SPI MUX as we need MTX_SMU2 for this test (no need GNDS)
			CheckError(idx, ret, __LINE__);

			unsigned int moduleTypeP = 0;
			unsigned int moduleTypeN = 0;
			unsigned int moduleType_MeasureP = 0;
			unsigned int moduleType_MeasureN = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_P, moduleTypeP);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeP = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_N, moduleTypeN);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeN = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Meas_Pin_P, moduleType_MeasureP);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureP = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Meas_Pin_N, moduleType_MeasureN);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType_MeasureN = DM_CONST_MODULE_TYPE;
			}

			int differential_measure = 0;
			if (Meas_Pin_P->Contains("DIFF_SENSE"))
			{
				differential_measure = 1;
			}

			// Configure P
			if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_P);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_P, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_P, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
			}

			// Configure N
			if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_N);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_N, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_N, true, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
			}

			int retest_count = 0;
RETEST:
			if (moduleType_MeasureP != moduleTypeP)
			{
				if (moduleType_MeasureP == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Meas_Pin_P, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Meas_Pin_P, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Meas_Pin_P, 6, -1 * Math::Abs(Clamp_Vo_V));
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Meas_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Meas_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Meas_Pin_P);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Meas_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Meas_Pin_P, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Meas_Pin_P, Math::Abs(Clamp_Vo_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Meas_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Meas_Pin_P, true, false);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
				}
			}

			if (differential_measure == 0)
			{
				if (moduleType_MeasureN != moduleTypeN)
				{
					if (moduleType_MeasureN == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->Force(Meas_Pin_N, DM_CONST_FORCE_STATE_PMU);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUOutputFunction(Meas_Pin_N, DM_CONST_DICV);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUVoltageLimit(Meas_Pin_N, 6, -1 * Math::Abs(Clamp_Vo_V));
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUCurrentLevel(Meas_Pin_N, 0);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->ConfigurePMUSamplingTime(Meas_Pin_N, NPLC, DM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DPINOn(Meas_Pin_N);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(On_Delay_s);
						ret = dm[idx]->ConfigurePMUCurrentLevel(Meas_Pin_N, 0);
						CheckError(idx, ret, __LINE__);
					}
					else //smu
					{
						ret = smu[idx]->ConfigureSamplingTime(Meas_Pin_N, NPLC, AM_CONST_PLC);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ClampVoltage(Meas_Pin_N, Math::Abs(Clamp_Vo_V));
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->DriveCurrent(Meas_Pin_N, 0);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->OnSmuPin(Meas_Pin_N, true, false);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(On_Delay_s);
						ret = smu[idx]->DriveCurrent(Meas_Pin_N, 0);
						CheckError(idx, ret, __LINE__);
					}
				}
			}

			////init
			//if(!USE_SPI) 
			//{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//}
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			{
				//SE voltage wrt GNDS
				double diffp_V1 = 0; //RDP @ -500uA 
				double diffn_V1 = 0; //RDN @ -500uA
				double diffp_V2 = 0; //RDP @ +500uA
				double diffn_V2 = 0; //RDN @ +500uA

				//diff voltage between RDP wrt RDN
				double diffpn_V1 = 0; //@ -500uA
				double diffpn_V2 = 0; //@ +500uA

				//Imbalance current due to external 100-ohm resistor btw RDP and RDN
				double ip1 = 0; // real current into RDP (test current @ -500uA)
				double in1 = 0; // real current into RDN (test current @ -500uA)
				double ip2 = 0; // real current out from RDP (test current @ +500uA)
				double in2 = 0; // real current out from RDP (test current @ +500uA)

				//////////////////////////////////////////////////
				//Drive -I
				//////////////////////////////////////////////////

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, -1 * Drive_Io_A);
				else
					ret = smu[idx]->DriveCurrent(Test_Pin_P, -1 * Drive_Io_A);
				CheckError(idx, ret, __LINE__);

				if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, -1 * Drive_Io_A);
				else
					ret = smu[idx]->DriveCurrent(Test_Pin_N, -1 * Drive_Io_A);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable)
				{	
					double curr = 0;
					double volt = 0;

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
					{
						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASURECURRENT, curr);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, volt);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ReadCurrent(Test_Pin_P, curr);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ReadVoltage(Test_Pin_P, volt);
						CheckError(idx, ret, __LINE__);
					}

					if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
					{
						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASURECURRENT, curr);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, volt);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ReadCurrent(Test_Pin_N, curr); 
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ReadVoltage(Test_Pin_N, volt);
						CheckError(idx, ret, __LINE__);
					}
				}

				if (differential_measure == 1)
				{
					//meas Hi wrt Lo
		
					ret = DriveMuxIO(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V1);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_P, diffpn_V1);
					CheckError(idx, ret, __LINE__);

					diffpn_V1 = diffpn_V1 / 3; // There is a x3 gain at the SE-to-DIFF converter

					diffpn_V1 = -1 * diffpn_V1;

					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);

					//meas Lo wrt GNDS
					
					ret = DriveMuxIO(idx, TPDispName[0], 1);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffn_V1);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_P, diffn_V1);
					CheckError(idx, ret, __LINE__);

					diffn_V1 = diffn_V1 / 3; // There is a x3 gain at the SE-to-DIFF converter

					diffp_V1 = diffn_V1 + diffpn_V1;

					ip1 = -Drive_Io_A - diffpn_V1 / 100;
					in1 = -Drive_Io_A + diffpn_V1 / 100;
					
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					_util->Wait_Sec(Measure_Delay_s);

					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V1);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_P, diffp_V1);
					CheckError(idx, ret, __LINE__);
					
					if (moduleType_MeasureN == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V1);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_N, diffn_V1);
					CheckError(idx, ret, __LINE__);
				}
				
				//////////////////////////////////////////////////
				//Drive +I
				//////////////////////////////////////////////////

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
				else
					ret = smu[idx]->DriveCurrent(Test_Pin_P, Drive_Io_A);
				CheckError(idx, ret, __LINE__);

				if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
				else
					ret = smu[idx]->DriveCurrent(Test_Pin_N, Drive_Io_A);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable)
				{	
					double curr = 0;
					double volt = 0;

					if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
					{
						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASURECURRENT, curr);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, volt);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ReadCurrent(Test_Pin_P, curr);
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ReadVoltage(Test_Pin_P, volt);
						CheckError(idx, ret, __LINE__);
					}

					if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
					{
						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASURECURRENT, curr);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, volt);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ReadCurrent(Test_Pin_N, curr); 
						CheckError(idx, ret, __LINE__);
						ret = smu[idx]->ReadVoltage(Test_Pin_N, volt);
						CheckError(idx, ret, __LINE__);
					}
				}

				if (differential_measure == 1)
				{
					//meas Hi wrt Lo

					ret = DriveMuxIO(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffpn_V2);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_P, diffpn_V2);
					CheckError(idx, ret, __LINE__);

					diffpn_V2 = diffpn_V2 / 3; // There is a x3 gain at the SE-to-DIFF converter

					diffpn_V2 = -1 * diffpn_V2;

					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);

					//meas Lo wrt GNDS

					ret = DriveMuxIO(idx, TPDispName[0], 1);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffn_V2);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_P, diffn_V2);
					CheckError(idx, ret, __LINE__);

					diffn_V2 = diffn_V2 / 3; // There is a x3 gain at the SE-to-DIFF converter

					diffp_V2 = diffn_V2 + diffpn_V2;
					
					ip2 = Drive_Io_A - diffpn_V2 / 100;
					in2 = Drive_Io_A + diffpn_V2 / 100;

					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					_util->Wait_Sec(Measure_Delay_s);

					if (moduleType_MeasureP == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V2);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_P, diffp_V2);
					CheckError(idx, ret, __LINE__);
					
					if (moduleType_MeasureN == DM_CONST_MODULE_TYPE)
						ret = dm[idx]->PMUMeasure(Meas_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V2);
					else
						ret = smu[idx]->ReadVoltage(Meas_Pin_N, diffn_V2);
					CheckError(idx, ret, __LINE__);
				}

				//////////////////////////////////////////////////
				//Drive 0
				//////////////////////////////////////////////////

				if (moduleTypeP == DM_CONST_MODULE_TYPE) //dm 
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				else
					ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);

				if (moduleTypeN == DM_CONST_MODULE_TYPE) //dm 
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				else
					ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);

				double routp = (diffp_V2 - diffp_V1) / (Math::Abs(ip1 - ip2));
				double routn = (diffn_V2 - diffn_V1) / (Math::Abs(in1 - in2));

					
				double max_limit = (double)(tf_TPHighLimit_Cast(TPName[0]));
				double min_limit = (double)(tf_TPLowLimit_Cast(TPName[0]));
			
 
					if ((routp < min_limit) || (routp > max_limit) ||(routn < min_limit) || (routn > max_limit) )
					{
						if (retest_count < TIMING_RESET_COUNT) 
						{
							retest_count++;
							goto RETEST;
						}

						/*_util->SampleRes("rout", "diffp_V2");
						_util->SampleRes("rout", diffp_V2);
						_util->SampleRes("rout", "diffp_V1");
						_util->SampleRes("rout", diffp_V1);
						_util->SampleRes("rout", "\n");*/


					}

				tf_SetResult_UUTOffset(TPName[0], routp + GetOffset(idx, TPDispName[0]), idx);

				tf_SetResult_UUTOffset(TPName[1], routn + GetOffset(idx, TPDispName[1]), idx);
			}

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DrivePin("GND_MUX_RST_N", 1);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	//Gain
	void TestProgram::gain_sup3(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{	
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double DAC				= (double)(tf_TestItemCondition_Cast("DAC"));
			double Vswg				= 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			//if (DAC >= 0 && DAC <=5)
			//{
			//	Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
			//}
			//else if (DAC >= 6 && DAC <=15)
			//{
			//	Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;
			//}
			//else
			//{
			//	Vswg = 5 * CONST_Rdr_Av_div * 1e-3;
			//}

			//ML - 2945 reader_seq.tl
			if (DAC >= 0 && DAC <=5)
			{
				Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
			}
			else if (DAC >= 6 && DAC <=12)
			{
				Vswg = 5 * CONST_Rdr_Av_div * 1e-3;
			}

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][idx];

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			//Write DEFAULT registers 

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 4096; //512; //1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

			double vout_pp = 0.0;

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;
		
			//Calibration of Vpp

			int max_loop = 50;
			
			if (Vswg_calibrated_gainsup->ContainsKey(idx.ToString() + "_" + DAC.ToString()) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

				double Vswg_cal = 0;
				int loop_count = 0;

				//On K3, K4
				ret = DriveCBit(idx, TPDispName[0], 1);
				CheckError(idx, ret, __LINE__);

				Vswg_cal = Vswg;

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				//ret = SWG_Configure(idx, Vswg_cal, Fswg, 0);
				//CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__);
						
						do_once = 1;
					}

					ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

					if (ret)
					{
						int FFTStop      = 0x2;

						if (sourcePattern == 1)
							ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
						else
							ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
							CheckError(idx,  ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						goto test_end;
					}

					if (Math::Abs(Vswg - vout_pp) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;

							int FFTStop      = 0x2;

							if (sourcePattern == 1)
								ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
							else
								ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
								CheckError(idx, ret, __LINE__);

							/*ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);*/
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							
							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
					int FFTStop      = 0x2;

					if (sourcePattern == 1)
						ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
					else
						ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
						CheckError(idx, ret, __LINE__);
					
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
					
					//Off K3, K4
					ret = DriveCBit(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
							
				int FFTStop      = 0x2;

				if (sourcePattern == 1)
					ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
				else
					ret = digitizer[idx]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
					CheckError(idx, ret, __LINE__);
				
				ret = acm[idx]->StopFG("ACM_CH"); 
				CheckError(idx, ret, __LINE__);
					
				//Off K3, K4 
				ret = DriveCBit(idx, TPDispName[0], 0);
				CheckError(idx, ret, __LINE__);

				Vswg_calibrated_gainsup->Add(idx.ToString() + "_" + DAC.ToString(), Vswg_cal);
				Vswg_at_dut_gainsup->Add(idx.ToString() + "_" + DAC.ToString(), vout_pp);

			}
			else
			{

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated_gainsup[idx.ToString() + "_" + DAC.ToString()]/2, -1 * Vswg_calibrated_gainsup[idx.ToString() + "_" + DAC.ToString()]/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				//ret = SWG_Configure(idx, Vswg_calibrated_gainsup[idx.ToString() + "_" + DAC.ToString()], Fswg, 0);
				//CheckError(idx, ret, __LINE__);

				ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
				CheckError(idx, ret, __LINE__);
		
			}

			//Test
			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);

			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			double Gmax = 0;
			double Gmin = 0;
			double vin = Vswg_at_dut_gainsup[idx.ToString() + "_" + DAC.ToString()];
			double vin_r1 = vin / CONST_Rdr_Av_div;

			for (int i=0; i<total_tp; i++)
			{
				if (i == 0)
				{
					tf_SetResult_UUTOffset(TPName[i], DAC + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (i == total_tp-1)
				{
					tf_SetResult_UUTOffset(TPName[i], Gmax - Gmin + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
	
					if (ret)
					{
						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						goto test_end;
					}

					result = 20 * Math::Log10(vout_pp / vin_r1);

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);

					if (i == 1)
					{
						Gmax = result;
						Gmin = result;
					}
					else
					{
						if (result > Gmax)
							Gmax = result;
			
						if (result < Gmin)
							Gmin = result;
					}
				}
			}	

			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			
	test_end:
		
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::gain_hds2(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed = false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			int DAC					= 0;
			double Vswg				= 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][idx];

			//double result = 0;

			int Global_Result_Index = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
//USE_SPI = 0;
			if(!USE_SPI)
			//if(1)
			{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}else{	
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 4096;//4096; //1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

		

			double dataTemp = 0;
			//complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
			//array<double> ^ magn = gcnew array<double>(nbrSamples);
			
			double vout_pp = 0.0;
			double fftBIN = 0;
			int magn_peak_index = 0;
			int max_loop = 50;

			//Test
			double vin_r1 = 0;

			array<double> ^ result = gcnew array<double>(total_tp);
			array<int> ^ dac = gcnew array<int>(total_tp);

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			for (int i=0; i<total_tp; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

				if (isCurrentTPBypassed == false)
				{
					if (TPName[i]->StartsWith("Av_DAC_Mono"))
					{
						double slope = 0;
						double offset = 0;

						//_util->line_fit(dac, result, total_tp-1, slope, offset);
						_util->line_fit(dac, result, 13, slope, offset);
						
						double mono = 0;
						double mono_step = _util->monotonicity(result, 13, 0, mono);
						mono /= slope;

						result[i] = mono;

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
					else
					{
						DAC = (int)(tf_TPCondition_Cast(TPName[i], "DAC"));
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

						dac[i] = DAC;

						//if (DAC >= 0 && DAC <=5)
						//{
						//	Vswg = 10 * CONST_Rdr_Av_div * 1e-3;
						//	fullScale = 2.0;
						//}
						//else if (DAC >= 6 && DAC <=15)
						//{
						//	Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;
						//	fullScale = 2.0;
						//}
						//else
						//{
						//	Vswg = 5 * CONST_Rdr_Av_div * 1e-3; 
						//	fullScale = 2.0;
						//}

						//2945
						if (DAC >= 0 && DAC <=5)
						{
							Vswg =  10 * CONST_Rdr_Av_div * 1e-3; //2935 10
							//fullScale = 2.0;  //comment out in 40A
						}
						else if (DAC >= 6 && DAC <=12)
						{
							Vswg = 5 * CONST_Rdr_Av_div * 1e-3; //2935 8.77415
							//fullScale = 2.0;	//comment out in 40A
						}

						///////////////////////////////
						//Program device (HSEL, IBIAS, GAIN)
						if(!USE_SPI)
						//if(1)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}else{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}

				#pragma region "Calibration of Vpp"

						if (Vswg_calibrated_gainhds->ContainsKey(idx.ToString() + "_" + DAC.ToString()) == false)
						{
								
							array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
							
							double Vswg_cal = 0;
							int loop_count = 0;

							//On K3, K4
							ret = DriveCBit(idx, TPDispName[0], 1);
							CheckError(idx, ret, __LINE__);

							Vswg_cal = Vswg;

							ret = acm[idx]->ResetChannel("ACM_CH");
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(1e-3);
							ret = acm[idx]->RunFG("ACM_CH", 0, true);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);

							int do_once = 0;
							while(loop_count <= max_loop)
							{
								if (do_once == 0)
								{
									ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
									do_once = 1;
								}

								ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

								if (ret)
								{
									ret = digitizer[idx]->StopAcquire("DIGITIZER");
									CheckError(idx, ret, __LINE__);

									ret = acm[idx]->StopFG("ACM_CH"); 
									CheckError(idx, ret, __LINE__);

									for (int i=0; i<total_tp; i++)
									{
										tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
									}

									goto test_end;
								}
		
								if (Math::Abs(Vswg - vout_pp) < 4e-3)
								{
									break;
								}
								else
								{
									Vswg_cal = Vswg_cal + (Vswg - vout_pp);

									ret = acm[idx]->StopFG("ACM_CH"); 
									CheckError(idx, ret, __LINE__);
									ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
									if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
									{
										CheckError(idx, ret, __LINE__);	
									}

									if (ret != 0)
									{
										ret = 0;

										ret = digitizer[idx]->StopAcquire("DIGITIZER");
										CheckError(idx, ret, __LINE__);
										ret = acm[idx]->StopFG("ACM_CH"); 
										CheckError(idx, ret, __LINE__);
										
										//Off K3, K4 
										ret = DriveCBit(idx, TPDispName[0], 0);
										CheckError(idx, ret, __LINE__);

										for (int i=0; i<total_tp; i++)
										{
											tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
										}

										goto test_end;
									}

									ret = acm[idx]->RunFG("ACM_CH", 0, true);
									CheckError(idx, ret, __LINE__);
									_util->Wait_Sec(Measure_Delay_s);
								}
					
								loop_count++;
							}

							if (loop_count > max_loop)
							{
								ret = digitizer[idx]->StopAcquire("DIGITIZER");
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->StopFG("ACM_CH"); 
								CheckError(idx, ret, __LINE__);
								
								//Off K3, K4 
								ret = DriveCBit(idx, TPDispName[0], 0);
								CheckError(idx, ret, __LINE__);

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
								}

								goto test_end;
							}
										
							ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							
							//Off K3, K4 
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							Vswg_calibrated_gainhds->Add(idx.ToString() + "_" + DAC.ToString(), Vswg_cal);
							Vswg_at_dut_gainhds->Add(idx.ToString() + "_" + DAC.ToString(), vout_pp);
						}
						else
						{
							if (i == 0)
							{
								ret = acm[idx]->ResetChannel("ACM_CH");
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
								CheckError(idx, ret, __LINE__);

								ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
								CheckError(idx, ret, __LINE__);
							}
						}

						#pragma endregion "Calibration of Vpp"

						//On K1, K2
						ret = DriveCBit(idx, TPDispName[0], 2);
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated_gainhds[idx.ToString() + "_" + DAC.ToString()]/2, -1 * Vswg_calibrated_gainhds[idx.ToString() + "_" + DAC.ToString()]/2, Fswg, 0);
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						
						_util->Wait_Sec(Measure_Delay_s);

						ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
						CheckError(idx, ret, __LINE__);

						vin_r1 = Vswg_at_dut_gainhds[idx.ToString() + "_" + DAC.ToString()] / CONST_Rdr_Av_div;

						result[i] = 20 * Math::Log10(vout_pp / vin_r1);

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);		

						if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
						{
							Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

							_glob->Global_Result[idx, Global_Result_Index] = result[i];
						}
					}
				}
			}	

			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			
	test_end:

			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		

	}

	void TestProgram::gain_hds_zdin2(Object^ object)
	{
		
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			int DAC					= 0;
			double Vswg				= 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			int Total_Zdin			= (int)(tf_TestItemCondition_Cast("Total_Zdin"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double  diff2se_digitizer_factor;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_ZDIN"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_ZDIN"][idx];
				
			int Global_Result_Index = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			//Write DEFAULT registers 
			
			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}else{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			
			}

			USE_SPI = 0;
			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 1024; //4096; //512; //1024; //must be 2^n
			int nbrSegments = 2;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;
	
			double dataTemp = 0;
				
			double vout_pp = 0.0;
			double fftBIN = 0;
			int magn_peak_index = 0;
			int max_loop = 50;

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			//Test
			array<double> ^ result		= gcnew array<double>(total_tp);

			array<double> ^ icc			= gcnew array<double>(2);
			array<double> ^ av_div_rin	= gcnew array<double>(Total_Zdin);
			array<double> ^ gain		= gcnew array<double>(Total_Zdin);
			array<double> ^ rdzin_r		= gcnew array<double>(Total_Zdin);
			array<double> ^ vout_meas	= gcnew array<double>(Total_Zdin);
			array<int> ^ rdzin_k		= gcnew array<int>(Total_Zdin);

			double rdzin = 0;
			double rdz_vin = 0;
			double r1_divider = 0;

			int k = 0;
			double current = 0;

			for (int i=0; i<total_tp; i++)
			{
				if (TPDispName[i]->StartsWith("Zdin^Func"))
				{
					double slope = 0;
					double offset = 0;

					_util->line_fit(rdzin_k, vout_meas, k, slope, offset);
					double mono = 0;
					double mono_step = _util->monotonicity(vout_meas, k, 0, mono);
					mono /= slope;

					if (mono > 0.10) 
						result[i] = 1;
					else
						result[i] = 0;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (TPDispName[i]->Contains("Delta")) //minus
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}else{
					ret = RunSPI(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				
				}

				ret = smu[idx]->ReadCurrent("VCC", current);
					CheckError(idx, ret, __LINE__);

					icc[1] = current;

					result[i] = icc[1] - icc[0];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (TPDispName[i]->Contains("-")) //minus
				{
					String ^ Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
					String ^ Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));
					String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));

					int A = 0;
					int B = 0;

					A = _util->StrToInt(Global_Result_Index_A);
					B = _util->StrToInt(Global_Result_Index_B);

					if (Operation == "A-B")
						result[i] = _glob->Global_Result[idx, A] - _glob->Global_Result[idx, B];
					else
						result[i] = _glob->Global_Result[idx, B] - _glob->Global_Result[idx, A];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (TPDispName[i]->Contains("ForceFastRec"))
				{
					String ^ Global_Result_Index_A = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_A"));
					String ^ Global_Result_Index_B = (String ^)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_B"));
					String ^ Operation = (String ^)(tf_TPCondition_Cast(TPName[i], "Operation"));
					double Threshold = (double)(tf_TPCondition_Cast(TPName[i], "Threshold")); 

					int A = 0;
					int B = 0;

					A = _util->StrToInt(Global_Result_Index_A);
					B = _util->StrToInt(Global_Result_Index_B);

					if (Operation == "A-B")
					{
						if (_glob->Global_Result[idx, A] - _glob->Global_Result[idx, B] > Threshold)
							result[i] = 1;
						else
							result[i] = 0;
					}
					else
					{
						if (_glob->Global_Result[idx, B] - _glob->Global_Result[idx, A] > Threshold)
							result[i] = 1;
						else
							result[i] = 0;
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else  //else if (! (i%2))
				{
					DAC = 12;  //2935 is 8
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					Vswg = 5 * CONST_Rdr_Av_div * 1e-3;					//Vswg = 8.77415 * CONST_Rdr_Av_div * 1e-3;		//ML change

					switch(k)
					{
						case 0:  rdzin=30.0;	break; 
						case 1:  rdzin=50.0;	break;
						case 2:  rdzin=70.0;	break;
						case 3:  rdzin=100.0;	break;

						//case 0:  rdzin=30.0;	break; //catalyst program use this but incorrect
						//case 1:  rdzin=55.0;	break;
						//case 2:  rdzin=75.0;	break;
						//case 3:  rdzin=100.0;	break;
						default:  rdzin=70.0;  break;
					}

					r1_divider = CONST_R1 * ((CONST_Rr1 - CONST_R1 + rdzin) / (CONST_Rr1 + rdzin));
					av_div_rin[k] = ((2 * CONST_R4) + r1_divider) / r1_divider;
					rdzin_k[k] = k;

					///////////////////////////////
					//Program device (HSEL, IBIAS, GAIN)

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}else{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}

					#pragma region "Calibration of Vpp"
					if (Vswg_calibrated->ContainsKey(idx.ToString() + "_" + DAC.ToString()) == false)
					{
						array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
						double Vswg_cal = 0;
						int loop_count = 0;

						//On K3, K4
						ret = DriveCBit(idx, TPDispName[0], 1);
						CheckError(idx, ret, __LINE__);

						Vswg_cal = Vswg;

						ret = acm[idx]->ResetChannel("ACM_CH");
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(1e-3);
						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);

						int do_once = 0;
						while(loop_count <= max_loop)
						{
							if (do_once == 0)
							{
								ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
								CheckError(idx, ret, __LINE__);
								do_once = 1;
							}

							ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

							if (ret)
							{
								ret = digitizer[idx]->StopAcquire("DIGITIZER");
								CheckError(idx, ret, __LINE__);

								ret = acm[idx]->StopFG("ACM_CH"); 
								CheckError(idx, ret, __LINE__);

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
								}

								goto test_end;
							}

							if (Math::Abs(Vswg - vout_pp) < 4e-3)
							{
								break;
							}
							else
							{
								Vswg_cal = Vswg_cal + (Vswg - vout_pp);

								ret = acm[idx]->StopFG("ACM_CH"); 
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
								if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
								{
									CheckError(idx, ret, __LINE__);	
								}

								if (ret != 0)
								{
									ret = 0;

									ret = digitizer[idx]->StopAcquire("DIGITIZER");
									CheckError(idx, ret, __LINE__);
									ret = acm[idx]->StopFG("ACM_CH"); 
									CheckError(idx, ret, __LINE__);

									//Off K3, K4 
									ret = DriveCBit(idx, TPDispName[0], 0);
									CheckError(idx, ret, __LINE__);

									for (int i=0; i<total_tp; i++)
									{
										tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
									}

									goto test_end;
								}

								ret = acm[idx]->RunFG("ACM_CH", 0, true);
								CheckError(idx, ret, __LINE__);
								_util->Wait_Sec(Measure_Delay_s);
							}
				
							loop_count++;
						}

						if (loop_count > max_loop)
						{
							ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							
							//Off K3, K4 
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}
									
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						//Off K3, K4 
						ret = DriveCBit(idx, TPDispName[0], 0);
						CheckError(idx, ret, __LINE__);

						Vswg_calibrated->Add(idx.ToString() + "_" + DAC.ToString(), Vswg_cal);
						Vswg_at_dut->Add(idx.ToString() + "_" + DAC.ToString(), vout_pp);
					}
					else
					{
						if (i == 0)
						{
							ret = acm[idx]->ResetChannel("ACM_CH");
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[idx.ToString() + "_" + DAC.ToString()]/2, -1 * Vswg_calibrated[idx.ToString() + "_" + DAC.ToString()]/2, Fswg, 0);
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
							CheckError(idx, ret, __LINE__);

							ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
							CheckError(idx, ret, __LINE__);
						}
					}
					#pragma endregion "Calibration of Vpp"

					//On K1, K2
					ret = DriveCBit(idx, TPDispName[0], 2);
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_calibrated[idx.ToString() + "_" + DAC.ToString()]/2, -1 * Vswg_calibrated[idx.ToString() + "_" + DAC.ToString()]/2, Fswg, 0);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);
//diff2se_digitizer_factor
					ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

					if (ret)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						goto test_end;
					}

					vout_meas[k] = vout_pp;

					rdz_vin = (Vswg_at_dut[idx.ToString() + "_" + DAC.ToString()]/CONST_Rdr_Av_div) * (av_div_rin[k] / CONST_Rdr_Av_div); 

					gain[k] = (vout_pp / rdz_vin) / 6.3096; //20log(6.3096)=16dB for gain dac=8
					
					rdzin_r[k] = (1985.0-(gain[k] * CONST_Rr1))/gain[k];

					ret = smu[idx]->ReadCurrent("VCC", current);
					CheckError(idx, ret, __LINE__);

					icc[0] = current;

					result[i] = vout_pp;
					//result[i+1] = rdzin_r[k];	 //not in 2945

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);	
					//tf_SetResult_UUTOffset(TPName[i+1], result[i+1] + GetOffset(idx, TPDispName[i+1]), idx);	  //not in 2945

					k++;
				}

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index"))
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

					_glob->Global_Result[idx, Global_Result_Index] = result[i];
				}
			}	

			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			
	test_end:
			
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);

			//USE_SPI = 1;
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	
	}

	void TestProgram::gain_hds_vir_vor2(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			int Global_Result_Index_av_odr = (int)(tf_TestItemCondition_Cast("Global_Result_Index_av_odr"));
			int Global_Result_Index_av_idr = (int)(tf_TestItemCondition_Cast("Global_Result_Index_av_idr"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			Stopwatch swatch;

			///////////////////////////////////////////////////////////////////////////////////////////
			//Pre-requisite is gain_hds_hr0 test
			///////////////////////////////////////////////////////////////////////////////////////////

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//Write DEFAULT registers 
			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
			}
			double Vswg_cal = 0;
			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 8192;//4096; //1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

			

			double dataTemp = 0;
			//complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
			//array<double> ^ magn = gcnew array<double>(nbrSamples);
			double vout_pp = 0.0;
			double fftBIN = 0;
			int magn_peak_index = 0;
			int max_loop = 50;

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;


			//Test
			array<double> ^ result		= gcnew array<double>(total_tp);

			//added by sidi for last param
			double vin  = 10 * CONST_Rdr_Av_div * 1e-3;  
			double vin_trim = vin / CONST_Rdr_Av_div;
			double vout_trim = 0;
			double ACM_adjustment_factor_at_50MHz = 1;

			double idr_l = 50e-3; //20mVpp, 50mVpp for 2945
			double odr_l = 400e-3; //400mVpp		//ML to confirm   // sidi change from 800e-3 to 400e-3
			double vin_idr = (idr_l * 1.5) * CONST_Rdr_Av_div;   
			double vout_odr = odr_l * 1.5;  

			double vin_odr_highest = 0.0;
			double vin_odr = 0;
			double vin_odr_i = 0;

			double compute_av_odr = 0;
			double compute_av_idr = 0;
			
			double vout_idr = 0;
			double vin_idr_meas = 0;
			double vout_odr_meas = 0;

			double dac_odr = 8;
			
		

#pragma region "Calibration of Vpp"
			
				if (Vswg_calibrated_gainhds_virvor->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
				{
					array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

					double Vswg_cal = 0;
					int loop_count = 0;
					double Vswg = vin_idr; 

					//On K3, K4
					ret = DriveCBit(idx, TPDispName[0], 1);
					CheckError(idx, ret, __LINE__);

					Vswg_cal = Vswg;

					ret = acm[idx]->ResetChannel("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(1e-3);
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);

					int do_once = 0;
					while(loop_count <= max_loop)
					{
						if (do_once == 0)
						{
							ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
							do_once = 1;
						}

						ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

						if (ret)
						{
							ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						if (Math::Abs(Vswg - vout_pp) < 4e-3)
						{
							break;
						}
						else
						{
							Vswg_cal = Vswg_cal + (Vswg - vout_pp);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
							{
								CheckError(idx, ret, __LINE__);	
							}

							if (ret != 0)
							{
								ret = 0;

								ret = digitizer[idx]->StopAcquire("DIGITIZER");
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->StopFG("ACM_CH"); 
								CheckError(idx, ret, __LINE__);
								
								//Off K3, K4 
								ret = DriveCBit(idx, TPDispName[0], 0);
								CheckError(idx, ret, __LINE__);

								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
								}

								goto test_end;
							}

							ret = acm[idx]->RunFG("ACM_CH", 0, true);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);
						}
			
						loop_count++;
					}

					if (loop_count > max_loop)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						//Off K3, K4 
						ret = DriveCBit(idx, TPDispName[0], 0);
						CheckError(idx, ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						goto test_end;
					}
								
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					//Off K3, K4 
					ret = DriveCBit(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					Vswg_calibrated_gainhds_virvor->Add(idx.ToString() + "_" + TIDispName ,Vswg_cal);
					
				}
	

		#pragma endregion "Calibration of Vpp"


				Vswg_cal = Vswg_calibrated_gainhds_virvor[idx.ToString() + "_" + TIDispName];
//Vswg_cal = vin_idr/2 ;
				ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
				CheckError(idx, ret, __LINE__);

				{
			
				// sidi added for mee ling to capture Vout trim 

				ret = DriveCBit(idx, TPDispName[0], 2); //On K1, K2
				CheckError(idx, ret, __LINE__);

				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, "write_hsel0_ibias_dac1");
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = RunSPI(idx, "write_hsel0_ibias_dac1");
					CheckError(idx, ret, __LINE__);
				}
				
				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}

				vout_trim = vout_pp*2; // single ended

				ret = acm[idx]->StopFG("ACM_CH");
				CheckError(idx, ret, __LINE__);

				//Off K1, K2 
				ret = DriveCBit(idx, TPDispName[0], 0);
				CheckError(idx, ret, __LINE__);

				// end capture Vout trim



				// Capture idr output
				
				ret = DriveCBit(idx, TPDispName[0], 2); //On K1, K2
				CheckError(idx, ret, __LINE__);

				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = RunSPI(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}
				
				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin_idr/2, -1 * vin_idr/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}

				vout_idr = vout_pp; 

				ret = acm[idx]->StopFG("ACM_CH");
				CheckError(idx, ret, __LINE__);

				//Off K1, K2 
				ret = DriveCBit(idx, TPDispName[0], 0);
				CheckError(idx, ret, __LINE__);

				///////////////////////
				// Capture idr output

				//On K3, K4
				ret = DriveCBit(idx, TPDispName[0], 1);
				CheckError(idx, ret, __LINE__);

				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				if (ret)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}

				vin_idr_meas = vout_pp;

				///////////////////////
				// Capture odr input

				vout_odr		= odr_l * 1.5;

				compute_av_odr	= Math::Pow(10, _glob->Global_Result[idx, Global_Result_Index_av_odr]/20);
				vin_odr			= (vout_odr / compute_av_odr * CONST_Rdr_Av_div);
				vin_odr_i		= vin_odr * 1000;
				vin_odr			= vin_odr_i / 1000.0;

				if (vin_odr > vin_odr_highest)   //  added for 2945
					vin_odr_highest = vin_odr * ACM_adjustment_factor_at_50MHz;  // added

				if (vin_odr_highest < 1.5)
				{
					ret = acm[idx]->StopFG("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", (vin_odr)/2, -1 * (vin_odr)/2, Fswg, 0);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);
				}


				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_1);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = RunSPI(idx, Vector_File_1);
					CheckError(idx, ret, __LINE__);
				}

				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}

				vin_odr = vout_pp; 

				///////////////////////
				// Capture odr input

				ret = acm[idx]->StopFG("ACM_CH");
				CheckError(idx, ret, __LINE__);

				//On K1, K2
				ret = DriveCBit(idx, TPDispName[0], 2);
				CheckError(idx, ret, __LINE__);

				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				
				_util->Wait_Sec(Measure_Delay_s);

				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);

				if (ret)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
				
				vout_odr_meas = vout_pp;		//ML to check with sidi ??? vout_odr_meas = vout_pp * 2 ;  

				compute_av_idr = Math::Pow(10, _glob->Global_Result[idx, Global_Result_Index_av_idr]/20);

				double idr_ref = compute_av_idr;
				double odr_ref = compute_av_odr;

				double idr = (vout_idr / (vin_idr_meas / CONST_Rdr_Av_div)) / idr_ref;
				double odr = (vout_odr_meas / (vin_odr / CONST_Rdr_Av_div)) / odr_ref;

				tf_SetResult_UUTOffset(TPName[0], idr * 100 + GetOffset(idx, TPDispName[0]), idx);

				if (idr < 0.9)
					tf_SetResult_UUTOffset(TPName[1], (double)(-1e-3) + GetOffset(idx, TPDispName[1]), idx);
				else if (idr > 1.1)
					tf_SetResult_UUTOffset(TPName[1], (double)(1e-3) + GetOffset(idx, TPDispName[1]), idx);
				else
					tf_SetResult_UUTOffset(TPName[1], (double)(vin_idr_meas / CONST_Rdr_Av_div) + GetOffset(idx, TPDispName[1]), idx);
	      
				tf_SetResult_UUTOffset(TPName[2], dac_odr + GetOffset(idx, TPDispName[2]), idx);

				tf_SetResult_UUTOffset(TPName[3], odr * 100 + GetOffset(idx, TPDispName[3]), idx);
				
				if (odr < 0.9)
					tf_SetResult_UUTOffset(TPName[4], (double)(-1e-3) + GetOffset(idx, TPDispName[4]), idx);
				else if (odr > 1.1)
					tf_SetResult_UUTOffset(TPName[4], (double)(1e-3) + GetOffset(idx, TPDispName[4]), idx);
				else
					tf_SetResult_UUTOffset(TPName[4], vout_odr_meas + GetOffset(idx, TPDispName[4]), idx);

				tf_SetResult_UUTOffset(TPName[5], 20*Math::Log10(vout_trim/vin_trim) + GetOffset(idx, TPDispName[5]), idx);
			}	

			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			
	test_end:
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}			

			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::fhsgain_sup2(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{		
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double Vswg				= 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			String ^ Vector_File_0	= String::Empty;
			String ^ Vector_File_1	= String::Empty;
			String ^ Vector_File_2  = String::Empty;

			Vswg = 1 * CONST_FSAv_div * 1e-3;		//2935 Vswg = 0.6 * 1 * CONST_FSAv_div * 1e-3;
			
			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_1M_1A_FHSGAIN_SUP"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_1M_1A_FHSGAIN_SUP"][idx];

			double result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]); 
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);
	
			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 4096;//1024; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager)
				//	delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 100;

			array<double> ^ dataArray_voutpp = gcnew array<double>(nbrSamples);
			//array<double> ^ dataArrayN;

			double dataTemp = 0;
			complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
			array<double> ^ magn = gcnew array<double>(nbrSamples);
			double vout_pp = 0.0;
			double vpp = 0.0;
			double fftBIN = 0;
			int magn_peak_index = 0;

			int max_loop = 50;

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);	//ML can be masked?
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			//Calibration of Vpp
			if (Vswg_fhsgain_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false)				
			{
				double Vswg_cal = 0;
				int loop_count = 0;

				//On K3, K4
				ret = DriveCBit(idx, TPDispName[0], 1);
				CheckError(idx, ret, __LINE__);

				Vswg_cal = Vswg;

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						//ret = DigitizerFFT_Configure(digitizer_setting);
						ret = Digitizer_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__);

						do_once = 1;
					}

					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
					//ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
					ret = Digitizer_CaptureVpp(idx, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp, dataArray_voutpp);

					if (ret)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						goto test_end;
					}

					if (Math::Abs(Vswg - vout_pp) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0)
						{
							ret = 0;

							ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							
							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					//off K3, K4
					ret = DriveCBit(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
							
				ret = digitizer[idx]->StopAcquire("DIGITIZER");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->StopFG("ACM_CH"); 
				CheckError(idx, ret, __LINE__);
				
				//off K3, K4
				ret = DriveCBit(idx, TPDispName[0], 0);
				CheckError(idx, ret, __LINE__);

				Vswg_fhsgain_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
				Vswg_fhsgain_at_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);				
			}
			else
			{
				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_fhsgain_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_fhsgain_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);

				ret = Digitizer_Configure(idx, _glob->digitizer_setting);
				CheckError(idx, ret, __LINE__);
			}

			//Test
			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);

			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			double Gmax = 0;
			double Gmin = 0;
			double vin = Vswg_fhsgain_at_dut[idx.ToString() + "_" + TIDispName];
			double vin_r1 = vin / CONST_FSAv_div;		//ML 2935 is double vin_r1 = vin * CONST_Rf;

			int step = 3;
			array<double> ^ res_sum = gcnew array<double>(step);
			for (int i=0; i<step; i++)
				res_sum[i] = 0;

			for (int i=0; i<total_tp; i++)
			{
				if (TPName[i]->Contains("Dev"))
				{
					//double G_vpv = Math::Pow(10, (Gmax-Gmin)/20);
					double G_vpv = Math::Pow(10, (Gmax)/20) - Math::Pow(10, (Gmin)/20);

					tf_SetResult_UUTOffset(TPName[i], G_vpv + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					int data = 0;
					ret = OnOffSPI(idx, 1);
					ret = ReadReg(idx, 2, 12, data);//expect 0
					ret = ReadReg(idx, 2, 2, data);//expect26(1a) //11010 for 52, with bit 0 at p2r12
					ret = ReadReg(idx, 2, 4, data);//expect 80(50), bit4 and bit6 set
					ret = ReadReg(idx, 1, 15, data);//expect 12 //mux
					ret = ReadReg(idx, 3, 13, data);//expect 0 //mux
					ret = ReadReg(idx, 1, 1, data);//expect 192
					ret = OnOffSPI(idx, 0);

					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp);
					//ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
					ret = Digitizer_CaptureVpp(idx, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp, dataArray_voutpp);
					Digitizer_GetVpp(0, _glob->digitizer_setting, diff2se_digitizer_factor, dataArray_voutpp, vpp);

					if (ret)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);

						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						goto test_end;
					}

					result = 20 * Math::Log10((2*vpp)/ vin_r1);

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);

					if (i == 0)
					{
						Gmax = result;
						Gmin = result;
					}
					else
					{
						if (result > Gmax)
							Gmax = result;
			
						if (result < Gmin)
							Gmin = result;
					}
				}
			}	

			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
		
test_end:
		
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
		
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::fhsgain_spd(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{		
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			//double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Vswg				= 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File1	= "";
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			int FHSGain_DAC_Count      = (int)(tf_TestItemCondition_Cast("FHSGain_DAC_Count"));
			int Global_Result_Index = 0;
			bool isCurrentTPBypassed = false;
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_1M_842A_FHSGAIN_SPD"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_1M_842A_FHSGAIN_SPD"][idx];

			double result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]); 
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 4096; //1024; //8192; //must be 2^n  //ML was 2048
			int nbrSegments = 1;
			int coupling = 3;//4;	//0 Ground (Averagers ONLY) //bk: change frm 3-> 4
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2;//1.0; //1V or 2V	//ML was 2.0
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager)
				//	delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);				
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 100;

			array<double> ^ dataArray_voutpp = gcnew array<double>(nbrSamples);
			//array<double> ^ dataArrayN;

			double dataTemp = 0;
			//complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
			//array<double> ^ magn = gcnew array<double>(nbrSamples);
			double vout_pp = 0.0;
			double vpp=0;
			double fftBIN = 0;
			int magn_peak_index = 0;

			int max_loop = 50;

			int Decimation_Factor = 1; //1GS/s
			if (Fswg < 10e6)
			{
				Decimation_Factor = 4; //250MS/s
			}

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			int cal_loop=0;
			for (cal_loop=0; cal_loop<3; cal_loop++)
			{	
				switch (cal_loop)
					{
						case 0:
							Vswg = 8 * CONST_FSAv_div * 1e-3;
							break;
						case 1:
							Vswg = 4 * CONST_FSAv_div * 1e-3;
							break;
						case 2:
							Vswg = 2 * CONST_FSAv_div * 1e-3;
							break;
					}
				
				if ((Vswg_fhsgain_spd_8_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") == false) || (Vswg_fhsgain_spd_4_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") == false) || (Vswg_fhsgain_spd_2_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") == false))	//bk: TIDispName
				//if ((Vswg_fhs gain_spd_8_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") == false) || (Vswg_fhsgain_spd_4_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") == false) || (Vswg_fhsgain_spd_2_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") == false))	//bk: TIDispName		
				{
					double Vswg_cal = 0;
					int loop_count = 0;

					//On K3, K4
					ret = DriveCBit(idx, TPDispName[0], 1);
					CheckError(idx, ret, __LINE__);

					Vswg_cal = Vswg;

					ret = acm[idx]->ResetChannel("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(1e-3);
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);

					int do_once = 0;
					while(loop_count <= max_loop)
					{
						if (do_once == 0)
						{
							//ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth); //bk
							//CheckError(idx, ret, __LINE__);	
							//ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
							ret = Digitizer_Configure(idx, _glob->digitizer_setting);
							CheckError(idx, ret, __LINE__);
							do_once = 1;
						}

						//ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.350, vout_pp);
						ret = Digitizer_CaptureVpp(idx, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp, dataArray_voutpp);
						//ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
						
						if (ret)
						{
							ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							if(TIDispName == "cal_fhsawgin")
							{
								tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
							}	
							else
							{
								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
								}
							}

							goto test_end;
						}

						if (Math::Abs(Vswg - vout_pp) < (2e-3))
						{
							break;
						}
						else
						{
							Vswg_cal = Vswg_cal + (Vswg - vout_pp);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
							{
								CheckError(idx, ret, __LINE__);	
							}

							if (ret != 0)
							{
								ret = 0;

								ret = digitizer[idx]->StopAcquire("DIGITIZER");
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->StopFG("ACM_CH"); 
								CheckError(idx, ret, __LINE__);
								
								//off K3, K4
								ret = DriveCBit(idx, TPDispName[0], 0);
								CheckError(idx, ret, __LINE__);

								if(TIDispName == "cal_fhsawgin")
								{
									tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
								}
								else
								{
									for (int i=0; i<total_tp; i++)
									{
										tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
									}
								}

								goto test_end;
							}

							ret = acm[idx]->RunFG("ACM_CH", 0, true);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);
						}
			
						loop_count++;
					}

					if (loop_count > max_loop)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						//off K3, K4
						ret = DriveCBit(idx, TPDispName[0], 0);
						CheckError(idx, ret, __LINE__);
						
						if(TIDispName == "cal_fhsawgin")
						{
							tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
						}		
						else
						{
							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}
						}

						goto test_end;
					}
								
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					//off K3, K4
					ret = DriveCBit(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					if (cal_loop==0)
					{
						Vswg_fhsgain_spd_8_calibrated->Add(idx.ToString() + "_" + "cal_fhsawgin", Vswg_cal);		//old syntax Vswg_fhsgain_spd_8_calibrated->Add(TIDispName, Vswg_cal);
						Vswg_fhsgain_spd_8_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);				//Vswg_fhsgain_spd_8_dut->Add(TIDispName, vout_pp);
					}
					if (cal_loop==1)
					{
						Vswg_fhsgain_spd_4_calibrated->Add(idx.ToString() + "_" + "cal_fhsawgin", Vswg_cal);
						Vswg_fhsgain_spd_4_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
					}
					if (cal_loop==2)
					{
						Vswg_fhsgain_spd_2_calibrated->Add(idx.ToString() + "_" + "cal_fhsawgin", Vswg_cal);
						Vswg_fhsgain_spd_2_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
					}
				}
			}
			#pragma endregion "Calibration of Vpp"

			//Test
			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2); 
			CheckError(idx, ret, __LINE__);
				
			double Gmax = 0;
			double Gmin = 0;
			double vin=0;
			double vin_r1=0;
			
			array<double> ^ res_temp = gcnew array<double>(TOTAL_GLOBAL_VARIABLE);
			array<double> ^ avdb = gcnew array<double>(FHSGain_DAC_Count);
			array<int> ^ av_k = gcnew array<int>(FHSGain_DAC_Count);
			array<double> ^ vout_meas = gcnew array<double>(FHSGain_DAC_Count);
			
			//JL: make sure CBIT 41 and 11 is set to enable MTX_SMU to FLTMUX; from DriveCBit(TPDispName[0], 2);
	/*bk disable SMU
			ret = smu->OffSmuPin("MTX_SMU");
			CheckError(idx, ret, __LINE__);
			ret = smu->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);
			ret = smu->DriveCurrent("MTX_SMU", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu->OnSmuPin("MTX_SMU", false, false);
			CheckError(idx, ret, __LINE__);
	bk: disable smu */	
			int meas_count = 50000;
			array<double> ^ vout = gcnew array<double>(meas_count);
			double ave_v = 0;
				
			for (int i=0; i<total_tp; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
				if(isCurrentTPBypassed)
					continue;
				
				if(TPName[i]->Contains("Mono"))//JL: addition for "Av_fhs_DAC_Mono!HS0!R"
				{
					double slope, offset, mono;
					
					_util->line_fit(av_k,avdb,8,slope,offset);
					_util->monotonicity(avdb,8,0,mono);
					mono/=slope;        /* Convert to LSBs */
					tf_SetResult_UUTOffset(TPName[i], mono + GetOffset(idx, TPDispName[i]), idx);
					
					continue;
				}		
				else if(TPName[i]->Contains("rdzin"))//JL: addition for "fhs_rdzin_delta!HS!R"
				{
					//JL: this is essentially vout_pp for dac=8 - vout_pp for dac=7; 				
					tf_SetResult_UUTOffset(TPName[i], 2*(vout_meas[8]-vout_meas[7]) + GetOffset(idx, TPDispName[i]), idx);
					
					continue;
				}
				else if(TPName[i]->Contains("cal")) //JL: addition for "fhs_awg_cal_status!R"
				{
					//JL: this test is to report if AWG is calibrated
					int fhs_awg_cal_status = 0;
					
					if(Vswg_fhsgain_spd_8_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin") != false)
					//if(Vswg_fhsgain_spd_8_calibrated->ContainsKey(idx.ToString() + "_" + "cal_fhsawgin"))
						fhs_awg_cal_status = 1;				

					tf_SetResult_UUTOffset(TPName[i], (int)(fhs_awg_cal_status + GetOffset(idx, TPDispName[i])), idx);
					
					continue;
				}
				//JL: Measuring gain starts here:
				Vector_File1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File1"));		//ML not Vector_File1

				if(!USE_SPI)		//ML to check with BK
				{
					ret = RunVectorFile(idx, Vector_File1);
					CheckError(idx, ret, __LINE__);
				} 
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx, Vector_File1);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(Measure_Delay_s);
			
				switch(i) //JL: use different amplitude for diff FHS gain
				{
					case 0:
					case 1:
					case 2:
					case 3:
					case 4:
						vin = Vswg_fhsgain_spd_8_calibrated[idx.ToString() + "_" + "cal_fhsawgin"];
						vin_r1 = Vswg_fhsgain_spd_8_dut[idx.ToString() + "_" + "cal_fhsawgin"]/CONST_FSAv_div;
						break;
					case 5:
					case 6:
					case 7:
					case 8:
						vin = Vswg_fhsgain_spd_4_calibrated[idx.ToString() + "_" + "cal_fhsawgin"];
						vin_r1 = Vswg_fhsgain_spd_4_dut[idx.ToString() + "_" + "cal_fhsawgin"]/CONST_FSAv_div;
						break;
					case 9:
					case 10:
					case 11:
						vin = Vswg_fhsgain_spd_2_calibrated[idx.ToString() + "_" + "cal_fhsawgin"];
						vin_r1 = Vswg_fhsgain_spd_2_dut[idx.ToString() + "_" + "cal_fhsawgin"]/CONST_FSAv_div;
						break;
					
				}
				
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
				ret = acm[idx]->RunFG("ACM_CH", 0, true);

				/*bk ret += smu->ReadVoltageWithAverage("MTX_SMU", meas_count, ave_v, vout);			
				//ret += smu->Measure("MTX_SMU", 1, vout);	//JL: this one only measures 1 result	
				ret += smu->MeasureArray("MTX_SMU", false, 1, vout);
				//JL: find max vout
				vout_pp = 0;
				for(int j=0; j< meas_count; j++)
				{
					if(vout[j] > vout_pp)
						vout_pp = vout[j]; //highest +ve voltage
				}
				vout_pp *= 2; //JL: peak to peak voltage, multiply by 2 to includes -ve voltage
				bk*/

				int data = 0;
				ret = OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 5, data); //expect 0
				ret = ReadReg(idx, 2, 12, data);//expect 0
				ret = ReadReg(idx, 2, 2, data);//expect26
				ret = ReadReg(idx, 2, 4, data);//expect 80
				ret = ReadReg(idx, 1, 15, data);//expect 12
				ret = ReadReg(idx, 3, 13, data);//expect 0
				ret = ReadReg(idx, 1, 1, data);//expect 192
				ret = OnOffSPI(idx, 0);
				
				//ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor0, vout_pp);
				ret = Digitizer_CaptureVpp(idx, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp, dataArray_voutpp);
				Digitizer_GetVpp(0, _glob->digitizer_setting, diff2se_digitizer_factor, dataArray_voutpp, vpp);

				if (ret)
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);

					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}

				//bk try ret = acm[idx]->StopFG("ACM_CH"); 	
				
				vout_meas[i]=vpp;
				result = 20 * Math::Log10((2*vpp) / vin_r1);
				avdb[i] = result; //JL for mono: measured gain result for given DAC.
				av_k[i] = i; //JL for mono: DAC value
				
				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
					res_temp[Global_Result_Index] = result;
					_glob->Global_Result[idx, Global_Result_Index] = Math::Pow(10, result/20);
				}

				if (TPName[i]->Contains("db"))
				{
					result = result - res_temp[Global_Result_Index];

					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					tf_SetResult_UUTOffset(TPName[i], result + GetOffset(idx, TPDispName[i]), idx);
				}			
			}	

			ret = acm[idx]->StopFG("ACM_CH");
			CheckError(idx, ret, __LINE__);
			
	test_end:
			
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
		
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
		
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::hi_spd_mux(Object^ object)
	{	
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{		
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s =0;
			double Vswg				= 0;
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			//int FHSGain_DAC_Count      = (int)(tf_TestItemCondition_Cast("FHSGain_DAC_Count"));
			//int Global_Result_Index = 0;
			bool isCurrentTPBypassed = false;
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			String ^ Vector_File_init = (String ^)(tf_TestItemCondition_Cast("Vector_File_init"));
			String ^ Vector_File_sweep = (String ^)(tf_TestItemCondition_Cast("Vector_File_sweep"));
			String ^ Vector_File_sweep_lfp = (String ^)(tf_TestItemCondition_Cast("Vector_File_sweep_lfp"));
			String ^ Vector_File_lcmin = (String ^)(tf_TestItemCondition_Cast("Vector_File_lcmin"));
			String ^ Vector_File_lcmin_end = (String ^)(tf_TestItemCondition_Cast("Vector_File_lcmin_end"));

			Vswg = 4 * CONST_FSAv_div * 1e-3;

			double diff2se_digitizer_factor = 1;
			
			//double diff2se_digitizer_factor0 = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_HSM"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_HSM"][idx];
				
			//if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC0"))
				//diff2se_digitizer_factor0 = calfactor["DIFF2SE_DIGITIZER_DC0"][testSite];

			double result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			//ret = DriveDIOPin(TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

	/*
			ret = OnOffSPI(1);
			ret += WriteSPI(2, 12, 0x0);
			ret += WriteSPI(2, 2, 0x0);
			ret += WriteSPI(2, 4, 0x40);
			ret += WriteSPI(2, 5, 0x0);
			ret += WriteSPI(1, 15, 0xc);
			ret += WriteSPI(3, 13, 0x0);
			ret += WriteSPI(2, 12, 0x0);
			ret += WriteSPI(2, 2, 0x1a);
			ret += WriteSPI(2, 4, 0x50);
			ret += WriteSPI(2, 4, 0x50);
			ret += WriteSPI(1, 1, 0xc0);

			int data = 0;
			ret = ReadReg(idx, 2, 5, data); //expect 0
			ret = ReadReg(idx, 2, 12, data);//expect 0
			ret = ReadReg(idx, 2, 2, data);//expect26
			ret = ReadReg(idx, 2, 4, data);//expect 80
			ret = ReadReg(idx, 1, 15, data);//expect 12
			ret = ReadReg(idx, 3, 13, data);//expect 0
			ret = ReadReg(idx, 1, 1, data);//expect 192

			ret = OnOffSPI(idx, 0);
	*/

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 16384;//16384; //1024; //8192; //must be 2^n  //ML was 2048
			int nbrSegments = 1;
			int coupling = 3;//4;	//0 Ground (Averagers ONLY) //bk: change frm 3-> 4
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2;//1.0; //1V or 2V	//ML was 2.0
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager)
				//	delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);		
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 100;

			//array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
			//array<double> ^ dataArrayN;

			double dataTemp = 0;
			//complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
			//array<double> ^ magn = gcnew array<double>(nbrSamples);
			double vout_pp = 0.0;
			double vpp=0;
			double fftBIN = 0;
			int magn_peak_index = 0;

			int max_loop = 50;

			int Decimation_Factor = 1; //1GS/s
			if (Fswg < 10e6)
			{
				Decimation_Factor = 16; 
			}

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			int cal_loop=0;
			double vin=0;
			double vin_r1=0;
			for (cal_loop=0; cal_loop<11; cal_loop++)
			{	
				switch (cal_loop)
					{
						case 0:
							//Vswg = 8 * CONST_FSAv_div * 1e-3;
							Fswg = 50000;
							break;
						case 1:
							//Vswg = 4 * CONST_FSAv_div * 1e-3;
							Fswg = 140e3; 
							break;
						case 2:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 35e3;
							break;
						case 3:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 100e3;
							break;
						case 4:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 1e6;
							break;	
						case 5:
							//Vswg = 8 * CONST_FSAv_div * 1e-3;
							Fswg = 110e3;
							break;
						case 6:
							//Vswg = 4 * CONST_FSAv_div * 1e-3;
							Fswg = 180e3; 
							break;
						case 7:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 250e3;
							break;
						case 8:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 2e6;
							break;
						case 9:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 3e6;
							break;	
						case 10:
							//Vswg = 2 * CONST_FSAv_div * 1e-3;
							Fswg = 20e6;
							break;	
					}
							
				if (Vswg_hsm_20M_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false) //bk: TIDispName
				{
					double Vswg_cal = 0;
					int loop_count = 0;

					//On K3, K4
					ret = DriveCBit(idx, TPDispName[0], 1);
					CheckError(idx, ret, __LINE__);

					Vswg_cal = Vswg;

					ret = acm[idx]->ResetChannel("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(1e-3);
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(Measure_Delay_s);

					int do_once = 0;
					while(loop_count <= max_loop)
					{
						if (do_once == 0)
						{
							//ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth); //bk
							//CheckError(idx, ret, __LINE__);	
							ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
							//ret = Digitizer_Configure(digitizer_setting);
							CheckError(idx, ret, __LINE__);
							do_once = 1;
						}

						//ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.350, vout_pp);
						//ret = Digitizer_CaptureVpp(digitizer_setting, vout_pp, dataArrayP);
						ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
						
						if (ret)
						{
							ret = digitizer[idx]->StopAcquire("DIGITIZER");
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							if(TIDispName == "cal_fhsawgin")
							{
								tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
							}	
							else
							{
								for (int i=0; i<total_tp; i++)
								{
									tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
								}
							}

							goto test_end;
						}

						if (Math::Abs(Vswg - vout_pp) < (2e-3))
						{
							break;
						}
						else
						{
							Vswg_cal = Vswg_cal + (Vswg - vout_pp);

							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);
							ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
							if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
							{
								CheckError(idx, ret, __LINE__);	
							}

							if (ret != 0)
							{
								ret = 0;

								ret = digitizer[idx]->StopAcquire("DIGITIZER");
								CheckError(idx, ret, __LINE__);
								ret = acm[idx]->StopFG("ACM_CH"); 
								CheckError(idx, ret, __LINE__);
								
								//off K3, K4
								ret = DriveCBit(idx, TPDispName[0], 0);
								CheckError(idx, ret, __LINE__);

								if(TIDispName == "cal_fhsawgin")
								{
									tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
								}
								else
								{
									for (int i=0; i<total_tp; i++)
									{
										tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
									}
								}

								goto test_end;
							}

							ret = acm[idx]->RunFG("ACM_CH", 0, true);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(Measure_Delay_s);
						}
			
						loop_count++;
					}

					if (loop_count > max_loop)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						//off K3, K4
						ret = DriveCBit(idx, TPDispName[0], 0);
						CheckError(idx, ret, __LINE__);
						
						if(TIDispName == "cal_fhsawgin")
						{
							tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
						}		
						else
						{
							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}
						}

						goto test_end;
					}
								
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					//off K3, K4
					ret = DriveCBit(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

					if (cal_loop==0)
					{
						Vswg_hsm_50k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==1)
					{
						Vswg_hsm_140k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==2)
					{
						Vswg_hsm_35k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==3)
					{
						Vswg_hsm_100k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==4)
					{
						Vswg_hsm_1M_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==5)
					{
						Vswg_hsm_110k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==6)
					{
						Vswg_hsm_180k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==7)
					{
						Vswg_hsm_250k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==8)
					{
						Vswg_hsm_2M_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==9)
					{
						Vswg_hsm_3M_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					if (cal_loop==10)
					{
						Vswg_hsm_20M_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
					}
					//bk exception: vin_r1 = Vswg_hsm_50k_dut[TIDispName]/CONST_FSAv_div;	
				}
			}

			int do_once=0;
			if (do_once == 0)
			{
				ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
				CheckError(idx, ret, __LINE__);
				do_once = 1;
			}
		
		
			//on k1 k2 for reader pins
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);
			
			ret = RunVectorFile(idx, Vector_File_init);
			CheckError(idx, ret, __LINE__);

			Fswg = 1e6;
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_hsm_1M_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_hsm_1M_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			
			array<double> ^ av = gcnew array<double>(3);
			array<double> ^ avdb = gcnew array<double>(3);
			array<double> ^ avlfp = gcnew array<double>(6);
			array<double> ^ avlfpdb = gcnew array<double>(6);
			array<double> ^ avhfp = gcnew array<double>(7);
			array<double> ^ avhfpdb = gcnew array<double>(7);
			array<double> ^ vin_meas = gcnew array<double>(7);
			int result_count=0;
			
			int dac=0;
			vin_r1=0.004;

			String ^ vector_file_str = "" ;
			String ^ vector_file_str1 = "" ;

			int reg_v=0;
			
			for (dac=0; dac<3; dac++)
			{
				switch(dac)
				{
					case 0:
						vector_file_str = Vector_File_sweep + "2";  
						break;
					case 1:
						vector_file_str = Vector_File_sweep + "1";  
						break;
					case 2:
						vector_file_str = Vector_File_sweep + "0";  
						break;
				}
				ret = RunVectorFile(idx, vector_file_str);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 12, reg_v); //FHSBIAS_V - bit3
				ret = ReadReg(idx, 2, 2, reg_v); //FHSBIAS_V - bit [5:0]
				ret = ReadReg(idx, 2, 4, reg_v); //FHSIMODE - bit6 
				ret = ReadReg(idx, 1, 7, reg_v); //MODECONFIG[, bit[7:6]
				ret = ReadReg(idx, 1, 1, reg_v); //GAIN, bit[7:4]; HSEL , bit [3:0]
				ret = ReadReg(idx, 2, 7, reg_v); //FHSVBIAS200, bit 7
				ret = ReadReg(idx, 2, 5, reg_v); //FHSGAIN, 0
				ret = ReadReg(idx, 2, 15, reg_v);//FHSMUXEN, bit6; MUXSEL, bit[4:3]
				OnOffSPI(idx, 0);
				
				//ret = Digitizer_CaptureVpp(digitizer_setting, vout_pp, dataArrayP);
				//Digitizer_GetVpp(0, digitizer_setting, dataArrayP, vpp);
				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
				
				av[dac] = vout_pp/vin_r1; //vin_r1
				avdb[dac] = 20*Math::Log10(fabs(av[dac]));

				tf_SetResult_UUTOffset(TPName[result_count], avdb[dac] + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;
			}
			double db_ref = 20*Math::Log10(fabs(av[2]/av[0]));
			
			//////for lcmin
			ret = RunVectorFile(idx, Vector_File_lcmin);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			OnOffSPI(idx, 1);
			ret = ReadReg(idx, 2, 7, reg_v); //expect c1
			ret = ReadReg(idx, 2, 4, reg_v); //previous 10
			ret = ReadReg(idx, 2, 12, reg_v); //previous 8
			ret = ReadReg(idx, 2, 2, reg_v); //previous 3f
			ret = ReadReg(idx, 2, 3, reg_v); //default 0x7 + set to 0
			OnOffSPI(idx, 0);

			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_hsm_50k_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_hsm_50k_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			_util->Wait_Sec(Measure_Delay_s);

			ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
			double av_lcmin = vout_pp/vin_r1;
			double db_lcmin = 20*(Math::Log10(Math::Abs(av_lcmin)));

			ret = RunVectorFile(idx, Vector_File_lcmin_end);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(Measure_Delay_s);

			OnOffSPI(idx, 1);
			ret = ReadReg(idx, 2, 7, reg_v); //expect c0
			ret = ReadReg(idx, 2, 4, reg_v); //previous 50
			ret = ReadReg(idx, 2, 12, reg_v); //previous 0
			ret = ReadReg(idx, 2, 2, reg_v); //previous 1a
			ret = ReadReg(idx, 2, 3, reg_v); //default 0x7 + set to 0
			OnOffSPI(idx, 0);
			
			/////for fhslfp
			for (dac=0;dac<6;dac++)
			{
				switch (dac)
				{
					case 0:
						vector_file_str = Vector_File_sweep_lfp + "0";
						Fswg = 50e3;
						vin = Vswg_hsm_50k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 1:
						vector_file_str = Vector_File_sweep_lfp + "1";
						Fswg = 50e3;
						vin = Vswg_hsm_50k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 2:
						vector_file_str = Vector_File_sweep_lfp + "2";
						Fswg = 140e3;
						vin = Vswg_hsm_140k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 3:
						vector_file_str = Vector_File_sweep_lfp + "3";
						Fswg = 35e3;
						vin = Vswg_hsm_35k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 4:
						vector_file_str = Vector_File_sweep_lfp + "4";
						Fswg = 100e3;
						vin = Vswg_hsm_100k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 5:
						vector_file_str = Vector_File_sweep_lfp + "5";
						Fswg = 1e6;
						vin = Vswg_hsm_1M_calibrated[idx.ToString() + "_" + TIDispName];
						break;
				}

				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 7, reg_v); //always c0
				ret = ReadReg(idx, 2, 4, reg_v); //50, 10, 50, 10, 10, 50
				ret = ReadReg(idx, 2, 12, reg_v); //0, 8, 0, 8, 8, 0
				ret = ReadReg(idx, 2, 2, reg_v); //1a, 3f, 1a, 3f, 3f, 1a
				ret = ReadReg(idx, 2, 3, reg_v); //7, 7, f, f,17, 3f
				OnOffSPI(idx, 0);
				
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				_util->Wait_Sec(Measure_Delay_s);
				
				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
				
				avlfp[dac] = vout_pp/vin_r1;
				avlfpdb[dac] = 20*(Math::Log10(Math::Abs(avlfp[dac])));
				
				ret = RunVectorFile(idx, vector_file_str);
				CheckError(idx, ret, __LINE__);
			}

			OnOffSPI(idx, 1);
			ret = ReadReg(idx, 2, 7, reg_v); //always c0
			ret = ReadReg(idx, 2, 4, reg_v); //50, 10, 50, 10, 10
			ret = ReadReg(idx, 2, 12, reg_v); //0, 8, 0, 8, 8, 0
			ret = ReadReg(idx, 2, 2, reg_v); //1a, 3f, 1a, 3f, 3f, 1a
			ret = ReadReg(idx, 2, 3, reg_v); //7, 7, f, f,17, 3f
			OnOffSPI(idx, 0);

			double db_loss = fabs(avdb[2] - db_lcmin);
			double calc_sqr = Math::Pow(10.0,(db_loss/10))-1;
			double f_lcmin=(50000 * Math::Sqrt(calc_sqr));
			double fi_FHSLFP[6] = {50000,50000,140000,35000,100000,1000000};
			double fhslcv_corr[8]={0,0,0,0,0,80000,0,0};
			double res;
			array<double> ^ lfp = gcnew array<double>(7);

			tf_SetResult_UUTOffset(TPName[result_count], f_lcmin + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;

			for (dac=0; dac<6; dac++)
			{	
				db_loss = avdb[2] - avlfpdb[dac];
				calc_sqr=pow(10.0,(db_loss/10))-1;
				lfp[dac]=(fi_FHSLFP[dac] * sqrt(calc_sqr));
		   
				res = lfp[dac]-fhslcv_corr[dac];
				tf_SetResult_UUTOffset(TPName[result_count], res + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;
			}
			
			db_loss = avdb[2] - db_lcmin;
			tf_SetResult_UUTOffset(TPName[result_count], db_loss + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;

			for (dac=0; dac<6; dac++) 
			{
				db_loss = avdb[2] - avlfpdb[dac]; 
				tf_SetResult_UUTOffset(TPName[result_count], db_loss + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;
			}

			ret = ReadReg(idx, 2, 3, reg_v);
			ret = ReadReg(idx, 2, 15, reg_v);

			////// for FHSHFP 
			for (dac=0; dac<3; dac++)
			{
				switch (dac)
				{
					case 0:
						Fswg = 110e3;
						vin = Vswg_hsm_110k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 1:
						Fswg = 180e3;
						vin = Vswg_hsm_180k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 2:
						Fswg = 250e3;
						vin = Vswg_hsm_250k_calibrated[idx.ToString() + "_" + TIDispName];
						break;
				}
				OnOffSPI(idx, 1);
				WriteSPI(idx, 2, 3, dac); //FHSHFP

				//muxsel=2
				WriteSPI(idx, 2,15,0x50);
				OnOffSPI(idx, 0);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				_util->Wait_Sec(Measure_Delay_s);

				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 3, reg_v);
				ret = ReadReg (idx, 2, 15, reg_v);
				OnOffSPI(idx, 0);
				
				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
				vin_meas[dac] = vout_pp;	
				
				//muxsel=0
				OnOffSPI(idx, 1);
				WriteSPI(idx, 2,15,0x40);
				OnOffSPI(idx, 0);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				_util->Wait_Sec(Measure_Delay_s);

				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 3, reg_v);
				ret = ReadReg (idx, 2, 15, reg_v);
				OnOffSPI(idx, 0);
				
				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
				avhfp[dac] = vout_pp / vin_meas[dac];
				avhfpdb[dac] = 20 * Math::Log10(fabs(avhfp[dac]));
			}
			
			Fswg = 1e6;
			vin = Vswg_hsm_1M_calibrated[idx.ToString() + "_" + TIDispName];
			
			OnOffSPI (idx, 1);
			WriteSPI(idx, 2, 3, 6); //FHSHFP
			//muxsel=2
			WriteSPI(idx, 2,15,0x50);
			OnOffSPI(idx, 0);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			_util->Wait_Sec(Measure_Delay_s);

			OnOffSPI(idx, 1);
			ret = ReadReg (idx, 2, 3, reg_v);
			ret = ReadReg (idx, 2, 15, reg_v);
			OnOffSPI(idx, 0);
				
			ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
			vin_meas[3] = vout_pp;	
				
			//muxsel=0
			OnOffSPI(idx, 1);
			WriteSPI(idx, 2,15,0x40);
			OnOffSPI(idx, 0);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			_util->Wait_Sec(Measure_Delay_s);

			OnOffSPI(idx, 1);
			ret = ReadReg(idx, 2, 3, reg_v);
			ret = ReadReg (idx, 2, 15, reg_v);
			OnOffSPI(idx, 0);
				
			ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
			avhfp[3] = vout_pp / vin_meas[3];
			avhfpdb[3] = 20 * Math::Log10(fabs(avhfp[3]));
					
			
			OnOffSPI (idx, 1);
			ret = ReadReg (idx, 2, 3, reg_v); //read before write: 0x6
			ret = ReadReg (idx, 2, 4, reg_v); //read before write: 0x10
			WriteSPI(idx, 2,3,0x46); //set b6=1 --> 46
			WriteSPI(idx, 2,4,0x50); //set b6=1 --> 50
			WriteSPI(idx, 2,2,0x1a);
			WriteSPI(idx, 2,12,0);
			OnOffSPI(idx, 0);
			
			for (dac=0; dac<2; dac++)
			{
				switch (dac)
				{
					case 0:
						Fswg = 2e6;
						vin = Vswg_hsm_2M_calibrated[idx.ToString() + "_" + TIDispName];
						break;
					case 1:
						Fswg = 3e6;
						vin = Vswg_hsm_3M_calibrated[idx.ToString() + "_" + TIDispName];
						break;
				}
				OnOffSPI (idx, 1);
				WriteSPI(idx, 2, 3, (dac+64)); //FHSHFP
				//muxsel=2
				WriteSPI(idx, 2,15,0x50);
				OnOffSPI(idx, 0);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				_util->Wait_Sec(Measure_Delay_s);

				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 3, reg_v);
				ret = ReadReg(idx, 2, 15, reg_v);
				OnOffSPI(idx, 0);
				
				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
				vin_meas[dac+4] = vout_pp;	
				
				//muxsel=0
				OnOffSPI(idx, 1);
				WriteSPI(idx, 2,15,0x40);
				OnOffSPI(idx, 0);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				_util->Wait_Sec(Measure_Delay_s);

				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 2, 3, reg_v);
				ret = ReadReg(idx, 2, 15, reg_v);
				OnOffSPI(idx, 0);
				
				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
				avhfp[dac+4] = vout_pp / vin_meas[dac+4];
				avhfpdb[dac+4] = 20 * Math::Log10(fabs(avhfp[dac+4]));
					
			}
			
			Fswg = 20e6;
			vin = Vswg_hsm_20M_calibrated[idx.ToString() + "_" + TIDispName];
			
			OnOffSPI (idx, 1);
			WriteSPI(idx, 2, 3, 0x46); //FHSHFP
			//muxsel=2
			WriteSPI(idx, 2,15,0x50);
			OnOffSPI(idx, 0);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			_util->Wait_Sec(Measure_Delay_s);

			OnOffSPI(idx, 1);
			ret = ReadReg(idx, 2, 3, reg_v);
			ret = ReadReg(idx, 2, 15, reg_v);
			OnOffSPI(idx, 0);
				
			ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
			vin_meas[6] = vout_pp;	
				
			//muxsel=0
			OnOffSPI(idx, 1);
			WriteSPI(idx, 2,15,0x40);
			OnOffSPI(idx, 0);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			_util->Wait_Sec(Measure_Delay_s);

			OnOffSPI(idx, 1);
			ret= ReadReg(idx, 2, 3, reg_v);
			ret = ReadReg (idx, 2, 15, reg_v);
			OnOffSPI(idx, 0);
				
			ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
			avhfp[6] = vout_pp / vin_meas[6];
			avhfpdb[6] = 20 * Math::Log10(fabs(avhfp[6]));

			double fi_FHSHFP[8] = {110000,180000,250000,1000000,2000000,3000000,20000000,20000000};
			double hfp_corr[16]={0,0,0,0,0.2e6,0.5e6,0.6e6,0,0,0,0,0,0,0,0,0};
			double res1;
			array<double> ^ hfp = gcnew array<double>(8);

			for (dac=0; dac<7; dac++)
			{
				db_loss = db_ref - avhfpdb[dac];
				calc_sqr=Math::Pow(10.0,(db_loss/10))-1;
				hfp[dac]=(fi_FHSHFP[dac])/(Math::Sqrt(calc_sqr));
				res1= hfp[dac] + hfp_corr[dac];

				tf_SetResult_UUTOffset(TPName[result_count], res1 + GetOffset(idx, TPDispName[result_count]), idx);
				tf_SetResult_UUTOffset(TPName[result_count+6], db_loss + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;

			}
		 
	test_end:	ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
	
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			ret = smu[idx]->ClampCurrent("VCC", 0.5);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampCurrent("VEE", 0.5);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(5e-3);

			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(5e-3); //discharge cap

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}	
	}
	//void TestProgram::lfp_ibias_vbias(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		bool isCurrentTPBypassed = false;
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
	//		double Fswg_Test_Freq   = 0;
	////		double Fswg_Test		= (double)(tf_TestItemCondition_Cast("Fswg_Test"));
	//		double Fswg_Ref			= (double)(tf_TestItemCondition_Cast("Fswg_Ref"));
	//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

	//		double diff2se_digitizer_factor = 1;

	//		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_LFP_IBIAS_VBIAS"))
	//			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_LFP_IBIAS_VBIAS"][idx];

	//		//diff2se_digitizer_factor = 0.25; //EW:

	//		double diff2se_digitizer_factor_dc = 1;

	//		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC_LFP_IBIAS_VBIAS"))
	//			diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC_LFP_IBIAS_VBIAS"][idx];

	////EW: DEBUG
	////diff2se_digitizer_factor = 0.85;
	////diff2se_digitizer_factor_dc = 0.8;

	//		double vih = 2.5;
	//		double vil = 0.00;
	//		double voh = 0.75; 
	//		double vol = 0.75;
	//		double ioh = 0.002;
	//		double iol = 0.002;
	//		double vch = 6;
	//		double vcl = -0.1;
	//		double vt = 0;

	//		int vector_engine_status = 0;
	//		Stopwatch swatch;
	//				
	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(On_Delay_s);

	//		ret = RunVectorFile(idx, Vector_File);
	//		CheckError(idx, ret, __LINE__);

	//		//Digitizer setting
	//		int mode = 0;	//0 = normal data acquisition (digitizer)
	//						//2 = averaging mode (it makes the instrument run as a real-time averager)
	//		int flag = 0;	//0 = normal
	//						//1 = ‘Start on Trigger’ mode
	//		double sampInterval = 1e-9;
	//		double delayTime = 0.0;
	//		int nbrSamples = 1024; //8192; //must be 2^n
	//		int nbrSegments = 1;
	//		int coupling = 3;	//0 Ground (Averagers ONLY)
	//							//1 DC, 1 M-ohm
	//							//2 AC, 1 M-ohm
	//							//3 DC, 50 M-ohm
	//							//4 AC, 50 M-ohm
	//		int bandwidth = 0;	//0 no bandwidth limit (default)
	//							//1 bandwidth limit at 25 MHz
	//							//2 bandwidth limit at 700 MHz
	//							//3 bandwidth limit at 200 MHz
	//							//4 bandwidth limit at 20 MHz
	//							//5 bandwidth limit at 35 MHz
	//		double fullScale = 2.0; //1V or 2V
	//		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
	//								//2V range: ±4 V (max signal = ±6.3 V)
	//		long trigClass = 0;		//0 edge trigger 
	//		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
	//										//0x000n0002 for Channel 2

	//		int Decimation_Factor = 1; //1GS/s

	//		long trigCoupling = 0;	//0 DC
	//								//1 AC
	//								//2 HF Reject (if available)
	//								//3 DC, 50 (ext. trigger only, if available)
	//								//4 AC, 50 (ext. trigger only, if available)
	//		long trigSlope = 0;	//0 Positive
	//							//1 Negative
	//							//2 out of Window
	//							//3 into Window
	//							//4 HF divide
	//							//5 Spike Stretcher
	//		double trigLevel = 0;	//% of FS 
	//								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
	//		int timeOut_ms = 1;

	//		array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	//		digitizer_setting[0] = sampInterval;
	//		digitizer_setting[1] = delayTime;
	//		digitizer_setting[2] = (double)nbrSamples;
	//		digitizer_setting[3] = (double)nbrSegments;
	//		digitizer_setting[4] = fullScale; 
	//		digitizer_setting[5] = offset;
	//		digitizer_setting[6] = (double)coupling;
	//		digitizer_setting[7] = (double)bandwidth;
	//		digitizer_setting[8] = (double)trigClass;
	//		digitizer_setting[9] = (double)sourcePattern;
	//		digitizer_setting[10] = (double)trigCoupling;
	//		digitizer_setting[11] = (double)trigSlope;
	//		digitizer_setting[12] = trigLevel;
	//		digitizer_setting[13] = (double)timeOut_ms;
	//		digitizer_setting[14] = (double)Decimation_Factor;
	//		
	//		try
	//		{
	//			//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);

	//			Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

	//			if (hardwareResource->Alias->Contains("Ch1"))
	//			{
	//				sourcePattern = 0x00000001;
	//			}
	//			else if (hardwareResource->Alias->Contains("Ch2"))
	//			{
	//				sourcePattern = 0x00000002;
	//			}

	//			//if (resourceManager)
	//			//	delete resourceManager;
	//		}
	//		catch (Exception ^ e)
	//		{
	//			throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
	//		}

	//		array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
	//		array<double> ^ dataArrayN;

	//		double dataTemp = 0;
	//		complex<double> * dataArrayComplex = new complex<double>[nbrSamples];
	//		array<double> ^ magn = gcnew array<double>(nbrSamples);
	//		double fftBIN = 0;
	//		int magn_peak_index = 0;

	//		int max_loop = 50;

	//		double Vswg_cal = 0;
	//		int loop_count = 0;

	//		/////////////////////////////////////////////
	//		//Calibration of Fswg_Ref Vpp
	//		/////////////////////////////////////////////

	////		array<double> ^ do_once = gcnew array<double>(2);
	////		array<double> ^ factor = gcnew array<double>(2); 
	////		array<double> ^ vout_pp = gcnew array<double>(2); 

	////		factor[0] = diff2se_digitizer_factor;
	////		factor[1] = diff2se_digitizer_factor_dc;

	//		int factor = 1;
	//		double vout_pp_ref = 0;

	//		if (Vswg_lpd_spd_calibrated->ContainsKey(idx.ToString() + "_" + Fswg_Ref.ToString()) == false)	//if (Vswg_lpd_spd_calibrated->ContainsKey(Fswg_Ref) == false) 
	//		{
	//			//On K3, K4
	//			ret = DriveCBit(idx, TPDispName[0], 1);
	//			CheckError(idx, ret, __LINE__);
	//		
	//			Vswg_cal = 0;
	//			loop_count = 0;

	//			if (Fswg_Ref < 0.5e6) 
	//			{
	//				Decimation_Factor = 16; //31.25MS/s
	//				nbrSamples = 8192;
	//			}
	//			else
	//			{
	//				Decimation_Factor = 1; //1GS/s
	//				nbrSamples = 1024;
	//			}

	//			digitizer_setting[2] = (double)nbrSamples;
	//			digitizer_setting[14] = (double)Decimation_Factor;

	//			Vswg_cal = Vswg;

	//			ret = SWG_Configure(idx, Vswg_cal, Fswg_Ref, 0);		//ret = SWG_Configure();
	//			CheckError(idx, ret, __LINE__);
	//			
	//			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg_Ref, 0);
	//			
	//			_util->Wait_Sec(1e-3);
	//			
	//			ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//			CheckError(idx, ret, __LINE__);
	//			
	//			_util->Wait_Sec(Measure_Delay_s);

	//			int do_once = 0;
	//			while(loop_count <= max_loop)
	//			{
	//				if (do_once == 0)
	//				{
	//					ret = DigitizerFFT_Configure(idx, digitizer_setting);
	//					CheckError(idx, ret, __LINE__);

	//					do_once = 1;
	//				}

	////				ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.8, vout_pp_ref);
	//				ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);	//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);

	//				if (ret)
	//				{
	//					for (int i=0; i<total_tp; i++)
	//					{
	//						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//					}

	//				goto test_end;
	//				}
	//		
	//				if (Math::Abs(Vswg - vout_pp_ref) < (4e-3))
	//				{
	//					break;
	//				}
	//				else
	//				{
	//					Vswg_cal = Vswg_cal + (Vswg - vout_pp_ref);

	//					ret = acm[idx]->StopFG("ACM_CH"); 
	//					CheckError(idx, ret, __LINE__);		//
	//					
	//					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg_Ref, 0);
	//					if (ret != 0xAE0900A0) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS
	//					{
	//						CheckError(idx, ret, __LINE__);	
	//					}

	//					if (ret != 0) 
	//					{
	//						ret = 0;

	//						//off K3, K4
	//						ret = DriveCBit(idx, TPDispName[0], 0);
	//						CheckError(idx, ret, __LINE__);

	//						for (int i=0; i<total_tp; i++)
	//						{
	//							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//						}

	//						goto test_end;
	//					}

	//				ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//				CheckError(idx, ret, __LINE__);	//
	//				_util->Wait_Sec(Measure_Delay_s);
	//				
	//				}
	//		
	//				loop_count++;
	//			}

	//				if (loop_count > max_loop)
	//				{
	//					ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
	//					CheckError(idx, ret, __LINE__);	//
	//					
	//					ret = acm[idx]->StopFG("ACM_CH"); 
	//					CheckError(idx, ret, __LINE__); //
	//					
	//					//off K3, K4
	//					ret = DriveCBit(idx, TPDispName[0], 0);
	//					CheckError(idx, ret, __LINE__);

	//					for (int i=0; i<total_tp; i++)
	//					{
	//						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//					}

	//					goto test_end;
	//				}
	//							
	//				ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
	//				CheckError(idx, ret, __LINE__);	//
	//				
	//				ret = acm[idx]->StopFG("ACM_CH"); 
	//				CheckError(idx, ret, __LINE__);
	//				
	//				//off K3, K4
	//				ret = DriveCBit(idx, TPDispName[0], 0);
	//				CheckError(idx, ret, __LINE__);

	////EW: CAL output
	//				Vswg_lpd_spd_calibrated->Add(idx.ToString() + "_" + Fswg_Ref.ToString(), Vswg_cal);	//Vswg_lpd_spd_calibrated->Add(Fswg_Ref, Vswg_cal);
	//				Vswg_lpd_spd_at_dut->Add(idx.ToString() + "_" + Fswg_Ref.ToString(), vout_pp_ref);	//Vswg_lpd_spd_at_dut->Add(Fswg_Ref, vout_pp_ref);
	//		}
	//		
	//		//On K1, K2
	//		ret = DriveCBit(idx, TPDispName[0], 2);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//ret = SWG_Configure();
	//		ret = SWG_Configure(idx, Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()], Fswg_Ref, 0);			
	//		CheckError(idx, ret, __LINE__);
	//		
	//		/////////////////////////////////////////////////////
	//		//Fswg_Ref

	//		Decimation_Factor = 1; //1GS/s
	//		nbrSamples = 1024;
	//	
	//		digitizer_setting[2] = (double)nbrSamples;
	//		digitizer_setting[14] = (double)Decimation_Factor;

	//		//ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[Fswg_Ref]/2, -1 * Vswg_lpd_spd_calibrated[Fswg_Ref]/2, Fswg_Ref, 0);
	//		ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()]/2, -1 * Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()]/2, Fswg_Ref, 0);			
	//		CheckError(idx, ret, __LINE__);
	//				
	//		ret = Digitizer_Configure(idx, digitizer_setting);	//_glob->digitizer_setting);
	//		CheckError(idx, ret, __LINE__);

	//		ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(Measure_Delay_s);

	//////		ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.8, vout_pp_ref);//diff2se_digitizer_factor
	////		ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);//diff2se_digitizer_factor
	//		ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);	
	//		if (ret)
	//		{
	//			for (int i=0; i<total_tp; i++)
	//			{
	//				tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//			}

	//			goto test_end;
	//		}

	//		ret = acm[idx]->StopFG("ACM_CH"); 
	//		CheckError(idx, ret, __LINE__);

	//		double vout_ref = 20 * Math::Log10(vout_pp_ref);
	//			
	//		//TEST 
	//		array<double> ^ result = gcnew array<double>(total_tp);
	//		array<double> ^ fswg_test_freq = gcnew array<double>(total_tp);
	//		double vout_pp = 0.0;
	//				
	//		for (int i=0; i<total_tp; i++)
	//		{
	//			if (isCurrentTPBypassed == false)
	//			{
	//				//EW: change to contain				if (TPName[i]->StartsWith("f_Ic_Mono"))
	//				if (TPName[i]->Contains("_Mono"))
	//				{
	//					double slope = 0;
	//					double offset = 0;

	//					_util->line_fit_d(fswg_test_freq, result, total_tp-1, slope, offset);
	//					double mono = 0;
	//					double mono_step = _util->monotonicity(result, total_tp-1, 0, mono);
	//					mono /= slope;

	//					if(mono > 5000) 
	//							result[i] = 1; 
	//					else
	//							result[i] = 0;

	//					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//				}
	//				else
	//				{
	//					Fswg_Test_Freq = (double)(tf_TPCondition_Cast(TPName[i], "Fswg_Test_Freq"));
	//					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

	//					fswg_test_freq[i] = Fswg_Test_Freq;

	//					///////////////////////////////
	//					//Program device (HSEL, IBIAS, GAIN)

	//					if (VectorSetNo->ContainsKey(Vector_File))
	//					{
	//						ret = RunVectorFile(idx, Vector_File);
	//						CheckError(idx, ret, __LINE__);
	//					}
	//					///////////////////////////////
	//					//Calibration of Vpp
	//							
	//					if (Vswg_lpd_spd_calibrated->ContainsKey(idx.ToString() + "_" + fswg_test_freq[i].ToString()) == false)	//if (Vswg_lpd_spd_calibrated->ContainsKey(fswg_test_freq[i]) == false)
	//					{
	//						//On K3, K4
	//						ret = DriveCBit(idx, TPDispName[0], 1);
	//						CheckError(idx, ret, __LINE__);

	//						Vswg_cal = 0;
	//						loop_count = 0;

	//						if (fswg_test_freq[i] <0.5e6)
	//						{
	//							Decimation_Factor = 16; //31.25MS/s
	//							nbrSamples = 8192;
	//						}
	//						else
	//						{
	//							Decimation_Factor = 1; //1GS/s
	//							nbrSamples = 1024;
	//						}

	//						digitizer_setting[2] = (double)nbrSamples;
	//						digitizer_setting[14] = (double)Decimation_Factor;

	//						Vswg_cal = Vswg;

	//						ret = SWG_Configure(idx, Vswg_cal, fswg_test_freq[i], 0);	//ret = SWG_Configure();

	//						CheckError(idx, ret, __LINE__);
	//						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, fswg_test_freq[i], 0);
	//						_util->Wait_Sec(1e-3);
	//						ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//						_util->Wait_Sec(Measure_Delay_s);

	//						int do_once = 0;
	//						while(loop_count <= max_loop)
	//						{
	//							if (do_once == 0)
	//							{
	//								ret = DigitizerFFT_Configure(idx, digitizer_setting);
	//								CheckError(idx, ret, __LINE__);

	//								do_once = 1;
	//							}
	//							
	////							ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.75, vout_pp);
	//							ret = DigitizerFFT_CaptureVpp(idx, digitizer_setting, diff2se_digitizer_factor_dc, vout_pp);

	//							if (ret)
	//							{
	//								for (int i=0; i<total_tp; i++)
	//								{
	//									tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//								}

	//								goto test_end;
	//							}
	//		
	//							if (Math::Abs(Vswg - vout_pp) < (4e-3))
	//							{
	//								break;
	//							}
	//							else
	//							{
	//								Vswg_cal = Vswg_cal + (Vswg - vout_pp);

	//								ret = acm[idx]->StopFG("ACM_CH"); 
	//								ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, fswg_test_freq[i], 0);
	//								if (ret != 0xAE0900A0) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS
	//								{
	//									CheckError(idx, ret, __LINE__);	
	//								}
	//								if (ret != 0) 
	//								{
	//									ret = 0;

	//									//off K3, K4
	//									ret = DriveCBit(idx, TPDispName[0], 0);
	//									CheckError(idx, ret, __LINE__);
	//
	//									for (int i=0; i<total_tp; i++)
	//									{
	//										tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//									}
	//									goto test_end;
	//								}

	//								ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//								_util->Wait_Sec(Measure_Delay_s);
	//							}
	//		
	//							loop_count++;
	//						}

	//						if (loop_count > max_loop)
	//						{
	//							ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
	//							CheckError(idx, ret, __LINE__);								
	//							
	//							ret = acm[idx]->StopFG("ACM_CH"); 
	//							CheckError(idx, ret, __LINE__);								
	//					
	//							//off K3, K4
	//							ret = DriveCBit(idx, TPDispName[0], 0);
	//							CheckError(idx, ret, __LINE__);
	//
	//							for (int j=0; j<total_tp; j++)
	//							{
	//								tf_SetResult_UUTOffset(TPName[j], (double)(INVALID_RESULT), idx);
	//							}
	//							goto test_end;
	//						}
	//							
	//						ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
	//						CheckError(idx, ret, __LINE__);	
	//						ret = acm[idx]->StopFG("ACM_CH"); 
	//						CheckError(idx, ret, __LINE__);	
	//				
	//						//off K3, K4
	//						ret = DriveCBit(idx, TPDispName[0], 0);
	//						CheckError(idx, ret, __LINE__);
	//	
	//						Vswg_lpd_spd_calibrated->Add(idx.ToString() + "_" + Fswg_Test_Freq.ToString(), Vswg_cal);	//Vswg_lpd_spd_calibrated->Add(Fswg_Test_Freq, Vswg_cal);
	//						Vswg_lpd_spd_at_dut->Add(idx.ToString() + "_" + Fswg_Test_Freq.ToString(), vout_pp);	//Vswg_lpd_spd_at_dut->Add(Fswg_Test_Freq, vout_pp);
	//					}
	//					
	//					//On K1, K2
	//					ret = DriveCBit(idx, TPDispName[0], 2);
	//					CheckError(idx, ret, __LINE__);
	//					
	//					//ret = SWG_Configure();
	//					ret = SWG_Configure(idx, Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()], Fswg_Ref, 0);						
	//					CheckError(idx, ret, __LINE__);
	//					
	//					/////////////////////////////////////////////////////
	//					//Fswg_Test

	//					Decimation_Factor = 16; //31.25MS/s
	//					nbrSamples = 8192;
	//	
	//					digitizer_setting[2] = (double)nbrSamples;
	//					digitizer_setting[14] = (double)Decimation_Factor;

	//	//double ew_vswg = Vswg_lpd_spd_calibrated[Fswg_Test_Freq]/2;	//ML mask

	//					//ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[Fswg_Test_Freq]/2, -1 * Vswg_lpd_spd_calibrated[Fswg_Test_Freq]/2, Fswg_Test_Freq, 0);
	//					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Test_Freq.ToString()]/2, -1 * Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Test_Freq.ToString()]/2, Fswg_Test_Freq, 0);
	//					CheckError(idx, ret, __LINE__);
	//				
	//					ret = Digitizer_Configure(idx, digitizer_setting);
	//					CheckError(idx, ret, __LINE__);

	//					ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//					CheckError(idx, ret, __LINE__);

	//					_util->Wait_Sec(Measure_Delay_s);

	//////					ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.75, vout_pp); //diff2se_digitizer_factor_dc
	//					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor_dc, vout_pp); //diff2se_digitizer_factor_dc
	//					ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor_dc, vout_pp);						

	//					if (ret)
	//					{
	//						for (int i=0; i<total_tp; i++)
	//						{
	//							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//						}

	//						goto test_end;
	//					}

	//					ret = acm[idx]->StopFG("ACM_CH"); 
	//					CheckError(idx, ret, __LINE__);

	//					//double vin_ratio	= Vswg_lpd_spd_at_dut[Fswg_Test_Freq] / Vswg_lpd_spd_at_dut[Fswg_Ref];
	//					double vin_ratio	= Vswg_lpd_spd_at_dut[idx.ToString() + "_" + Fswg_Test_Freq.ToString()] / Vswg_lpd_spd_at_dut[idx.ToString() + "_" + Fswg_Ref.ToString()];

	//					double vout_lpf		= 20 * Math::Log10(vout_pp * vin_ratio);
	//		
	//					double db_loss		= vout_ref - vout_lpf;

	//					double lfp_spd		= Fswg_Test_Freq * Math::Sqrt(Math::Pow(10, db_loss/10)-1);

	//					if (_util->IsInf(lfp_spd) == false)
	//					result[i] = lfp_spd;
	//					else
	//					result[i] = 0;

	//					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//				}
	//			}
	//		}

	//test_end:
	//		
	//		ret = acm[idx]->ResetChannel("ACM_CH");
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::lfp_ibias_vbias(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		int override = 0;	// EW: Debug 1 = override, 0 = normal

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed = false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
			double Fswg_Test_Freq   = 0;
	//		double Fswg_Test		= (double)(tf_TestItemCondition_Cast("Fswg_Test"));
			double Fswg_Ref			= (double)(tf_TestItemCondition_Cast("Fswg_Ref"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_LFP_IBIAS_VBIAS"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_LFP_IBIAS_VBIAS"][idx];

			//diff2se_digitizer_factor = 0.25; //EW:

			double diff2se_digitizer_factor_dc = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC_LFP_IBIAS_VBIAS"))
				diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC_LFP_IBIAS_VBIAS"][idx];

	//EW: DEBUG
	//diff2se_digitizer_factor = 0.85;
	//diff2se_digitizer_factor_dc = 0.8;

			double vih = 2.5;
			double vil = 0.00;
			double voh = 0.75; 
			double vol = 0.75;
			double ioh = 0.002;
			double iol = 0.002;
			double vch = 6;
			double vcl = -0.1;
			double vt = 0;

			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret += SetupDigital(idx);
			ret += DriveCBit(idx, TPDispName[0]);

			ret += smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);

			ret += dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPE");

			ret += dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPD");

			ret += dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPC");

			ret += dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			ret += dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			ret += dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			ret += dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");

			ret += DriveDMPin(idx, TPDispName[0]);

			//Configure Input Delay
			ret += dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			//_util->Wait_Sec(On_Delay_s);

			ret += RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

// Digitizer setting
#pragma region "Digitizer setting"
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			int Decimation_Factor = 1; //1GS/s

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;


#pragma region "Digitizer setting"

			/////////////////////////////////////////////
			//Calibration of Fswg_Ref Vpp
			/////////////////////////////////////////////

			double fftBIN = 0;
			int magn_peak_index = 0;
			int max_loop = 50;
			double dataTemp = 0;
			double Vswg_cal = 0;
			int loop_count = 0;
			int factor = 1;
			double vout_pp_ref = 0;
			array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
			array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
			array<double> ^ dataArrayN;
			
// ###############################################
	
			digitizer_setting[0] = sampInterval;
			digitizer_setting[1] = delayTime;
			digitizer_setting[2] = (double)nbrSamples;
			digitizer_setting[3] = (double)nbrSegments;
			digitizer_setting[4] = fullScale; 
			digitizer_setting[5] = offset;
			digitizer_setting[6] = (double)coupling;
			digitizer_setting[7] = (double)bandwidth;
			digitizer_setting[8] = (double)trigClass;
			digitizer_setting[9] = (double)sourcePattern;
			digitizer_setting[10] = (double)trigCoupling;
			digitizer_setting[11] = (double)trigSlope;
			digitizer_setting[12] = trigLevel;
			digitizer_setting[13] = (double)timeOut_ms;
			digitizer_setting[14] = (double)Decimation_Factor;

// ###############################################
#pragma endregion "Digitizer setting"

			try
			{
				//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

//				if (resourceManager)
//					delete resourceManager;
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}



			if (Vswg_lpd_spd_calibrated->ContainsKey(idx.ToString() + "_" + Fswg_Ref.ToString()) == false || override)	//if (Vswg_lpd_spd_calibrated->ContainsKey(Fswg_Ref) == false) 
			{
				//On K3, K4
				ret = DriveCBit(idx, TPDispName[0], 1); CheckError(idx, ret, __LINE__);
			
				Vswg_cal = 0;
				loop_count = 0;

				if (Fswg_Ref < 0.5e6) 
				{
					Decimation_Factor = 16; //31.25MS/s
					nbrSamples = 8192;
				}
				else
				{
					Decimation_Factor = 1; //1GS/s
					nbrSamples = 1024;
				}


				digitizer_setting[2] = (double)nbrSamples;
				digitizer_setting[14] = (double)Decimation_Factor;

				Vswg_cal = Vswg;

				ret = SWG_Configure(idx, Vswg_cal, Fswg_Ref, 0);		
				CheckError(idx, ret, __LINE__);
			
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg_Ref, 0);
				_util->Wait_Sec(1e-3);
				
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						ret = DigitizerFFT_Configure(idx, digitizer_setting);
						CheckError(idx, ret, __LINE__);
						do_once = 1;
					}

					ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);	//ret = DigitizerFFT_CaptureVpp(digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);

					if (ret)
					{
						for (int i=0; i<total_tp; i++)
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);

					goto test_end;
					}
			
					if (Math::Abs(Vswg - vout_pp_ref) < (4e-3))
					{
						ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
                        CheckError(idx, ret, __LINE__);
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp_ref);
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg_Ref, 0);	// New Vswg
						if (ret != 0xAE0900A0) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;
							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0); CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);

							goto test_end;
						}

					ret = acm[idx]->RunFG("ACM_CH", 0, true); CheckError(idx, ret, __LINE__);	//
					_util->Wait_Sec(Measure_Delay_s);
					}
					loop_count++;
				}

					if (loop_count > max_loop)
					{
						ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
						ret += acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__); //
						
						//off K3, K4
						ret += DriveCBit(idx, TPDispName[0], 0);

						for (int i=0; i<total_tp; i++)
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);

						goto test_end;
					}
								
					ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
					ret += acm[idx]->StopFG("ACM_CH"); 

					//off K3, K4
					ret += DriveCBit(idx, TPDispName[0], 0);
					CheckError(idx, ret, __LINE__);

//EW: CAL output
String ^ Vswg_Cal_String = idx.ToString() + "_" + Fswg_Ref.ToString() + "," + Vswg_cal.ToString();
String ^ Vpp_outRef_String = idx.ToString() + "_" + Fswg_Ref.ToString() + "," + vout_pp_ref.ToString();

//EW: Only override switch is not enable
if(Vswg_lpd_spd_calibrated->ContainsKey(idx.ToString() + "_" + Fswg_Ref.ToString()) == false)	{
					Vswg_lpd_spd_calibrated->Add(idx.ToString() + "_" + Fswg_Ref.ToString(), Vswg_cal);	//Vswg_lpd_spd_calibrated->Add(Fswg_Ref, Vswg_cal);
					Vswg_lpd_spd_at_dut->Add(idx.ToString() + "_" + Fswg_Ref.ToString(), vout_pp_ref);	//Vswg_lpd_spd_at_dut->Add(Fswg_Ref, vout_pp_ref);
					}
			}
			
			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);

String ^ Vswg_Test_String = idx.ToString() + "_" + Fswg_Ref.ToString() + "," + Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()].ToString();

			 ret = SWG_Configure(idx, Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()], Fswg_Ref, 0);			
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////////////////////
			//Fswg_Ref

			Decimation_Factor = 1; //1GS/s
			nbrSamples = 1024;
		
			digitizer_setting[2] = (double)nbrSamples;
			digitizer_setting[14] = (double)Decimation_Factor;

// EW: DEBUG
String ^ Test_String = "Found " + idx.ToString() + "_" + Fswg_Ref.ToString() + "," + Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()].ToString();

			//ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[Fswg_Ref]/2, -1 * Vswg_lpd_spd_calibrated[Fswg_Ref]/2, Fswg_Ref, 0);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()]/2, -1 * Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()]/2, Fswg_Ref, 0);			
			ret += Digitizer_Configure(idx, digitizer_setting);	//_glob->digitizer_setting);
			ret += acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp_ref);	
			if (ret)
			{
				for (int i=0; i<total_tp; i++)
					tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);

				goto test_end;
			}

			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);

			double vout_ref = 20 * Math::Log10(vout_pp_ref);

//=================================================================================

			//TEST 
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ fswg_test_freq = gcnew array<double>(total_tp);
			double vout_pp = 0.0;

			for (int i=0; i<total_tp; i++)
			{
				if (isCurrentTPBypassed == false)
				{
					if (TPName[i]->Contains("_Mono"))
					{
						double slope = 0;
						double offset = 0;

						_util->line_fit_d(fswg_test_freq, result, total_tp-1, slope, offset);
						double mono = 0;
						double mono_step = _util->monotonicity(result, total_tp-1, 0, mono);
						mono /= slope;

						if(mono > 5000) 
								result[i] = 1; 
						else
								result[i] = 0;

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
					else
					{
						Fswg_Test_Freq = (double)(tf_TPCondition_Cast(TPName[i], "Fswg_Test_Freq"));
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

						fswg_test_freq[i] = Fswg_Test_Freq;

						///////////////////////////////
						//Program device (HSEL, IBIAS, GAIN)

						if (VectorSetNo->ContainsKey(Vector_File))
						{
							ret = RunVectorFile(idx, Vector_File); CheckError(idx, ret, __LINE__);
						}
						///////////////////////////////
						//Calibration of Vpp

						if (Vswg_lpd_spd_calibrated->ContainsKey(idx.ToString() + "_" + fswg_test_freq[i].ToString()) == false || override)	//if (Vswg_lpd_spd_calibrated->ContainsKey(fswg_test_freq[i]) == false)
						{
							//On K3, K4
							ret = DriveCBit(idx, TPDispName[0], 1);	CheckError(idx, ret, __LINE__);

							if (fswg_test_freq[i] <0.5e6)
							{
								Decimation_Factor = 16; //31.25MS/s
								nbrSamples = 8192;
							}
							else
							{
								Decimation_Factor = 1; //1GS/s
								nbrSamples = 1024;
							}

							digitizer_setting[2] = (double)nbrSamples;
							digitizer_setting[14] = (double)Decimation_Factor;

							ret = DigitizerFFT_Configure(idx, digitizer_setting);
							CheckError(idx, ret, __LINE__);

							loop_count = 0;
							Vswg_cal = Vswg;
							double freq = fswg_test_freq[i];

							ret = SWG_Configure(idx, Vswg_cal, fswg_test_freq[i], 0);	
							CheckError(idx, ret, __LINE__);

							ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, fswg_test_freq[i], 0);
							_util->Wait_Sec(1e-3);
							ret = acm[idx]->RunFG("ACM_CH", 0, true);
							_util->Wait_Sec(Measure_Delay_s);

							int do_once = 0;
							while(loop_count <= max_loop)
							{
								if (do_once == 0)
								{
									ret = DigitizerFFT_Configure(idx, digitizer_setting);
									CheckError(idx, ret, __LINE__);

									do_once = 1;
								}

								ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor_dc, vout_pp);

								if (ret)
								{
									for (int i=0; i<total_tp; i++)
										tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);

									goto test_end;
								}
			
								if (Math::Abs(Vswg - vout_pp) < (4e-3))
								{
									break;
								}
								else
								{
									Vswg_cal = Vswg_cal + (Vswg - vout_pp);

									ret = acm[idx]->StopFG("ACM_CH"); 
									ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, fswg_test_freq[i], 0);
									if (ret != 0xAE0900A0) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS
									{
										CheckError(idx, ret, __LINE__);	
									}
									if (ret != 0) 
									{
										ret = 0;

										//off K3, K4
										ret = DriveCBit(idx, TPDispName[0], 0); CheckError(idx, ret, __LINE__);
	
										for (int i=0; i<total_tp; i++)
											tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
										goto test_end;
									}

									ret = acm[idx]->RunFG("ACM_CH", 0, true);
									_util->Wait_Sec(Measure_Delay_s);
								}
			
								loop_count++;
							}

							if (loop_count > max_loop)
							{
								ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
								ret += acm[idx]->StopFG("ACM_CH"); 
						
								//off K3, K4
								ret += DriveCBit(idx, TPDispName[0], 0);
								CheckError(idx, ret, __LINE__);
	
								for (int j=0; j<total_tp; j++)
									tf_SetResult_UUTOffset(TPName[j], (double)(INVALID_RESULT), idx);

								goto test_end;
							}
								
							ret = stopDigitizerDGTAcquire(idx,sourcePattern);	//ret = digitizer->StopAcquire("DIGITIZER");
							ret += acm[idx]->StopFG("ACM_CH"); 
					
							//off K3, K4
							ret += DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

//EW: Only override switch is not enable
if(Vswg_lpd_spd_calibrated->ContainsKey(idx.ToString() + "_" + Fswg_Test_Freq.ToString()) == false)		{
							Vswg_lpd_spd_calibrated->Add(idx.ToString() + "_" + Fswg_Test_Freq.ToString(), Vswg_cal);	//Vswg_lpd_spd_calibrated->Add(Fswg_Test_Freq, Vswg_cal);
							Vswg_lpd_spd_at_dut->Add(idx.ToString() + "_" + Fswg_Test_Freq.ToString(), vout_pp);	//Vswg_lpd_spd_at_dut->Add(Fswg_Test_Freq, vout_pp);
					}
			}
						
						//On K1, K2
						ret = DriveCBit(idx, TPDispName[0], 2);
						CheckError(idx, ret, __LINE__);
						
						//ret = SWG_Configure();
					 ret = SWG_Configure(idx, Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Ref.ToString()], fswg_test_freq[i], 0);						
						CheckError(idx, ret, __LINE__);
						
						/////////////////////////////////////////////////////
						//Fswg_Test

						Decimation_Factor = 16; //31.25MS/s
						nbrSamples = 8192;
		
						digitizer_setting[2] = (double)nbrSamples;
						digitizer_setting[14] = (double)Decimation_Factor;
				ret = DigitizerFFT_Configure(idx, digitizer_setting);
				CheckError(idx, ret, __LINE__);

String ^ Test_String1 = "Found " + idx.ToString() + "_" + Fswg_Test_Freq.ToString() + "," + Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Test_Freq.ToString()].ToString();
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Test_Freq.ToString()]/2, -1 * Vswg_lpd_spd_calibrated[idx.ToString() + "_" + Fswg_Test_Freq.ToString()]/2, Fswg_Test_Freq, 0);
						ret += Digitizer_Configure(idx, digitizer_setting);
						ret += acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);

						ret = DigitizerFFT_CaptureVpp(idx, sourcePattern, digitizer_setting, diff2se_digitizer_factor_dc, vout_pp);						

						if (ret)
						{
							for (int i=0; i<total_tp; i++)
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);

							goto test_end;
						}

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);

						//double vin_ratio	= Vswg_lpd_spd_at_dut[Fswg_Test_Freq] / Vswg_lpd_spd_at_dut[Fswg_Ref];
						double vin_ratio	= Vswg_lpd_spd_at_dut[idx.ToString() + "_" + Fswg_Test_Freq.ToString()] / Vswg_lpd_spd_at_dut[idx.ToString() + "_" + Fswg_Ref.ToString()];
						double vout_lpf		= 20 * Math::Log10(vout_pp * vin_ratio);
						double db_loss		= vout_ref - vout_lpf;
						double lfp_spd		= Fswg_Test_Freq * Math::Sqrt(Math::Pow(10, db_loss/10)-1);

						if (_util->IsInf(lfp_spd) == false)
						result[i] = lfp_spd;
						else
						result[i] = 0;

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
				}
			}

	test_end:
				
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//writer
	void TestProgram::iw_step3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result_iwx = gcnew array<double>(total_tp);
			array<double> ^ result_iwy = gcnew array<double>(total_tp);			

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				result_iwx[i] = 0;
				result_iwy[i] = 0;				
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int step				= (int)(tf_TestItemCondition_Cast("step"));

			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
				
			/*****Initialize*****/	//1st writer test in 2945
			ret = writer_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 3);
			CheckError(idx, ret, __LINE__);
		
			double iw_dac_dc_cm = 0;
			double diffp_V		= 0;
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			String ^ Vector_File;

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = step;
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = param_index + step;
				}

				ret = dm[idx]->DrivePin ("RWN", 0);
				CheckError(idx, ret, __LINE__);

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

				//param loop
				for (int i=param_index; i<loop; i++)
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
												
						//if(!USE_SPI) 
						//{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						//} 
						//else
						//{
						//	ret = RunSPI(idx, Vector_File);
						//	CheckError(idx, ret, __LINE__);
						//}
					}

					//X
					ret = dm[idx]->DrivePin("WDX", 1);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DrivePin("WDY", 0);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

					diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

					if (i == (step+param_index) - 1)
					{
						//connect N to GNDS
						ret = ResetMuxIO(idx);
						CheckError(idx, ret, __LINE__);
						ret = DriveMuxIO(idx, TPDispName[param_index], 1);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
						CheckError(idx, ret, __LINE__);

						//polarity
						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
							diffp_V = _glob->PolWR_DUT[hsel, idx]*diffp_V;
						else 
							diffp_V = _glob->PolWR_PROBE[hsel, idx]*diffp_V;
					
						diffp_V = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
					}

					result_iwx[i] = diffpn_V / CONST_Rw;
					result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);

					if (i == (step+param_index) - 1)
					{
						iw_dac_dc_cm = diffp_V - (result_iwx[i] / 2);
					}
					
				//Y
				ret = dm[idx]->DrivePin("WDX", 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DrivePin("WDY", 1);
				CheckError(idx, ret, __LINE__);

				//connect PN to diffAmp
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index], 0);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);
						
				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
				else 
					diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

				diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];				
				
				result_iwy[i] = (diffpn_V) / CONST_Rw;
				result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);

				result[i] = result_iwx[i];

				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
					_glob->Global_Result[idx, Global_Result_Index] = result[i];
				}
			}

			//copy result to front array so that process correctly for hsel1 onward
			if(hsel>0)
			{
				for(int i=0; i<step; i++)
				{
					result_iwx[i] = result_iwx[i+param_index];
					result_iwy[i] = result_iwy[i+param_index];
				}
			}
				
			/////////////////////////////////
			// X
			/////////////////////////////////

			double slope_iwx = 0;
			double offset_iwx = 0;
			array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,16,32,63};
			array<double> ^ result_iwx_tmp = gcnew array<double> (step);
			for (int k=0; k<step; k++)
			{
				//if (k == 0) result_iwx_tmp[k] = 0; //Special data changed for monotanicity quad apu resolution, follow Catalyst
				//else
				{
					result_iwx_tmp[k] = result_iwx[k];
				}
			}

			_util->line_fit(asym_iwx, result_iwx_tmp, step, slope_iwx, offset_iwx);

			tf_SetResult_UUTOffset(TPName[8+param_index], slope_iwx + GetOffset(idx, TPDispName[8+param_index]), idx);
			tf_SetResult_UUTOffset(TPName[9+param_index], offset_iwx + GetOffset(idx, TPDispName[9+param_index]), idx);

			int smallest_delta_index_iwx = 0;
			double smallest_delta_iwx = 0;

			smallest_delta_index_iwx = _util->monotonicity(result_iwx_tmp, step, 0, smallest_delta_iwx); //type = 0 (ascending)

			tf_SetResult_UUTOffset(TPName[10+param_index], smallest_delta_index_iwx + (int)GetOffset(idx, TPDispName[10+param_index]), idx);
			tf_SetResult_UUTOffset(TPName[11+param_index], smallest_delta_iwx / slope_iwx + GetOffset(idx, TPDispName[11+param_index]), idx);
			
			/////////////////////////////////
			// Y
			/////////////////////////////////

			double slope_iwy = 0;
			double offset_iwy = 0;
			array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,16,32,63};
			array<double> ^ result_iwy_tmp = gcnew array<double> (step);
			for (int k=0; k<step; k++)
			{
				result_iwy_tmp[k] = result_iwy[k];
			}

			_util->line_fit(asym_iwy, result_iwy_tmp, step, slope_iwy, offset_iwy);

			tf_SetResult_UUTOffset(TPName[12+param_index], slope_iwy + GetOffset(idx, TPDispName[12+param_index]), idx);
			tf_SetResult_UUTOffset(TPName[13+param_index], offset_iwy + GetOffset(idx, TPDispName[13+param_index]), idx);

			int smallest_delta_index_iwy = 0;
			double smallest_delta_iwy = 0;

			smallest_delta_index_iwy = _util->monotonicity(result_iwy_tmp, step, 1, smallest_delta_iwy); //type = 1 (decending)

			tf_SetResult_UUTOffset(TPName[14+param_index], smallest_delta_index_iwy + (int)GetOffset(idx, TPDispName[14+param_index]), idx);
			tf_SetResult_UUTOffset(TPName[15+param_index], smallest_delta_iwy / slope_iwy + GetOffset(idx, TPDispName[15+param_index]), idx);		

			/////////////////////////////////
			array<double> ^ iw_dac_asy= gcnew array<double>(step+param_index);
			double iw_dac_asy_fabs = 0;
			double iw_asy_max = 0;
			int iw_asy_max_dac = 0;
			
			for(int k=0; k<step; k++)
			{	
				if(Math::Abs(result_iwx[k]) == Math::Abs(result_iwy[k]))
					iw_dac_asy[k] = 0;
				else 
					//iw_dac_asy[k] = (Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k])) / ((Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]))/2);
					iw_dac_asy[k] = ((result_iwx[k]) - (result_iwy[k])) / ((result_iwx[k]) - (result_iwy[k])/2);				
			}
				
			for(int k=5; k<step; k++)
			{
				iw_dac_asy_fabs = Math::Abs(iw_dac_asy[k]);

				if(iw_dac_asy_fabs > iw_asy_max)
				{
					iw_asy_max = iw_dac_asy_fabs;
					iw_asy_max_dac = k;
				}
			}

			tf_SetResult_UUTOffset(TPName[16+param_index], iw_asy_max_dac + (int)GetOffset(idx, TPDispName[16+param_index]), idx);
			tf_SetResult_UUTOffset(TPName[17+param_index], iw_dac_asy[iw_asy_max_dac] + GetOffset(idx, TPDispName[17+param_index]), idx);
			tf_SetResult_UUTOffset(TPName[18+param_index], iw_dac_dc_cm + GetOffset(idx, TPDispName[18+param_index]), idx);
		}
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::iw_supply3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			int vector_engine_status = 0;
			Stopwatch swatch;

			/*****Initialize*****/
			//if(Debug_Enable == true)
			//{
				ret = writer_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			//}	

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//if(!USE_SPI)
			//{
			//	ret = RunVectorFile(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			int hsel		= 0;
			double diffpn_V = 0;
			int data		= 0;
			int Drive_WDX	= 0;
			int Drive_WDY	= 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			/*****Start Test*****/
			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_WDX") == true)
				{
					Drive_WDX = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDX"));

					ret = dm[idx]->DrivePin("WDX", Drive_WDX);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_WDY") == true)
				{
					Drive_WDY = (int)(tf_TPCondition_Cast(TPName[i], "Drive_WDY"));

					ret = dm[idx]->DrivePin("WDY", Drive_WDY);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(On_Delay_s);

				if (i == 0)
				{
					//if(!USE_SPI) 
					//{
					//	ret = ReadVector(idx, Vector_File, data);
					//	CheckError(idx, ret, __LINE__);
					//} 
					//else 
					//{
					//	ret = ReadSPI(idx, Vector_File, data);
					//	CheckError(idx, ret, __LINE__);
					//}	
							
					ret = ReadVector(idx, Vector_File, data);
					CheckError(idx, ret, __LINE__);

					//OnOffSPI(idx, 1);
					//ret = ReadReg(idx, 1, 2, data);
					//CheckError(idx, ret, __LINE__);
					//OnOffSPI(idx, 0);

					//OnOffSPI(idx, 1);
					//ret = ReadSPI(idx, Vector_File, data);
					//CheckError(idx, ret, __LINE__);
					//OnOffSPI(idx, 0);

					if (ret == 0)
						//result[i] = data  & 0x3F;	//ML 2935 (data >> 4) & 0x0F;
						result[i] = data; 
					else
						result[i] = INVALID_RESULT;
					
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (TPDispName[i]->Contains("Y_Sply_Dev")) //TP1-4
				{
					double max = 0;
					double min = 0;

					for (int k=1; k<=4; k++)
					{
						if (k == 1)
						{
							min = max = result[k];
							min = max = result[k];
						}	
						else
						{
							if(result[k] > max)
								max = result[k];

							if(result[k] < min)
								min = result[k];
						}
					}

					result[i] = max - min;
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else if (TPDispName[i]->Contains("X_Sply_Dev")) //TP5-8
				{
					double max = 0;
					double min = 0;

					for (int k=5; k<=8; k++)
					{
						if (k == 5)
						{
							min = max = result[k];
							min = max = result[k];
						}	
						else
						{
							if(result[k] > max)
								max = result[k];

							if(result[k] < min)
								min = result[k];
						}
					}

					result[i] = max - min;
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{				
					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

					diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];	
					result[i] = diffpn_V / CONST_Rw;
			
					if (TPDispName[i]->Contains("X"))
						result[i] = result[i] * (1 - 0.09 * result[i] / 0.07);
					else //Y
						result[i] = result[i] * (1 + 0.09 * result[i] / 0.07);

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}
			
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::iw_unsel_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_P_H0	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P_H0"));
			String ^ Test_Pin_N_H0	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N_H0"));
			String ^ Test_Pin_P_H1	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P_H1"));
			String ^ Test_Pin_N_H1	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N_H1"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File1	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File	= "";
			int Measure_Mode		= 0;
			double RWOpen			= CONST_Rw + CONST_Rwo;			
			int local_barrierCount	= (int)(tf_TestItemCondition_Cast("barrier_index"));
			
			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize (Serial)*****/
			ret = writer_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);			
			
			//Configure P_H0
			ret = dm[idx]->Force(Test_Pin_P_H0, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P_H0, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P_H0, Math::Abs(Clamp_Vo_V), 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P_H0, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P_H0, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P_H0);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P_H0, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			//Configure P_H1
			ret = dm[idx]->Force(Test_Pin_P_H1, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P_H1, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P_H1, Math::Abs(Clamp_Vo_V), 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P_H1, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P_H1, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P_H1);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P_H1, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			//Configure N_H0
			ret = dm[idx]->Force(Test_Pin_N_H0, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N_H0, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N_H0, Math::Abs(Clamp_Vo_V), 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N_H0, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N_H0, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N_H0);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N_H0, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			//Configure N_H1
			ret = dm[idx]->Force(Test_Pin_N_H1, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N_H1, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N_H1, Math::Abs(Clamp_Vo_V), 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N_H1, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N_H1, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N_H1);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N_H1, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);
			
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);

			//Control GNDS FET
			ret = Probe_Card_FET_Control(0, 0, 1, 0);
			
			double diffp_V		= 0;
			double diffn_V		= 0;
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			double volt			= 0;
			String ^ Test_Pin_P;	
			String ^ Test_Pin_N;

			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
					Test_Pin_P = Test_Pin_P_H0;
					Test_Pin_N = Test_Pin_N_H0;
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
					Test_Pin_P = Test_Pin_P_H1;
					Test_Pin_N = Test_Pin_N_H1;
				}		
					
				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index], 1);
				CheckError(idx, ret, __LINE__);

				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File1);
					CheckError(idx, ret, __LINE__);
				//}
				//else 
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx, Vector_File1);
				//	CheckError(idx, ret, __LINE__);
				//}

				ret = Probe_Card_FET_Control(0, 0, 1, 0);

			for (int i=param_index; i<loop; i++)
			{
				if (TPName[i]->StartsWith("WHST"))
					ret = Probe_Card_FET_Control(0, 1, 1, 0);
				
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					//} 
					//else 
					//{
					//	ret = RunSPI(idx, Vector_File);
					//	CheckError(idx, ret, __LINE__);
					//}
				}

				if (TPName[i]->StartsWith("IW_flt"))
				{
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, 0.05, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, 0.05, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);

					ret = Configure_GNDS_Mux(idx, NPLC);
					CheckError(idx, ret, __LINE__);

					ret = DriveDMPin(idx, TPDispName[i]);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[param_index], 0);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);					

					ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(idx, ret, __LINE__);				
				
					if (!SingleSiteTest)
					{
						//*****Start Barrier*****/
						for(int s = 0; s<_numOffset; s++)
						{
							if(!run_test[s])
								__barriers[local_barrierCount]->Signal(s); //auto set the flag of non-test site so that it won't fall into infinite waiting loop
						}
						Barrier(local_barrierCount, idx);
						local_barrierCount++;
						//*****End Barrier*****/
					}
						
					ret = DriveMuxIO(idx, TPDispName[param_index], 0);
					CheckError(idx, ret, __LINE__);

					ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
					CheckError(idx, ret, __LINE__);

					if (!SingleSiteTest)
					{
						/*****Start Barrier*****/
						for(int s = 0; s<_numOffset; s++)
						{
							if(!run_test[s])
								__barriers[local_barrierCount]->Signal(s); //auto set the flag of non-test site so that it won't fall into infinite waiting loop
						}
						Barrier(local_barrierCount, idx);
						local_barrierCount++;
						/*****End Barrier*****/
					}
					diffp_V = diffp_V - volt;
					diffn_V = diffn_V - volt;
					result[i] = (diffp_V - diffn_V) / RWOpen;

					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ConfigureSamplingTime("GND_MUX_SENSE", NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);

				}
				else
				{
					ret = DriveDMPin(idx, TPDispName[i]);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);		
				
					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveMuxIO(idx, TPDispName[param_index], 2);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveMuxIO(idx, TPDispName[param_index], 1);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					{
						diffp_V = _glob->PolWR_DUT[hsel, idx]*diffp_V;
						diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
					}
					else 
					{
						diffp_V = _glob->PolWR_PROBE[hsel, idx]*diffp_V;
						diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;
					}

					diffp_V = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
					diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

				if (tf_TPCondition_exist(TPName[i], "Measure_Mode") == true)
				{
					Measure_Mode = (int)(tf_TPCondition_Cast(TPName[i], "Measure_Mode"));

					if (Measure_Mode == AM_CONST_MEASURECURRENT || Measure_Mode == DM_CONST_MEASURECURRENT)
					{
						//iw_unsel
						//iw_rd_unsel
						//iw_off
						//who_i

						result[i] = diffpn_V  / RWOpen;
					}
					else
					{
						//wxv_unsel
						//wyv_unsel
						//wxv_rd_unsel
						//wxv_rd_unsel
						//who_v

						result[i] = diffp_V;
					}
				}
			}
			if (i == 3 || i == 8) //who_i #ml 2935 is i ==7
			{
				_glob->global_who_i[idx, hsel] = result[i];
			}

			if (i == 4 || i == 9) //who_v #ml 2935 is i ==8 
			{
				_glob->global_who_v[idx, hsel] = result[i];
			}

			tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[(loop-1)]);
			CheckError(idx, ret, __LINE__);
		}
			
		/*****Power down*****/
		ret = Probe_Card_FET_Control(0, 1, 0, 0);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if(run_test[idx])
			{
				//Power down supplies
				ret = smu[idx]->DriveVoltage("VEE", 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveVoltage("VCC", 0);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}
	}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::osd_spd(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
			double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			int step				= (int)(tf_TestItemCondition_Cast("step"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleType = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin, moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType = DM_CONST_MODULE_TYPE;
			}

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampCurrent(Test_Pin, Clamp_Io_A);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveVoltage(Test_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveVoltage(Test_Pin, Drive_Vo_V);
				CheckError(idx, ret, __LINE__);
			}

			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);
												
			//if(!USE_SPI) 
			//{
			//	ret = RunVectorFile(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//} 
			//else
			//{
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			for (int i=0; i<step; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
	
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);

					//if(!USE_SPI) 
					//{
					//	ret = RunVectorFile(idx, Vector_File);
					//	CheckError(idx, ret, __LINE__);
					//} 
					//else
					//{
					//	ret = RunSPI(idx, Vector_File);
					//	CheckError(idx, ret, __LINE__);
					//}
				}

				_util->Wait_Sec(Measure_Delay_s);

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result[i]);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = smu[idx]->ReadCurrent(Test_Pin, result[i]);
					CheckError(idx, ret, __LINE__);
				}

				result[i] = Math::Abs(result[i]);

				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
			}

			/////////////////////////////////

			//ML mask lines below - not in 2945
			//double slope = 0;
			//double offset = 0;
			//array<int> ^ x = gcnew array<int> {0,1,2,3,4,8,15};		//ML 2935 0,1,2,3,4,8,15

			//_util->line_fit(x, result, step, slope, offset);

			//int smallest_delta_index_x = 0;
			//double smallest_delta_x = 0;

			//smallest_delta_index_x = _util->monotonicity(result, step, 1, smallest_delta_x); //type = 1 (decending)

			//tf_SetResult_UUTOffset(TPName[7], smallest_delta_index_x + (int)GetOffset(TPDispName[7]));	//ML - not in 2945
			//tf_SetResult_UUTOffset(TPName[8], smallest_delta_x / slope + GetOffset(TPDispName[8]));		//ML - not in 2945

			/////////////////////////////////
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::osa_step3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result_iwx = gcnew array<double>(total_tp);
			array<double> ^ result_iwy = gcnew array<double>(total_tp);			

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				result_iwx[i] = 0;
				result_iwy[i] = 0;				
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			//String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			int step				= (int)(tf_TestItemCondition_Cast("step"));

			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";
			
			int vector_engine_status = 0;
			Stopwatch swatch;	
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			//if(Debug_Enable == true)
			//{
				ret = writer_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			//}	

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
		
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);
			
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			String ^ Vector_File;			
			String ^ Vector_File_1	= String::Empty;
			double iosmax_x		= 0; 
			double iosmax_y		= 0;
			double reference_x	= 0;
			double reference_y	= 0;

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = step;
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = param_index + step;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));

				//ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
				//CheckError(idx, ret, __LINE__);

				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

				//param loop
				for (int i=param_index; i<loop; i++)	//i<step
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
						if(!USE_SPI) {
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						} else {
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						}
					}

					// X

					ret = dm[idx]->DrivePin("WDX", 1);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DrivePin("WDY", 0);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);
				
					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

					diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

					result_iwx[i] = diffpn_V / CONST_Rw;

					if (i == 0 || i == 17)
					{
						reference_x = result_iwx[i];

						int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_X"));
							_glob->Global_Result[idx, Global_Result_Index] = reference_x;		
					}

					result_iwx[i] = result_iwx[i] - reference_x;
					//result_iwx[i] = result_iwx[i] * (1 - 0.09 * result_iwx[i] / 0.07);	//ML 2935 specified
					
					// Y
					ret = dm[idx]->DrivePin("WDX", 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DrivePin("WDY", 1);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);
					
					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

					diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

					result_iwy[i] = diffpn_V / CONST_Rw;					
					
					if (i == 0 || i== 17)
					{
						reference_y = result_iwy[i];

						int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Y"));
							_glob->Global_Result[idx, Global_Result_Index] = reference_y;
					}
				
					result_iwy[i] = result_iwy[i] - reference_y;
					//result_iwy[i] = result_iwy[i] * (1 + 0.09 * result_iwy[i] / 0.07);	//ML 2935 specified

					result[i] = result_iwx[i];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
					{
						int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}
				}

				for (int i=0; i<total_tp; i++)
				{
					if (TPName[i]->Contains("rng1_K0") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
						if(!USE_SPI) {
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						} else {
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						}
					//}
	
						// rng1_K0
						ret = dm[idx]->DrivePin("WDX", 1);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->DrivePin("WDY", 0);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);
					
						//double diffp_V_rng1 =0;
						//double diffn_V_rng1 =0;
						
						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
						CheckError(idx, ret, __LINE__);
						
						//polarity
						if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
							diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
						else 
							diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

						diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];
						
						double result_osa_p1 = 0;
						result_osa_p1 = ( diffpn_V/ CONST_Rw ) - reference_x;
						tf_SetResult_UUTOffset(TPName[i], result_osa_p1 + GetOffset(idx, TPDispName[i]), idx);
					}
				}
				//copy result to front array so that process correctly for hsel1 onward
				if(hsel>0)
				{
					for(int i=0; i<step; i++)
					{
						result_iwx[i] = result_iwx[i+param_index];
						result_iwy[i] = result_iwy[i+param_index];
					}
				}
				
				/////////////////////////////////
				// X
				/////////////////////////////////
				double slope_iwx = 0;
				double offset_iwx = 0;
				array<int> ^ asym_iwx = gcnew array<int> {0,1,2,4,8,15};

				_util->line_fit(asym_iwx, result_iwx, step, slope_iwx, offset_iwx);

				tf_SetResult_UUTOffset(TPName[7+param_index], slope_iwx + GetOffset(idx, TPDispName[7+param_index]), idx);	//6
				tf_SetResult_UUTOffset(TPName[8+param_index], offset_iwx + GetOffset(idx, TPDispName[8+param_index]), idx);	//7

				int smallest_delta_index_iwx = 0;
				double smallest_delta_iwx = 0;

				smallest_delta_index_iwx = _util->monotonicity(result_iwx, step, 0, smallest_delta_iwx); //type = 0 (ascending)

				tf_SetResult_UUTOffset(TPName[9+param_index], smallest_delta_index_iwx + (int)GetOffset(idx, TPDispName[9+param_index]), idx);	//8
				tf_SetResult_UUTOffset(TPName[10+param_index], smallest_delta_iwx / slope_iwx + GetOffset(idx, TPDispName[10+param_index]), idx);	//9
			
				/////////////////////////////////
				// Y
				/////////////////////////////////

				double slope_iwy = 0;
				double offset_iwy = 0;
				array<int> ^ asym_iwy = gcnew array<int> {0,1,2,4,8,15};

				_util->line_fit(asym_iwy, result_iwy, step, slope_iwy, offset_iwy);

				tf_SetResult_UUTOffset(TPName[11+param_index], slope_iwy + GetOffset(idx, TPDispName[11+param_index]), idx);	//10
				tf_SetResult_UUTOffset(TPName[12+param_index], offset_iwy + GetOffset(idx, TPDispName[12+param_index]), idx);	//11

				int smallest_delta_index_iwy = 0;
				double smallest_delta_iwy = 0;

				smallest_delta_index_iwy = _util->monotonicity(result_iwy, step, 1, smallest_delta_iwy); //type = 1 (decending)

				tf_SetResult_UUTOffset(TPName[13+param_index], smallest_delta_index_iwy + (int)GetOffset(idx, TPDispName[13+param_index]), idx);	//12
				tf_SetResult_UUTOffset(TPName[14+param_index], smallest_delta_iwy / slope_iwy + GetOffset(idx, TPDispName[14+param_index]), idx);	//13

				/////////////////////////////////				
				array<double> ^ iw_dac_asy= gcnew array<double>(step);
				double iw_dac_asy_fabs = 0;
				double iw_asy_max = 0;
				int iw_asy_max_dac = 0;
				
				for(int k=0; k<step; k++)
				{	
					iw_dac_asy[k] = Math::Abs(result_iwx[k]) - Math::Abs(result_iwy[k]);
				}

				int dac_fill[]={0,1,2,4,8,15};		//added by sidi to solve 2nd last param dec
				for(int k=5; k<step; k++)
				{
					iw_dac_asy_fabs = abs(iw_dac_asy[k]);

					if(iw_dac_asy_fabs > iw_asy_max)
					{
						iw_asy_max = iw_dac_asy_fabs;
						iw_asy_max_dac = dac_fill[k];	//2935 iw_asy_max_dac = k;
					}
				}

				//tf_SetResult_UUTOffset(TPName[15], iw_dac_asy[step-1] + GetOffset(TPDispName[15]));
				tf_SetResult_UUTOffset(TPName[15+param_index], iw_asy_max_dac + (int)GetOffset(idx, TPDispName[15+param_index]), idx);
				tf_SetResult_UUTOffset(TPName[16+param_index], iw_asy_max + GetOffset(idx, TPDispName[16+param_index]), idx);
			
			}
				/////////////////////////////////
				
				/*****Power down*****/
				if(USE_SPI) 
				{
					ret = OnOffSPI(idx, 0);
					CheckError(idx, ret, __LINE__);
				}

				if(Debug_Enable == true)
				{
					ret = ResetDMPin(idx, TPDispName[0]);
					CheckError(idx, ret, __LINE__);

					//Power down supplies
					//ret = smu[idx]->DriveVoltage("VEE", 0);
					//CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveVoltage("VCC", 0);
					CheckError(idx, ret, __LINE__);

					//IO setting
					ret = ResetCBit(idx);
					CheckError(idx, ret, __LINE__);
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
				}
			}

			catch (Exception^ ex) 
			{
				d->Exception = ex;
				d->ErrorCode = ret;
			}
	}
	void TestProgram::servo(Object^ object)	
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result_servo = gcnew array<double>(total_tp); //array<double> ^ result	= gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result_servo[i]	= 0;   //result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed	= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			//int SPD_Channel				= _glob->SPD_Channel_Number;
			double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File		= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
				
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			array<int>^ HistoryRam = gcnew array<int>(256);	
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			//ret = DriveDIOPin(TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);		
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			unsigned int moduleType  = 0;
			unsigned int TestPinP_moduleType  = 0;
			unsigned int TestPinN_moduleType  = 0;

			//if(!USE_SPI) 
			//{
			//	ret = RunVectorFile(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//} 
			//else
			//{
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			for (int i = 0; i < total_tp; i++)		//i < HDS + 1
			{
				String ^ Test_Pin_N			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin_N"));
				String ^ Test_Pin_P			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin_P"));

				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
				//ret = DriveCBit(idx, TPDispName[i]);
				//CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);

				double diffp_V = 0;
				double diffn_V = 0;

				// DICV pin (WRxP)
				try
				{
					ret = smu[idx]->QueryModuleType(Test_Pin_P, TestPinP_moduleType);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					TestPinP_moduleType = DM_CONST_MODULE_TYPE;
				}

				if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2); //
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin_P);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin_P, Clamp_Vo_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_P, Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}
				
				// DICV pin (WRxN)
				try
				{
					ret = smu[idx]->QueryModuleType(Test_Pin_N, TestPinN_moduleType);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					TestPinN_moduleType = DM_CONST_MODULE_TYPE;
				}

				if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2); 
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin_N);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin_N, Clamp_Vo_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_N, Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}
							
				_util->Wait_Sec(Measure_Delay_s);

				double result_servo = 0;

				if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(idx, ret, __LINE__);
					//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					//CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(idx, ret, __LINE__);
					//ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
					//CheckError(idx, ret, __LINE__);
				}	

				if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(idx, ret, __LINE__);
				}	
				
				result_servo = Math::Abs(diffp_V - diffn_V) / CONST_Rw;
				result_servo = result_servo * (1 - 0.09 * result_servo / 0.07);			

				tf_SetResult_UUTOffset(TPName[i], result_servo + GetOffset(idx, TPDispName[i]), idx);
			}
			
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//heater
	void TestProgram::heater_sup_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			//String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			//double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			//double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			int Range				= (int)(tf_TestItemCondition_Cast("Range"));
			int DAC					= (int)(tf_TestItemCondition_Cast("DAC"));

			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";
			
			//int Drive_RWN			= 1; //SL:0

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			ret = heater_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			double diffpn_V			= 0;
			int data				= 0;
			int Drive_RWN			= 1;
			array<int>^ HistoryRam = gcnew array<int>(256);	

			//set CBit & MUX
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
						
			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//}
			//else
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}
				
			tf_SetResult_UUTOffset(TPName[0], Range + (int)GetOffset(idx, TPDispName[0]), idx);
			tf_SetResult_UUTOffset(TPName[1], DAC + (int)GetOffset(idx, TPDispName[1]), idx);

			for (int i=2; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_RWN") == true)
				{
					Drive_RWN = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWN"));

					ret = dm[idx]->DrivePin("RWN", Drive_RWN);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(On_Delay_s);
				
				if (TPName[i]->Contains("Dev"))
				{
					double min = 0;
					double max = 0;

					int start = 0;
					int stop = 0;

					if (TPName[i]->Contains("Rd"))
					{
						start = 2;
						stop = 5;
					}
					else //Wt
					{
						start = 7;
						stop = 10;
					}

					for(int k=start; k<=stop; k++) // start from the 4th until 7th parameter only
					{
						if(k == start)
						{
							min = max = result[k]; 
						}
						else
						{
							if(result[k] > max)
								max = result[k];

							if(result[k] < min)
								min = result[k];
						}		
					}

					result[i] = max - min;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					result[i] = (diffpn_V * diffpn_V) / CONST_RhNom;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::heater_servo(Object^ object)	//used for both heater_rsrv & wsrv
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result_servo = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result_servo[i]	= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed	= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;

			double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File		= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
				
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			array<int>^ HistoryRam = gcnew array<int>(256);	
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);		
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			unsigned int moduleType  = 0;
			//unsigned int TestPinP_moduleType  = 0;
			//unsigned int TestPinN_moduleType  = 0;

			//if(!USE_SPI) 
			//{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//} 
			//else
			//{
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}
			
			for (int i = 0; i <total_tp; i++)
			{
				String ^ Test_Pin			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));

				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
				//ret = DriveCBit(idx, TPDispName[i]);
				//CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);

				double volt = 0;

				// Check whether resource is SMU or DM
				try
				{
					ret = smu[idx]->QueryModuleType(Test_Pin, moduleType);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					moduleType = DM_CONST_MODULE_TYPE;
				}

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
					ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Io_A);
					CheckError(idx, ret, __LINE__);
				}

				double val = 0;
				ret = Configure_GNDS_Mux(idx, NPLC);
				CheckError(idx, ret, __LINE__);
				
				//Set Hsel
				//ret += RunVectorFile(Vector_File_Hsel);
				
					//double volt = 0;
					double result_servo = 0;

				if (moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, volt);
					CheckError(idx, ret, __LINE__);

				}
				else
				{
					ret = smu[idx]->ReadVoltage(Test_Pin, volt);
					CheckError(idx, ret, __LINE__);
				}	

				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, val);
				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(idx, ret, __LINE__);
				volt = volt - val;	
				
				result_servo = volt;
					
				tf_SetResult_UUTOffset(TPName[i], result_servo + GetOffset(idx, TPDispName[i]), idx);
			}
			
			/////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
						
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::heater_slew2(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{

			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			//String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Test_Pin		= "";
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			int Global_Result_Index	= 0;
			double PHi = 0;
			double PLo = 0;
			double Vdiff = 0;
			double P90 = 0;
			double P10 = 0;

			int tmu_start_range = 0;
			int tmu_stop_range = 0;
			double tmu_start_threshold = 0;
			double tmu_stop_threshold = 0;
			double tmu_start_hysteresis = 0;
			double tmu_stop_hysteresis = 0;
			int number_of_samples = 0;
			double tmu_timeout = 0;
			int returned_sample_count = 0;
			array<double> ^ sampled_result;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			double tm_heater_fast_slew_factor = 0;

			if (calfactor->ContainsKey("TM_HEATER_FAST_SLEW"))
				tm_heater_fast_slew_factor = calfactor["TM_HEATER_FAST_SLEW"][idx];

			Stopwatch swatch;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			//ret = DriveCBit(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			//ret = DriveMuxIO(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//When CBIT is turned on, TMU is connected. From previous TMU tests (DGF/DGT), 50-ohm range is selected, so DM measurement will be incorrect. Reset TMU range here first.
			ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_2_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
			CheckError(idx, ret, __LINE__);
			ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_2_1MOHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleType = 0;

			//if(!USE_SPI) {
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//} else {
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			for (int i=0; i<total_tp; i++)
			{

				if (i % 8 == 0)		//2935 has 6 params only, (i % 6 == 0)	
				{		
					if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
					{
						Test_Pin = (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
							
						// Check whether resource is SMU or DM
						try
						{
							ret = smu[idx]->QueryModuleType(Test_Pin, moduleType);
							CheckError(idx, ret, __LINE__);
						}
						catch (Exception ^) //not a smu resource if exception occurs
						{
							moduleType = DM_CONST_MODULE_TYPE;
						}

						if (moduleType == DM_CONST_MODULE_TYPE) //dm
						{
							ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->DPINOn(Test_Pin);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(On_Delay_s);
							ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
							CheckError(idx, ret, __LINE__);
						}
						else //smu
						{
							ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->DriveCurrent(Test_Pin, 0);
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
							CheckError(idx, ret, __LINE__);
							_util->Wait_Sec(On_Delay_s);
							ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Io_A);
							CheckError(idx, ret, __LINE__);
						}
					
						ret = ResetCBit(idx);
						CheckError(idx, ret, __LINE__);
						ret = ResetMuxIO(idx);
						CheckError(idx, ret, __LINE__);

						//
						ret = DriveCBit(idx, TPDispName[i]);
						CheckError(idx, ret, __LINE__);
						ret = DriveMuxIO(idx, TPDispName[i]);
						CheckError(idx, ret, __LINE__);

					}
				}
				
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
					
					//if(!USE_SPI) {
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					//} else {
					//ret = RunSPI(idx, Vector_File);
					//CheckError(idx, ret, __LINE__);
					//}
				}

				if (TPName[i]->StartsWith("SRHV_"))		//ML change to SRHV_
				{
					if (TPName[i]->Contains("Vlo"))
					{
						ret = dm[idx]->DrivePin("RWN", 0);	//1
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = dm[idx]->DrivePin("RWN", 1);	//0
						CheckError(idx, ret, __LINE__);
					}

					_util->Wait_Sec(On_Delay_s);

					if (moduleType == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result[i]);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->ReadVoltage(Test_Pin, result[i]);
						CheckError(idx, ret, __LINE__);
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}

					if (TPName[i]->Contains("Vlo"))
					{
						PLo = result[i];
					}
					else //Vhi
					{
						PHi = result[i];
					}
				}
				else
				{
					ret = dm[idx]->DrivePin("RWN", 0); //Lo		//1
					CheckError(idx, ret, __LINE__);

					if (moduleType == DM_CONST_MODULE_TYPE) //dm
					{
						ret = dm[idx]->DPINOff(Test_Pin);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = smu[idx]->OffSmuPin(Test_Pin);
						CheckError(idx, ret, __LINE__);
					}

					Vdiff = PHi - PLo;
					P90 = PHi - 0.1*Vdiff; 
					P10 = PLo + 0.1*Vdiff;

					if(P90>5)
					{
						P90 = 5;
					}
					if(P10<0)
					{
						P10 = 0;
					}

					if (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_DUT)
					{
						//For TMU range2 
						tmu_start_threshold = 0.396 * P10 + 0.030;
						tmu_stop_threshold = 0.396 * P90 + 0.030;

						tmu_start_threshold = 58.255 * tmu_start_threshold + (-14.817);
						tmu_stop_threshold = 61.255 * tmu_stop_threshold + (-14.817);
						
						tmu_start_hysteresis = 38 * 0.01; //max for 5V is 20mV
						tmu_stop_hysteresis = 38 * 0.01;

						tmu_start_range = TM_CONST_RANGE_2_1MOHM;
						tmu_stop_range = TM_CONST_RANGE_2_1MOHM;
					}
					else
					{
						tmu_start_threshold = P10;
						tmu_stop_threshold = P90;
						tmu_start_hysteresis = 0.02;
						tmu_stop_hysteresis = 0.02;

						tmu_start_range = TM_CONST_RANGE_0_50OHM;
						tmu_stop_range = TM_CONST_RANGE_0_50OHM;
					}

					tmu_timeout = 10e-3;

					number_of_samples = 1;

					sampled_result = gcnew array<double>(number_of_samples);

					int retest_count = 0;

	RETEST:

					ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_start_range, tmu_start_threshold, tmu_start_hysteresis, 0);
					if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
					{
						for (int z=0; z<total_tp; z++)
						{	
							result[i] = 999;
						}
						ret = 0;
						goto TEST_END;
					}

					CheckError(idx, ret, __LINE__);

					ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_stop_range, tmu_stop_threshold, tmu_stop_hysteresis, 0);
					if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
					{
						for (int z=0; z<total_tp; z++)
						{	
							result[i] = 999;
						}
						ret = 0;
						goto TEST_END;
					}

					CheckError(idx, ret, __LINE__);
					//_util->Wait_Sec(On_Delay_s);

					ret = dm[idx]->DrivePin("RWN", 0); //Lo	//1
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);

					ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);
		
					ret = dm[idx]->DrivePin("RWN", 1); //Hi	//0
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);

					ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

					if (ret)
					{
						result[i] = 999;
						ret = 0;
					}
					else
					{
						//result[i] = Vdiff / (sampled_result[0] * 1e6); //V/us
						result[i] = (P90-P10) / (sampled_result[0] * 1e6); //V/us
					}

					if (TPName[i]->Contains("K3"))
					{
						result[i] = result[i] + tm_heater_fast_slew_factor;
					}

					double max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
					double min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));

					if ((result[i] < min_limit) || (result[i] > max_limit))
					{
						if (retest_count < TIMING_RESET_COUNT)
						{
							retest_count++;
							goto RETEST;
						}
					}

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
					{
						Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}
				}
			}

			/////////////////////////////////

	TEST_END:

			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::heater_power(Object^ object)	//seq_heater_rng
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);	//array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result2 = gcnew array<double>(total_tp);	//array<double> ^ result2 = gcnew array<double>(total_tp);	

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				result2[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Vector_File	= String::Empty;
			String ^ Measure_Pin	= "VCC";
			String ^ Test_Pin		= "HTR0_F";
				
			double Drive_Io_A		= 0;
			double Clamp_Vo_V		= 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			array<int>^ HistoryRam = gcnew array<int>(256);

			int vector_engine_status = 0;
			Stopwatch swatch;
			
			int data = 0;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			//ret = DriveCBit(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			//ret = DriveMuxIO(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleType = 0;
			
			//ML to setup HTR0_F hardware here!!!
			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin, moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleType = DM_CONST_MODULE_TYPE;
			}

			if (moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(On_Delay_s);
				ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Io_A);
				CheckError(idx, ret, __LINE__);
			}


			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = OnOffSPI(idx, 1);
						CheckError(idx, ret, __LINE__);
						ret = RunSPI(idx,Vector_File);	
						CheckError(idx, ret, __LINE__);
					}					
				}

				_util->Wait_Sec(On_Delay_s);
				
				if (tf_TPCondition_exist(TPName[i], "Measure_Pin") == true)
				{
					Measure_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Measure_Pin"));
					
					if (Measure_Pin == "VCC")
						ret = smu[idx]->ReadCurrent("VCC", result[i]);
						CheckError(idx, ret, __LINE__);

					if (Debug_Enable == true)
					{
						double volt_vcc = 0;
						ret = smu[idx]->ReadVoltage("VCC", volt_vcc);
						CheckError(idx, ret, __LINE__);
					}
				}			
				
				if (tf_TPCondition_exist(TPName[i], "Test_Pin") == true)
				{
					Test_Pin	= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin"));
					
					if (Test_Pin == "HTR0_F") {
						//ret = smu[idx]->ReadVoltage("HTR0_F", result2[i]);	//ret = smu[idx]->ReadCurrent("VCC", result2[i]);

						//double volt = 0;
						if (moduleType == DM_CONST_MODULE_TYPE) //dm
						{
						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result2[i]);
						CheckError(idx, ret, __LINE__);
						}
						else
						{
						ret = smu[idx]->ReadVoltage(Test_Pin, result2[i]);
						}

						double val = 0;
						ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
						CheckError(idx, ret, __LINE__);
						result2[i] = result2[i] - val;
					}
					
				} //existing
							
					array<double> ^ reading = gcnew array<double>(15);
					double icc_target_vht_lo = 0;
					double icc_target_vht_hi = 0;
					double icc_target_pht_lo = 0;
					double icc_target_pht_hi = 0;
					double RhNom = 100; 
					
					reading[0] = result[0];
					reading[1] = result2[1];
					reading[2] = result2[2];
					reading[3] = result2[3];
					reading[4] = result2[4];
					reading[5] = result[1] - result[0];
					reading[6] = result[2] - result[0];
					reading[7] = result[3] - result[0];
					reading[8] = result[4] - result[0];
					
					icc_target_vht_lo = 1.3e-3 + (0.315e-3 * result2[1]) + (1.03 * (result2[1] / CONST_RhNom)); //RhNom
					icc_target_vht_hi = 1.3e-3 + (0.315e-3 * result2[2]) + (1.03 * (result2[2] / CONST_RhNom));
					icc_target_pht_lo = 1.3e-3 + (0.315e-3 * result2[3]) + (1.03 * (result2[3] / CONST_RhNom));
					icc_target_pht_hi = 1.3e-3 + (0.315e-3 * result2[4]) + (1.03 * (result2[4] / CONST_RhNom));
					
					reading[9]  = (reading[5] / icc_target_vht_lo) - 1.0;
					reading[10] = (reading[6] / icc_target_vht_hi) - 1.0;
					reading[11] = (reading[7] / icc_target_pht_lo) - 1.0;
					reading[12] = (reading[8] / icc_target_pht_hi) - 1.0;
					
					//tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					tf_SetResult_UUTOffset(TPName[i], reading[i] + GetOffset(idx, TPDispName[i]), idx);
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::heater_blank(Object^ object)
	{
		//heater_slew must run prior to blanking tests to get PHi, PLo and PSlew

		//TMU START: RWN
		//TMU STOP: HEATER
		
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double tm_heater_dig_delay_factor = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			//String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			int PLo_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PLo_Global_Result_Index"));
			int PHi_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PHi_Global_Result_Index"));
			int PSlew_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("PSlew_Global_Result_Index"));

			int VLo_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("VLo_Global_Result_Index"));
			int VHi_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("VHi_Global_Result_Index"));
			int VSlew_Global_Result_Index	= (int)(tf_TestItemCondition_Cast("VSlew_Global_Result_Index"));

			int PLo_Global_Result_Index1	= (int)(tf_TestItemCondition_Cast("PLo_Global_Result_Index1"));
			int PHi_Global_Result_Index1	= (int)(tf_TestItemCondition_Cast("PHi_Global_Result_Index1"));
			int PSlew_Global_Result_Index1	= (int)(tf_TestItemCondition_Cast("PSlew_Global_Result_Index1"));

			int VLo_Global_Result_Index1	= (int)(tf_TestItemCondition_Cast("VLo_Global_Result_Index1"));
			int VHi_Global_Result_Index1	= (int)(tf_TestItemCondition_Cast("VHi_Global_Result_Index1"));
			int VSlew_Global_Result_Index1	= (int)(tf_TestItemCondition_Cast("VSlew_Global_Result_Index1"));

			int step = (int)(tf_TestItemCondition_Cast("step"));

			int vector_engine_status = 0;
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			if (calfactor->ContainsKey("TM_HEATER_DIG_DELAY"))
				tm_heater_dig_delay_factor = calfactor["TM_HEATER_DIG_DELAY"][idx];		

			/*****Initialize*****/
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			double PHi = 0;	//_glob->Global_Result[idx, PHi_Global_Result_Index];
			double PLo = 0;	//_glob->Global_Result[idx, PLo_Global_Result_Index];
			double PSlew = 0;	//_glob->Global_Result[idx, PSlew_Global_Result_Index];
			double Vdiff = 0;
			double P90 = 0;
			double P10 = 0;
			
			double VHi = 0;	//_glob->Global_Result[idx, VHi_Global_Result_Index];
			double VLo = 0;	//_glob->Global_Result[idx, VLo_Global_Result_Index];
			double VSlew = 0;	//_glob->Global_Result[idx, VSlew_Global_Result_Index];
			//double Vdiff = VHi - VLo;
			double V90 = 0;
			double V10 = 0;
			double THi = 0;
			double TLo = 0;
			double T90 = 0;
			double T10 = 0;
			double TSlew = 0;

			int tmu_start_range = 0;
			int tmu_stop_range = 0;
			double tmu_start_threshold = 0;
			double tmu_stop_threshold = 0;
			double tmu_start_hysteresis = 0;
			double tmu_stop_hysteresis = 0;
			int number_of_samples = 0;
			double tmu_timeout = 0;
			int returned_sample_count = 0;
			array<double> ^ sampled_result;
					
			int loop			= 0;
			int param_index		= 0;
			String ^ Vector_File;
			String ^ Vector_File1;

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
		
				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

				//param loop
				for (int i=param_index; i<loop; i++)
				{
					if (TPName[i]->Contains("HT0")){
						PHi = _glob->Global_Result[idx, PHi_Global_Result_Index];
						PLo = _glob->Global_Result[idx, PLo_Global_Result_Index];
						PSlew = _glob->Global_Result[idx, PSlew_Global_Result_Index];
						VHi = _glob->Global_Result[idx, VHi_Global_Result_Index];
						VLo = _glob->Global_Result[idx, VLo_Global_Result_Index];
						VSlew = _glob->Global_Result[idx, VSlew_Global_Result_Index];
					}else{
						PHi = _glob->Global_Result[idx, PHi_Global_Result_Index1];
						PLo = _glob->Global_Result[idx, PLo_Global_Result_Index1];
						PSlew = _glob->Global_Result[idx, PSlew_Global_Result_Index1];
						VHi = _glob->Global_Result[idx, VHi_Global_Result_Index1];
						VLo = _glob->Global_Result[idx, VLo_Global_Result_Index1];
						VSlew = _glob->Global_Result[idx, VSlew_Global_Result_Index1];
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File	= (String ^)(tf_TPCondition_Cast(TPName[i],"Vector_File"));

							if(!USE_SPI) {
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
							} else {
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
							}
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File1") == true)
					{
						Vector_File1 = (String ^)(tf_TPCondition_Cast(TPName[i],"Vector_File1"));

							if(!USE_SPI) {
							ret = RunVectorFile(idx, Vector_File1);
							CheckError(idx, ret, __LINE__);
							} else {
							ret = RunSPI(idx, Vector_File1);
							CheckError(idx, ret, __LINE__);
							}
					}
					
					if (TPName[i]->Contains("V_K"))
					{
						THi = VHi;
						TLo = VLo;		//orig TLo = VLo+0.5;
						T90 = V90;
						T10 = V10;
						Vdiff = VHi - VLo;
						TSlew = VSlew;
					}else{
						THi = PHi;
						TLo = PLo+1;		//crig TLo = PLo+0.8;
						T90 = P90;
						T10 = P10;
						Vdiff = PHi - PLo;		
						TSlew = VSlew;
					}
					if (TPName[i]->Contains("_K"))
					{	
						ret = dm[idx]->DrivePin("RWN", 1); //Lo		
						CheckError(idx, ret, __LINE__);

						//Vdiff = PHi - PLo;
						T90 = 2.5 * 0.9; //RWN
						T10 = TLo + 0.1*Vdiff; //Heater

						if(T90>5)
						{
							T90 = 5;
						}
						if(T10<0)
						{
							T10 = 0;
						}

						if (Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_DUT)
						{
							tmu_start_threshold = T90; //50-ohm termination

							tmu_stop_threshold = 0.396 * T10 + 0.030;
							tmu_stop_threshold = 61.255 * tmu_stop_threshold + (-14.817);

							tmu_start_hysteresis = 0.02;//0.2;
							//tmu_stop_hysteresis = 0.02;//0.2;

							tmu_stop_hysteresis = 38 * 0.01;

							tmu_start_range = TM_CONST_RANGE_1_1MOHM;
							tmu_stop_range = TM_CONST_RANGE_2_1MOHM;
						}
						else
						{
							tmu_start_threshold = T90;
							tmu_stop_threshold = T10;
							tmu_start_hysteresis = 0.02;
							tmu_stop_hysteresis = 0.02;

							tmu_start_range = TM_CONST_RANGE_0_50OHM;	//TM_CONST_RANGE_1_1MOHM
							tmu_stop_range = TM_CONST_RANGE_0_50OHM;
						}

						tmu_timeout = 10e-3;

						number_of_samples = 1;

						sampled_result = gcnew array<double>(number_of_samples);

						int retest_count = 0;

		RETEST:

						//ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, tmu_start_range, tmu_start_threshold, tmu_start_hysteresis, 0);
						ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_start_range, tmu_start_threshold, tmu_start_hysteresis, 0);
						if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
						{
							for (int z=0; z<total_tp; z++)
							{	
								result[i] = 999;
							}
							ret = 0;
							goto TEST_END;
						}

						CheckError(idx, ret, __LINE__);
						ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_stop_range, tmu_stop_threshold, tmu_stop_hysteresis, 0);
						//ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, tmu_stop_range, 0.5, tmu_stop_hysteresis, 0);
						if (ret == ERROR_BAD_ARGUMENTS || ret == AEMPXIE_E_BAD_ARGUMENTS)
						{
							for (int z=0; z<total_tp; z++)
							{	
								result[i] = 999;
							}
							ret = 0;
							goto TEST_END;
						}

						CheckError(idx, ret, __LINE__);
						//_util->Wait_Sec(On_Delay_s);

						ret = dm[idx]->DrivePin("RWN", 0); //Lo		
						CheckError(idx, ret, __LINE__);
						//_util->Wait_Sec(On_Delay_s);
						
						
						ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(On_Delay_s);


						//ret = RunVectorFile(idx, Vector_File);
						//CheckError(idx, ret, __LINE__);
						
			
						ret = dm[idx]->DrivePin("RWN", 1); //Hi	
						CheckError(idx, ret, __LINE__);
						//_util->Wait_Sec(On_Delay_s);

						ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

						if (ret)
						{
							result[i] = 999;
							ret = 0;
						}
						else
						{
							if (TSlew != 0)
							{
								//result[i] = sampled_result[0] - 0.75e-6 - ((T10 - TLo) / (TSlew * 1e6));
								result[i] = sampled_result[0] - ((T10 - TLo) / (TSlew * 1e6));	//ML remove 0.75e-6 as not in 2945
								//0.75u is voltage and power in HBT shift factor

								result[i] = result[i] + tm_heater_dig_delay_factor;
							}
							else
							{
								result[i] = 999;
								ret = 0;
							}
						}

						double max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
						double min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));

						if ((result[i] < min_limit) || (result[i] > max_limit))
						{
							if (retest_count < TIMING_RESET_COUNT)
							{
								retest_count++;
								goto RETEST;
							}
						}

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}
					//else
					if (TPName[i]->Contains("_FUNC"))
					{
						//double mono_meas = 0; 
						//int smallest_delta_index = 0;
						//mallest_delta_index = _util->monotonicity(result, step, 0, mono_meas);

						if ((fabs(result[i-2]) - fabs(result[i-1])) > 2.5e-6){
							result[i] = 1;
						}else{
							result[i] = 0;
						}
						tf_SetResult_UUTOffset(TPName[i], result[i] + (int)GetOffset(idx, TPDispName[i]), idx);
					}
				}
			}
			/////////////////////////////////
	TEST_END:
	
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//heater - to fake techflow 
	void TestProgram::heater_rng_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<String ^> ^ Test_Pin = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));	

			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";

			int vector_engine_status = 0;	
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			/*****Initialize*****/
			for(int hsel=0; hsel<HDSS; hsel++)
				Test_Pin[hsel] = (String ^)(tf_TestItemCondition_Cast("Test_Pin_H" + hsel));

			if(Debug_Enable == true)
			{
				ret = heater_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			}

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DrivePin("RWN", 1);
			CheckError(idx, ret, __LINE__);

			double diffpn_V			= 0;
			int loop				= 0;
			int param_index			= 0;
			int data				= 0;
			int Drive_RWN			= 0;
			String ^ Vector_File;
			String ^ Vector_File_1;
			array<int>^ HistoryRam = gcnew array<int>(256);	

			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
		
				//param loop
				for (int i=param_index; i<loop; i++)
				{
					if (tf_TPCondition_exist(TPName[i], "Drive_RWN") == true)
					{
						Drive_RWN = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWN"));

						ret = dm[idx]->DrivePin("RWN", Drive_RWN);
						CheckError(idx, ret, __LINE__);
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
									
						if(!USE_SPI) {
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						} else {
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						}
					}

					if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
					{
						Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
								
						if(!USE_SPI) {
						ret = RunVectorFile(idx, Vector_File_1);
						CheckError(idx, ret, __LINE__);
						} else {
						ret = RunSPI(idx, Vector_File_1);
						CheckError(idx, ret, __LINE__);
						}
					}

					_util->Wait_Sec(Measure_Delay_s);
				
					ret = smu[idx]->Measure("MTX_SMU", 1, diffpn_V);
					CheckError(idx, ret, __LINE__);

					result[i] = (diffpn_V * diffpn_V) / CONST_RhNom;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}
			
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	//heater hsel0
	void TestProgram::heater_rng(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			String ^ Vector_File_1  = String::Empty;
			
			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";	//

			int Drive_RWN			= 0;
			
			int vector_engine_status = 0;	
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
				
			/*****Initialize*****/				
			ret = heater_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			
			//set CBit & MUX
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);			

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);		

			//ret = dm[idx]->DrivePin("RWN", 1);
			//CheckError(idx, ret, __LINE__);
				
			array<int>^ HistoryRam = gcnew array<int>(256);
			int data = 0;
			double diffpn_V			= 0;


			//if(!USE_SPI) {
			//ret = RunVectorFile(idx, Vector_File);
			//CheckError(idx, ret, __LINE__);
			//} else {
			//ret = RunSPI(idx, Vector_File);
			//CheckError(idx, ret, __LINE__);
			//}

			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Drive_RWN") == true)
				{
					Drive_RWN = (int)(tf_TPCondition_Cast(TPName[i], "Drive_RWN"));

					ret = dm[idx]->DrivePin("RWN", Drive_RWN);
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					if(!USE_SPI) {
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					} else {
					ret = RunSPI(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					}
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
				{
					Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));

					if(!USE_SPI) {
					ret = RunVectorFile(idx, Vector_File_1);
					CheckError(idx, ret, __LINE__);
					} else {
					ret = RunSPI(idx, Vector_File_1);
					CheckError(idx, ret, __LINE__);
					}
				}

				_util->Wait_Sec(On_Delay_s);
				
				ret = smu[idx]->Measure("MTX_SMU", 1, diffpn_V);
				CheckError(idx, ret, __LINE__);
				
								
				if (TPName[i]->Contains("Rd"))
				{
//					for(int k=0; k<=13; k++) 
//					{
						result[i] = diffpn_V;
//					}
				}
				else //Wt
				{
//					for(int k=14; k<=17; k++) 
//					{
						result[i] = (diffpn_V * diffpn_V) / CONST_RhNom;		//(volt * volt) / CONST_RhNom; 
//				    }
				}
			
				if (TPName[i]->Contains("Off"))
				{
					/////////////////////////////////
					//Find valid pht steps
					/////////////////////////////////
					array<double> ^ pht_steps= gcnew array<double>{16,32,64,128,129,130,132,136,198,255};
					int valid_step_size	= 10; //initially set as similar to step size
					int first, last	= 0;
					double max			= Drive_Vcc_V - 0.7; //follow catalyst
					double pht, vht		= 0;
					int step = 10;

					for(int k=0; k<step; k++)
					{
						if(pht_steps[k] >= 64)	
						{
							first = k;
							break;	
						}
					}
					
					for(int k=first; k<step; k++)
					{
						pht = 4e-3 + (0.708e-3 * pht_steps[k]);
						vht = sqrt(pht * CONST_RhNom);
						last = k;
						if(vht>max)
						break;	
					}	

					valid_step_size = last - first + 1;

					/////////////////////////////////
					//Processing delta
					/////////////////////////////////
					double delta		= 0;
					int K_min, K_max	= -1;
					double delta_min	= 1000;
					double delta_max	= -1000;
					
					for(int k=first; k<step; k++)//process only within the valid pht steps
					{
						if((pht_steps[k] - pht_steps[k-1]) == 1)
						{
							delta = result[k] - result[k-1];

							if(k == first)
							{
								K_min = K_max = k;
								delta_min = delta_max = delta;
							}

							else //ascending 
							{
								if(delta < delta_min)
								{
									K_min = k;
									delta_min = delta;
								}
								if(delta > delta_max)
								{
									K_max = k;
									delta_max = delta;
								}
							}
						}
					}

					/////////////////////////////////
					//Processing slope & offset - pht_steps VS phs
					/////////////////////////////////
					double slope = 0;
					double offset = 0;
					double sum_x = 0;
					double sum_y = 0;
					double mult_xy = 0;
					double exp_x = 0;
					
					for(int k=first; k<valid_step_size; k++)
					{
						sum_x	+= pht_steps[k];
						sum_y	+= result[k];
						mult_xy += pht_steps[k] * result[k];
						exp_x	+= pht_steps[k] * pht_steps[k];
					}

					slope = ((valid_step_size*mult_xy) - (sum_x*sum_y)) / ((valid_step_size*exp_x) - (sum_x*sum_x));
					offset = (sum_y/valid_step_size) - (slope*(sum_x/valid_step_size));
					result[i] = offset;

//					tf_SetResult_UUTOffset(TPName[10], offset + GetOffset(idx, TPDispName[10]), idx);
				}
				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				 
				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));

					_glob->Global_Result[idx, Global_Result_Index] = result[i];
				}
					
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//fhs
	void TestProgram::ifhs_bias_hds(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int step				= (int)(tf_TestItemCondition_Cast("step"));
			
			String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";
			
			int vector_engine_status = 0;	
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			//if(Debug_Enable == true)
			ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
		
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);
			
			//double diffp_V		= 0;
			//double diffn_V		= 0;
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			int data			= 0;
			String ^ Vector_File;
			array<int>^ HistoryRam = gcnew array<int>(256);
			
		/*****Start Test*****/
		for(int hsel=0; hsel<HDSS; hsel++)
		{			
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = step;
				}		
				else 
				{
					param_index = 5; //special case because number of hsel0 param != hsel1 param
					loop = param_index + step;
				}

				//set CBit & MUX - add by ML
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

			//param loop
			for (int i=param_index; i<loop; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
								
						if(!USE_SPI) 
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						} 
						else 
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
				}

				//connect PN to diffAmp
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index],1); 
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);

				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
				else 
					diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
						
				result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);
				result[i] = result[i] / CONST_Rfhs;
		
				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

				if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
				{
					int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
					_glob->Global_Result[idx, Global_Result_Index] = result[i];
				}
			}
				
		}
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)		//ML - reset due to different settings than test below
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::vfhs_bias_hds4_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int step				= (int)(tf_TestItemCondition_Cast("step"));

			String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";
			
			int vector_engine_status = 0;
			Stopwatch swatch;		

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			if(Debug_Enable == true)
				ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//
			//ret = DriveCBit(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);
			//ret = DriveMuxIO(idx, TPDispName[0],0);
			//CheckError(idx, ret, __LINE__);
			
			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
		
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);
			
			double diffp_V		= 0;
			double diffn_V		= 0;
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			int data			= 0;
			String ^ Vector_File;
			array<int>^ HistoryRam = gcnew array<int>(256);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = step;
				}		
				else 
				{
					param_index = 15; //special case because number of hsel0 param != hsel1 param
					loop = param_index + step;
				}

				////set CBit & MUX - ML add
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

				//param loop
				for (int i=param_index; i<loop; i++)
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				
						if(!USE_SPI) 
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						} 
						else 
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index_Vcm") == true)
					{	
						//connect P to GNDS 
						ret = ResetMuxIO(idx);
						CheckError(idx, ret, __LINE__);
						ret = DriveMuxIO(idx, TPDispName[param_index],2); 
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
						CheckError(idx, ret, __LINE__);

						//connect N to GNDS 
						ret = ResetMuxIO(idx);
						CheckError(idx, ret, __LINE__);
						ret = DriveMuxIO(idx, TPDispName[param_index],3); 
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage("MTX_SMU", diffn_V);
						CheckError(idx, ret, __LINE__);	

						//polarity
						if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS0")))
							diffp_V = -1 * diffp_V;
						else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS1")))
							diffn_V = -1 * diffn_V;	//2935 diffp_V = -1 * diffp_V;

						if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS1")))
							diffn_V = -1 * diffn_V;		//2935 diffn_V = -1 * diffn_V;
						else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS0")))
							diffp_V = -1 * diffp_V;		//2935 diffn_V = -1 * diffn_V;

						diffp_V = (diffp_V-_glob->DA_c[idx])/_glob->DA_m[idx];
						diffn_V = (diffn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

						int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));
						_glob->Global_Result[idx, Global_Result_Index_Vcm] = (diffp_V + diffn_V) / 2;
					}

					//connect PN to diffAmp
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[param_index],1); 
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
						
					result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);
		
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

					if (tf_TPCondition_exist(TPName[i], "Global_Result_Index") == true)
					{
						int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index"));
						_glob->Global_Result[idx, Global_Result_Index] = result[i];
					}
				}
			}
			///*double slope = 0;
			//double offset = 0;
			//array<int> ^ x = gcnew array<int> {1,16,31};

			//_util->line_fit(x, result, step, slope, offset);

			//if (total_tp > step)
			//{
			//	tf_SetResult_UUTOffset(TPName[step], slope + GetOffset(TPDispName[step]));
			//	tf_SetResult_UUTOffset(TPName[step+1], offset + GetOffset(TPDispName[step+1]));
			//}*/
			
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::vfhsv4_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{

			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";
			
			int vector_engine_status = 0;
			Stopwatch swatch;			

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			if(Debug_Enable == true)
			{
				ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			}

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
		
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);

			double diffp_V		= 0;
			double diffn_V		= 0;
			double diffpn_V		= 0;
			int loop			= 0;
			int param_index		= 0;
			String ^ Vector_File;

		/*****Start Test*****/
		for(int hsel=0; hsel<HDSS; hsel++)
		{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

			//param loop				
			for (int i=param_index; i<loop; i++)
			{
				if (TPName[i]->Contains("sel"))
				{
					int Global_Result_Index_Vcm = (int)(tf_TPCondition_Cast(TPName[i], "Global_Result_Index_Vcm"));

					result[i] = _glob->Global_Result[idx, Global_Result_Index_Vcm];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
					
						if(!USE_SPI) {
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						} else {
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
						}
					}

					_util->Wait_Sec(Measure_Delay_s);

					//connect P to GNDS 
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[param_index],2); 
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
					CheckError(idx, ret, __LINE__);
						
					//connect N to GNDS 
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[param_index],3); 
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffn_V);
					CheckError(idx, ret, __LINE__);							
						
					////2945 specified for diffp_V
					//if ((Test == TEST_QS_BLKDGN_DUT_IF2 || Test == TEST_QS_BLKDGN_DUT) && (TPName[i]->Contains("HS0")))
					//{
					//	diffp_V = -1 * diffp_V;
					//}
					//else if ((Test == TEST_QS_BLKDGN_PROBE || Test == TEST_QS_BLKDGN_PROBE_IF2) && (TPName[i]->Contains("HS1")))
					//{
					//	diffp_V = -1 * diffp_V;
					//}

					//diffp_V = (diffp_V-c)/m;

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					{				
						diffp_V = _glob->PolTA_DUT[hsel, idx]*diffp_V;
						diffn_V = _glob->PolTA_DUT[hsel, idx]*diffn_V;
					}
					else 
					{		
						diffp_V = _glob->PolTA_PROBE[hsel, idx]*diffp_V;
						diffn_V = _glob->PolTA_PROBE[hsel, idx]*diffn_V;
					}
						
					result[i] = (diffp_V + diffn_V) / 2;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);

					i++;

					//connect PN to diffAmp
					ret = ResetMuxIO(idx);
					CheckError(idx, ret, __LINE__);
					ret = DriveMuxIO(idx, TPDispName[param_index],1); 
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
							
					result[i] = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}
		}
		/*****Power down*****/
		if(USE_SPI)
		{
			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);
		}

		//Power down supplies
		//ret = smu[idx]->DriveVoltage("VEE", 0);
		//CheckError(idx, ret, __LINE__);
		ret = smu[idx]->DriveVoltage("VCC", 0);
		CheckError(idx, ret, __LINE__);

		if(Debug_Enable == true)
		{
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
	}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::ifhs_bias_sup_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{

			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			//double Rfhs = 79.91;

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";
						
			int vector_engine_status = 0;
			Stopwatch swatch;
					
			/*****Initialize*****/
			ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0],1);
			CheckError(idx, ret, __LINE__);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			else 
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			int hsel		= 0;
			double diffpn_V = 0;
			int data		= 0;
			array<int>^ HistoryRam = gcnew array<int>(256);	

			/*****Start Test*****/			
			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(On_Delay_s);

				if (i == 0)
				{
					//#ifndef USE_SPI
					//ret = RunVectorFile(idx, Vector_File);
					//CheckError(idx, ret, __LINE__);

					//if (vector_engine_status == 0)
					//{
					//	ret = dm[idx]->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					//	CheckError(idx, ret, __LINE__);

					//	if (Debug_Enable == true)
					//	{
					//		sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					//	}

					//	ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					//	CheckError(idx, ret, __LINE__);
					//	result[i] = data & 0x3F;

					//	if (Debug_Enable == true)
					//	{
					//		sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					//	}
					//}
					//else
					//{
					//	result[i] = -999;
					//}
					//#else
					//ret = ReadSPI(Vector_File, data);
					//CheckError(idx, ret, __LINE__);

					//result[i] = data & 0x3F;
					//#endif

					OnOffSPI(idx, 1);
					int reg_fhs_bias, reg_fhs_bias1, fhs_bias;
					ret = ReadReg(idx, 2, 2, reg_fhs_bias);//FHSBIAS[6:1] = pg2_reg2[5:0]
					ret = ReadReg(idx, 2, 12, reg_fhs_bias1); //FHSBIAS[0] = pg2_reg12[3]
					reg_fhs_bias = (reg_fhs_bias & 0x3f) << 1; //Get bit [5:0], shift into position = 6:1
					reg_fhs_bias1 = (reg_fhs_bias1 & 0x08) >> 3;//Get bit [3], shift into position = 0
					fhs_bias = reg_fhs_bias | reg_fhs_bias1;
					OnOffSPI(idx, 0);
					tf_SetResult_UUTOffset(TPName[i], (int)(fhs_bias + GetOffset(idx, TPDispName[i])), idx);
				}
				else if (i == 5)
				{
					double min = 0;
					double max = 0;

					for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
					{
						if(k == 3)
						{
							min = max = result[k]; 
						}
						else
						{
							if(result[k] > max)
								max = result[k];

							if(result[k] < min)
								min = result[k];
						}		
					}

					result[i] = max - min;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
					
					result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]/ CONST_Rfhs);		//ML modify			
					//result[i] = Math::Abs(diffp_V - diffn_V) / Rfhs;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}	
	}
	void TestProgram::vfhs_bias_sup_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{

			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
				
			int vector_engine_status = 0;
			Stopwatch swatch;
					
			/*****Initialize*****/
			ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);		//ML - if mask, get 471mV ++ readings

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0],1);
			CheckError(idx, ret, __LINE__);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			else 
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			int hsel		= 0;
			double diffpn_V = 0;
			int data		= 0;
			array<int>^ HistoryRam = gcnew array<int>(256);	

			/*****Start Test*****/
			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vcc_V") == true)
				{
					Drive_Vcc_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vcc_V"));

					ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "Drive_Vee_V") == true)
				{
					Drive_Vee_V = (double)(tf_TPCondition_Cast(TPName[i], "Drive_Vee_V"));

					ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
					CheckError(idx, ret, __LINE__);
				}

				_util->Wait_Sec(On_Delay_s);

				if (i == 0)
				{
					//#ifndef USE_SPI
					//ret = RunVectorFile(idx, Vector_File);
					//CheckError(idx, ret, __LINE__);

					//if (vector_engine_status == 0)
					//{
					//	ret = dm[idx]->ReadHistoryRam("DM_2", VectorLineCount[Vector_File], 0, VectorSetNo[Vector_File], HistoryRam);
					//	CheckError(idx, ret, __LINE__);

					//	if (Debug_Enable == true)
					//	{
					//		sb->AppendLine("ReadHistoryRam return=" + ret.ToString());
					//	}

					//	ret = GetDataByteFromHistoryRam(Vector_File, HistoryRam, data, SPD_Channel);
					//	CheckError(idx, ret, __LINE__);
					//	result[i] = data & 0x3F;

					//	if (Debug_Enable == true)
					//	{
					//		sb->AppendLine("GetDataByteFromHistoryRam return=" + ret.ToString());
					//	}
					//}
					//else
					//{
					//	result[i] = -999;
					//}
					//#else
					//ret = ReadSPI(Vector_File, data);
					//CheckError(idx, ret, __LINE__);

					//result[i] = data & 0x3F;
					//#endif
					OnOffSPI(idx, 1);
					int reg_fhs_bias, reg_fhs_bias1, fhs_bias;
					ret = ReadReg(idx, 2, 2, reg_fhs_bias);//FHSBIAS[6:1] = pg2_reg2[5:0]
					ret = ReadReg(idx, 2, 12, reg_fhs_bias1); //FHSBIAS[0] = pg2_reg12[3]
					reg_fhs_bias = (reg_fhs_bias & 0x3f) << 1; //Get bit [5:0], shift into position = 6:1
					reg_fhs_bias1 = (reg_fhs_bias1 & 0x08) >> 3;//Get bit [3], shift into position = 0
					fhs_bias = reg_fhs_bias | reg_fhs_bias1;
					OnOffSPI(idx, 0);
					tf_SetResult_UUTOffset(TPName[i], (int)(fhs_bias + GetOffset(idx, TPDispName[i])), idx);
				}
				else if (i == 5)
				{
					double min = 0;
					double max = 0;

					for(int k=3; k<total_tp-1; k++) // start from the 4th until 7th parameter only
					{
						if(k == 3)
						{
							min = max = result[k]; 
						}
						else
						{
							if(result[k] > max)
								max = result[k];

							if(result[k] < min)
								min = result[k];
						}		
					}

					result[i] = max - min;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
				else
				{
					if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
					{
						if(!USE_SPI)
						{
							ret = RunVectorFile(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
						else
						{
							ret = RunSPI(idx, Vector_File);
							CheckError(idx, ret, __LINE__);
						}
					}

					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
					
					result[i] = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}	
	}
	void TestProgram::fhs_func(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;
		
		int ret = 0;
		try
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			bool isCurrentTPBypassed = false;

				StringBuilder ^ sb = gcnew StringBuilder();
				StreamWriter ^ sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double vih = 2.5;
			double vil = 0.0;
			double voh = 0.75; 
			double vol = 0.75;
			double ioh = 0.002;
			double iol = 0.002;
			double vch = 6;
			double vcl = -0.1;
			double vt  = 0;

			int vector_engine_status = 0;
			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			ret += smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			ret += smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			ret += dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPE");

			ret += dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPD");

			ret += dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPC");

			ret += dm[idx]->DPINOff("RWN");
			ret += dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("RWN");

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret += dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx,ret, __LINE__);

			// Write Register Default value		
			ret = RunVectorFile(idx,"write_default_reg");
			CheckError(idx,ret, __LINE__);

			/////////////////////////////////
			int reg_val = 0;
			int fhs_counter_fail = 0;
			
			ret += OnOffSPI(idx,1);

	#pragma region "Test Param #1"
	// =========================
	// Starting create_fhs_func_dsio_segment() ... 
	//      REG:FHSBIAS_V VAL:0 	p2_r2 	<BB000000> p2_r12 <BBBB0BBB>
	//      REG:FHSBIAS_I VAL:0		p2_r2 	<BB000000> p2_r12 <BBBB0BBB> 
			ret += WriteSPI(idx,2, 2, 0); 
			ret += WriteSPI(idx,2, 12, 0);

	//      REG:FAULTMASK VAL:1007 	p3_r11	<11BBBBBB> p1_r10 <11101111> 
			ret += WriteSPI(idx,3, 11, 0xc0);		// EW: need to declare as p3_regXX are not in the default register write
			ret += WriteSPI(idx,1, 10, 0xef);

	//      REG:FHSIMODE VAL:0 		p2_r4	<B0BBBBBB>
			ret += WriteSPI(idx,2, 4, 0x0);

	//      REG:FHSEN VAL:1 		p2_r4	<BBB1BBBB>
			ret += WriteSPI(idx,2, 4, 0x10);

	// Ending create_fhs_func_dsio_segment() ... 
	// =========================

	//   start hsd50 pattern= PAT_fhs vector = "fhs_counter";
				
			//FHS counter test - param 0
			//p2_reg02=0x40 JL: FHSCountEn=1 
			ret += WriteSPI(idx,2, 2, 0x40);
			//p2_reg03=0xc7 JL: FHSEnvelopeDetect=1 (affects FHSCount+FLTMUX); FHS high freq pole
			ret += WriteSPI(idx,2, 3, 0xc7);
			//p2_reg10=0x40 JL: enable Ext clk through SPC 
			ret += WriteSPI(idx,2, 10, 0x40);
			//p2_reg04=0x9f JL: FHSCountClear(bit 7)=1 (read FHS event counter resets the count), FHSVth=0xf 
			ret += WriteSPI(idx,2, 4, 0x9f);
			//read p1_reg09 JL: Read FHS Event counter, read to reset count.
			ret+= ReadReg(idx,1, 9, reg_val);

	// ==============================================================================================
			//Run vector to drive SPC for 8x2 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_8");						//EW: Check SPC pulse 
			ret += OnOffSPI(idx,1);

			//read p1_reg09 (FHS Event counter), expect = 0x10
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x10)
				fhs_counter_fail = 1;
			//read p1_reg09 (FHS Event counter), expect = 0x00
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x00)
				fhs_counter_fail ++;

	// ==============================================================================================
			//Run vector to drive SPC for 8x2 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_8");						//EW: Check SPC pulse 
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0x10
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x10) 
				fhs_counter_fail ++;
			//p2_reg04=0x1f JL: FHSCountClear(bit 7)=0 (reading FHS event counter does not reset the count), FHSVth=0xf 
			ret += WriteSPI(idx,2, 4, 0x1f);

	// ==============================================================================================
			//Run vector to drive SPC for 8 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_8");						//EW: Check SPC pulse 
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0x10
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x10) 
				fhs_counter_fail ++;

	// ==============================================================================================
			//Run vector to drive SPC for 8 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_8");
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0x20
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x20)
				fhs_counter_fail ++;
			//p2_reg04=0x0f, clear bit 4 - FHS En = 0
			ret += WriteSPI(idx,2, 4, 0x0f);
			//read p1_reg09 (FHS Event counter), expect = 0x20, does not change
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x20)
				fhs_counter_fail ++;
			//read p1_reg09 (FHS Event counter), expect = 0x20, again, does not change
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x20)
				fhs_counter_fail ++;

			//p2_reg04=0x1f, set bit 4 - FHS En = 1
			ret += WriteSPI(idx,2, 4, 0x1f);
			//read p1_reg09 (FHS Event counter), expect = 0x20, does not change without toggling SPC
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x20)
				fhs_counter_fail ++;

			//p2_reg04=0x8f, FHSCountClear(bit 7)=1; FHS En (bit 4) = 0
			ret += WriteSPI(idx,2, 4, 0x8f);
			//read p1_reg09 (FHS Event counter), expect = 0x20, does not change without toggling SPC, but will reset the counter now FHSCountClear=1
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x20)
				fhs_counter_fail ++;
			//read p1_reg09 (FHS Event counter), expect = 0x00, confirm counter is reset
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x00)
				fhs_counter_fail ++;

			//p2_reg04=0x1f, FHSCountClear(bit 7)=0; FHS En (bit 4) = 1
			ret += WriteSPI(idx,2, 4, 0x1f);

	// ==============================================================================================
			//Run vector to drive SPC for 8 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_8");
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0x10
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x10)
				fhs_counter_fail ++;
			//p2_reg02=0x00 JL: FHSCountEn (bit 6)=0 
			ret += WriteSPI(idx,2, 2, 0x00);

	// ==============================================================================================
			//Run vector to drive SPC for 8 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_8");
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0x00
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0x00)
				fhs_counter_fail ++;
			//p2_reg02=0xc0 JL: FHSFltEn (bit 7)=1, FHS events are reported to the FLTMUX pin along with the standard faults. FHS event detection drives the FLTMUX pin to the opposite polarity of the RWn pin.
			//                  FHSCountEn (bit 6)=1 
			ret += WriteSPI(idx,2, 2, 0xc0);

	// ==============================================================================================
			//Run vector to drive SPC for 127 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_127");
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0xfe
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0xfe)
				fhs_counter_fail ++;

	// ==============================================================================================
			//Run vector to drive SPC for 4 pulses, SPE remains 0
			ret += OnOffSPI(idx,0);
				ret += RunVectorFile(idx,"fhscount_spc_4");
			ret += OnOffSPI(idx,1);
			
			//read p1_reg09 (FHS Event counter), expect = 0xff
			ret+= ReadReg(idx,1, 9, reg_val);
			if(reg_val != 0xff)
				fhs_counter_fail ++;

			//JL: Clean up
			//p2_reg04=0x13, FHSCountClear(bit 7)=0; FHS En (bit 4) = 1, FHS Vth=0x3
			ret += WriteSPI(idx,2, 4, 0x13);
			//p2_reg03=0x44
			ret += WriteSPI(idx,2, 3, 0x44);
			//p2_reg10=0 JL: disable Ext clk through SPC 
			ret += WriteSPI(idx,2, 10, 0x00);
			//p1_reg01 JL: Gain[2:0]=0 (default=6)
			ret += WriteSPI(idx,1, 1, 0x00);
			//p2_reg05=0x07
			ret += WriteSPI(idx,2, 5, 0x07);
			//p2_reg02=0; clear FHSFltEn & FHSCountEn
			ret += WriteSPI(idx,2, 2, 0x00);
			//p2_reg02=0x80 set FHSFltEn (bit 7)=1
			ret += WriteSPI(idx,2, 2, 0x80);
			
			if(fhs_counter_fail == 0)
				fhs_counter_fail = 1; //JL result requires "1" for passing.
			else
				fhs_counter_fail = 2;

			tf_SetResult_UUTOffset(TPName[0], (int)(fhs_counter_fail + GetOffset(idx,TPDispName[0])),idx); 


	#pragma endregion "Test Param #1"
	//************************************************************************************************//		
	//EW: Disabling MODE to 0
			ret += DriveDMPin(idx,TPDispName[1]);
			ret += DriveMuxIO(idx,TPDispName[1]);
			CheckError(idx,ret, __LINE__);

			//Param 1
			double result = 0;
			//JL: NOTE: CBIT to enable FLTMUX to DM.
			voh = 0.4;	vol = 0.4;	ioh = 0;	iol = 0;	
			ret = dm[idx]->DPINOff("FLTMUX");
			ret += dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_DIO);
			ret += dm[idx]->ConfigurePEAttribute("FLTMUX", 0, 0, 0, 0);
			ret += dm[idx]->DPINLevel("FLTMUX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->SetPinDirection("FLTMUX", DM_CONST_DIR_INPUT);
			ret += dm[idx]->DPINOn("FLTMUX");
			ret += dm[idx]->DrivePin("FLTMUX", 0);

			ret += OnOffSPI(idx,0);
			ret += RunVectorFile(idx,"write_default_reg");
			CheckError(idx,ret, __LINE__);
			ret += OnOffSPI(idx,1);

			/*
			write_reg(FHS_VBIAS,0);
			write_reg(FHS_IBIAS,0);
			JL: Refers to same register, FHSBias<6:0>=pg2_reg2[5:0]+pg2_reg12[3]
			*/
			ret += WriteSPI(idx,2, 2, 0); //JL: default = 0x3f
			ret += WriteSPI(idx,2, 12, 0);//JL: default = 0x08 
			
			// write_reg("FAULTMASK", MASK_ALL_BUT_FHS); JL: pg2_reg10 clear bit 4; Enables FHS head open and short detection
			ret += WriteSPI(idx,3, 11, 0xc0);
			ret += WriteSPI(idx,1, 10, 0xef);
			
			// write_reg(FHS_BIAS_MODE,FHS_VMODE); JL: pg2_reg4 bit 6 = 0; voltage bias
			ret += WriteSPI(idx,2, 4, 0x0);//JL: seems redundant, same as default value. For initial coding, just follow CAT's code.
			
			//write_reg(FHSVTH,3); JL: pg2_reg4[3:0]
			ret += WriteSPI(idx,2, 4, 0x03);
			//write_reg("FHSTAFREQ",1); JL: pg2_reg3[6]
			ret += WriteSPI(idx,2, 3, 0x47); //JL: default = 0x07
			//write_reg("FHSFLTEN",1); JL: pg2_reg2[7] FHS events are reported to the FLTMUX pin along with the standard faults. FHS event detection drives the FLTMUX pin to the opposite polarity of the RWn pin.
			ret += WriteSPI(idx,2, 2, 0x80);
			//EW:   write_reg("FHSENVELOPEDETECT",1);	
			ret += WriteSPI(idx,2, 3, 0xc7);
			//write_reg("FHSRDANDWRT",1); JL: pg2_reg4[5]
			ret += WriteSPI(idx,2, 4, 0x13);
			//write_reg(FHSGAIN,0); JL: pg2_reg5[2:0]
			ret += WriteSPI(idx,2, 5, 0x00); //JL: same as default value
			// write_reg(FHS_ENABLE,FHS_ON); JL: pg2_reg4 bit 4 = 1; enable FHS
			ret += WriteSPI(idx,2, 4, 0x33);
			CheckError(idx,ret, __LINE__);
			
	//   start hsd50 pattern= PAT_fhs vector = "fhs_EnvelopeDetect";	

			ret = acm[idx]->StopFG("ACM_CH"); 


	#pragma region "Funny 199.999KHz square wave construction"

			ret = acm[idx]->StopFG("ACM_CH"); 

				ret += dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
				ret += dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
				ret += dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx,ret, __LINE__);


	//Digitizer setting
				int mode = 0;	//0 = normal data acquisition (digitizer)
								//2 = averaging mode (it makes the instrument run as a real-time averager)
				int flag = 0;	//0 = normal
								//1 = ‘Start on Trigger’ mode
				double sampInterval = 1e-9;
				double delayTime = 0.0;
				int nbrSamples = 16384; //1024; //must be 2^n
				int nbrSegments = 1;
				int coupling = 3;	//0 Ground (Averagers ONLY)
									//1 DC, 1 M-ohm
									//2 AC, 1 M-ohm
									//3 DC, 50 M-ohm
									//4 AC, 50 M-ohm
				int bandwidth = 0;	//0 no bandwidth limit (default)
									//1 bandwidth limit at 25 MHz
									//2 bandwidth limit at 700 MHz
									//3 bandwidth limit at 200 MHz
									//4 bandwidth limit at 20 MHz
									//5 bandwidth limit at 35 MHz
				double fullScale = 2.0; //1V or 2V
				double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
										//2V range: ±4 V (max signal = ±6.3 V)
				long trigClass = 0;		//0 edge trigger 
				double amp_0deg, amp_90deg, amp_180deg, amp_270deg = 0;

				long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
												//0x000n0002 for Channel 2

				long trigCoupling = 0;	//0 DC
										//1 AC
										//2 HF Reject (if available)
										//3 DC, 50 (ext. trigger only, if available)
										//4 AC, 50 (ext. trigger only, if available)
				long trigSlope = 0;	//0 Positive
									//1 Negative
									//2 out of Window
									//3 into Window
									//4 HF divide
									//5 Spike Stretcher
				double trigLevel = 0;	//% of FS 
										//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
				int timeOut_ms = 1;
				int Decimation_Factor = 16;
				array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);

				double vout_pp = 0.0;
				int max_loop = 50;
				double freqq = 200000;  //2000

				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

				try
				{
					//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);
					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

					if (hardwareResource->Alias->Contains("Ch1"))
					{
						sourcePattern = 0x00000001;
					}
					else if (hardwareResource->Alias->Contains("Ch2"))
					{
						sourcePattern = 0x00000002;
					}
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				_glob->digitizer_setting[0] = sampInterval;
				_glob->digitizer_setting[1] = delayTime;
				_glob->digitizer_setting[2] = (double)nbrSamples;
				_glob->digitizer_setting[3] = (double)nbrSegments;
				_glob->digitizer_setting[4] = fullScale; 
				_glob->digitizer_setting[5] = offset;
				_glob->digitizer_setting[6] = (double)coupling;
				_glob->digitizer_setting[7] = (double)bandwidth;
				_glob->digitizer_setting[8] = (double)trigClass;
				_glob->digitizer_setting[9] = (double)sourcePattern;
				_glob->digitizer_setting[10] = (double)trigCoupling;
				_glob->digitizer_setting[11] = (double)trigSlope;
				_glob->digitizer_setting[12] = trigLevel;
				_glob->digitizer_setting[13] = (double)timeOut_ms;
				_glob->digitizer_setting[14] = (double)Decimation_Factor;

//EW: turning on K5 and ADC3 for FLTMUX digitizer
				////On K3, K4
				ret = DriveCBit(idx,TPDispName[0], 1);
				CheckError(idx,ret, __LINE__);
		//ret = DriveCBit(idx,TPDispName[0], 3);

				//Off S0P, S0N
				ret += DriveMuxIO(idx,TPDispName[0],0);		

	//			ret = OnOffCbit(idx,0, 0);

		//AWG setting
				ret = acm[idx]->ResetChannel("ACM_CH");
				ret += acm[idx]->ChannelWaveShape("ACM_CH", 4); //square 4
				ret += acm[idx]->ChannelFrequency("ACM_CH", freqq);
				ret += acm[idx]->ChannelPhase("ACM_CH", 0);
				ret += acm[idx]->ChannelOffset("ACM_CH", 0);
	//			ret += acm[idx]->ChannelAmplitude("ACM_CH", 0);			//EW: DEBUG 04022016

				ret += acm[idx]->ChannelAmplitude("ACM_CH", 1.9);			//EW: need to scope to confirm the amplitude

				//ret = acm[idx]->ModulationAmplitudeConfig("ACM_CH", 1, Vswg_timing_calibrated[idx.ToString() + "_" + TIDispName]/2);
				//CheckError(idx,ret, __LINE__);
				//ret += acm[idx]->ModulationAmplitudeConfig("ACM_CH", 1, 2.5);		// ~1V
	//			ret += acm[idx]->ModulationAmplitudeConfig("ACM_CH", 1, 5);			// ~2V
				ret += acm[idx]->ModulationAmplitudeConfig("ACM_CH", 1, 5);			// ~2V
				ret += acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
				CheckError(idx,ret, __LINE__);
			
				int awg_trigger_source = 0;
				int WaveformSetNo = 0;

				array<double> ^ wav199Ksq = gcnew array<double>(5000);

				for (int i = 0; i < 1250; i++) wav199Ksq[i] = 1*(int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform
				for (int i = 1250; i < 2500; i++) wav199Ksq[i] = 0*(int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform
				for (int i = 2500; i < 3750; i++) wav199Ksq[i] = -1*(int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform
				for (int i = 3750; i < 5000; i++) wav199Ksq[i] = 0*(int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform

				ret = acm[idx]->AWGWaveformFlush("ACM");
				ret = acm[idx]->AWGWaveformLoad("ACM_CH", 0, wav199Ksq->Length, 1, wav199Ksq); //The waveform is transfered to the onboard RAM. Waveform number is 0
	//			ret = acm[idx]->AWGQueueWaveform("ACM_CH", 1, ACM_CONST_AUTOTRIG, 0, 3, 0); //Waveform is queued. AWG 0, Waveform 0, 2 cycle, and external trigger=2; auto-trigger=0
				ret = acm[idx]->AWGQueueWaveform("ACM_CH", 1, ACM_CONST_AUTOTRIG, 0, 4, 0); //Waveform is queued. AWG 0, Waveform 0, 2 cycle, and external trigger=2; auto-trigger=0

				////0 deg
				//ret = acm[idx]->ChannelPhase("ACM_CH", 0);
				//ret = acm[idx]->StartAWG("ACM_CH");
				//CheckError(idx,ret, __LINE__);
				
				trigLevel = 300;	//% of FS, or mV if external trigger is used
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
				trigSlope = 1; //negative
				timeOut_ms = 100;

				ret = digitizer[idx]->StopAcquire("DIGITIZER");
				ret += digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
				ret += digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
				ret += digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
				ret += digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
				CheckError(idx,ret, __LINE__);


				//Digitizer setting
				try
				{
					//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);
					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];
					if (hardwareResource->Alias->Contains("ExtTrigIn1"))
					{
						sourcePattern = 0x80000000;
						ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26); //PXITRIGGER0
						ret += acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
						CheckError(idx,ret, __LINE__);
						awg_trigger_source = 4000 + PXITRIGGER0;
						WaveformSetNo = 0;
					}
					else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
					{
						sourcePattern = 0x40000000;
						ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 2, 26); //PXITRIGGER1
						ret += acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER1, ACM_CONST_TRIG_FALL);
						CheckError(idx,ret, __LINE__);
						awg_trigger_source = 4000 + PXITRIGGER1;
						WaveformSetNo = 1;
					}
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}
					//ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);


					//automatic setting: CH1-TrigIn1, CH2-TrigIn2
					ret += digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
				
				//0 deg
				ret = acm[idx]->ChannelPhase("ACM_CH", 0);

					ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
					CheckError(idx,ret, __LINE__);

		ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
		ret = digitizer[idx]->StopAcquire("DIGITIZER"); // dummy

		ret = digitizer[idx]->StartAcquire("DIGITIZER"); 
						ret += digitizer[idx]->ForceTrigger("DIGITIZER");
						ret = acm[idx]->StartAWG("ACM_CH"); ret = acm[idx]->StartAWG("ACM_CH");



	//vout_pp = 0.0;
	//ret = DigitizerFFT_CaptureVpp(digitizer_setting, 1, vout_pp);

					//apply digitizer setting
					ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx,ret, __LINE__);

	// 		ret = acm[idx]->StopFG("ACM_CH"); 


	//EW: setting RWN (CBIT21) to TMU Start and FLTMUX (CBIT19) to TMU Stop
	 ret += DriveCBit(idx,TPDispName[0],2);

				ret = OnOffCbit(idx,21,0);//JL: Disconnect RWN from TMU Start			
				ret = OnOffCbit(idx,20, 0);
				ret = OnOffCbit(idx,18, 1);
				ret = OnOffCbit(idx,19, 1);

			// On S0N, S0P
			ret += DriveMuxIO(idx,TPDispName[0],1);

			//p2_reg03=0xc7. JL: enable FHS envelope detection
			ret += WriteSPI(idx,2, 3, 0xc7); //JL: The sense counter and the FLTMUX pin respond the envelope of the sensor detection events.
	//		
	//		//measures freq of FLTMUX. Note: FLTMUX low represents FHS event, refer spec 9.2.4; given RWN is default to 1 through DM_Setting.
	//		//NOTE: Make sure CBIT connects FLTMUX to both TMU Start and Stop. Set cbit 18, 19 in CBITA_Setting.csv
	//
	//// 9.2.4 Envelope Detection
	//// The FHS circuitry provides a feature that reports and increments based on the envelope of the detected sense events,
	//// rather than the isolated events individually. When FHSEnvelopeDetect = 1, the FHS circuit reports as single events
	//// detections that are delayed in time by less than the time constant (43 μs ± 33%). In this mode, the FLTMUX pin
	//// deasserts 43 μs after the leading edge of the last detected event. In other words, isolated, single FHS-detected events
	//// that last 10 μs still assert the FLTMUX pin for 43 μs and increment the FHSCount register once. If, however, a second
	//// event occurs 20 μs after the first, the second event extends the FLTMUX pin assertion by 43 μs and does not increment
	//// the FHSCount register.

			double voh_flt = 0.3;
			double tmu_start_hysteresis = 0.02;
			double tmu_stop_hysteresis = 0.02;
			double tmu_start_threshold = voh_flt;
			double tmu_stop_threshold = voh_flt;

			int number_of_samples = 1;
			double tmu_timeout = 50e-3; 
			int returned_sample_count = 0;
			array<double> ^ sampled_result = gcnew array<double>(number_of_samples);

	//		ret = acm[idx]->AWGQueueWaveform("ACM_CH", 1, ACM_CONST_AUTOTRIG, 0, 4, 0); //Waveform is queued. AWG 0, Waveform 0, 2 cycle, and external trigger=2; auto-trigger=0

			ret += tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
			ret += tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
			ret += tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(Measure_Delay_s);					
				ret = acm[idx]->StartAWG("ACM_CH");
			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

				//ret = acm[idx]->StartAWG("ACM_CH");
				//CheckError(idx,ret, __LINE__);
					//ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
					//CheckError(idx,ret, __LINE__);

					ret += digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx,ret, __LINE__);

	#pragma endregion "Funny 199.999kHz square wave construction"

			//take 10 samples, compute the ave period = t
					int t[5] = { 0, 0,0,0,0};
					int ewi = 0;
			int tx_count = 0;
			int store_status = 0;
			int current_status = 0;
			int stop_me = 3;
			for(int i=0; i<dataArrayP->Length && tx_count <stop_me; i++)
			{
				if(dataArrayP[i] < 0) 
						current_status = -1;
						
				else if(dataArrayP[i] > 0)
						current_status = 1;

				if(!store_status) 
						store_status = current_status;

				if(store_status != current_status) 
					{
						store_status = current_status;
							tx_count ++;
							t[ewi] = i;
							ewi ++;
						if(tx_count == stop_me) 
						{
							result = (double) 1/((t[2] - t[0]+1)*1e-9);	
						}
					}
			}
			
			tf_SetResult_UUTOffset(TPName[1], (result + GetOffset(idx,TPDispName[1])),idx); 
		
			//Param 2
			ret += OnOffSPI(idx,0);
			ret = RunVectorFile(idx,"write_default_reg");
			ret += OnOffSPI(idx,1);
			CheckError(idx,ret, __LINE__);
			
			/*
			write_reg(FHS_VBIAS,0);
			write_reg(FHS_IBIAS,0);
			JL: Refers to same register, FHSBias<6:0>=pg2_reg2[5:0]+pg2_reg12[3]
			*/
			ret += WriteSPI(idx,2, 2, 0); //JL: default = 0x3f
			ret += WriteSPI(idx,2, 12, 0);//JL: default = 0x08 
			
			// write_reg("FAULTMASK", MASK_ALL_BUT_FHS); JL: pg2_reg10 clear bit 4; Enables FHS head open and short detection
			ret += WriteSPI(idx,1, 10, 0xef);
			ret += WriteSPI(idx,3, 11, 0xc0);

			// write_reg(FHS_BIAS_MODE,FHS_VMODE); JL: pg2_reg4 bit 6 = 0; voltage bias
			ret += WriteSPI(idx,2, 4, 0x00);//JL: seems redundant, same as default value. For initial coding, just follow CAT's code.		
			//write_reg(FHSVTH,1); JL: pg2_reg4[3:0]
			ret += WriteSPI(idx,2, 4, 0x01);
			//write_reg("FHSTAFREQ",1); JL: pg2_reg3[6]
			ret += WriteSPI(idx,2, 3, 0x47); //JL: default = 0x07
			//write_reg("FHSFLTEN",1); JL: pg2_reg2[7] FHS events are reported to the FLTMUX pin along with the standard faults. FHS event detection drives the FLTMUX pin to the opposite polarity of the RWn pin.
			ret += WriteSPI(idx,2, 2, 0x80);
			//write_reg("FHSENVELOPEDETECT",1); JL: pg2_reg3[7]
			ret += WriteSPI(idx,2, 3, 0xc7);
			//write_reg("FHSRDANDWRT",1); JL: pg2_reg4[5]
			ret += WriteSPI(idx,2, 4, 0x21);		
			// write_reg(FHS_ENABLE,FHS_ON); JL: pg2_reg4 bit 4 = 1; enable FHS
			ret += WriteSPI(idx,2, 4, 0x31);
			CheckError(idx,ret, __LINE__);

			//EW:   write_reg("FHSENVELOPEDETECT",1);	
			ret += WriteSPI(idx,2, 3, 0xc7);

			ret += DriveMuxIO(idx,TPDispName[1]);

	ret += OnOffSPI(idx,0);

			ret = acm[idx]->StopFG("ACM_CH"); 
				ret = acm[idx]->AWGWaveformFlush("ACM");
				ret = acm[idx]->AWGWaveformLoad("ACM_CH", 0, wav199Ksq->Length, 1, wav199Ksq); //The waveform is transfered to the onboard RAM. Waveform number is 0
	//			ret = acm[idx]->AWGQueueWaveform("ACM_CH", 1, ACM_CONST_AUTOTRIG, 0, 10000, 0); //Waveform is queued. AWG 0, Waveform 0, 2 cycle, and external trigger=2; auto-trigger=0
				ret = acm[idx]->AWGQueueWaveform("ACM_CH", 1, ACM_CONST_AUTOTRIG, 0, 4, 0); //Waveform is queued. AWG 0, Waveform 0, 2 cycle, and external trigger=2; auto-trigger=0

			number_of_samples = 1;
			ret += tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_start_threshold, tmu_start_hysteresis, 0);
			ret += tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_1_1MOHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
			_util->Wait_Sec(Measure_Delay_s);
					
			ret += tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
			_util->Wait_Sec(Measure_Delay_s);

				ret = acm[idx]->StartAWG("ACM_CH");
				CheckError(idx,ret, __LINE__);

			ret += tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);


			result = sampled_result[0] - 42.5e-6; //EW: rev56 is -42.5uS
			
			tf_SetResult_UUTOffset(TPName[2], (result + GetOffset(idx,TPDispName[2])),idx); 
			
			/////////////////////////////////
			ret += OnOffSPI(idx,0);
			ret += Digital_Init_State(idx); 
			ret += ResetDMPin(idx,TPDispName[0]);

			//Power down supplies
			ret = smu[idx]->DriveVoltage("VEE", 0);
			ret = smu[idx]->DriveVoltage("VCC", 0);

			//IO setting
	//		ret = ResetDIOPin(idx,TPDispName[0]);
			ret = ResetCBit(idx);
			ret = ResetMuxIO(idx);

			if (Debug_Enable == true)
			{
				sw->Write(sb);	
				sb = nullptr;
				sw->Close();
				sw = nullptr;

				Debug_Enable = false;
			}
	//		return ret;
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}	
	}
	void TestProgram::prox_diffmux(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));		
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			String ^ Test_Pin_P		= String::Empty;
			String ^ Test_Pin_N		= String::Empty;
			String ^ Vector_File1	= String::Empty;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleTypeP = 0;
			unsigned int moduleTypeN = 0;

			// Check whether resource is SMU or DM
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_P, moduleTypeP);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeP = DM_CONST_MODULE_TYPE;
			}

			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_N, moduleTypeN);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				moduleTypeN = DM_CONST_MODULE_TYPE;
			}

			//init
			//if(!USE_SPI) 
			//{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}
			
			double diffp_V = 0;
			double diffn_V = 0;		
			for (int i=0; i<total_tp; i++)
			{
				Test_Pin_P		= (String ^)tf_TPCondition_Cast(TPName[i], "Test_Pin_P");
				Test_Pin_N		= (String ^)tf_TPCondition_Cast(TPName[i], "Test_Pin_N");	
				//Vector_File1		= (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File1");				
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);

				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);	
				ret = DriveCBit(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);				

				if (Test_Pin_P == "RDP_F")
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin_P, 5); //2
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
					CheckError(idx, ret, __LINE__);
					//_util->Wait_Sec(0.1e-03); //	On_Delay_s	//orig 0.05		//ML remove
				}
				else
				{
					ret = dm[idx]->DPINOff(Test_Pin_P);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 0.5, -0.5); //Clamp_Vo_V, -2
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);	
					ret = dm[idx]->DPINOn(Test_Pin_P);
					CheckError(idx, ret, __LINE__);

					//_util->Wait_Sec(0.1e-03); //On_Delay_s	//ML remove
					//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
					//CheckError(idx, ret, __LINE__);	//orig 0.05
				}
				if (Test_Pin_N == "RDN_F")
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin_N, 5);//2
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
					CheckError(idx, ret, __LINE__);
					//_util->Wait_Sec(0.1e-03);	//On_Delay_s	//orig 0.05			//ML remove
				}
				else
				{
					ret = dm[idx]->DPINOff(Test_Pin_N);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 0.5, -0.5); //Clamp_Vo_V, -2
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);				
					ret = dm[idx]->DPINOn(Test_Pin_N);
					CheckError(idx, ret, __LINE__);

					//_util->Wait_Sec(0.1e-03); //On_Delay_s	//ML remove
					//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
					//CheckError(idx, ret, __LINE__);		//orig 0.05
				}
				
				if (tf_TPCondition_exist(TPName[i], "Vector_File1") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File1"));
				
					if(!USE_SPI) 
					{
						ret = RunVectorFile(idx, Vector_File1);
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = RunSPI(idx, Vector_File1);
						CheckError(idx, ret, __LINE__);
					}
				}

				_util->Wait_Sec(Measure_Delay_s);
				if (Test_Pin_P == "RDP_F") 
				{				
					ret = DriveCBit(idx, TPDispName[0], 1); //for RDP
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(0.1e-03);	//ML ori 0.05
					ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
					CheckError(idx, ret, __LINE__);

					ret = DriveCBit(idx, TPDispName[0], 2); //for RDP
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(0.1e-03);	//ML ori 0.05
					ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					_util->Wait_Sec(0.1e-03);	//ML added
					ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
					CheckError(idx, ret, __LINE__);
				}	
							
				double volt = 0;
				//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
				CheckError(idx, ret, __LINE__);
				
				diffp_V = diffp_V - volt;
				diffn_V = diffn_V - volt;
				
				result[i] = Math::Abs(diffp_V - diffn_V);	

				if (Test_Pin_P == "S0P_F") 
					result[i]/=CONST_Rfhs;
				
				//double vin = (46e-06) * CONST_Rfhs;			//double vin = (result[2] - result[3]) * CONST_Rfhs;
				//double av = (42e-03) / vin;					//double av = (result[1] - result[0]) / vin;
				//double avdb = 20 * Math::Log10(1.055);			//double avdb = 20 * Math::Log10(fabs(av));

				double vin = (result[2] - result[3]) * CONST_Rfhs;
				double av = (result[1] - result[0]) / vin;
				double avdb = 20 * Math::Log10(fabs(av));

				if (TPName[i]->Contains("Av_g2"))
					result[i] = avdb;
					
				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				
			}

		/////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::prox_detect(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;
		
		int ret = 0;
		
		try 
		{		
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result		= gcnew array<double>(20);	//ori 10

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				//result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			// hardware constant
			double R30			= 37.4;    //update to 2945, 2935 is 45.3
			double R31			= 5.11;      //2935 is 10
			double Rfhs			= R31 + (2*R30);

			// result variables
			/*bk : need to change for result array
			array<double> ^ result_sbhv	= gcnew array<double>(10);	//ori is 5
			array<double> ^ result_fhs	= gcnew array<double>(10);	//
			array<double> ^ result_adc	= gcnew array<double>(10);	//
			double diffp_V = 0.0;
			double diffn_V = 0.0;
			array<double> ^ result_sbhv_500	= gcnew array<double>(5);	
			array<double> ^ result_fhs500	= gcnew array<double>(5);	
			array<double> ^ result_adc500	= gcnew array<double>(5); */

			//Get test condition from techFlow
			bool isCurrentTPBypassed= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;

			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
		
			String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
			String ^ Vector_File_Init2		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init2"));
			String ^ Vector_File_FHSBIAS32		= (String ^)(tf_TestItemCondition_Cast("Vector_File_FHSBIAS32"));
			String ^ Vector_File_FHSBIAS31		= (String ^)(tf_TestItemCondition_Cast("Vector_File_FHSBIAS31"));
			String ^ Vector_File_Sweep_DAC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep_DAC"));
			String ^ Vector_FHSFLTBLANK_44		= (String ^)(tf_TestItemCondition_Cast("Vector_FHSFLTBLANK_44"));
			String ^ Vector_FHSFLTBLANK_43		= (String ^)(tf_TestItemCondition_Cast("Vector_FHSFLTBLANK_43"));
		
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			array<int>^ HistoryRam = gcnew array<int>(256);	
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			///////////////////////////////////////////////////////////////////////////

			//Configuring FLTMUX pin
			String ^ Test_Pin = "FLTMUX";
			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, 2, -2);	//5, 0
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ConfigurePLF("MTX_SMU", Power_Line_Freq);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->SetBandwidth("MTX_SMU", 1);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->SetNPLC("MTX_SMU", NPLC);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampVoltage("MTX_SMU", Clamp_Vo_V);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("MTX_SMU", false, false);
			//CheckError(idx, ret, __LINE__);

			////Configure GNDS Mux
			//ret = Configure_GNDS_Mux(idx, NPLC);		//added by ML
			//CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s); 

			//Init
			//if(!USE_SPI) 
			//{
				ret = RunVectorFile(idx, Vector_File_Init);
				CheckError(idx, ret, __LINE__);
				//ret = RunVectorFile(idx, Vector_File_Hsel);	//ML mask first...
				//CheckError(idx, ret, __LINE__);				
			//} 
			//else 
			//{
				//ret = RunSPI(idx, Vector_File_Init);
				//CheckError(idx, ret, __LINE__);
				//ret = RunSPI(idx, Vector_File_Hsel);
				//CheckError(idx, ret, __LINE__);			
			//}			
			
			_util->Wait_Sec(Measure_Delay_s); //5ms wait time before measure

			double vout_initial=0;
			double val = 0;	//added by ML

			//Measure FLTMUX initial voltage
			ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vout_initial);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ReadVoltage("MTX_SMU", vout_initial);
			//CheckError(idx, ret, __LINE__);

			//OnOffCbit(idx, 11,0);
			//OnOffCbit(idx, 42,0);
			//OnOffCbit(idx, 8,1);
			//OnOffCbit(idx, 17,1);

			//_util->Wait_Sec(Measure_Delay_s);

			//ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);		//added by ML
			//CheckError(idx, ret, __LINE__);

			//Measure GNDS
			ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
			CheckError(idx, ret, __LINE__);

			vout_initial = vout_initial - val;

			int found_GT=0;
			int found_LT=0;
			double vsout_adj=0;
			int i=0;
			int bk=0;
			int dccanceldac;		//ML suppose to be 0	//44
			String ^ vector_file_str = "" ;

			for (int dccancel_dac_1 = 22 ; dccancel_dac_1 < 66; dccancel_dac_1++)
			{
				found_LT=1;
				switch (dccancel_dac_1)
				{
					case 22:
						vector_file_str = Vector_File_Sweep + "22";  
						break;
					case 23:
						vector_file_str = Vector_File_Sweep + "23";
						break;
					case 24:
						vector_file_str = Vector_File_Sweep + "24";
						break;
					case 25:
						vector_file_str = Vector_File_Sweep + "25";	
						break;
					case 26:
						vector_file_str = Vector_File_Sweep + "26";	
						break;
					case 27:
						vector_file_str = Vector_File_Sweep + "27";  
						break;
					case 28:
						vector_file_str = Vector_File_Sweep + "28";
						break;
					case 29:
						vector_file_str = Vector_File_Sweep + "29";
						break;
					case 30:
						vector_file_str = Vector_File_Sweep + "30";	
						break;
					case 31:
						vector_file_str = Vector_File_Sweep + "31";	
						break;
					case 32:
						vector_file_str = Vector_File_Sweep + "32";  
						break;
					case 33:
						vector_file_str = Vector_File_Sweep + "33";
						break;
					case 34:
						vector_file_str = Vector_File_Sweep + "34";
						break;
					case 35:
						vector_file_str = Vector_File_Sweep + "35";	
						break;
					case 36:
						vector_file_str = Vector_File_Sweep + "36";	
						break;
					case 37:
						vector_file_str = Vector_File_Sweep + "37";  
						break;
					case 38:
						vector_file_str = Vector_File_Sweep + "38";
						break;
					case 39:
						vector_file_str = Vector_File_Sweep + "39";
						break;
					case 40:
						vector_file_str = Vector_File_Sweep + "40";	
						break;
					case 41:
						vector_file_str = Vector_File_Sweep + "41";	
						break;
					case 42:
						vector_file_str = Vector_File_Sweep + "42";  
						break;
					case 43:
						vector_file_str = Vector_File_Sweep + "43";
						break;
					case 44:
						vector_file_str = Vector_File_Sweep + "44";
						break;
					case 45:
						vector_file_str = Vector_File_Sweep + "45";	
						break;
					case 46:
						vector_file_str = Vector_File_Sweep + "46";	
						break;
					case 47:
						vector_file_str = Vector_File_Sweep + "47";  
						break;
					case 48:
						vector_file_str = Vector_File_Sweep + "48";
						break;
					case 49:
						vector_file_str = Vector_File_Sweep + "49";
						break;
					case 50:
						vector_file_str = Vector_File_Sweep + "50";	
						break;
					case 51:
						vector_file_str = Vector_File_Sweep + "51";	
						break;
					case 52:
						vector_file_str = Vector_File_Sweep + "52";  
						break;
					case 53:
						vector_file_str = Vector_File_Sweep + "53";
						break;
					case 54:
						vector_file_str = Vector_File_Sweep + "54";
						break;
					case 55:
						vector_file_str = Vector_File_Sweep + "55";	
						break;
					case 56:
						vector_file_str = Vector_File_Sweep + "56";	
						break;
					case 57:
						vector_file_str = Vector_File_Sweep + "57";  
						break;
					case 58:
						vector_file_str = Vector_File_Sweep + "58";
						break;
					case 59:
						vector_file_str = Vector_File_Sweep + "59";
						break;
					case 60:
						vector_file_str = Vector_File_Sweep + "60";	
						break;
					case 61:
						vector_file_str = Vector_File_Sweep + "61";	
						break;
					case 62:
						vector_file_str = Vector_File_Sweep + "62";  
						break;
					case 63:
						vector_file_str = Vector_File_Sweep + "63";
						break;
					case 64:
						vector_file_str = Vector_File_Sweep + "64";
						break;
					case 65:
						vector_file_str = Vector_File_Sweep + "65";	
						break;	
				}

				//if(!USE_SPI) {
				ret = RunVectorFile(idx, vector_file_str);
				CheckError(idx, ret, __LINE__);
				//} else {
				//ret = RunSPI(idx, vector_file_str);
				//CheckError(idx, ret, __LINE__);
				//}				
					
				_util->Wait_Sec(Measure_Delay_s);
				
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout_adj);
				CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ReadVoltage("MTX_SMU", vsout_adj);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				//OnOffCbit(idx, 11,0);
				//OnOffCbit(idx, 42,0);
				//OnOffCbit(idx, 8,1);
				//OnOffCbit(idx, 17,1);

				//ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);		//added by ML
				//CheckError(idx, ret, __LINE__);

				//Measure GNDS
				ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
				CheckError(idx, ret, __LINE__);

				vsout_adj = vsout_adj - val;

				if (vsout_adj<1)
				{
					dccanceldac=dccancel_dac_1;
					break;
				}
				found_GT=1;
				found_LT=0;
			} 
			
			//bk = dccancel_dac_1;
			//int dccanceldac = 0;
			double vsout_gaincal[2] = {0};
			double vsout[8][2] = {0};
			int dac=0;
			int result_count=0;

			//bk int dccanceldac=i;
			//Run dccancel init file
			
			//if(!USE_SPI) {
			ret = RunVectorFile(idx, Vector_File_Init2);
			CheckError(idx, ret, __LINE__);
			//} else {
			//ret = RunSPI(idx, Vector_File_Init2);	//ML to check with BK - Vector_File_Init2 or Vector_File_Init
			//CheckError(idx, ret, __LINE__);
			//}
						
			_util->Wait_Sec(Measure_Delay_s);
			
			ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout_gaincal[0]);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ReadVoltage("MTX_SMU", vsout_gaincal[0]);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(Measure_Delay_s);

			//OnOffCbit(idx, 11,0);
			//OnOffCbit(idx, 42,0);
			//OnOffCbit(idx, 8,1);
			//OnOffCbit(idx, 17,1);

			//ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);		//added by ML
			//CheckError(idx, ret, __LINE__);

			//Measure GNDS
			ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
			CheckError(idx, ret, __LINE__);

			vsout_gaincal[0] =  vsout_gaincal[0] - val;

			tf_SetResult_UUTOffset(TPName[result_count], vsout_gaincal[0] + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;

			//if(!USE_SPI) {
			ret = RunVectorFile(idx, Vector_File_FHSBIAS32);
			CheckError(idx, ret, __LINE__);
			//} else {
			//ret = RunSPI(idx, Vector_File_FHSBIAS32);
			//CheckError(idx, ret, __LINE__);
			//}			
			
			_util->Wait_Sec(Measure_Delay_s);
			ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout_gaincal[1]);
			CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->ReadVoltage("MTX_SMU", vsout_gaincal[1]);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(Measure_Delay_s);

			//OnOffCbit(idx, 11,0);
			//OnOffCbit(idx, 42,0);
			//OnOffCbit(idx, 8,1);
			//OnOffCbit(idx, 17,1);

			//ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);		//added by ML
			//CheckError(idx, ret, __LINE__);

			//Measure GNDS
			ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
			CheckError(idx, ret, __LINE__);

			vsout_gaincal[1] =  vsout_gaincal[1] - val;

			tf_SetResult_UUTOffset(TPName[result_count], vsout_gaincal[1] + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;

			//if(!USE_SPI) {
			ret = RunVectorFile(idx, Vector_File_FHSBIAS31);
			CheckError(idx, ret, __LINE__);
			//} else {
			//ret = RunSPI(idx, Vector_File_FHSBIAS31);
			//CheckError(idx, ret, __LINE__);
			//}				
			
			for (dac=0; dac<8; dac++)
			{
				switch (dac)
				{
					case 0:
						vector_file_str = Vector_File_Sweep_DAC + "0";  
						break;
					case 1:
						vector_file_str = Vector_File_Sweep_DAC + "1";  
						break;
					case 2:
						vector_file_str = Vector_File_Sweep_DAC + "2";  
						break;
					case 3:
						vector_file_str = Vector_File_Sweep_DAC + "3";  
						break;
					case 4:
						vector_file_str = Vector_File_Sweep_DAC + "4";  
						break;
					case 5:
						vector_file_str = Vector_File_Sweep_DAC + "5";  
						break;
					case 6:
						vector_file_str = Vector_File_Sweep_DAC + "6";  
						break;
					case 7:
						vector_file_str = Vector_File_Sweep_DAC + "7";  
						break;
					}
					
				//if(!USE_SPI) {
				ret = RunVectorFile(idx, vector_file_str);
				CheckError(idx, ret, __LINE__);
				//} else {
				//ret = RunSPI(idx, vector_file_str);
				//CheckError(idx, ret, __LINE__);
				//}
					
				_util->Wait_Sec(Measure_Delay_s);

				int reg_value;
				ret = OnOffSPI(idx,1);
				ret = WriteSPI(idx, 2, 6,dccanceldac);
				ret = ReadReg(idx, 2, 6, reg_value);
				ret = OnOffSPI(idx, 0);

				////For i=0;
				////if(!USE_SPI) {
				//ret = RunVectorFile(idx, Vector_FHSFLTBLANK_44);
				//CheckError(idx, ret, __LINE__);
				////} else {
				////ret = RunSPI(idx, Vector_FHSFLTBLANK_44);
				////CheckError(idx, ret, __LINE__);
				////}				
				
				_util->Wait_Sec(Measure_Delay_s);
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout[dac][0]);
				CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ReadVoltage("MTX_SMU", vsout[dac][0]);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				//OnOffCbit(idx, 11,0);
				//OnOffCbit(idx, 42,0);
				//OnOffCbit(idx, 8,1);
				//OnOffCbit(idx, 17,1);

				//ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);		//added by ML
				//CheckError(idx, ret, __LINE__);

				//Measure GNDS
				ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
				CheckError(idx, ret, __LINE__);

				vsout[dac][0] =  vsout[dac][0] - val;
				
				tf_SetResult_UUTOffset(TPName[result_count], vsout[dac][0] + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;

				int dccanceldac_m1 = dccanceldac - 1;
				ret = OnOffSPI(idx,1);
				ret = WriteSPI(idx, 2, 6,dccanceldac_m1);
				ret = ReadReg(idx, 2, 6, reg_value);
				ret = OnOffSPI(idx, 0);

				////For i=1
				////if(!USE_SPI) {
				//ret = RunVectorFile(idx, Vector_FHSFLTBLANK_43);
				//CheckError(idx, ret, __LINE__);
				////} else {
				////ret = RunSPI(idx, Vector_FHSFLTBLANK_43);
				////CheckError(idx, ret, __LINE__);
				////}								
				
				_util->Wait_Sec(Measure_Delay_s);
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout[dac][1]);
				CheckError(idx, ret, __LINE__);

				//ret = smu[idx]->ReadVoltage("MTX_SMU", vsout[dac][1]);
				//CheckError(idx, ret, __LINE__);

				//_util->Wait_Sec(Measure_Delay_s);

				//OnOffCbit(idx, 11,0);
				//OnOffCbit(idx, 42,0);
				//OnOffCbit(idx, 8,1);
				//OnOffCbit(idx, 17,1);

				//ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);		//added by ML
				//CheckError(idx, ret, __LINE__);

				//Measure GNDS
				ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
				CheckError(idx, ret, __LINE__);

				vsout[dac][1] =  vsout[dac][1] - val;
				
				tf_SetResult_UUTOffset(TPName[result_count], vsout[dac][1] + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;
		
			}

			double vin=0;
			double diffmux_k32=1661.8958e-6;		//to get from diffmux value
			double diffmux_k31=1606.3693e-6;		//to get from diffmux value
			double rfhs=79.91;
			double av[8];
			double FSAV0;
			double avdb[8];
			double dccancel;
			double test_r;

			//bk: for dccancel_dac, dunno why it always 0 and need to use i
			tf_SetResult_UUTOffset(TPName[result_count], dccanceldac + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;

			vin = (diffmux_k32-diffmux_k31)*rfhs;
			av[0]= (vsout_gaincal[1] - vsout_gaincal[0])/vin;
			FSAV0=av[0];	//pass to prox_dacs -- to assign global

			_glob->global_fsav0 = FSAV0;
			
			dccancel=((2e-3)*44)+(40e-3);
			test_r=((diffmux_k31*Rfhs)-dccancel)-((vsout_gaincal[0]-1)/FSAV0);
			tf_SetResult_UUTOffset(TPName[result_count], test_r + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;

			avdb[0]=(20*Math::Log10(fabs(FSAV0)));
			tf_SetResult_UUTOffset(TPName[result_count], avdb[0] + GetOffset(idx, TPDispName[result_count]), idx);
			result_count++;
			
			vin = (vsout[0][1]-vsout[0][0])/FSAV0;
			
			for (dac=1; dac<8; dac++)
			{
				av[dac] = (vsout[dac][1]-vsout[dac][0])/vin;
				avdb[dac] = (20 * log10(fabs(av[dac])));

				tf_SetResult_UUTOffset(TPName[result_count], avdb[dac] + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;

			}

				tf_SetResult_UUTOffset(TPName[result_count], avdb[0] + GetOffset(idx, TPDispName[result_count]), idx);
				result_count++;

//			//////////////////AC part
//			double Vswg=0.4;
//			double Fswg=0;
//
//			double diff2se_digitizer_factor = 1;
//			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_LF_PROX_DETECT"))
//				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_LF_PROX_DETECT"][idx];
//
//			for (dac=0; dac<3; dac++)
//			{
//				//Digitizer setting
//				int mode = 0;	//0 = normal data acquisition (digitizer)
//								//2 = averaging mode (it makes the instrument run as a real-time averager)
//				int flag = 0;	//0 = normal
//								//1 = ‘Start on Trigger’ mode
//				double sampInterval = 1e-9; //1e-9; //32ns to capture 5 cycles of 20kHz signal
//				double delayTime = 0.0;
//				int nbrSamples = 8192; //262144; //4096; //1024; //8192; //must be 2^n  //ML was 2048
//				int nbrSegments = 1;
//				int coupling = 3;//4;	//0 Ground (Averagers ONLY) //bk: change frm 3-> 4
//									//1 DC, 1 M-ohm
//									//2 AC, 1 M-ohm
//									//3 DC, 50 M-ohm
//									//4 AC, 50 M-ohm
//				int bandwidth = 0;	//0 no bandwidth limit (default)
//									//1 bandwidth limit at 25 MHz
//									//2 bandwidth limit at 700 MHz
//									//3 bandwidth limit at 200 MHz
//									//4 bandwidth limit at 20 MHz
//									//5 bandwidth limit at 35 MHz
//				double fullScale = 2;//1.0; //1V or 2V	//ML was 2.0
//				double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
//										//2V range: ±4 V (max signal = ±6.3 V)
//				long trigClass = 0;		//0 edge trigger 
//				long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
//												//0x000n0002 for Channel 2
//
//				switch (dac)
//				{
//					case 0:
//						Fswg=20000;
//						nbrSamples = 65536;
//						break;
//					case 1:
//						Fswg=120000;
//						break;
//					case 2:
//						Fswg=600000;
//						nbrSamples = 4096;
//						break;
//				}
//
//				try
//				{
//					//resourceManager = gcnew ResourceManager(HardwareProfile, testHead, idx);
//
//					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];
//
//					if (hardwareResource->Alias->Contains("Ch1"))
//					{
//						sourcePattern = 0x00000001;
//					}
//					else if (hardwareResource->Alias->Contains("Ch2"))
//					{
//						sourcePattern = 0x00000002;
//					}
//
//					//if (resourceManager)
//					//	delete resourceManager;
//				}
//				catch (Exception ^ e)
//				{
//					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
//				}
//
//				long trigCoupling = 0;	//0 DC
//										//1 AC
//										//2 HF Reject (if available)
//										//3 DC, 50 (ext. trigger only, if available)
//										//4 AC, 50 (ext. trigger only, if available)
//				long trigSlope = 0;	//0 Positive
//									//1 Negative
//									//2 out of Window
//									//3 into Window
//									//4 HF divide
//									//5 Spike Stretcher
//				double trigLevel = 0;	//% of FS 
//										//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
//				int timeOut_ms = 100;
//
//				//try array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
//				array<double> ^ dataArrayN;
//				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
//				dataArrayN = gcnew array<double>(nbrSamples);
//
//				double dataTemp = 0;
//				complex<double> * dataArrayComplex = new complex<double>[nbrSamples];		//
//				array<double> ^ magn = gcnew array<double>(nbrSamples);			//
//				double vout_pp = 0.0;
//				double vpp;
//				double fftBIN = 0;
//				int magn_peak_index = 0;
//
//				int max_loop = 50;
//
//				int Decimation_Factor = 1; //1GS/s
//				if (Fswg < 10e6)
//				{
//					Decimation_Factor = 4; //250MS/s
//				}
//
//				array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
//				digitizer_setting[0] = sampInterval;
//				digitizer_setting[1] = delayTime;
//				digitizer_setting[2] = (double)nbrSamples;
//				digitizer_setting[3] = (double)nbrSegments;
//				digitizer_setting[4] = fullScale; 
//				digitizer_setting[5] = offset;
//				digitizer_setting[6] = (double)coupling;
//				digitizer_setting[7] = (double)bandwidth;
//				digitizer_setting[8] = (double)trigClass;
//				digitizer_setting[9] = (double)sourcePattern;
//				digitizer_setting[10] = (double)trigCoupling;
//				digitizer_setting[11] = (double)trigSlope;
//				digitizer_setting[12] = trigLevel;
//				digitizer_setting[13] = (double)timeOut_ms;
//				digitizer_setting[14] = (double)Decimation_Factor;
//
//			//Calibration of Vpp
//			
//			if ((Vswg_proxdetect_20k_calibrated->ContainsKey(TIDispName) == false) || (Vswg_proxdetect_120k_calibrated->ContainsKey(TIDispName) == false) || (Vswg_proxdetect_600k_calibrated->ContainsKey(TIDispName) == false))
//			{
//				double Vswg_cal = 0;
//				int loop_count = 0;
//
//				//On K3, K4
//				ret = DriveCBit(idx, TPDispName[0], 1);
//				CheckError(idx, ret, __LINE__);
//
//				Vswg_cal = Vswg;
//
//				ret = acm[idx]->ResetChannel("ACM_CH");
//				CheckError(idx, ret, __LINE__);
//				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
//				CheckError(idx, ret, __LINE__);
//				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
//				CheckError(idx, ret, __LINE__);
//				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
//				CheckError(idx, ret, __LINE__);
//				_util->Wait_Sec(1e-3);
//				ret = acm[idx]->RunFG("ACM_CH", 0, true);
//				CheckError(idx, ret, __LINE__);
//				_util->Wait_Sec(Measure_Delay_s);
//
//				int do_once = 0;
//				while(loop_count <= max_loop)
//				{
//					if (do_once == 0)
//					{
//						ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth); //bk
//						CheckError(idx, ret, __LINE__);	
//						//ret = DigitizerFFT_Configure(digitizer_setting);
//						ret = Digitizer_Configure(idx, digitizer_setting);
//						CheckError(idx, ret, __LINE__);
//						do_once = 1;
//					}
//
//					//ret = DigitizerFFT_CaptureVpp(digitizer_setting, 0.350, vout_pp);
//					ret = Digitizer_CaptureVpp(idx, digitizer_setting, diff2se_digitizer_factor, vout_pp, dataArrayP);
//					//ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
//					
//					//ML temp mask
//					if (ret)
//					{
//						ret = digitizer[idx]->StopAcquire("DIGITIZER");
//						CheckError(idx, ret, __LINE__);
//
//						ret = acm[idx]->StopFG("ACM_CH"); 
//						CheckError(idx, ret, __LINE__);
//
//						if(TIDispName == "cal_fhsawgin")
//						{
//							tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
//						}	
//						else
//						{
//							for (int i=0; i<total_tp; i++)
//							{
//								tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
//							}
//						}
//
//						goto test_end;
//					}
//
//					if (Math::Abs(Vswg - vout_pp) < (2e-3))
//					{
//						break;
//					}
//					else
//					{
//						Vswg_cal = Vswg_cal + (Vswg - vout_pp);
//
//						ret = acm[idx]->StopFG("ACM_CH"); 
//						CheckError(idx, ret, __LINE__);
//						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
//						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
//						{
//							CheckError(idx, ret, __LINE__);	
//						}
//
//						if (ret != 0)
//						{
//							ret = 0;
//
//							ret = digitizer[idx]->StopAcquire("DIGITIZER");
//							CheckError(idx, ret, __LINE__);
//							ret = acm[idx]->StopFG("ACM_CH"); 
//							CheckError(idx, ret, __LINE__);
//							
//							//off K3, K4
//							ret = DriveCBit(idx, TPDispName[0], 0);
//							CheckError(idx, ret, __LINE__);
//
//							if(TIDispName == "cal_fhsawgin")
//							{
//								tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
//							}
//							else
//							{
//								for (int i=0; i<total_tp; i++)
//								{
//									tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
//								}
//							}
//
//							goto test_end;
//						}
//
//						ret = acm[idx]->RunFG("ACM_CH", 0, true);
//						CheckError(idx, ret, __LINE__);
//						_util->Wait_Sec(Measure_Delay_s);
//					}
//		
//					loop_count++;
//				}
//
//				if (loop_count > max_loop)
//				{
//					ret = digitizer[idx]->StopAcquire("DIGITIZER");
//					CheckError(idx, ret, __LINE__);
//					ret = acm[idx]->StopFG("ACM_CH"); 
//					CheckError(idx, ret, __LINE__);
//					
//					//off K3, K4
//					ret = DriveCBit(idx, TPDispName[0], 0);
//					CheckError(idx, ret, __LINE__);
//
//					if(TIDispName == "cal_fhsawgin")
//					{
//						tf_SetResult_UUTOffset(TPName[0], (int)(0 + GetOffset(idx, TPDispName[0])), idx);
//					}		
//					else
//					{
//						for (int i=0; i<total_tp; i++)
//						{
//							tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
//						}
//					}
//
//					goto test_end;
//				}
//							
//				ret = digitizer[idx]->StopAcquire("DIGITIZER");
//				CheckError(idx, ret, __LINE__);
//				ret = acm[idx]->StopFG("ACM_CH"); 
//				CheckError(idx, ret, __LINE__);
//				
//				//off K3, K4
//				ret = DriveCBit(idx, TPDispName[0], 0);
//				CheckError(idx, ret, __LINE__);
//
//				if (dac==0)
//				{
//					Vswg_proxdetect_20k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
//					Vswg_proxdetect_20k_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);	
//				}
//				if (dac==1)
//				{
//					Vswg_proxdetect_120k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
//					Vswg_proxdetect_120k_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
//				}
//				if (dac==2)
//				{
//					Vswg_proxdetect_600k_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
//					Vswg_proxdetect_600k_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
//				}
//			}
//
//			int reg_val;
//
//			double vin=0;
//			double vin_r1=0;
//			array<double> ^ avhfpdb = gcnew array<double>(3);
//			array<double> ^ hfp = gcnew array<double>(3);
//			
//			ret = DriveCBit(idx, TPDispName[0], 2);
//			CheckError(idx, ret, __LINE__);
//
//			if (dac==0)
//			{
//				ret = OnOffSPI(idx, 1);
//				ret = WriteSPI(idx, 2, 5, 0x0);
//				ret = WriteSPI(idx, 2, 6, dccanceldac);
//				ret = WriteSPI(idx, 2, 3, 0x0); //7
//				ret = OnOffSPI(idx, 0);
//				vin = Vswg_proxdetect_20k_calibrated[idx.ToString() + "_" + TIDispName];
//				vin_r1 = Vswg_proxdetect_20k_dut[idx.ToString() + "_" + TIDispName]/CONST_FSAv_div;
//			}
//			if (dac==1)
//			{
//				ret = OnOffSPI(idx, 1);
//				ret = WriteSPI(idx, 2, 3, 0x1); //0
//				ret = OnOffSPI(idx, 0);
//				vin = Vswg_proxdetect_120k_calibrated[idx.ToString() + "_" + TIDispName];
//				vin_r1 = Vswg_proxdetect_120k_dut[idx.ToString() + "_" + TIDispName]/CONST_FSAv_div;	
//			}
//			if (dac==2)
//			{
//				ret = OnOffSPI(idx, 1);
//				ret = WriteSPI(idx, 2, 3, 0x7);//1
//				ret = OnOffSPI(idx, 0);
//				vin = Vswg_proxdetect_600k_calibrated[idx.ToString() + "_" + TIDispName];
//				vin_r1 = Vswg_proxdetect_600k_dut[idx.ToString() + "_" + TIDispName]/CONST_FSAv_div;
//			}
//		
//			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", vin/2, -1 * vin/2, Fswg, 0); //JL: pin, high level, low level, freq, offset	
//			ret = acm[idx]->RunFG("ACM_CH", 0, true);
//			_util->Wait_Sec(Measure_Delay_s);
//			
//			//ret = DigitizerFFT_CaptureVpp(sourcePattern, digitizer_setting, diff2se_digitizer_factor, vout_pp);
//			ret = OnOffSPI(idx, 1);
//			ret = ReadReg(idx, 2, 12, reg_val); //expect bit3=1
//			ret = ReadReg(idx, 2, 2, reg_val); //expect bit[3:0]=1
//			ret = ReadReg(idx, 2, 11, reg_val); //expect bit3=0
//			ret = ReadReg(idx, 2, 4, reg_val);//expect bit4=1
//			ret = ReadReg(idx, 2, 6, reg_val);//expect 44
//			ret = ReadReg(idx, 2, 5, reg_val);//expect 0
//			ret = ReadReg(idx, 2, 3, reg_val);//expect 7
//			ret = OnOffSPI(idx, 0);
//
//			ret = Digitizer_CaptureVpp(idx, digitizer_setting, diff2se_digitizer_factor, vout_pp, dataArrayP);
//			Digitizer_GetVpp(0, digitizer_setting, diff2se_digitizer_factor, dataArrayP, vpp);
//
//			avhfpdb[dac]= 20*Math::Log10(vpp/vin_r1);
//			//double db_loss = Math::Abs(avdb[0] - avhfpdb[dac]);
//			double db_loss = avdb[0] - avhfpdb[dac];
//			double calc_sqr = Math::Pow(10, (db_loss/10))-1;
//			double calc_sqr_2=Math::Sqrt(calc_sqr);
//			if (calc_sqr>0)
//			{
//				hfp[dac]=(Fswg/calc_sqr_2);
//			}
//
//			tf_SetResult_UUTOffset(TPName[result_count], hfp[dac] + GetOffset(idx, TPDispName[result_count]), idx);
//			tf_SetResult_UUTOffset(TPName[result_count+3], db_loss + GetOffset(idx, TPDispName[result_count+3]), idx);
//			result_count++;
//
//		}
//			
//			ret = OnOffSPI(idx, 1);
//			ret = WriteSPI(idx, 2, 3, 0x7);
//			ret = OnOffSPI(idx, 0);
//
//			/////////////////AC part
//
//test_end:	ret = acm[idx]->ResetChannel("ACM_CH");
//			CheckError(idx, ret, __LINE__);
		
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::prox_dacs(Object^ object) //JL new test
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
					
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]); 
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//String ^ Test_Pin_P = "S0P_F";		
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);

			//String ^ Test_Pin_P = "S0N_F";
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(idx, ret, __LINE__);
			
			String ^ Flt_Pin = "FLTMUX";
			ret = dm[idx]->Force(Flt_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Flt_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Flt_Pin, Math::Abs(Clamp_Vo_V), -1 * Math::Abs(Clamp_Vo_V));
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Flt_Pin, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Flt_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Flt_Pin);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Flt_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			///////////////////////////////////////////////////////////////////////////////
			//init
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);

			double diffp_V = 0;
			double diffn_V = 0;
			
			array<double> ^ vsout = gcnew array<double>(3);
			array<double> ^ dccancel_v = gcnew array<double>(3);
			
			int dac, i, found_GT, found_LT;
			
			//FHSBIAS_V=0 <6:1> p2_reg2{5:0] <0> p2_reg12[3]
			WriteSPI(idx, 2, 2, 0x0); //default bit7:6=0
			WriteSPI(idx, 2, 12, 0x0); //default 0		
			//FHSIMODE=1 p2_reg4[6]=1; FHS_EN=1 bit4=1
			WriteSPI(idx, 2, 4, 0x50);		
			//FHSDCDISABLE = 0, p2_reg11[3]
			WriteSPI(idx, 2, 11, 0x0);
			//FHSGAIN = 0, p2_reg5[2:0]
			WriteSPI(idx, 2, 5, 0x0);
			//AMUX=7 (FHS_PeakDet_VoutP), pg1_reg15 bit7=0, bit6=DMUXAMUXN=0, bit5:0=MUX[5:0]=00_0111 ; pg3_reg13[6]=MUX[6]=0
			ret = WriteSPI(idx, 1, 15, 0x07);
			ret = WriteSPI(idx, 3, 13, 0x00);		
			
			for(dac=0; dac<2; dac++)
			{
				switch(dac)
				{
					case 0:
							//FHSBIAS_I=9=000_1001 <6:1> p2_reg2{5:0] <0> p2_reg12[3]
							WriteSPI(idx, 2, 2, 0x04); //p2_reg2{5:0]=00_0100
							WriteSPI(idx, 2, 12, 0x08); //p2_reg12[3]=1
							//FHSFLTBLANK=0 p2_reg6
							WriteSPI(idx, 2, 6, 0x00);
							break;
					case 1:
							//FHSBIAS_I=74=100_1010 <6:1> p2_reg2{5:0] <0> p2_reg12[3]
							WriteSPI(idx, 2, 2, 0x25); //p2_reg2{5:0]=10_0101
							WriteSPI(idx, 2, 12, 0x00); //p2_reg12[3]=0
							//FHSFLTBLANK=127 p2_reg6
							WriteSPI(idx, 2, 6, 0x7f);
				}
				
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout[dac]);
			}

			//FHSFLTBLANK=228 p2_reg6
			WriteSPI(idx, 2, 6, 0xe4);
			
			for (i=117; i<127; i+=3)
			{
				found_GT=1;
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vsout[2]);
				if(vsout[2]>0.1)
					break;
				found_LT=1;
				found_GT=0;
				//FHSBIAS_I=i
				WriteSPI(idx, 2, 2, i>>1); //p2_reg2{5:0]
				WriteSPI(idx, 2, 12, (i&1)<<3); //p2_reg12[3]
			}		
			int dccancel_dac=i;
			
			array<double> ^ ifhs_k = gcnew array<double>(128);
			int j=0;
			
			for(i=0; i<6; i++)//get vdiff 6 times for different FHSBIAS_I
			{
				switch(i)
				{
					case 0:
						//FHSBIAS_I=126=111_1110
						WriteSPI(idx, 2, 2, 0x3f); //p2_reg2{5:0]=11_1111
						WriteSPI(idx, 2, 12, 0x0); //p2_reg12[3]=0
						j=126;
						break;
						
					case 1:
						//FHSBIAS_I=123=111_1011
						WriteSPI(idx, 2, 2, 0x3d); //p2_reg2{5:0]=11_1101
						WriteSPI(idx, 2, 12, 0x08); //p2_reg12[3]=1
						j=123;
						break;
						
					case 2:
						//FHSBIAS_I=120=111_1000
						WriteSPI(idx, 2, 2, 0x3c); //p2_reg2{5:0]=11_1100
						WriteSPI(idx, 2, 12, 0x0); //p2_reg12[3]=0
						j=120;
						break;
						
					case 3:
						//FHSBIAS_I=117=111_0101
						WriteSPI(idx, 2, 2, 0x3a); //p2_reg2{5:0]=11_1010
						WriteSPI(idx, 2, 12, 0x08); //p2_reg12[3]=1
						j=117;
						break;
						
					case 4:
						//FHSBIAS_I=74=100_1010
						WriteSPI(idx, 2, 2, 0x25); //p2_reg2{5:0]=10_0101
						WriteSPI(idx, 2, 12, 0x0); //p2_reg12[3]=0
						j=74;
						break;
						
					case 5:
						//FHSBIAS_I=9=000_1001
						WriteSPI(idx, 2, 2, 0x04); //p2_reg2{5:0]=00_0100
						WriteSPI(idx, 2, 12, 0x08); //p2_reg12[3]=1
						j=9;
						break;				
				}			
				_util->Wait_Sec(0.5e-6);
				
				ret = dm[idx]->PMUMeasure("S0P_F", DM_CONST_MEASUREVOLTAGE, diffp_V);
				ret = dm[idx]->PMUMeasure("S0N_F", DM_CONST_MEASUREVOLTAGE, diffn_V);
				
				ifhs_k[j] = fabs(diffp_V-diffn_V)/79.91 ; //JL: from pinmap_p2.tl, Rfhs - Fly Height Sense load = R31 + 2*R30; R31 = 5.11; R30 = 37.4
			}
			
			//param 0 - ifhs_k[dccancel_dac]
			i=0;
			tf_SetResult_UUTOffset(TPName[i], ifhs_k[dccancel_dac] + GetOffset(idx, TPDispName[i]), idx);
			
			//param 1 - ifhs_k[74]
			i=1;
			tf_SetResult_UUTOffset(TPName[i], ifhs_k[74] + GetOffset(idx, TPDispName[i]), idx);
			
			//param 2 - ifhs_k[9]
			i=2;
			tf_SetResult_UUTOffset(TPName[i], ifhs_k[9] + GetOffset(idx, TPDispName[i]), idx);
			
			//param 3-5 - vsout[dac]
			for (dac=0; dac<3; dac++)
				tf_SetResult_UUTOffset(TPName[3+dac], vsout[dac] + GetOffset(idx, TPDispName[3+dac]), idx);
			
			//param 6 - dccancel_v[0] =((ifhs_k[9]*Rfhs)-(vsout[0]-1v)/FSAV0);
			i=6;
			//double FSAV0 = 1; //JL: FSAV0 comes from prox_detect test
			dccancel_v[0] =((ifhs_k[9]*79.91)-(vsout[0]-1)/ _glob->global_fsav0);		//ML	dccancel_v[0] =((ifhs_k[9]*79.91)-(vsout[0]-1)/FSAV0);
			tf_SetResult_UUTOffset(TPName[i], dccancel_v[0] + GetOffset(idx, TPDispName[i]), idx);
			
			//param 7 - dccancel_v[1] =((ifhs_k[74]*Rfhs)-(vsout[1]-1v)/FSAV0);
			i=7;
			dccancel_v[1] =((ifhs_k[74]*79.91)-(vsout[1]-1)/_glob->global_fsav0);		//ML	dccancel_v[1] =((ifhs_k[74]*79.91)-(vsout[1]-1)/FSAV0);
			tf_SetResult_UUTOffset(TPName[i], dccancel_v[1] + GetOffset(idx, TPDispName[i]), idx);
			
			//param 8 - dccancel_dac;
			i=8;
			tf_SetResult_UUTOffset(TPName[i], int(dccancel_dac + GetOffset(idx, TPDispName[i])), idx);
			
			//param 9 - dccancel_v[2] =((ifhs_k[dccancel_dac]*Rfhs)-(vsout[2]-1v)/FSAV0);
			i=9;
			dccancel_v[2] =((ifhs_k[dccancel_dac]*79.91)-(vsout[2]-1)/_glob->global_fsav0); //ML	dccancel_v[2] =((ifhs_k[dccancel_dac]*79.91)-(vsout[2]-1)/FSAV0);
			tf_SetResult_UUTOffset(TPName[i], dccancel_v[2] + GetOffset(idx, TPDispName[i]), idx);
				
			/*****Power down*****/			
			//if(USE_SPI)
			//{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			//}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::fhs_dmux(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;
		
		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			
			int i;
			for (i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File")); //JL: fhs_dmux_init

			bool isCurrentTPBypassed = false;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SYNC");
			CheckError(idx, ret, __LINE__);

			int pin_val;
			
			ret = RunVectorFile(idx, Vector_File);				// write_default_reg
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////
			//init TMU; TMU start = RWN, TMU stop = FLTMUX
			double vox_flt = 0.5;
			double voh_flt = 1.5;
			double vol_flt = 0.5;
			double tmu_start_hysteresis = 0.02;
			double tmu_stop_hysteresis = 0.02;
			double tmu_start_threshold = voh_flt; 
			double tmu_stop_threshold = vol_flt; 
			int number_of_samples = 1;
			double tmu_timeout = 30e-3; 
			int returned_sample_count = 0;
			array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
			int start_slope, stop_slope;
			int debug_test = 16;	// checking failing test#
			int result = 0;		
			int expected_val;
			int debug=0;


			for (i=0; i<27; i++) // JL: FHS Read/Write/Fast mode tests
			{
				//debug = i;

	//EW: for debug purpose. Just want to break it
				//if(debug == debug_test)
				//		CheckError(idx, ret, __LINE__);

				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
				if (isCurrentTPBypassed)
					continue;
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true) //JL: registers setting for each Params
				{
					//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
					//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);		//ML remove
					//_util->Wait_Sec(Measure_Delay_s);
					
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);				
				}
				
				if (tf_TPCondition_exist(TPName[i], "Vector_DMUX") == true) //JL: set DMUX 
				{
					//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
					//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
					//_util->Wait_Sec(Measure_Delay_s);	//ML
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_DMUX");
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}
				
				if (tf_TPCondition_exist(TPName[i], "Vector_Setup") == true) //JL: registers setting for each Params
				{
					//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
					//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);	//ML
					//_util->Wait_Sec(Measure_Delay_s);
					
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_Setup");
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}

				if (tf_TPCondition_exist(TPName[i], "TMU_Start_Edge") == true) //JL: time measurement
				{
					// CBIT Settings
					//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
					//OnOffCbit(idx, 17,0);//EW: Connect FLTMUX to DM
					OnOffCbit(idx, 19,1);//EW: Connect FLTMUX to TMU Stop
					OnOffCbit(idx, 21,1);//EW: Connect RWN from TMU Start

					if(i == 21 || i == 25) {
					ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);		//added by EW
					ret = dm[idx]->DrivePin("RWN", 1);
					}
					
					ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);

					//configure TMU start & stop edge
					if((String ^)(tf_TPCondition_Cast(TPName[i], "TMU_Start_Edge")) == "POS")
					{
						start_slope = TM_CONST_SLOPE_POSITIVE;
						tmu_start_threshold = voh;
					}
					else
					{
						start_slope = TM_CONST_SLOPE_NEGATIVE;
						tmu_start_threshold = vol;
					}
					
					if((String ^)(tf_TPCondition_Cast(TPName[i], "TMU_Stop_Edge")) == "POS")
						stop_slope = TM_CONST_SLOPE_POSITIVE;
					else
						stop_slope = TM_CONST_SLOPE_NEGATIVE;

					ret = tm[idx]->ConfigureStart("TM_CH", start_slope, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
					ret = tm[idx]->ConfigureStop("TM_CH", stop_slope, 0, TM_CONST_RANGE_0_50OHM, vox_flt, tmu_stop_hysteresis, 0);

					_util->Wait_Sec(100e-6);	////ML put 100us

					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_TMU"); //JL: Vector pattern for RWN to trigger TMU
					ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
					_util->Wait_Sec(100e-6);	////ML put 100us

					ret = RunVectorFile(idx, Vector_File);
					ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);

					tf_SetResult_UUTOffset(TPName[i], sampled_result[0] + GetOffset(idx, TPDispName[i]), idx); 
					/*
					JL: 
					Param 0-FHS Hold Timer test, when SleepN, IdleN, FHS_En=1, DisFHSHold=0, 
							RWN 1->0 FHS State=hold until FHS hold timer expires in 100us
					*/
				}

				if (tf_TPCondition_exist(TPName[i], "RWN_1") == true) //JL: verify FLTMUX state with given RWN transitions
				{

					// CBIT Settings
					//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
					//OnOffCbit(idx, 17,1);//EW: Connect FLTMUX to DM
					//OnOffCbit(idx, 19,0);//EW: Connect FLTMUX to TMU Stop
					//OnOffCbit(idx, 21,0);//EW: Connect RWN from TMU Start
					ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
					result = 0; //JL: <=0 fail, 1 pass
					
					pin_val = (int)tf_TPCondition_Cast(TPName[i], "RWN_1"); //JL: RWN pin val
					expected_val = (int)tf_TPCondition_Cast(TPName[i], "FLTMUX_1"); //JL: expected FLTMUX val
					int init_pin_val = pin_val;				
					ret = dm[idx]->DrivePin("RWN", pin_val);
					ret = dm[idx]->ReadPin("RWN", pin_val);//debug				
					//verify expected FLTMUX result
					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
					if(pin_val!=expected_val)
						result = -1;
					else
						result = 1;
					
					if(tf_TPCondition_exist(TPName[i], "RWN_2") == true) //JL: 2nd stage of testing
					{
						pin_val = (int)tf_TPCondition_Cast(TPName[i], "RWN_2"); //JL: RWN pin val
						expected_val = (int)tf_TPCondition_Cast(TPName[i], "FLTMUX_2"); //JL: expected FLTMUX val

						ret = dm[idx]->DrivePin("RWN", pin_val);
						ret = dm[idx]->ReadPin("RWN", pin_val);//debug	
						//verify expected FLTMUX result
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=expected_val)
							result += -3;
					}

					tf_SetResult_UUTOffset(TPName[i], (int)(result + GetOffset(idx, TPDispName[i])), idx); 

					// CBIT Settings
					//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
					//OnOffCbit(idx, 17,1);//EW: Connect FLTMUX to DM
					//OnOffCbit(idx, 19,0);//EW: Connect FLTMUX to TMU Stop
					//OnOffCbit(idx, 21,0);//EW: Connect RWN from TMU Start
					ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
					ret = dm[idx]->DrivePin("RWN", init_pin_val);
				}	

	// CBIT Settings
				//OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
				//OnOffCbit(idx, 17,1);//EW: Connect FLTMUX to DM
				//OnOffCbit(idx, 19,0);//EW: Connect FLTMUX to TMU Stop
				//OnOffCbit(idx, 21,0);//EW: Connect RWN from TMU Start
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1 after done with each param
				_util->Wait_Sec(Measure_Delay_s);

			}

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);		// EW: ensuring RWN is still config to VECTOR force

			//JL: param 27-30 FHS Fault Mask Timer test
			array<double> ^ FODMASK = gcnew array<double>(4);
			int i_offset = i;
			double mask_monotonicity = 0;
			
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
			if (!isCurrentTPBypassed)
			{	

				//Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File"); //JL: write_fhs_FODonMask - set(DFH_EN) p1_reg7[5], then SYNC=1 for 50us; clear DFH_EN, SYNC=0 for 50us
				//change TMU_Start pin from RWN to SYNC
				String ^ Vector_TMU = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_TMU");;
				ret = DriveCBit(idx, TPDispName[i]);//JL: reminder to add "FHS_FODonMask_k0^!DMUX!S" to CBIT file.
				
				ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
				ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
				
					ret = OnOffSPI(idx, 1);
					ret = WriteSPI(idx, 3, 13, 0x40);
					ret = WriteSPI(idx, 1, 15, 0x51);
					ret = OnOffSPI(idx, 0);

				for(; i<31; i++)
				{
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");		// Setting FHSMASKTIME
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);

					ret = OnOffSPI(idx, 1);
					ret = WriteSPI(idx, 1, 7, 0x13); //JL: Clear DFH_EN bit 5, default bit4,1,0 are set. 
					ret = WriteSPI(idx, 2, 12, ((i-i_offset) <<6) | 0x08); //JL: bit 3 = 1 by default 
					ret = OnOffSPI(idx, 0);

					ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
					_util->Wait_Sec(Measure_Delay_s);		
					ret = RunVectorFile(idx, Vector_TMU);
					//ret = RunVectorFile("write_fhs_FODonMask");
					CheckError(idx, ret, __LINE__);
							
					ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
					
					FODMASK[i-i_offset] = sampled_result[0];
					tf_SetResult_UUTOffset(TPName[i], FODMASK[i-i_offset] + GetOffset(idx, TPDispName[i]), idx); 
				}
			}
			
			//JL: Param 31 - mono
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
			 
			if (!isCurrentTPBypassed)
			{
				_util->monotonicity(FODMASK,4,0,mask_monotonicity);
				if(mask_monotonicity > 0.5e-6)
					result = 1;
				else
					result = 0;	
				
				tf_SetResult_UUTOffset(TPName[i], (int)(result + GetOffset(idx, TPDispName[i])), idx);
			}
			 
			//JL: Param 32
			i++;
			isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;
			
			//if (!isCurrentTPBypassed)
			//{
			//	Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");//JL: write_fhs_mask_func
			//	
			//	ret = RunVectorFile(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->AcquireVectorFailCount("DM_2", result);
			//	CheckError(idx, ret, __LINE__);
			//	
			//	result++;
			//	tf_SetResult_UUTOffset(TPName[i], (int)(result + GetOffset(TPDispName[i]))); 
			//}
			
			if (!isCurrentTPBypassed)
			{
				ret = OnOffSPI(idx, 0);
				ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
				ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_VECTOR);

				result = 0;
				int result1 = 0;
				int result2 = 0;
				int result3 = 0;
				int result4 = 0;
				int result5 = 0;
				int result6 = 0;

	//			ret = RunVectorFile("write_default_reg");
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");//JL: write_fhs_mask_func
				//ret = RunVectorFile(idx, Vector_File);
				//ret = dm[idx]->AcquireVectorFailCount("DM_2", result);
				//CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, "write_fhs_mask_func_1");
				ret = dm[idx]->AcquireVectorFailCount("DM_2", result1);
				ret = RunVectorFile(idx, "write_fhs_mask_func_2");
				ret = dm[idx]->AcquireVectorFailCount("DM_2", result2);
				ret = RunVectorFile(idx, "write_fhs_mask_func_3");
				ret = dm[idx]->AcquireVectorFailCount("DM_2", result3);
				ret = RunVectorFile(idx, "write_fhs_mask_func_4");
				ret = dm[idx]->AcquireVectorFailCount("DM_2", result4);
				ret = RunVectorFile(idx, "write_fhs_mask_func_5");
				ret = dm[idx]->AcquireVectorFailCount("DM_2", result5);
				ret = RunVectorFile(idx, "write_fhs_mask_func_6");
				ret = dm[idx]->AcquireVectorFailCount("DM_2", result6);
				CheckError(idx, ret, __LINE__);

				result = result1 + result2 + result3 + result4 + result5 + result6;

	//// CBIT Settings
	//			OnOffCbit(idx, 20,1);//EW: Connect RWN to DM
	//			OnOffCbit(idx, 17,1);//EW: Connect FLTMUX to DM
	//			OnOffCbit(idx, 19,0);//EW: Connect FLTMUX to TMU Stop
	//			OnOffCbit(idx, 21,0);//EW: Connect RWN from TMU Start
	//// using SPI
	//ret = OnOffSPI(1);
	//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
	//ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_DIO);
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1 
	////EW:#1 
	//// CALL w_p2_reg12, QUAL
	//// CALL d_0000_0000     
	//// REPEAT 200           
	//// REPEAT 4             
	//// REPEAT 40, QUAL		(RWN = 0, FLTMUX = L)
	//     
	//ret = WriteSPI(2, 12, 0x00); 
	//_util->Wait_Sec(20e-6);
	//					ret = dm[idx]->DrivePin("RWN", 0);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1
	////EW:#2
	//// CALL w_p1_reg07 
	//// CALL d_0011_0011
	//// CALL w_p2_reg12 
	//// CALL d_0100_0000
	//// REPEAT 200
	//// REPEAT 20 
	//// QUAL      			(RWN = 0, FLTMUX = H)
	//// REPEAT 40 
	//// QUAL      			(RWN = 0, FLTMUX = L)
	//ret = WriteSPI(1, 7, 0x33); 
	//ret = WriteSPI(2, 12, 0x40); 
	//_util->Wait_Sec(20e-6);
	//					ret = dm[idx]->DrivePin("RWN", 0);
	////_util->Wait_Sec(2e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//_util->Wait_Sec(4e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1
	////EW:3
	//// CALL w_p2_reg12  
	//// CALL d_1000_0000 
	//// REPEAT 200       
	//// REPEAT 60        
	//// QUAL       			(RWN = 0, FLTMUX = H)      
	//// REPEAT 40        
	//// QUAL             	(RWN = 0, FLTMUX = L)	
	//ret = WriteSPI(2, 12, 0x80); 
	//_util->Wait_Sec(20e-6);
	//					ret = dm[idx]->DrivePin("RWN", 0);
	////_util->Wait_Sec(6e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//_util->Wait_Sec(4e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1
	////EW:4
	//// CALL w_p2_reg12  
	//// CALL d_1100_0000 
	//// REPEAT 200       
	//// REPEAT 100       
	//// QUAL             	(RWN = 0, FLTMUX = H)
	//// REPEAT 40        
	//// QUAL             	(RWN = 0, FLTMUX = L)
	//// REPEAT 100       
	//// QUAL             	(RWN = 0, FLTMUX = H)
	//// REPEAT 40        
	//// QUAL             	(RWN = 0, FLTMUX = L)
	//ret = WriteSPI(2, 12, 0xC0); 
	//_util->Wait_Sec(20e-6);
	//					ret = dm[idx]->DrivePin("RWN", 0);
	////_util->Wait_Sec(10e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//_util->Wait_Sec(4e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1
	////_util->Wait_Sec(10e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//_util->Wait_Sec(4e-6);
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	////EW:5
	//// CALL w_p2_reg12 
	//// CALL d_0100_0000
	//// CALL w_p1_reg07 
	//// CALL d_0011_0011
	//// REPEAT 200      
	//// CALL w_p1_reg07 
	//// CALL d_0011_0111
	//// REPEAT 20, QUAL 		(RWN = 0, FLTMUX = L)
	//ret = WriteSPI(2, 12, 0x80); 
	//ret = WriteSPI(1, 7, 0x33); 
	//_util->Wait_Sec(20e-6);
	//ret = WriteSPI(1, 7, 0x37); 
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=0)
	//						result --;			
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1
	////EW:6
	//// CALL w_p1_reg07   
	//// CALL d_0011_0011  
	//// CALL w_p2_reg11   
	//// CALL d_1001_0000  
	//// CALL w_p1_reg07   
	//// CALL d_0011_0111  
	//// REPEAT 20, QUAL   
	//ret = WriteSPI(1, 7, 0x33); 
	//ret = WriteSPI(2, 11, 0x90); 
	//ret = WriteSPI(1, 7, 0x37); 
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//					ret = dm[idx]->ReadPin("FLTMUX", pin_val);
	//					if(pin_val!=1)
	//						result --;			
	//
	//ret = dm[idx]->DrivePin("RWN", 1); //Reset RWN to 1
	////EW:7
	//// CALL w_p2_reg11  
	//// CALL d_1000_0000 
	//// CALL w_p2_reg12  
	//// CALL d_0000_0000 
	//ret = WriteSPI(2, 11, 0x80); 
	//ret = WriteSPI(2, 12, 0x00); 


	//EW: Final result
	if(!result)				// 0 = no failure then pass = 1
			result = 1;
		
				tf_SetResult_UUTOffset(TPName[i], (int)(result + GetOffset(idx, TPDispName[i])), idx); 

	//EW: SPI OFF			
				ret = OnOffSPI(idx, 0);
				}
			
		/////////////////////////////////

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//diag
	void TestProgram::rbhv4_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);
			array<double> ^ result_rbhv = gcnew array<double>(total_tp); 
			array<double> ^ result_mrhv = gcnew array<double>(total_tp); 

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
				result_rbhv[i] = 0;
				result_mrhv[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			double Vos_Target		= (double)(tf_TestItemCondition_Cast("Vos_Target"));
			int local_barrierCount	= (int)(tf_TestItemCondition_Cast("barrier_index"));

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;
			bool isCurrentTPBypassed = false;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			/*****Initialize*****/	
			ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			
			//Configure FLTMUX
			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			//Configure GNDS Mux
			ret = Configure_GNDS_Mux(idx, NPLC);
			CheckError(idx, ret, __LINE__);
		
			int step			= 9;
			int mrhv_index		= 0;
			int rbhv_index		= 0;
			double diffp_V		= 0;
			double diffpn_V		= 0;
			double val			= 0;	
			int loop			= 0;
			int param_index		= 0;
			String ^ Vector_File;
			double meas_offset	= 0;

			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

				ret = dm[idx]->DrivePin("RWN", 0);	//2935 is 1
				CheckError(idx, ret, __LINE__);

				//param loop
				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (TPName[i]->Contains("Target"))
					{
						result[i] = Vos_Target;

						if (isCurrentTPBypassed == false)
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}

					else
					{
						if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
						{
							Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
													
							if(!USE_SPI) 
							{
								ret = RunVectorFile(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							} 
							else
							{
								ret = RunSPI(idx, Vector_File);
								CheckError(idx, ret, __LINE__);
							}
						}

						if (TPName[i]->Contains("mV"))
						{
							ret = dm[idx]->DrivePin("RWN", 1);	//2935 is 0
							CheckError(idx, ret, __LINE__);

							_util->Wait_Sec(Measure_Delay_s);

							ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
							CheckError(idx, ret, __LINE__);

							//polarity
							if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
								diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
							else 
								diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

							diffpn_V = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

							result_mrhv[mrhv_index] = diffpn_V;
							mrhv_index++;
						}
						else if (TPName[i]->Contains("Vosc"))
						{
						//added by cb
						int dbhv_off_Global_Result_Index    = (int)(tf_TPCondition_Cast(TPName[i],"dbhv_off_Global_Result_Index"));
						int adc_slope_Global_Result_Index   = (int)(tf_TPCondition_Cast(TPName[i],"adc_slope_Global_Result_Index"));
						int adc_offset_Global_Result_Index  = (int)(tf_TPCondition_Cast(TPName[i],"adc_offset_Global_Result_Index"));

						double dbhv_off = _glob->Global_Result[idx, dbhv_off_Global_Result_Index];
						double adc_slope = _glob->Global_Result[idx, adc_slope_Global_Result_Index];
						double adc_offset = _glob->Global_Result[idx, adc_offset_Global_Result_Index];
						double cal_value = ((dbhv_off-9)*adc_slope) - adc_offset;
						result[i] = meas_offset -((dbhv_off-9)*adc_slope) - adc_offset - Vos_Target; 

						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						}

					if (!SingleSiteTest)
					{
						//*****Start Barrier*****/
						for(int s = 0; s<_numOffset; s++)
						{
							if(!run_test[s])
								__barriers[local_barrierCount]->Signal(s); //auto set the flag of non-test site so that it won't fall into infinite waiting loop
						}
						Barrier(local_barrierCount, idx);
						local_barrierCount++;
						//*****End Barrier*****/
					}

						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);

						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);
						CheckError(idx, ret, __LINE__);
					if (!SingleSiteTest)
					{
						//*****Start Barrier*****/
						for(int s = 0; s<_numOffset; s++)
						{
							if(!run_test[s])
								__barriers[local_barrierCount]->Signal(s); //auto set the flag of non-test site so that it won't fall into infinite waiting loop
						}
						Barrier(local_barrierCount, idx);
						local_barrierCount++;
						//*****End Barrier*****/
					}
						result[i]		= diffp_V - val;

						if (TPName[i]->Contains("mV"))
						{
							result_rbhv[rbhv_index]	= Math::Abs(diffp_V - val);
							rbhv_index++;
						}
						
						if(i == param_index)
						{
							if (isCurrentTPBypassed == false)
								tf_SetResult_UUTOffset(TPName[i], result[i] - Vos_Target + GetOffset(idx, TPDispName[i]), idx);


							meas_offset = result[i];
						}
					}
				}

				mrhv_index = 0;
				rbhv_index = 0;

				//Processing slope & offset
				array<double> ^ gain = gcnew array<double>(step);
				double slope = 0;
				double offset = 0;
				double dev_hd = 0;
				double sum_x = 0;
				double sum_y = 0;
				double mult_xy = 0;
				double exp_x = 0;

				if (step > 1)
				{
					for(int k=0; k<step; k++)
					{
						sum_x	+= result_mrhv[k];
						sum_y	+= result_rbhv[k]; 
						mult_xy += result_mrhv[k] * result_rbhv[k];
						exp_x	+= result_mrhv[k] * result_mrhv[k];
					}

					slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
					offset = (sum_y/step) - (slope*(sum_x/step));
				}
				
				for (int i=0; i<step; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[param_index+i+1]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						if (offset > 0)
							gain[i]	= (result_rbhv[i] - offset) / result_mrhv[i];
						else
							gain[i]	= (result_rbhv[i] - result[param_index]) / result_mrhv[i];

						if (_util->IsInf(gain[i]) == false)
							tf_SetResult_UUTOffset(TPName[param_index+i+1], gain[i] + GetOffset(idx, TPDispName[param_index+i+1]), idx);
						else
							tf_SetResult_UUTOffset(TPName[param_index+i+1], (double)INVALID_RESULT, idx);

						if (tf_TPCondition_exist(TPName[param_index+i+1], "Global_Result_Index") == true)
						{
							int Global_Result_Index = (int)(tf_TPCondition_Cast(TPName[param_index+i+1], "Global_Result_Index"));

							_glob->Global_Result[idx, Global_Result_Index] = gain[i];
						}
					}
				}
			}
				
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}		

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
			
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::rbhi3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
					
			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			bool isCurrentTPBypassed= false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Drive_Vo_V		= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
			double Clamp_Io_A		= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
			int step				= (int)(tf_TestItemCondition_Cast("step"));
			int local_barrierCount	= (int)(tf_TestItemCondition_Cast("barrier_index"));

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));	
			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/	
			ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", 0.001, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 1);
			CheckError(idx, ret, __LINE__);

			//Configure FLTMUX
			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin, Clamp_Io_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin, Drive_Vo_V);
			CheckError(idx, ret, __LINE__);

			double diffpn_V		= 0;	
			int param_index		= 0;
			array<double> ^ result_rbhi = gcnew array<double>(step); 
			array<double> ^ result_mr = gcnew array<double>(step); 
			String ^ Vector_File;

			array<bool>^ run_test = gcnew array<bool>(_numOffset);
			IsRunTest(site, run_test);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
				}		
				else 
				{
					param_index = (total_tp/2);
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

				//param loop
				for (int i=0; i<step; i++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					//}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx,Vector_File);	
					//	CheckError(idx, ret, __LINE__);
					//}
			
					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					if (!SingleSiteTest)
					{
						//*****Start Barrier*****/
						for(int s = 0; s<_numOffset; s++)
						{
							if(!run_test[s])
								__barriers[local_barrierCount]->Signal(s); //auto set the flag of non-test site so that it won't fall into infinite waiting loop
						}
						Barrier(local_barrierCount, idx);
						local_barrierCount++;
						//*****End Barrier*****/
					}
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASURECURRENT, result_rbhi[i]);
					CheckError(idx, ret, __LINE__);

					if (!SingleSiteTest)
					{
						//*****Start Barrier*****/
						for(int s = 0; s<_numOffset; s++)
						{
							if(!run_test[s])
								__barriers[local_barrierCount]->Signal(s); //auto set the flag of non-test site so that it won't fall into infinite waiting loop
						}
						Barrier(local_barrierCount, idx);
						local_barrierCount++;
						/*****End Barrier*****/
					}

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

					diffpn_V = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

					result_mr[i]	= diffpn_V / CONST_Rr1;;
					result_rbhi[i] = Math::Abs(result_rbhi[i]);
				}

				//Processing slope & offset
				array<double> ^ gain = gcnew array<double>(step);
				double slope = 0;
				double offset = 0;
				double dev_hd = 0;
				double sum_x = 0;
				double sum_y = 0;
				double mult_xy = 0;
				double exp_x = 0;
				
				for(int k=0; k<step; k++)
				{
					sum_x	+= result_mr[k];
					sum_y	+= result_rbhi[k]; 
					mult_xy += result_mr[k] * result_rbhi[k];
					exp_x	+= result_mr[k] * result_mr[k];
				}

				slope  = ((step*mult_xy) - (sum_x*sum_y)) / ((step*exp_x) - (sum_x*sum_x));
				offset = (sum_y/step) - (slope*(sum_x/step));

				if (_util->IsInf(slope) == false)
					tf_SetResult_UUTOffset(TPName[param_index], 1/slope + GetOffset(idx, TPDispName[param_index]), idx);
				else
					tf_SetResult_UUTOffset(TPName[param_index], (double)INVALID_RESULT, idx);

				tf_SetResult_UUTOffset(TPName[1+param_index], offset + GetOffset(idx, TPDispName[1+param_index]), idx);

				/////////////////////////////////////////
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::rdbhv3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<String ^> ^ Vector_File_Rd = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(10);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed= false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int step				= (int)(tf_TestItemCondition_Cast("step"));
			double Target			= (double)(tf_TestItemCondition_Cast("Target"));

			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/	
			ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);

			double diffpn_V = 0;
			int data		= 0;
			int loop		= 0;
			int param_index	= 0;
			array<double> ^ result_v = gcnew array<double>(step);
			array<double> ^ result_adc = gcnew array<double>(step);
			array<int>^ HistoryRam = gcnew array<int>(256);	
			array<String ^> ^ Vector_File = gcnew array<String ^>(step);
			
			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 1;//special case because number of hsel0 param != hsel1 param
				}		
				else 
				{
					param_index = (total_tp/2) + 1;//special case because number of hsel0 param != hsel1 param
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Rd[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd_H" + hsel));
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
				//	ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	if(hsel == 0)
				//	{
				//		ret = OnOffSPI(idx, 1);
				//		CheckError(idx, ret, __LINE__);
				//		ret = RunSPI(idx, "write_default_reg");
				//		CheckError(idx, ret, __LINE__);
				//	}
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

				ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);
				CheckError(idx, ret, __LINE__);

				//param loop
				for (int i=0; i<step; i++)
				{
					Vector_File[i] = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File[i]);	
						CheckError(idx, ret, __LINE__);
					//}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx,Vector_File[i]);	
					//	CheckError(idx, ret, __LINE__);
					//}
			
					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);

					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
						diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
					else 
						diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

					diffpn_V = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

					result_v[i] = diffpn_V;

					_util->Wait_Sec(Measure_Delay_s);	//ML add

					//read adc
					//if(!USE_SPI) 
					//{
						//ret = ReadVector(idx, Vector_File_Rd[hsel], data);		//ML not working
						//CheckError(idx, ret, __LINE__);
					//} 
					//else 
					//{
					//	ret = ReadSPI(idx, Vector_File_Rd[hsel], data);
					//	CheckError(idx, ret, __LINE__);
					//}	

					if (hsel == 0)
					{
						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);
					} else {
						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);
					}

					result_adc[i] = data;
				}					

				//Processing slope & offset
				double gain		= 0;
				double offset	= 0;
				double rmr		= 0;	
				double delta	= 0;

				//ML both 2945 formula also get passing result
				delta = ((7.5e-6 * 45) + 90e-6)  - ((7.5e-6 * 7) + 90e-6);
				//delta = ((7.5e-6 * 45) + 90e-6) - ((7.5e-6 * 7) + 90e-6);		//ML bias_i=7 & 45 for 2945
				//delta = ((6.25e-6 * 65) + 50e-6) - ((6.25e-6 * 16) + 50e-6); //bias_i = 16 & 65. Follow the formula in datasheet page18.
				rmr = ((result_adc[1] - result_adc[0]) * 1e-3) / delta;
				offset = result_adc[1] - (1000*result_v[1]);
				gain = (result_adc[1] - result_adc[0]) / (1000*(result_v[1] - result_v[0]));
				
				result[param_index] = ((rmr/Target) - 1)*100;
				result[1+param_index] = offset;
				result[2+param_index] = gain;

				if(hsel == 0)//special case because number of hsel0 param != hsel1 param
					result[3+param_index] = Target;				

				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
					}			
				}

			}
			
			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);		

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::rdbhvc_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);	
			array<String ^> ^ Vector_File_Rd = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);	//10

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			bool isCurrentTPBypassed= false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			double Target			= (double)(tf_TestItemCondition_Cast("Target"));

			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";
			
			int vector_engine_status = 0;
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/	
			ret = reader_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);

			double diffpn_V = 0;
			int loop		= 0;
			int param_index	= 0;			
			int data		= 0;
			double result_v = 0; 

			//array<double> ^ result_v = gcnew array<double>(step);
			//array<double> ^ result_adc = gcnew array<double>(step);
			array<int>^ HistoryRam = gcnew array<int>(256);	
			//array<String ^> ^ Vector_File = gcnew array<String ^>(step);
			
		/*****Start Test*****/
		for(int hsel=0; hsel<HDSS; hsel++)
		{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 1;//special case because number of hsel0 param != hsel1 param
				}		
				else 
				{
					param_index = (total_tp/2) + 1;//special case because number of hsel0 param != hsel1 param
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Rd[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd_H" + hsel));
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	if(hsel == 0)
				//	{
				//		ret = OnOffSPI(idx, 1);
				//		CheckError(idx, ret, __LINE__);
				//		ret = RunSPI(idx, "write_default_reg");
				//		CheckError(idx, ret, __LINE__);
				//	}
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}
			
				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);

				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					diffpn_V = _glob->PolRD_DUT[hsel, idx]*diffpn_V;
				else 
					diffpn_V = _glob->PolRD_PROBE[hsel, idx]*diffpn_V;

				diffpn_V = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

				result_v = diffpn_V;

				////read adc
				//if(!USE_SPI) 
				//{
					//ret = ReadVector(idx, Vector_File_Rd[hsel], data);
					//CheckError(idx, ret, __LINE__);
				//} 
				//else 
				//{
				//	ret = ReadSPI(idx, Vector_File_Rd[hsel], data);
				//	CheckError(idx, ret, __LINE__);
				//}	
				
			//Processing slope & offset

					if (hsel == 0)
					{
						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);
					} else {
						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);
					}

			double gain		= 0;
			double offset	= 0;
			double rmr		= 0;
			double delta	= 0;
			double vmr      = 0;	//ML add in to compile
			//double vmr	= 0; //ML added

			// rmr[hd]=(adc_cal[hd]*1e-3) / (double) imr;  => rmr formula, whereby adc_cal=data, delta=imr
			// test (rmr[hd]/Rr1 - 1.0);    => Rr1=target 
			// test ((adc_cal[hd]*1e-3) - vmr[hd])/vmr[hd]; 

			delta = (7.5e-6 * 34) + 90e-6;	//ML assume ImrOffsetN is 0 now. thats why have 90uA
			//delta = (6.25e-6 * 52) + 50e-6; //bias_i = 52. Follow the formula in datasheet page18.   //ML for 2945 is 34
			rmr = (data * 1e-3) / delta;
					
			result[param_index] = ((rmr/Target) - 1)*100;
	//		result[1] = ((data * 1e-3) - vmr)/vmr*100;			//need to code method to measure vmr
	//		result[1] = ((data * 1e-3) - Math::Abs(diffp_V - diffn_V))/Math::Abs(diffp_V - diffn_V)*100;			//need to code method to measure vmr
			result[1+param_index] = (((data * 1e-3) - result_v)/result_v)*100;			//need to code method to measure vmr	//ML remove *100

			if(hsel == 0)			
				result[2+param_index] = Target;		//ML change from 1 to 2

			for (int i=param_index; i<loop; i++)
			{
				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

				if (isCurrentTPBypassed == false)
				{
					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}			
			}
		}
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::rdbhi_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			bool isCurrentTPBypassed= false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			String ^ Vector_File_Rd	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd"));
			int step				= (int)(tf_TestItemCondition_Cast("step"));
			double Target			= (double)(tf_TestItemCondition_Cast("Target"));

			int vector_engine_status = 0;	
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			/*****Initialize*****/
			if(Debug_Enable == true)
			{
				double vih;
				double vil;
				double voh; 
				double vol;
				double ioh;
				double iol;
				double vch;
				double vcl;
				double vt;

				vih = 2.5;
				vil = 0.00;
				voh = 0.75; 
				vol = 0.75;
				ioh = 0.002;
				iol = 0.002;
				vch = 6;
				vcl = -0.1;
				vt = 0;

				//Reset Cbit & MUX
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);

				//Configure Digital Pins
				ret = SetupDigital(idx);
				CheckError(idx, ret, __LINE__);

				//Configure SPE
				ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPE");
				CheckError(idx, ret, __LINE__);

				//Configure SPD
				ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPD");
				CheckError(idx, ret, __LINE__);

				//Configure SPC
				ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPC");
				CheckError(idx, ret, __LINE__);

				//Configure Input Delay
				ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
				CheckError(idx, ret, __LINE__);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			}

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			int loop			= 0;
			int param_index		= 0;
			int data			= 0;
			String ^ Vector_File;
			array<int>^ HistoryRam = gcnew array<int>(256);	
			array<double> ^ result_adc = gcnew array<double>(step);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 1;
				}		
				else 
				{
					param_index = (total_tp/2) + 1;
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

				//param loop
				for (int i=0; i<step; i++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					//}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx,Vector_File);	
					//	CheckError(idx, ret, __LINE__);
					//}
			
					_util->Wait_Sec(Measure_Delay_s);

					// read adc
					//if(!USE_SPI) 
					//{
						ret = ReadVector(idx, Vector_File_Rd, data);
						CheckError(idx, ret, __LINE__);
					//}
					//else 
					//{
					//	ret = ReadSPI(idx, Vector_File_Rd, data);
					//	CheckError(idx, ret, __LINE__);
					//}

					result_adc[i] = data;
				}	

				//Processing slope & offset
				double MRResRng    = 2; // see pg2_reg29 bit4 to bit6, default = 2
				double gain		= 0;
				double rmr		= 0;	
				double delta	= 0;

				delta = ((2.53e-3 * 63) + 40e-3) - ((2.53e-3 * 0) + 40e-3); //bias_i = 0 & 63. Follow the formula in datasheet page18.

				gain = 2.08e-6 * pow(2,(MRResRng-1)); // see datasheet page11 for this formula ML change from 2.11 to 2.08

				rmr = delta / ((result_adc[1] - result_adc[0]) * gain);
				
				result[param_index] = ((rmr/Target) - 1);		//ML remove the *100, result[0] = ((rmr/Target) - 1)*100;	
				
				if(hsel == 0)
					result[1+param_index] = Target;

				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						if (_util->IsInf(result[i]) == false)
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						else
							tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
					}
				}
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}		

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::wbhv3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);	
			array<String ^> ^ Drive_Pin_P = gcnew array<String ^>(HDSS);
			array<String ^> ^ Drive_Pin_N = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(10);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			bool isCurrentTPBypassed= false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Drive_Current_Hi_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Hi_A"));
			double Drive_Current_Lo_A	= (double)(tf_TestItemCondition_Cast("Drive_Current_Lo_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			double Target			= (double)(tf_TestItemCondition_Cast("Target"));

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			String ^ Test_Pin_PN = "GRP1_DIFF_SENSE";

			int vector_engine_status = 0;
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/	
			ret = writer_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			
			//Configure Test_Pin
			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);				

			for(int hsel=0; hsel<HDSS; hsel++)
			{
				Drive_Pin_P[hsel] = (String ^)(tf_TestItemCondition_Cast("Drive_Pin_P_H" + hsel));
				Drive_Pin_N[hsel] = (String ^)(tf_TestItemCondition_Cast("Drive_Pin_N_H" + hsel));
				
				//Configure Drive_Pin_P
				ret = dm[idx]->Force(Drive_Pin_P[hsel], DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_P[hsel], DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_P[hsel], Math::Abs(Clamp_Vo_V), -2);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_P[hsel], 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_P[hsel], NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Drive_Pin_P[hsel]);
				CheckError(idx, ret, __LINE__);
				
				//Configure Drive_Pin_N
				ret = dm[idx]->Force(Drive_Pin_N[hsel], DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Drive_Pin_N[hsel], DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Drive_Pin_N[hsel], Math::Abs(Clamp_Vo_V), -2);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_N[hsel], 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Drive_Pin_N[hsel], NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Drive_Pin_N[hsel]);	
				CheckError(idx, ret, __LINE__);
			}			

			double result_wbhv1 = 0;
			double result_wbhv2 = 0;
			double result_whv1 = 0;
			double result_whv2 = 0;
			double result_whi = 0;
			double result_whvx = 0;
			double diffp_V = 0;
			double diffn_V = 0;
			double diffpn_V = 0;	
			double val			= 0;
			int loop			= 0;
			int param_index		= 0;			

			ret = smu[idx]->ConfigurePLF("MTX_SMU", Power_Line_Freq);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->SetBandwidth("MTX_SMU", 1);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->SetNPLC("MTX_SMU", NPLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", Clamp_Vo_V);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin("MTX_SMU", false, false);
			CheckError(idx, ret, __LINE__);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 1;//special case because number of hsel0 param != hsel1 param
				}		
				else 
				{
					param_index = (total_tp/2) + 1;//special case because number of hsel0 param != hsel1 param
					loop = total_tp;
				}

				//Configure GNDS Mux
				ret = Configure_GNDS_Mux(idx, NPLC);
				CheckError(idx, ret, __LINE__);

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}	

				//Drive Lo//////////////////////////////////////////////////////////////////////////////////
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_P[hsel], Drive_Current_Lo_A);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_N[hsel], -1 * Drive_Current_Lo_A);
				CheckError(idx, ret, __LINE__);
				
				//Measure Lo
				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);
				
				OnOffCbit(idx, 11,1);
				OnOffCbit(idx, 42,1);
				OnOffCbit(idx, 8,0);
				OnOffCbit(idx, 17,0);
				
				ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(idx, ret, __LINE__);

				OnOffCbit(idx, 11,0);
				OnOffCbit(idx, 42,0);
				OnOffCbit(idx, 8,1);
				OnOffCbit(idx, 17,1);
				
				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", val);
				CheckError(idx, ret, __LINE__);				

				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
				else 
					diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

				diffpn_V = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

				result_whv1 = diffpn_V;
				result_wbhv1 = diffp_V*2 - val;

				//Drive Hi//////////////////////////////////////////////////////////////////////////////////
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_P[hsel], Drive_Current_Hi_A);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Drive_Pin_N[hsel], -1 * Drive_Current_Hi_A);
				CheckError(idx, ret, __LINE__);
				
				//Measure Hi
				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(Measure_Delay_s);

				OnOffCbit(idx, 11,1);
				OnOffCbit(idx, 42,1);
				OnOffCbit(idx, 8,0);
				OnOffCbit(idx, 17,0);

				/*ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, diffp_V);
				CheckError(idx, ret, __LINE__);*/

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffp_V);
				CheckError(idx, ret, __LINE__);

				OnOffCbit(idx, 11,0);
				OnOffCbit(idx, 42,0);
				OnOffCbit(idx, 8,1);
				OnOffCbit(idx, 17,1);

				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
					diffpn_V = _glob->PolWR_DUT[hsel, idx]*diffpn_V;
				else 
					diffpn_V = _glob->PolWR_PROBE[hsel, idx]*diffpn_V;

				diffpn_V = Math::Abs((diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx]);

				result_whv2 = diffpn_V;
				result_wbhv2 = diffp_V*2 - val;
				
				////////////////////////////////////////////////////////////////////////////////////				
				double gain		= 0;
				double offset	= 0;
				double result_wvcm = 0;

				//1-2mV can affect gain results by 0.2-0.3!

				gain = (result_wbhv2 - result_wbhv1) / (result_whv2 - result_whv1); //Direct use DMM to measure will get better correlation.
				offset = result_wbhv2 - (gain * result_whv2); //Don't care correlation as customer's datalog also fluctuate a lot
				//result_wvcm = result_whvx - (result_whi * (CONST_Rw/2));

				result[0+param_index] = gain;
				result[1+param_index] = offset - Target;
				//result[2] = result_whi;
				//result[3] = result_wvcm;
				
				if(hsel==0)//special case because number of hsel0 param != hsel1 param				
					result[2+param_index] = Target;

				for (int i=0; i<total_tp; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
						tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}
			
			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}
	void TestProgram::wdbhv_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			
			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
					
			/*****Get test condition from techFlow*****/
			bool isCurrentTPBypassed	= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			int step				= (int)(tf_TestItemCondition_Cast("step"));	
			
			String ^ Vector_File_ReadADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
			String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));

			int vector_engine_status = 0;	
			Stopwatch swatch;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			if(Debug_Enable == true)
			{
				double vih;
				double vil;
				double voh; 
				double vol;
				double ioh;
				double iol;
				double vch;
				double vcl;
				double vt;

				vih = 2.5;
				vil = 0.00;
				voh = 0.75; 
				vol = 0.75;
				ioh = 0.002;
				iol = 0.002;
				vch = 6;
				vcl = -0.1;
				vt = 0;

				//Reset Cbit & MUX
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);

				//Configure Digital Pins
				ret = SetupDigital(idx);
				CheckError(idx, ret, __LINE__);

				//Configure SPE
				ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPE");
				CheckError(idx, ret, __LINE__);

				//Configure SPD
				ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPD");
				CheckError(idx, ret, __LINE__);

				//Configure SPC
				ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPC");
				CheckError(idx, ret, __LINE__);

				//Configure Input Delay
				ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
				CheckError(idx, ret, __LINE__);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			}

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			
			double result		= 0;
			double RhNom		= 100;		//ML 2935 is 78.3(RhNom=Rh+Rh1) but 2945 is RhNom=Rh
			int loop			= 0;
			int param_index		= 0;
			int data			= 0;
			String ^ Vector_File;
			array<int>^ HistoryRam = gcnew array<int>(256);	
			array<double> ^ result_adc = gcnew array<double>(step);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				if(!USE_SPI)
				{
					ret = RunVectorFile(idx, Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = OnOffSPI(idx, 1);
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				}

				//param loop
				for (int i=0; i<step; i++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = OnOffSPI(idx, 1);
						CheckError(idx, ret, __LINE__);
						ret = RunSPI(idx,Vector_File);	
						CheckError(idx, ret, __LINE__);
					}
			
					_util->Wait_Sec(Measure_Delay_s);

					//// read adc
					//if(!USE_SPI) 
					//{
						//ret = ReadVector(idx, Vector_File_ReadADC, data);
						//CheckError(idx, ret, __LINE__);		//ML mask it temp
						
						ret = OnOffSPI(idx, 1);
						_util->Wait_Sec(0.1e-3);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						

					//}
					//else 
					//{
					//	ret = ReadSPI(idx, Vector_File_ReadADC, data);
					//	CheckError(idx, ret, __LINE__);
					//}

					result_adc[i] = data;
				}	

				ret = OnOffSPI(idx, 0);	//ML

				//processing result
				double rw		= 0;	
				double delta	= 0;

				delta = (2e-3 + (1e-3 * 35)) -  (2e-3 + (1e-3 * 10));	//follow 2945 IW=10 & 35
				//delta = (10.24e-3 + (3.463e-3 * 6)) -  (10.24e-3 + (3.463e-3 * 0));//ISS = 0 & 6. Follow the formula in datasheet page18. 

				result = ((result_adc[1] - result_adc[0]) * 1e-3) / delta ; 

				tf_SetResult_UUTOffset(TPName[param_index], result + GetOffset(idx, TPDispName[param_index]), idx);
			}

			/*****Power down*****/
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				//	ret = ResetDMPin(idx, TPDispName[0]);
				//	CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}		
	void TestProgram::fhcr_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result = gcnew array<double>(10);

			//hardware constant	
			//double RhNom		= 100.0	; //follow catalyst RH+RH1, ML - 78.3 in 2935

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed= false;
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			
			String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
			String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
			String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
		
			int vector_engine_status = 0;	
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

					
			/*****Initialize*****/
			//if(Debug_Enable == true)
			{
				double vih;
				double vil;
				double voh; 
				double vol;
				double ioh;
				double iol;
				double vch;
				double vcl;
				double vt;

				vih = 2.5;
				vil = 0.00;
				voh = 0.75; 
				vol = 0.75;
				ioh = 0.002;
				iol = 0.002;
				vch = 6;
				vcl = -0.1;
				vt = 0;

				//Reset Cbit & MUX
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);

				//Configure Digital Pins
				ret = SetupDigital(idx);
				CheckError(idx, ret, __LINE__);

				//Configure SPE
				ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPE");
				CheckError(idx, ret, __LINE__);

				//Configure SPD
				ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPD");
				CheckError(idx, ret, __LINE__);

				//Configure SPC
				ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn("SPC");
				CheckError(idx, ret, __LINE__);

				//Configure Input Delay
				ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
				CheckError(idx, ret, __LINE__);

				ret = DriveDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);
			}

			//Configure FLTMUX
			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			
			int result_adc		= 0; 
			double result_flt	= 0; 
			int data			= 0;
			int loop			= 0;
			int param_index		= 0;
			double val			= 0;
			String ^ Vector_File;
			
			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2);
				}		
				else 
				{
					param_index = (total_tp/2);
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Init);	
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}
		
				//Measure FLTMUX pin
				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_flt);
				CheckError(idx, ret, __LINE__);

				//Measure GNDS
				ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, val);
				CheckError(idx, ret, __LINE__);				
				
				result_flt = result_flt - val;

				// setup to get digital reading from adc	
				//if(!USE_SPI) 
				//{
					ret = RunVectorFile(idx, Vector_File_ADC);
					CheckError(idx, ret, __LINE__);
					//ret = ReadVector(idx, Vector_File_ReadADC, result_adc);		//ML not working
					//CheckError(idx, ret, __LINE__);
				//} 
				//else 
				//{
				//	ret = RunSPI(idx, Vector_File_ADC);
				//	CheckError(idx, ret, __LINE__);
				//	ret = ReadSPI(idx, Vector_File_ReadADC, result_adc);
				//	CheckError(idx, ret, __LINE__);
				//}	
				
				
				//processing result
				OnOffSPI(idx, 1);
				ret = ReadReg(idx, 1, 11, result_adc);
				CheckError(idx, ret, __LINE__);
				OnOffSPI(idx, 0);

				double afhcr	= 0;	
				double dfhcr	= 0;

				afhcr = (result_flt * 143) - 68.7;	//follow catalyst ML 2935 - (result_flt * 143) - 71.4;
				dfhcr = result_adc * 0.749;			//follow catalyst ML 2935 - result_adc * 0.715;
			
				//tf_SetResult_UUTOffset(TPName[0], ((afhcr/CONST_RhNom) - 1)*100 + GetOffset(idx, TPDispName[0]), idx);
				//tf_SetResult_UUTOffset(TPName[1], ((dfhcr/CONST_RhNom) - 1)*100 + GetOffset(idx, TPDispName[1]), idx);
				tf_SetResult_UUTOffset(TPName[param_index], ((afhcr/CONST_RhNom) - 1) + GetOffset(idx, TPDispName[param_index]), idx);
				tf_SetResult_UUTOffset(TPName[1+param_index], ((dfhcr/CONST_RhNom) - 1) + GetOffset(idx, TPDispName[1+param_index]), idx);

				isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[2+param_index]][site]->Bypass;

					if (isCurrentTPBypassed == false)
						tf_SetResult_UUTOffset(TPName[2+param_index], CONST_RhNom, idx);
			}

			/*****Power down*****/
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff(Test_Pin);
			CheckError(idx, ret, __LINE__);
		
			if(USE_SPI) 
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//Power down supplies
				//ret = smu[idx]->DriveVoltage("VEE", 0);
				//CheckError(idx, ret, __LINE__);
				//ret = smu[idx]->DriveVoltage("VCC", 0);
				//CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::sbhv(Object^ object)	//seq_sbhi
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result		= gcnew array<double>(total_tp);	//ori 10

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			bool isCurrentTPBypassed= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
		
			double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
			double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
			//int Hsel					= (int)(tf_TestItemCondition_Cast("Hsel"));  //2945
			int step					= (int)(tf_TestItemCondition_Cast("step"));
			int step500					= (int)(tf_TestItemCondition_Cast("step500"));	//2945

			String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			//String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
			//String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
			String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
			String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));

			double Vos_Target		= (double)(tf_TestItemCondition_Cast("Vos_Target"));
			String ^ Test_Pin_1		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_1"));			
			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";			
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
								
			int vector_engine_status = 0;
			Stopwatch swatch;

			/*****Initialize*****/
			ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);		

			//Configure FLTMUX
			ret = dm[idx]->Force(Test_Pin_1, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_1, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_1, Clamp_Io_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_1, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_1, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_1);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_1, Drive_Vo_V);
			CheckError(idx, ret, __LINE__);			
			
			// hardware constant
			double R30			= 37.4;    //update to 2945, 2935 is 45.3
			double R31			= 5.11;      //2935 is 10
			double Rfhs			= R31 + (2*R30);

			double diffpn_V			= 0;
			int loop				= 0;
			int param_index			= 0;
			int data				= 0;
			String ^ Vector_File;
			array<double> ^ result_sbhv	= gcnew array<double>(step);	//ori is 5
			array<double> ^ result_fhs	= gcnew array<double>(step);	//
			array<double> ^ result_adc	= gcnew array<double>(step);	//
			array<double> ^ meas_off	= gcnew array<double>(2); //bk: added for meas_off
			array<double> ^ result_sbhv_500	= gcnew array<double>(step500);	
			array<double> ^ result_fhs500	= gcnew array<double>(step500);	
			array<double> ^ result_adc500	= gcnew array<double>(step500);

			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 2; //special case because number of hsel0 param != hsel1 param		
				}		
				else 	//ML to double check
				{
					param_index = (total_tp/2) + 2; //special case because number of hsel0 param != hsel1 param	//2
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index],1);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Init);	
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

			// 5 steps sweep
			int steps = 5;
			//double meas_off= 0;
			//double meas_off_smu=0;

			//bk: for meas_offset
			ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, meas_off[hsel]);	//ML change to voltage	//meas_off[Hsel]
			CheckError(idx, ret, __LINE__);

			String ^ vector_file_str = "" ;

			for (int i = 0 ; i < step; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
				{
					Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
				}else{
					Measure_Delay_s = 0;
				}

				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File);	
				//	CheckError(idx, ret, __LINE__);
				//}

				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
		
				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);
	
				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)			
					diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
				else 	
					diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
				
				diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm[idx]->PMUMeasure(Test_Pin_1, DM_CONST_MEASUREVOLTAGE, result_sbhv[i]);	//ML change to voltage
				CheckError(idx, ret, __LINE__);

				//read adc
				//if(!USE_SPI) 
				//{
					ret = RunVectorFile(idx, Vector_File_ADC);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					//ret = ReadVector(idx, Vector_File_ReadADC, data);		//ReadVector not working in 2945
					//CheckError(idx, ret, __LINE__);
				//} 
				//else 
				//{
				//	ret = RunSPI(idx, Vector_File_ADC);
				//	CheckError(idx, ret, __LINE__);

				//	_util->Wait_Sec(Measure_Delay_s);

				//	ret = ReadSPI(idx, Vector_File_ReadADC, data);
				//	CheckError(idx, ret, __LINE__);
				//}

					OnOffSPI(idx, 1);
					ret = ReadReg(idx, 1, 11, data);
					CheckError(idx, ret, __LINE__);
					OnOffSPI(idx, 0);

				result_fhs[i] = Math::Abs(diffpn_V);	//sbhv not sbhi (Math::Abs(diffp_V - diffn_V)) / Rfhs;
				result_sbhv[i] = result_sbhv[i];	//	result_sbhv[i]*-1;
				result_adc[i] = data;	
			}
									OnOffSPI(idx, 1);
					ret = WriteSPI(idx, 2, 7, 0x90);
					CheckError(idx, ret, __LINE__);
					OnOffSPI(idx, 0);
			//int steps500 = 5;
			for (int i=0 ; i<step500; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
				{
					Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
				}else{
					Measure_Delay_s = 0;
				}

				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));

				//if(!USE_SPI)
				//{
				//	ret = RunVectorFile(idx, Vector_File);	
				//	CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File);	
				//	CheckError(idx, ret, __LINE__);
				//}

				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
		
				_util->Wait_Sec(Measure_Delay_s);

				ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
				CheckError(idx, ret, __LINE__);
	
				//polarity
				if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)			
					diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
				else 	
					diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
				
				diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

				_util->Wait_Sec(Measure_Delay_s);

				ret = dm[idx]->PMUMeasure(Test_Pin_1, DM_CONST_MEASUREVOLTAGE, result_sbhv_500[i]);	//ML change to voltage
				CheckError(idx, ret, __LINE__);
				
				//read adc
				//if(!USE_SPI) 
				//{
					ret = RunVectorFile(idx, Vector_File_ADC);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(Measure_Delay_s);

					//ret = ReadVector(idx, Vector_File_ReadADC, data);
					//CheckError(idx, ret, __LINE__);
				//} 
				//else 
				//{
				//	ret = RunSPI(idx, Vector_File_ADC);
				//	CheckError(idx, ret, __LINE__);

				//	_util->Wait_Sec(Measure_Delay_s);

				//	ret = ReadSPI(idx, Vector_File_ReadADC, data);
				//	CheckError(idx, ret, __LINE__);
				//}					

					OnOffSPI(idx, 1);
					ret = ReadReg(idx, 1, 11, data);
					CheckError(idx, ret, __LINE__);
					OnOffSPI(idx, 0);
					
				result_fhs500[i] = Math::Abs(diffpn_V);	//sbhv not sbhi (Math::Abs(diffp_V - diffn_V)) / Rfhs;
				result_sbhv_500[i] = result_sbhv_500[i];	//	result_sbhv_500[j]*-1;			
				result_adc500[i] = data;
			}
											OnOffSPI(idx, 1);
					ret = WriteSPI(idx, 2, 7, 0x00);
					CheckError(idx, ret, __LINE__);
					OnOffSPI(idx, 0);
			// Calculation 

			// fhs VS fltmux
			double slope_a	= 0;
			double offset_a = 0;
			double slope_a_500	= 0;
			double offset_a_500 = 0;
			
			_util->line_fit_d(result_fhs, result_sbhv, 5, slope_a, offset_a);
			_util->line_fit_d(result_fhs500, result_sbhv_500, 5, slope_a_500, offset_a_500);
			
			// adc vs fhs
			double slope_d	= 0;
			double offset_d = 0;
			
			_util->line_fit_d(result_adc, result_fhs, 5, slope_d, offset_d);
		
			// min max
		
			double K_mid, K_max			= 0;
			double ifhs_mid, ifhs_max 	= 0;

			ifhs_mid = 200e-6 + (29* 44.44e-6); //BIAS_I = 29. Follow Catalyst's formula
			ifhs_max = 200e-6 + (52* 44.44e-6); //BIAS_I = 52. Follow Catalyst's formula

			K_mid = ((29e-3 / ifhs_mid) / Rfhs) - 1;
			K_max = ((52e-3 / ifhs_max) / Rfhs) - 1;

			result[0] = meas_off[hsel] - Vos_Target;		//result_sbhv[i]??? //bk: original Hsel change to 0
			result[1+param_index] = slope_a;
			result[2+param_index] = slope_d * 1000;
			result[3+param_index] = offset_d * 1000;
			result[4+param_index] =	K_mid;
			result[5+param_index] = K_max;
			
			if(hsel == 0)			
				{
				result[6] = Vos_Target;
				result[7] = Rfhs;
				result[8] = result_sbhv_500[0] - Vos_Target;		//result_sbhv[i]???
				result[9] = slope_a_500;
				}
			
				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						if (_util->IsInf(result[i]) == false)
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						else
							tf_SetResult_UUTOffset(TPName[i], INVALID_RESULT + GetOffset(idx, TPDispName[i]), idx);
					}			
				}
			}	
			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::sbhi3_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);			
			array<double> ^ result		= gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			/*****Get test condition from techFlow*****/
			bool isCurrentTPBypassed= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
			double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
			int step					= (int)(tf_TestItemCondition_Cast("step"));
			
			//String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));
			//String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));	
			//double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			//double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			
			String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			//String ^ Vector_File_Hsel		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Hsel"));
			//String ^ Vector_File_Sweep		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Sweep"));
			String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
			String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));

			String ^ Test_Pin_1			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_1"));
			String ^ Test_Pin_PN		= "GRP1_DIFF_SENSE";
			
			int vector_engine_status = 0;	
			Stopwatch swatch;
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			/*****Initialize*****/
			ret = fhs_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
			CheckError(idx, ret, __LINE__);

			//Configure FLTMUX
			ret = dm[idx]->Force(Test_Pin_1, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_1, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_1, Clamp_Io_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_1, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_1, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_1);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_1, Drive_Vo_V);
			CheckError(idx, ret, __LINE__);	

			// hardware constant
			double R30			= 37.4;    //update to 2945, 2935 is 45.3
			double R31			= 5.11;      //2935 is 10
			double Rfhs			= R31 + (2*R30);
			
			double diffpn_V			= 0;
			int loop				= 0;
			int param_index			= 0;
			int data				= 0;
			String ^ Vector_File;
			array<int>^ HistoryRam = gcnew array<int>(256);			
			array<double> ^ result_sbhi	= gcnew array<double>(step);
			array<double> ^ result_fhs	= gcnew array<double>(step);
			array<double> ^ result_adc	= gcnew array<double>(step);		
			
			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 1; //special case because number of hsel0 param != hsel1 param
				}		
				else 
				{
					param_index = (total_tp/2) + 1; //special case because number of hsel0 param != hsel1 param
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index],1);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Init);	
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}
			
				//param loop
				for (int i=0; i<step; i++)
				{
					if (tf_TPCondition_exist(TPName[i], "Measure_Delay_s") == true)
					{
						Measure_Delay_s = (double)(tf_TPCondition_Cast(TPName[i], "Measure_Delay_s"));
					}else{
						Measure_Delay_s = 0;
					}

					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					//}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx,Vector_File);	
					//	CheckError(idx, ret, __LINE__);
					//}

					//ret = RunVectorFile(idx, Vector_File);		//ML mask due to extra
					//CheckError(idx, ret, __LINE__);
			
					_util->Wait_Sec(Measure_Delay_s);

					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
					CheckError(idx, ret, __LINE__);
		
					//polarity
					if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)			
						diffpn_V = _glob->PolTA_DUT[hsel, idx]*diffpn_V;
					else 	
						diffpn_V = _glob->PolTA_PROBE[hsel, idx]*diffpn_V;
					
					diffpn_V = (diffpn_V-_glob->DA_c[idx])/_glob->DA_m[idx];

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_1, DM_CONST_MEASURECURRENT, result_sbhi[i]);
					CheckError(idx, ret, __LINE__);

					//read adc
					//if(!USE_SPI) 
					//{
						ret = RunVectorFile(idx, Vector_File_ADC);
						CheckError(idx, ret, __LINE__);

						_util->Wait_Sec(Measure_Delay_s);

						//ret = ReadVector(idx, Vector_File_ReadADC, data);
						//CheckError(idx, ret, __LINE__);

						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);

					//} 
					//else 
					//{
					//	ret = RunSPI(idx, Vector_File_ADC);
					//	CheckError(idx, ret, __LINE__);

					//	_util->Wait_Sec(Measure_Delay_s);

					//	ret = ReadSPI(idx, Vector_File_ReadADC, data);
					//	CheckError(idx, ret, __LINE__);
					//}
					
					result_fhs[i] = Math::Abs(diffpn_V) / Rfhs;
					result_sbhi[i] = result_sbhi[i]*-1;
					result_adc[i] = data;
				}	
						 
				// Calculation 

				// fhs VS fltmux
				double slope_a	= 0;
				double offset_a = 0;
				
				_util->line_fit_d(result_fhs, result_sbhi, 3, slope_a, offset_a);	//ML change from 5 to 3, pls. add in func into utility.cpp
				
				// adc vs fhs
				double slope_d	= 0;
				double offset_d = 0;
				
				_util->line_fit_d(result_adc, result_fhs, 3, slope_d, offset_d);	//ML change from 5 to 3
			
				// min max
				double K_mid, K_max				= 0;
				double vfhs_mid, vfhs_max 		= 0;
				double dsbhi_mid, dsbhi_max		= 0;

				//double K_min, K_mid, K_max					= 0;
				//double vfhs_min, vfhs_mid, vfhs_max 		= 0;
				//double dsbhi_min, dsbhi_mid, dsbhi_max		= 0;

				//vfhs_min = 49e-3 + (12* 3.47e-3); //BIAS_V = 12. Follow Catalyst's formula ML why 12, 16, 29???
				//vfhs_mid = 49e-3 + (32* 3.47e-3); //BIAS_V = 16. Follow Catalyst's formula
				//vfhs_max = 49e-3 + (63* 3.47e-3); //BIAS_V = 29. Follow Catalyst's formula

				//ML correct 2945 formula
				vfhs_mid = 40e-3 + (32* 2.54e-3); //BIAS_V = 16. Follow Catalyst's formula
				vfhs_max = 40e-3 + (63* 2.54e-3); //BIAS_V = 29. Follow Catalyst's formula

				//ML mask, refer SBHI_STEPS in 2945
				/*vfhs_min = 48.96e-3 + (12* 8.16e-3); //BIAS_V = 12. Follow Catalyst's formula
				vfhs_mid = 48.96e-3 + (16* 8.16e-3); //BIAS_V = 16. Follow Catalyst's formula
				vfhs_max = 48.96e-3 + (29* 8.16e-3); //BIAS_V = 29. Follow Catalyst's formula */

				//dsbhi_min = 33.4e-6 * 16; //BIAS_V = 12. Follow Catalyst's formula 2935 is 34e-6 from diag_seq.tl
				dsbhi_mid = 33.4e-6 * result_adc[1];	//dsbhi_mid = 33.4e-6 * 32; //BIAS_V = 16. Follow Catalyst's formula
				dsbhi_max = 33.4e-6 * result_adc[2];	//dsbhi_max = 33.4e-6 * 63; //BIAS_V = 29. Follow Catalyst's formula

				//K_min = ((vfhs_min / dsbhi_min) / Rfhs) - 1;
				K_mid = ((vfhs_mid / dsbhi_mid) / Rfhs) - 1;
				K_max = ((vfhs_max / dsbhi_max) / Rfhs) - 1;

				result[param_index] = 1/slope_a;
				result[1+param_index] = offset_a;
				result[2+param_index] = slope_d;
				result[3+param_index] = offset_d * 1000;
				result[4+param_index] = K_mid*100;//display in percentage
				result[5+param_index] = K_max*100;//display in percentage
				
				if(hsel == 0)//special case because number of hsel0 param != hsel1 param
					result[6] = Rfhs;		
								
				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						if (_util->IsInf(result[i]) == false)
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						else
							tf_SetResult_UUTOffset(TPName[i], INVALID_RESULT + GetOffset(idx, TPDispName[i]), idx);
					}			
				}
			}
			
			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::hbhi_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			/*****Get test name from techFlow*****/
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(HDSS);
			array<String ^> ^ Test_Pin = gcnew array<String ^>(HDSS);			
			array<double> ^ result		= gcnew array<double>(total_tp);		//ML change to 15

			//double RhNom		= 100; //follow catalyst RH+RH1 2935 78.3
			int reading_adc		= 0; 

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;
			double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			double Drive_Vo_V			= (double)(tf_TestItemCondition_Cast("Drive_Vo_V"));
			double Clamp_Io_A			= (double)(tf_TestItemCondition_Cast("Clamp_Io_A"));
			int step					= (int)(tf_TestItemCondition_Cast("step"));	
			int step_lo					= (int)(tf_TestItemCondition_Cast("step_lo"));
			
			String ^ Vector_File_ADC		= (String ^)(tf_TestItemCondition_Cast("Vector_File_ADC"));
			String ^ Vector_File_ReadADC	= (String ^)(tf_TestItemCondition_Cast("Vector_File_ReadADC"));
			String ^ Vector_File_Init		= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));

			String ^ Test_Pin_1			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_1"));

			String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";	
			
			int vector_engine_status = 0;
			Stopwatch swatch;
			bool isCurrentTPBypassed= false;			
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			/*****Initialize*****/
			ret = heater_init(idx, Test_Pin_PN, NPLC, Input_Channel_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Power Supply
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);

			//Configure FLTMUX
			ret = dm[idx]->Force(Test_Pin_1, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_1, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_1, Clamp_Io_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_1, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_1, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_1);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_1, Drive_Vo_V);
			CheckError(idx, ret, __LINE__);

			int loop			= 0;
			int param_index		= 0;
			double val			= 0;
			double RhNom		= 100; //follow catalyst RH+RH1 2935 78.3			
			int data			= 0;
			String ^ Vector_File;
			array<int>^ HistoryRam = gcnew array<int>(256);
			array<double> ^ result_htr	= gcnew array<double>(step);
			array<double> ^ result_hbhi = gcnew array<double>(step);
			array<double> ^ result_adc	= gcnew array<double>(step);
			array<double> ^ result_htr_lo  = gcnew array<double>(step_lo);	//
			array<double> ^ result_hbhi_lo = gcnew array<double>(step_lo);	//
			array<double> ^ result_adc_lo  = gcnew array<double>(step_lo);	//		
					
			/*****Start Test*****/
			for(int hsel=0; hsel<HDSS; hsel++)
			{
				//setting for hsel
				if(hsel==0)
				{
					param_index = 0;
					loop = (total_tp/2) + 4;
				}		
				else 
				{
					param_index = (total_tp/2) + 4;	
					loop = total_tp;
				}

				//set CBit & MUX
				ret = DriveCBit(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[param_index]);
				CheckError(idx, ret, __LINE__);

				//run vector for hsel
				Vector_File_Hsel[hsel] = (String ^)(tf_TestItemCondition_Cast("Vector_File_H" + hsel));
				//if(!USE_SPI)
				//{
					ret = RunVectorFile(idx, Vector_File_Init);	
					CheckError(idx, ret, __LINE__);
					ret = RunVectorFile(idx, Vector_File_Hsel[hsel]);	
					CheckError(idx, ret, __LINE__);
				//}
				//else
				//{
				//	ret = OnOffSPI(idx, 1);
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Init);	
				//	CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx,Vector_File_Hsel[hsel]);	
				//	CheckError(idx, ret, __LINE__);
				//}

				//param loop
				for (int i=0; i<step; i++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					//}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx,Vector_File);	
					//	CheckError(idx, ret, __LINE__);
					//}
			
					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_1, DM_CONST_MEASURECURRENT, result_hbhi[i]);
					CheckError(idx, ret, __LINE__);

					ret = smu[idx]->ReadVoltage("MTX_SMU", result_htr[i]);
					CheckError(idx, ret, __LINE__);

					result_htr[i] = result_htr[i] / CONST_RhNom;		//result_htr[i] = Math::Abs(result_htr[i]) / CONST_RhNom;

					result_hbhi[i] = result_hbhi[i]*-1;
			
					//read adc	
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File_ADC);
						CheckError(idx, ret, __LINE__);
						//ret = ReadVector(idx, Vector_File_ReadADC, data);	//ML mask
						//CheckError(idx, ret, __LINE__);
					//}
					//else 
					//{
					//	ret = RunSPI(idx, Vector_File_ADC);
					//	CheckError(idx, ret, __LINE__);
					//	ret = ReadSPI(idx, Vector_File_ReadADC, data);
					//	CheckError(idx, ret, __LINE__);
					//}
					
						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);

					result_adc[i] = (double)data;
				}

				//param loop for lo
				for (int i=0; i<step_lo; i++)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[param_index],"Vector_File_" + (i)));
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);	
						CheckError(idx, ret, __LINE__);
					//}
					//else
					//{
					//	ret = OnOffSPI(idx, 1);
					//	CheckError(idx, ret, __LINE__);
					//	ret = RunSPI(idx,Vector_File);	
					//	CheckError(idx, ret, __LINE__);
					//}
			
					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_1, DM_CONST_MEASURECURRENT, result_hbhi_lo[i]);
					CheckError(idx, ret, __LINE__);

					ret = smu[idx]->ReadVoltage("MTX_SMU", result_htr_lo[i]);
					CheckError(idx, ret, __LINE__);

					result_htr_lo[i] = Math::Abs(result_htr_lo[i]) / CONST_RhNom;
					result_hbhi_lo[i] = result_hbhi_lo[i]*-1;
			
					//read adc	
					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File_ADC);
						CheckError(idx, ret, __LINE__);
						//ret = ReadVector(idx, Vector_File_ReadADC, data);	//ML mask
						//CheckError(idx, ret, __LINE__);
					//}
					//else 
					//{
					//	ret = RunSPI(idx, Vector_File_ADC);
					//	CheckError(idx, ret, __LINE__);
					//	ret = ReadSPI(idx, Vector_File_ReadADC, data);
					//	CheckError(idx, ret, __LINE__);
					//}
					
						OnOffSPI(idx, 1);
						ret = ReadReg(idx, 1, 11, data);
						CheckError(idx, ret, __LINE__);
						OnOffSPI(idx, 0);

					result_adc_lo[i] = (double)data;
				}
				
				// Calculation 

				// htr VS adc
				double slope_d	= 0;
				double offset_d = 0;
				double slope_d_lo	= 0;
				double offset_d_lo = 0;
				 
				_util->line_fit_d(result_htr, result_adc, 4, slope_d, offset_d);		//5
				_util->line_fit_d(result_htr_lo, result_adc_lo, 4, slope_d_lo, offset_d_lo);	//_util->line_fit_d(result_htr_lo, result_adc_lo, 4, slope_d_lo, offset_d_lo);
				
				// htr VS fltmux
				double slope_a	= 0;
				double offset_a = 0;
				
				_util->line_fit_d_hbhi(result_htr, result_hbhi, 4, slope_a, offset_a);		//5
				
				// htr VS adc
				double adc_iav	= 0;
				double adc_ioff = 0;
				double adc_iav_lo	= 0;
				double adc_ioff_lo = 0;

				_util->line_fit_d(result_adc, result_hbhi, 4, adc_iav, adc_ioff);		//5
				_util->line_fit_d(result_adc_lo, result_hbhi_lo, 4, adc_iav_lo, adc_ioff_lo);	//_util->line_fit_d(result_adc_lo, result_hbhi_lo, 4, adc_iav_lo, adc_ioff_lo);
			
				// min max
				double K_min, K_max		= 0;
				double K_min_lo, K_max_lo		= 0;

				K_min = result_hbhi[0];
				K_max = result_hbhi[3];	//4 in 2935
				K_min_lo = result_hbhi[0];
				K_max_lo = result_hbhi[3];


				result[param_index] = 1/slope_a;
				result[1+param_index] = offset_a;
				result[2+param_index] = 1/slope_d;
				result[3+param_index] = offset_d;
				result[4+param_index] =	1/slope_d_lo;
				result[5+param_index] =	offset_d_lo;

				if(hsel == 0)
				{
				result[6] = K_min;
				result[7] = K_max;
				result[8] = adc_iav;
				result[9] = adc_ioff;
				result[10] = K_min_lo;
				result[11] = K_max_lo;
				result[12] = adc_iav_lo;
				result[13] = adc_ioff_lo;
				}
				
				for (int i=param_index; i<loop; i++)
				{
					isCurrentTPBypassed = ((TestItem^)site->CurrentFlowItem)->TestParameters[TPName[i]][site]->Bypass;

					if (isCurrentTPBypassed == false)
					{
						if (_util->IsInf(result[i]) == false)
							tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
						else
							tf_SetResult_UUTOffset(TPName[i], INVALID_RESULT + GetOffset(idx, TPDispName[i]), idx);
					}			
				}
			}

			/*****Power down*****/
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//fault
	void TestProgram::flt_wr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp				= (int)tf_TPCount();
			array<String ^> ^ TPName	= gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result		= gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i]	= tf_TestParameter_DisplayName(i);
				TPName[i]		= tf_TestParameter_Name(i);
				result[i]		= 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			// result variables
			double diffp_V		= 0;
			double diffn_V		= 0;

			array<double> ^ result_trip = gcnew array<double>(HDS);
			for (int i=0; i<HDS; i++)
			{
				result_trip[i] = 0;
			}

			//Get test condition from techFlow
			bool isCurrentTPBypassed	= false;
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;

			double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
				
			String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));

			int Start_Data				= (int)(tf_TestItemCondition_Cast("Start_Data"));
			int Stop_Data				= (int)(tf_TestItemCondition_Cast("Stop_Data"));
			int Compare_Bit				= (int)(tf_TestItemCondition_Cast("Compare_Bit"));
			int Compare_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Compare_Reg_Addr"));
			int Sweep_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			int mask = 0;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0;

			array<int>^ HistoryRam = gcnew array<int>(256);	
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			unsigned int moduleType  = 0;
			unsigned int TestPinP_moduleType  = 0;
			unsigned int TestPinN_moduleType  = 0;
			
			//_util->Wait_Sec(On_Delay_s);
			//Init
			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, Vector_File_Init);
				CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File_Init);
			//	CheckError(idx, ret, __LINE__);
			//}
			
			int spi_group = 0;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			//ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->SPI_NCS_ACTIVE_STATE("DM_2", spi_group, DM_CONST_SPI_NCS_ACTIVE_HIGH);
			//CheckError(idx, ret, __LINE__);
		
			//if (Input_Channel_Delay_s == 0)
			//{
			//	ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 0);
			//	CheckError(idx, ret, __LINE__);
			//}
			//else if (Input_Channel_Delay_s < 5e-9)
			//{
			//	ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
			//	CheckError(idx, ret, __LINE__);
			//}
			//else
			//{
			//	ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 2);
			//	CheckError(idx, ret, __LINE__);
			//}

			//ret = dm[idx]->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
			//CheckError(idx, ret, __LINE__);

			//sweep register

			ret = Configure_GNDS_Mux(idx, NPLC);
			CheckError(idx, ret, __LINE__);

			for (int i = 1; i < HDS + 1 ; i++)
			{
				String ^ Vector_File_Hsel	= (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_Hsel"));
				String ^ Test_Pin_N			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin_N"));
				String ^ Test_Pin_P			= (String ^)(tf_TPCondition_Cast(TPName[i], "Test_Pin_P"));

				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);

				diffp_V = 0;
				diffn_V = 0;

				if (TPName[i]->Contains("wop") == true)
				{
					mask = 1 << Compare_Bit;
				}
				else
				{
					mask = Compare_Bit;
				}
		
				// DICV pin (WRxP)
				try
				{
					ret = smu[idx]->QueryModuleType(Test_Pin_P, TestPinP_moduleType);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					TestPinP_moduleType = DM_CONST_MODULE_TYPE;
				}

				if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2); //
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin_P);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin_P, Clamp_Vo_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
					CheckError(idx, ret, __LINE__);
				}
				
				// DICV pin (WRxN)
				try
				{
					ret = smu[idx]->QueryModuleType(Test_Pin_N, TestPinN_moduleType);
					CheckError(idx, ret, __LINE__);
				}
				catch (Exception ^) //not a smu resource if exception occurs
				{
					TestPinN_moduleType = DM_CONST_MODULE_TYPE;
				}

				if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
				{
					ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2); 
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = dm[idx]->DPINOn(Test_Pin_N);
					CheckError(idx, ret, __LINE__);
				}
				else //smu
				{
					ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->ClampVoltage(Test_Pin_N, Clamp_Vo_V);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
					CheckError(idx, ret, __LINE__);
					ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
					CheckError(idx, ret, __LINE__);
				}

				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);		//ML - dont mask, else last 2 params will fail
				CheckError(idx, ret, __LINE__);

				//Set Hsel
				//if(!USE_SPI)
				//{
					
					ret = RunVectorFile(idx, Vector_File_Hsel);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");		
					CheckError(idx, ret, __LINE__);
				//} 
				//else
				//{
				//	//ret = OnOffSPI(idx, 1);
				//	//CheckError(idx, ret, __LINE__);
				//	ret = RunSPI(idx, Vector_File_Hsel);
				//	CheckError(idx, ret, __LINE__);
				//}
				
				spi_wr_byte_length = 1;

				for (int k=Start_Data; k<=Stop_Data; k++)
				{
					int datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
									
					ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
					CheckError(idx, ret, __LINE__);

					spi_status = 0;

					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
						CheckError(idx, ret, __LINE__);

						if (spi_status == 2) //0=idle, 1=busy, 2=done
							break;

						swatch.Stop();
					}

					if (spi_status == 2)
					{
						//_util->Wait_Sec(On_Delay_s);

						spi_status = 0;
						readback = 0;

						spi_data_dir[0] = 0x00000ff; 
						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
						CheckError(idx, ret, __LINE__);
					
						swatch.Reset();
						swatch.Start();
						swatch.Stop();

						while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
						{
							swatch.Start();

							ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
							CheckError(idx, ret, __LINE__);

							if (spi_status == 2) //0=idle, 1=busy, 2=done
								break;

							swatch.Stop();
						}

						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(idx, ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								readback = (data & (mask & 0xff)) & 0xff;
							}
							else
							{
								readback = INVALID_RESULT;
							}
						}
						if (readback == (mask & 0xff))
						{
							_util->Wait_Sec(Measure_Delay_s);

							// Measure WRxP
							if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
							{
								ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
								CheckError(idx, ret, __LINE__);
							}
							else
							{
								ret = smu[idx]->ReadVoltage(Test_Pin_P, diffp_V);
								CheckError(idx, ret, __LINE__);
							}

							if (TPName[i]->Contains("Rf_wop") == true)
							{
								// Measure WRxN
								if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
								{
									ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
									CheckError(idx, ret, __LINE__);
								}
								else
								{
									ret = smu[idx]->ReadVoltage(Test_Pin_N, diffn_V);
									CheckError(idx, ret, __LINE__);
								}
							}
							else
							{
								diffn_V = 0;
								{
									//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, diffn_V);
									ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", diffn_V);
									CheckError(idx, ret, __LINE__);
								}
							}

							result_trip[i-1] = Math::Abs(diffp_V - diffn_V);

							break;
						}
					}
				}
				
				double result_final = 0;

				if(_glob->global_who_i[idx, i-1] == INVALID_RESULT || _glob->global_who_v[idx, i-1] == INVALID_RESULT)
					result_final = (4000 * result_trip[i-1]) / (0.4 - result_trip[i-1]); 
				else 
					result_final = result_trip[i-1] / _glob->global_who_i[idx, i-1];

				tf_SetResult_UUTOffset(TPName[0], result_trip[0] + GetOffset(idx, TPDispName[0]), idx);
				tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
			}
			
			/////////////////////////////////
			
			//if(!USE_SPI) 
			//{
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = RunSPI(idx, Vector_File_End);
			//	CheckError(idx, ret, __LINE__);

			//	ret = OnOffSPI(idx, 0);
			//	CheckError(idx, ret, __LINE__);
			//}

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}

	void TestProgram::flt_ht_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
			double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
			String ^ Test_Pin		= String::Empty;

			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;
			Stopwatch swatch1;
			Stopwatch swatch2;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			ret = dm[idx]->DPINOff(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOn(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			int Start_Data		= 0;
			int Stop_Data		= 0;
			int Compare_Bit		= 0;
			int Compare_Reg_Addr = 0;

			double result_Rh_trip = 0;
			double result_vheat = 0;

			int spi_group = 0;
			double spi_clk_freq = 10e6; //2e6;
			int spi_clk_divider = (int)(100e6/spi_clk_freq - 1); //200e6
			int cpol = 0;
			int cpha = 0;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			//sweep_reg
			array<int> ^ sweep_step = gcnew array<int>(256);
			array<int> ^ reverse_bits = gcnew array<int>(256);
			array<int> ^ compare_bits = gcnew array<int>(256);
			array<int> ^ compare_value = gcnew array<int>(256);


			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->SPI_NCS_ACTIVE_STATE("DM_2", spi_group, DM_CONST_SPI_NCS_ACTIVE_HIGH);
			CheckError(idx, ret, __LINE__);
		
			if (Input_Channel_Delay_s == 0)
			{
				ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 0);
				CheckError(idx, ret, __LINE__);
			}
			else if (Input_Channel_Delay_s < 5e-9)
			{
				ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
				CheckError(idx, ret, __LINE__);
			}
			else
			{
				ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 2);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
			CheckError(idx, ret, __LINE__);

			ret = Configure_GNDS_Mux(idx, NPLC);
			CheckError(idx, ret, __LINE__);

			Dictionary <String ^, int> ^ TestPin = gcnew Dictionary <String ^, int>;

			for (int i=0; i<total_tp; i++)
			{
				Test_Pin	= (String ^)tf_TPCondition_Cast(TPName[i], "Test_Pin");
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

				Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
				Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
				Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
				Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

				ret = DriveMuxIO(idx, TPDispName[i]);
				CheckError(idx, ret, __LINE__);

				/////

				if (TestPin->ContainsKey(Test_Pin) == false)
				{
					ret = dm[idx]->DPINOff(Test_Pin);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->DPINOn(Test_Pin);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(On_Delay_s);

					ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
					CheckError(idx, ret, __LINE__);

					TestPin->Add(Test_Pin, 1);
				}

				/////

				// Load vector file

				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);		//ML don't mask. Else get 0
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
				//ret = RunSPI(idx, Vector_File);
				//CheckError(idx, ret, __LINE__);

				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");	//ML don't mask. Else get 0
				CheckError(idx, ret, __LINE__);
				
				//Counter start
				//swatch1.Reset();
				//swatch1.Start();
				//
				//swatch2.Reset();
				//swatch2.Start();

				//int do_once = 0;
				//int do_once2 = 0;

				//Sweep reg
				
				spi_wr_byte_length = 2; // org 1
				//double spi_clk_freq = 10e6;

				int k = Start_Data;
				//while(k != Stop_Data)
				//{
					int datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
					delay_s_after_byte[0] = 25e-9;
					if(Start_Data < Stop_Data)
					{
						sweep_step[0] = 1;
					}
					else
					{
						sweep_step[0] = -1;
					}
					reverse_bits[0] = 8;
					compare_bits[0] = 0; 
					compare_value[0] = 0;

					spi_data_dir[1] = 0x00000ff; 
					spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

					//ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
					//ret = SPI_TTR(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status, spi_clk_freq);
					//CheckError(idx, ret, __LINE__);
					
					int max_sweep_loop = 256;
					sweep_step[1] = 0;
					delay_s_after_byte[1] = 0; //100e-9;
					reverse_bits[1] = 0;
					compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
					compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

					ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
					
					
					//spi_status = 2;

					//_util->Wait_Sec(0.0001);

					//spi_status = 0;
				
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
						CheckError(idx, ret, __LINE__);

						if (spi_status == 2) //0=idle, 1=busy, 2=done
							break;

						swatch.Stop();
					}

					int sweep_count = 0;
					ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

					if (spi_status == 2)
					{
						spi_status = 0;
						readback = 0;

						//spi_data_dir[0] = 0x00000ff; 
						//spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						////ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
						//ret = SPI_TTR(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status, spi_clk_freq);
						//CheckError(idx, ret, __LINE__);

						//if (do_once2 == 0)
						//{
						//	ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
						//	CheckError(idx, ret, __LINE__);
						//	//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						//	//CheckError(idx, ret, __LINE__);
						//	do_once2 = 1;
						//}
						//else
						//{
						//	ret = dm[idx]->SPI_RERUN("DM_2", spi_group);
						//}
						//spi_status = 2;
						//_util->Wait_Sec(0.0001);

						//swatch.Reset();
						//swatch.Start();
						//swatch.Stop();

						//while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
						//{
						//	swatch.Start();

						//	ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
						//	CheckError(idx, ret, __LINE__);

						//	if (spi_status == 2) //0=idle, 1=busy, 2=done
						//		break;

						//	swatch.Stop();
						//}

						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(idx, ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
							}
							else
							{
								readback = INVALID_RESULT;
							}
						}

						if (readback == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_Rh_trip);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vheat);
							CheckError(idx, ret, __LINE__);

							double volt = 0;
							//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(idx, ret, __LINE__);
							result_vheat = result_vheat - volt;

							result_Rh_trip = result_Rh_trip * -1;

							//break;
						}
						else 
						{
							result_Rh_trip = 0.0000001; //follow catalyst
							result_vheat = 0;
						}
					}

					////Counter end
					//swatch1.Stop();
					//double TotalTime = swatch1.Elapsed.TotalMilliseconds;

				//	if (Start_Data < Stop_Data)
				//	{	
				//		k++;
				//	}
				//	else
				//	{
				//		k--;
				//	}
				//}

				////Counter end
				//swatch2.Stop();
				//double TotalTime2 = swatch2.Elapsed.TotalMilliseconds;

				double result_final = 0;
				result_final = result_vheat / (135 * result_Rh_trip);

				tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
			}

			/////////////////////////////////

			//ret = RunSPI(idx, Vector_File_End);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
			//CheckError(idx, ret, __LINE__);

			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
			CheckError(idx, ret, __LINE__);

			ret = RunVectorFile(idx, Vector_File_End);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::fhs_flt_spd(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
			double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
			String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			/////////////////////////////////

			ret = dm[idx]->DPINOff(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOn(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{			
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

					//if(!USE_SPI)
					//{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					//} 
					//else 
					//{
					//	ret = RunSPI(idx, Vector_File);
					//	CheckError(idx, ret, __LINE__);
					//}

					_util->Wait_Sec(Measure_Delay_s);

					ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result[i]);
					CheckError(idx, ret, __LINE__);

					result[i] = result[i] * -1;

					tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}

			/////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::fhs_vtrip_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;
			String ^ Vector_File_1		= String::Empty;
			String ^ Vector_File_2		= String::Empty;	//ML

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

			double result				= 0;
			array<double> ^ result_fhs_Vout_ref = gcnew array<double>(6);	//ML
			double result_adc_up		= 0;
			double result_adc_dn		= 0;
			array<double> ^ result_fhs_Vout_up = gcnew array<double>(6);	//ML
			array<double> ^ result_fhs_Vout_dn = gcnew array<double>(6);	//ML
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);		//no in 2945 47s TP earlier
			CheckError(idx, ret, __LINE__);			
			
			//Setup Power supplies
			//ret = smu->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			//if(!USE_SPI) 
			//{
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File_Start);
			//	CheckError(idx, ret, __LINE__);
			//}
			
			ret = Configure_GNDS_Mux(idx, NPLC);		//new in rev54
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			ret = dm[idx]->DPINOff(Test_Pin);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(Measure_Delay_s);

			//ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref);
			//if (ret < 0) return ret;

			//#ifdef USE_GNDS
			//double volt = 0;
			//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
			//if (ret < 0) return ret;
			//result_fhs_Vout_ref = result_fhs_Vout_ref - volt;
			//#endif

			/////////////////////////////////

			int Start_Data		= 0;
			int Stop_Data		= 0;
			int Compare_Bit		= 0;
			int Compare_Reg_Addr = 0;

			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

				Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
				Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
				Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
				Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

				// Load vector file

				if (tf_TPCondition_exist(TPName[i], "Vector_File_2") == true)
				{			
					Vector_File_2 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_2");

					//if(!USE_SPI) {
					ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
					CheckError(idx, ret, __LINE__);

					ret = RunVectorFile(idx, Vector_File_2);
					CheckError(idx, ret, __LINE__);					
					
					ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
					CheckError(idx, ret, __LINE__);
					//} else {
					//ret = RunSPI(idx, Vector_File_2);
					//CheckError(idx, ret, __LINE__);
					//}
				}

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

					//if(!USE_SPI) {
					ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
					CheckError(idx, ret, __LINE__);

					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);					
					
					ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
					CheckError(idx, ret, __LINE__);
					//} else {
					//ret = RunSPI(idx, Vector_File);
					//CheckError(idx, ret, __LINE__);
					//}
				}
				
				if(i%2 == 0)
				{
					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref[i/2]);
					CheckError(idx, ret, __LINE__);

					double volt = 0;
					//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
					ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);					
					CheckError(idx, ret, __LINE__);
					result_fhs_Vout_ref[i/2] = result_fhs_Vout_ref[i/2] - volt;
				}	
				
				//Sweep reg
				spi_wr_byte_length = 1;

				int datain = 0;

				int k = Start_Data;
				while(k != Stop_Data)
				{
					datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

					spi_status = 0;

					ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(idx, ret, __LINE__);	

					if (spi_status == 2)
					{
						spi_status = 0;
						readback = 0;

						spi_data_dir[0] = 0x00000ff; 
						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(idx, ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
							}
							else
							{
								readback = INVALID_RESULT;
							}
						}

						if (i%2 == 0 && readback == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]);
							CheckError(idx, ret, __LINE__);

							double volt = 0;
							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(idx, ret, __LINE__);
							result_fhs_Vout_up[i/2] = result_fhs_Vout_up[i/2] - volt;

							break;
						}
						else if (i%2 == 1 && readback != ((1 << Compare_Bit) & 0xff))	//ML (i == 1 && readback != ((1 << Compare_Bit) & 0xff))
						{
							ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_dn[(i-1)/2]);
							CheckError(idx, ret, __LINE__);

							double volt = 0;
							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(idx, ret, __LINE__);
							
							result_fhs_Vout_dn[(i-1)/2] = result_fhs_Vout_dn[(i-1)/2] - volt;

							break;
						}
						else if (i%2 == 0 && readback != ((1 << Compare_Bit) & 0xff))
						{
							ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
							CheckError(idx, ret, __LINE__);

							ret = RunVectorFile(idx, Vector_File_1);
							CheckError(idx, ret, __LINE__);
							
							ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
							CheckError(idx, ret, __LINE__);

							spi_status = 0;
							readback = 0;

							spi_data_dir[0] = 0x00000ff; 
							spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

							ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
							CheckError(idx, ret, __LINE__);

							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
							CheckError(idx, ret, __LINE__);

							for (int m=0; m<spi_rd_byte_length; m++)
							{
								if (spi_rd_biterror[m] == 0)
								{
									data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
								}
								else
								{
									readback = INVALID_RESULT;
								}
							}

							if (readback == ((1 << Compare_Bit) & 0xff))
							{
								ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]);
								CheckError(idx, ret, __LINE__);

								double volt = 0;
								//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
								ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
								CheckError(idx, ret, __LINE__);
								
								result_fhs_Vout_up[i/2] = result_fhs_Vout_up[i/2] - volt;

								break;
							}
						}
					}

					if (i%2 == 0)
						k++;
					else
						k--;
				}
			}


			double result_final_0 = 0;
			double result_final_1 = 0;

			//ML extra in 2945
			double result_final_2 = 0;
			double result_final_3 = 0;
			double result_final_4 = 0;
			double result_final_5 = 0;
			double result_final_6 = 0;
			double result_final_7 = 0;
			double result_final_8 = 0;
			double result_final_9 = 0;
			double result_final_10 = 0;
			double result_final_11 = 0;

			result_final_0 = result_fhs_Vout_up[0] - result_fhs_Vout_ref[0];
			result_final_1 = result_fhs_Vout_up[0] - result_fhs_Vout_dn[0];

			result_final_2 = result_fhs_Vout_up[1] - result_fhs_Vout_ref[1];
			result_final_3 = result_fhs_Vout_up[1] - result_fhs_Vout_dn[1];
			result_final_4 = result_fhs_Vout_up[2] - result_fhs_Vout_ref[2];
			result_final_5 = result_fhs_Vout_up[2] - result_fhs_Vout_dn[2];
			result_final_6 = result_fhs_Vout_up[3] - result_fhs_Vout_ref[3];//fail
			result_final_7 = result_fhs_Vout_up[3] - result_fhs_Vout_dn[3];
			result_final_8 = result_fhs_Vout_up[4] - result_fhs_Vout_ref[4];//fail
			result_final_9 = result_fhs_Vout_up[4] - result_fhs_Vout_dn[4];
			result_final_10 = result_fhs_Vout_up[5] - result_fhs_Vout_ref[5];//fail
			result_final_11 = result_fhs_Vout_up[5] - result_fhs_Vout_dn[5];

			tf_SetResult_UUTOffset(TPName[0], result_final_0 + GetOffset(idx, TPDispName[0]), idx);
			tf_SetResult_UUTOffset(TPName[1], result_final_1 + GetOffset(idx, TPDispName[1]), idx);
			tf_SetResult_UUTOffset(TPName[2], result_final_2 + GetOffset(idx, TPDispName[2]), idx);
			tf_SetResult_UUTOffset(TPName[3], result_final_3 + GetOffset(idx, TPDispName[3]), idx);
			tf_SetResult_UUTOffset(TPName[4], result_final_4 + GetOffset(idx, TPDispName[4]), idx);
			tf_SetResult_UUTOffset(TPName[5], result_final_5 + GetOffset(idx, TPDispName[5]), idx);
			tf_SetResult_UUTOffset(TPName[6], result_final_6 + GetOffset(idx, TPDispName[6]), idx);
			tf_SetResult_UUTOffset(TPName[7], result_final_7 + GetOffset(idx, TPDispName[7]), idx);
			tf_SetResult_UUTOffset(TPName[8], result_final_8 + GetOffset(idx, TPDispName[8]), idx);
			tf_SetResult_UUTOffset(TPName[9], result_final_9 + GetOffset(idx, TPDispName[9]), idx);
			tf_SetResult_UUTOffset(TPName[10], result_final_10 + GetOffset(idx, TPDispName[10]), idx);
			tf_SetResult_UUTOffset(TPName[11], result_final_11 + GetOffset(idx, TPDispName[11]), idx);
		
			/////////////////////////////////

			if(!USE_SPI)
			{
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = RunSPI(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);

				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//void TestProgram::fhs_vtrip_ttr(Object^ object)		//Ml temp mask due to fail
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
	//		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		String ^ Vector_File_1		= String::Empty;
	//		String ^ Vector_File_2		= String::Empty;	//ML

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

	//		double result				= 0;
	//		array<double> ^ result_fhs_Vout_ref = gcnew array<double>(6);	//ML
	//		double result_adc_up		= 0;
	//		double result_adc_dn		= 0;
	//		array<double> ^ result_fhs_Vout_up = gcnew array<double>(6);	//ML
	//		array<double> ^ result_fhs_Vout_dn = gcnew array<double>(6);	//ML
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);		//no in 2945 47s TP earlier
	//		CheckError(idx, ret, __LINE__);			
	//		
	//		//Setup Power supplies
	//		//ret = smu->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(0.001);

	//		//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		if(!USE_SPI) 
	//		{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else 
	//		{
	//			ret = OnOffSPI(idx, 1);
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunSPI(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		
	//		ret = Configure_GNDS_Mux(idx, NPLC);		//new in rev54
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////
	//		ret = dm[idx]->DPINOff(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOn(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(Measure_Delay_s);

	//		//ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref);
	//		//if (ret < 0) return ret;

	//		//#ifdef USE_GNDS
	//		//double volt = 0;
	//		//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//		//if (ret < 0) return ret;
	//		//result_fhs_Vout_ref = result_fhs_Vout_ref - volt;
	//		//#endif

	//		/////////////////////////////////

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		int spi_group = 0;
	//		double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);			
	//		
	//		for (int i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		if(USE_SPI)
	//		{
	//			//ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//			//CheckError(idx, ret, __LINE__);
	//		}

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

	//			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			// Load vector file

	//			if (tf_TPCondition_exist(TPName[i], "Vector_File_2") == true)
	//			{			
	//				Vector_File_2 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_2");

	//				if(!USE_SPI) {
	//				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//				CheckError(idx, ret, __LINE__);

	//				ret = RunVectorFile(idx, Vector_File_2);
	//				CheckError(idx, ret, __LINE__);					
	//				
	//				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//				CheckError(idx, ret, __LINE__);
	//				} else {
	//				ret = RunSPI(idx, Vector_File_2);
	//				CheckError(idx, ret, __LINE__);
	//				}
	//			}

	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

	//				if(!USE_SPI) {
	//				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//				CheckError(idx, ret, __LINE__);

	//				ret = RunVectorFile(idx, Vector_File);
	//				CheckError(idx, ret, __LINE__);					
	//				
	//				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//				CheckError(idx, ret, __LINE__);
	//				} else {
	//				ret = RunSPI(idx, Vector_File);
	//				CheckError(idx, ret, __LINE__);
	//				}
	//			}
	//			
	//			if(i%2 == 0)
	//			{
	//				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref[i/2]);
	//				CheckError(idx, ret, __LINE__);

	//				double volt = 0;
	//				//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
	//				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);					
	//				CheckError(idx, ret, __LINE__);
	//				result_fhs_Vout_ref[i/2] = result_fhs_Vout_ref[i/2] - volt;
	//			}	
	//			
	//			//Sweep reg
	//			spi_wr_byte_length = 2;		//1

	//			int datain = 0;

	//			int k = Start_Data;
	//			//while(k != Stop_Data)
	//			//{
	//				datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 5e-9; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				if(i == 0)
	//				{
	//					compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}
	//				else if(i == 1)
	//				{
	//					compare_value[1] = 0; //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);

	//				//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

	//				if (spi_status == 2)
	//				{
	//					spi_status = 0;
	//					readback = 0;

	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);

	//					for (int m=0; m<spi_rd_byte_length; m++)
	//					{
	//						if (spi_rd_biterror[m] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}
	//					_util->Wait_Sec(Measure_Delay_s);
	//					
	//					if (i%2 == 0 && readback == ((1 << Compare_Bit) & 0xff))
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]);
	//						CheckError(idx, ret, __LINE__);

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						result_fhs_Vout_up[i/2] = result_fhs_Vout_up[i/2] - volt;

	//						break;
	//					}
	//					else if (i%2 == 1 && readback != ((1 << Compare_Bit) & 0xff))	//ML (i == 1 && readback != ((1 << Compare_Bit) & 0xff))
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_dn[(i-1)/2]);
	//						CheckError(idx, ret, __LINE__);

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						result_fhs_Vout_dn[(i-1)/2] = result_fhs_Vout_dn[(i-1)/2] - volt;

	//						break;
	//					}
	//					else if (i%2 == 0 && readback != ((1 << Compare_Bit) & 0xff))
	//					{
	//						if(!USE_SPI) 
	//						{
	//							ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//							CheckError(idx, ret, __LINE__);

	//							ret = RunVectorFile(idx, Vector_File_1);
	//							CheckError(idx, ret, __LINE__);
	//							
	//							ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//							CheckError(idx, ret, __LINE__);
	//						} 
	//						else 
	//						{
	//							ret = RunSPI(idx, Vector_File_1);
	//							CheckError(idx, ret, __LINE__);
	//						}

	//						//spi_status = 0;
	//						readback = 0;

	//						spi_data_dir[1] = 0x00000ff; 
	//						spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//						ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//						CheckError(idx, ret, __LINE__);

	//						//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//						//CheckError(idx, ret, __LINE__);

	//						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//						CheckError(idx, ret, __LINE__);

	//						for (int m=0; m<spi_rd_byte_length; m++)
	//						{
	//							if (spi_rd_biterror[m] == 0)
	//							{
	//								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//							}
	//							else
	//							{
	//								readback = INVALID_RESULT;
	//							}
	//						}

	//						if (readback == ((1 << Compare_Bit) & 0xff))
	//						{
	//							ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]);
	//							CheckError(idx, ret, __LINE__);

	//							double volt = 0;
	//							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//							CheckError(idx, ret, __LINE__);
	//							
	//							result_fhs_Vout_up[i/2] = result_fhs_Vout_up[i/2] - volt;

	//							break;
	//						}
	//					}
	//				//}

	//				//if (i%2 == 0)
	//				//	k++;
	//				//else
	//				//	k--;
	//			}
	//		}


	//		double result_final_0 = 0;
	//		double result_final_1 = 0;

	//		//ML extra in 2945
	//		double result_final_2 = 0;
	//		double result_final_3 = 0;
	//		double result_final_4 = 0;
	//		double result_final_5 = 0;
	//		double result_final_6 = 0;
	//		double result_final_7 = 0;
	//		double result_final_8 = 0;
	//		double result_final_9 = 0;
	//		double result_final_10 = 0;
	//		double result_final_11 = 0;

	//		result_final_0 = result_fhs_Vout_up[0] - result_fhs_Vout_ref[0];
	//		result_final_1 = result_fhs_Vout_up[0] - result_fhs_Vout_dn[0];

	//		result_final_2 = result_fhs_Vout_up[1] - result_fhs_Vout_ref[1];
	//		result_final_3 = result_fhs_Vout_up[1] - result_fhs_Vout_dn[1];
	//		result_final_4 = result_fhs_Vout_up[2] - result_fhs_Vout_ref[2];
	//		result_final_5 = result_fhs_Vout_up[2] - result_fhs_Vout_dn[2];
	//		result_final_6 = result_fhs_Vout_up[3] - result_fhs_Vout_ref[3];//fail
	//		result_final_7 = result_fhs_Vout_up[3] - result_fhs_Vout_dn[3];
	//		result_final_8 = result_fhs_Vout_up[4] - result_fhs_Vout_ref[4];//fail
	//		result_final_9 = result_fhs_Vout_up[4] - result_fhs_Vout_dn[4];
	//		result_final_10 = result_fhs_Vout_up[5] - result_fhs_Vout_ref[5];//fail
	//		result_final_11 = result_fhs_Vout_up[5] - result_fhs_Vout_dn[5];

	//		tf_SetResult_UUTOffset(TPName[0], result_final_0 + GetOffset(idx, TPDispName[0]), idx);
	//		tf_SetResult_UUTOffset(TPName[1], result_final_1 + GetOffset(idx, TPDispName[1]), idx);
	//		tf_SetResult_UUTOffset(TPName[2], result_final_2 + GetOffset(idx, TPDispName[2]), idx);
	//		tf_SetResult_UUTOffset(TPName[3], result_final_3 + GetOffset(idx, TPDispName[3]), idx);
	//		tf_SetResult_UUTOffset(TPName[4], result_final_4 + GetOffset(idx, TPDispName[4]), idx);
	//		tf_SetResult_UUTOffset(TPName[5], result_final_5 + GetOffset(idx, TPDispName[5]), idx);
	//		tf_SetResult_UUTOffset(TPName[6], result_final_6 + GetOffset(idx, TPDispName[6]), idx);
	//		tf_SetResult_UUTOffset(TPName[7], result_final_7 + GetOffset(idx, TPDispName[7]), idx);
	//		tf_SetResult_UUTOffset(TPName[8], result_final_8 + GetOffset(idx, TPDispName[8]), idx);
	//		tf_SetResult_UUTOffset(TPName[9], result_final_9 + GetOffset(idx, TPDispName[9]), idx);
	//		tf_SetResult_UUTOffset(TPName[10], result_final_10 + GetOffset(idx, TPDispName[10]), idx);
	//		tf_SetResult_UUTOffset(TPName[11], result_final_11 + GetOffset(idx, TPDispName[11]), idx);
	//	
	//		/////////////////////////////////

	//		if(!USE_SPI)
	//		{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else
	//		{
	//			ret = RunSPI(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);

	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//void TestProgram::fhs_vtrip_ttr(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{

	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
	//		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		String ^ Vector_File_1		= String::Empty;
	//		String ^ Vector_File_2		= String::Empty;	//ML

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

	//		double result				= 0;
	//		array<double> ^ result_fhs_Vout_ref = gcnew array<double>(6);	//ML
	//		double result_adc_up		= 0;
	//		double result_adc_dn		= 0;
	//		array<double> ^ result_fhs_Vout_up = gcnew array<double>(6);	//ML
	//		array<double> ^ result_fhs_Vout_dn = gcnew array<double>(6);	//ML
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);		//no in 2945 47s TP earlier
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);
	//		
	//		//_util->Wait_Sec(0.001);

	//		//ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);
	//		
	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		//if(!USE_SPI) 
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else 
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}
	//		
	//		ret = Configure_GNDS_Mux(idx, NPLC);		//new in rev54
	//		CheckError(idx, ret, __LINE__);
	//		
	//		/////////////////////////////////
	//		if(0)
	//		{// DM
	//		ret = dm[idx]->DPINOff(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOn(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(Measure_Delay_s);

	//		//ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref);
	//		//CheckError(idx, ret, __LINE__);
	//		}else{
	//		//SMU
	//		ret = smu[idx]->ConfigurePLF("MTX_SMU", Power_Line_Freq);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->SetBandwidth("MTX_SMU", 1); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->SetNPLC("MTX_SMU", NPLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampVoltage("MTX_SMU", 2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveCurrent("MTX_SMU", Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->OnSmuPin("MTX_SMU", false, false);
	//		CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->Measure("MTX_SMU", DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref); 
	//		}
	//		
	//		/////////////////////////////////

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		int spi_group = 0;
	//		double spi_clk_freq = 2e6;	//mask inb rev54
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);			
	//		
	//		for (int i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//if(USE_SPI)
	//		//{
	//			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//			CheckError(idx, ret, __LINE__);
	//		//}

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

	//			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			// Load vector file
	//			if (tf_TPCondition_exist(TPName[i], "Vector_File_2") == true)
	//			{			
	//				Vector_File_2 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_2");

	//				//if(!USE_SPI) {
	//				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//				CheckError(idx, ret, __LINE__);

	//				ret = RunVectorFile(idx, Vector_File_2);
	//				CheckError(idx, ret, __LINE__);					
	//				
	//				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//				CheckError(idx, ret, __LINE__);
	//				//} else {
	//				//ret = RunSPI(idx, Vector_File_2);
	//				//CheckError(idx, ret, __LINE__);
	//				//}
	//			}

	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

	//				//if(!USE_SPI) {
	//				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//				CheckError(idx, ret, __LINE__);

	//				ret = RunVectorFile(idx, Vector_File);
	//				CheckError(idx, ret, __LINE__);					
	//				
	//				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//				CheckError(idx, ret, __LINE__);
	//				//} else {
	//				//ret = RunSPI(idx, Vector_File);
	//				//CheckError(idx, ret, __LINE__);
	//				//}
	//			}
	//			
	//			if(i%2 == 0)
	//			{
	//				ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_ref[i/2]);
	//				CheckError(idx, ret, __LINE__);

	//				double volt = 0;
	//				//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
	//				ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);					
	//				CheckError(idx, ret, __LINE__);
	//				result_fhs_Vout_ref[i/2] = result_fhs_Vout_ref[i/2] - volt;
	//				
	//			}	
	//			//Sweep reg

	//			spi_wr_byte_length = 2;		//b4 rev54 is 1

	//			int datain = 0;

	//			int k = Start_Data;
	//			//while(k != Stop_Data)
	//			//{
	//				datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;	//new in rev54
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}					
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 5e-9; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				if(i == 0)
	//				{
	//					compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}
	//				else if(i == 1)
	//				{
	//					compare_value[1] = 0; //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);

	//				//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();
	//				
	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}					

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

	//				if (spi_status == 2)
	//				{
	//					spi_status = 0;
	//					readback = 0;

	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);

	//					for (int m=0; m<spi_rd_byte_length; m++)
	//					{
	//						if (spi_rd_biterror[m] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}
	//					_util->Wait_Sec(Measure_Delay_s);
	//					
	//					if (i%2 == 0 && readback == ((1 << Compare_Bit) & 0xff))
	//					{
	//						//ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]);
	//						//CheckError(idx, ret, __LINE__);
	//						ret = smu[idx]->Measure("MTX_SMU", DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]); 
	//						
	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						result_fhs_Vout_up[i/2] = result_fhs_Vout_up[i/2] - volt;
	//						
	//						break;
	//					}
	//					else if (i%2 == 1 && readback != ((1 << Compare_Bit) & 0xff))	//ML (i == 1 && readback != ((1 << Compare_Bit) & 0xff))
	//					{
	//						//ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_dn[(i-1)/2]);
	//						//CheckError(idx, ret, __LINE__);
	//						ret = smu[idx]->Measure("MTX_SMU", DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_dn[(i-1)/2]); 

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						result_fhs_Vout_dn[(i-1)/2] = result_fhs_Vout_dn[(i-1)/2] - volt;

	//						break;
	//					}
	//					else if (i%2 == 0 && readback != ((1 << Compare_Bit) & 0xff))
	//					{
	//						//if(!USE_SPI) 
	//						//{
	//							ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//							CheckError(idx, ret, __LINE__);

	//							ret = RunVectorFile(idx, Vector_File_1);
	//							CheckError(idx, ret, __LINE__);
	//							
	//							ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//							CheckError(idx, ret, __LINE__);
	//						//} 
	//						//else 
	//						//{
	//						//	ret = RunSPI(idx, Vector_File_1);
	//						//	CheckError(idx, ret, __LINE__);
	//						//}

	//						//spi_status = 0;
	//						readback = 0;

	//						spi_data_dir[0] = 0x00000ff; 
	//						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//						ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//						//CheckError(idx, ret, __LINE__);

	//						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//						CheckError(idx, ret, __LINE__);

	//						for (int m=0; m<spi_rd_byte_length; m++)
	//						{
	//							if (spi_rd_biterror[m] == 0)
	//							{
	//								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//							}
	//							else
	//							{
	//								readback = INVALID_RESULT;
	//							}
	//						}

	//						if (readback == ((1 << Compare_Bit) & 0xff))
	//						{
	//							//ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]);
	//							//CheckError(idx, ret, __LINE__);
	//							ret = smu[idx]->Measure("MTX_SMU", DM_CONST_MEASUREVOLTAGE, result_fhs_Vout_up[i/2]); 

	//							double volt = 0;
	//							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//							CheckError(idx, ret, __LINE__);
	//							
	//							result_fhs_Vout_up[i/2] = result_fhs_Vout_up[i/2] - volt;

	//							break;
	//						}
	//					}
	//				//}

	//				//if (i%2 == 0)
	//				//	k++;
	//				//else
	//				//	k--;
	//			}
	//		}

	//		double result_final_0 = result_fhs_Vout_up[0] - result_fhs_Vout_ref[0];
	//		double result_final_1 = result_fhs_Vout_up[0] - result_fhs_Vout_dn[0];

	//		double result_final_2 = result_fhs_Vout_up[1] - result_fhs_Vout_ref[1];
	//		double result_final_3 = result_fhs_Vout_up[1] - result_fhs_Vout_dn[1];
	//		double result_final_4 = result_fhs_Vout_up[2] - result_fhs_Vout_ref[2];
	//		double result_final_5 = result_fhs_Vout_up[2] - result_fhs_Vout_dn[2];
	//		double result_final_6 = result_fhs_Vout_up[3] - result_fhs_Vout_ref[3];//fail
	//		double result_final_7 = result_fhs_Vout_up[3] - result_fhs_Vout_dn[3];
	//		double result_final_8 = result_fhs_Vout_up[4] - result_fhs_Vout_ref[4];//fail
	//		double result_final_9 = result_fhs_Vout_up[4] - result_fhs_Vout_dn[4];
	//		double result_final_10 = result_fhs_Vout_up[5] - result_fhs_Vout_ref[5];//fail
	//		double result_final_11 = result_fhs_Vout_up[5] - result_fhs_Vout_dn[5];

	//		tf_SetResult_UUTOffset(TPName[0], result_final_0 + GetOffset(idx, TPDispName[0]), idx);
	//		tf_SetResult_UUTOffset(TPName[1], result_final_1 + GetOffset(idx, TPDispName[1]), idx);
	//		tf_SetResult_UUTOffset(TPName[2], result_final_2 + GetOffset(idx, TPDispName[2]), idx);
	//		tf_SetResult_UUTOffset(TPName[3], result_final_3 + GetOffset(idx, TPDispName[3]), idx);
	//		tf_SetResult_UUTOffset(TPName[4], result_final_4 + GetOffset(idx, TPDispName[4]), idx);
	//		tf_SetResult_UUTOffset(TPName[5], result_final_5 + GetOffset(idx, TPDispName[5]), idx);
	//		tf_SetResult_UUTOffset(TPName[6], result_final_6 + GetOffset(idx, TPDispName[6]), idx);
	//		tf_SetResult_UUTOffset(TPName[7], result_final_7 + GetOffset(idx, TPDispName[7]), idx);
	//		tf_SetResult_UUTOffset(TPName[8], result_final_8 + GetOffset(idx, TPDispName[8]), idx);
	//		tf_SetResult_UUTOffset(TPName[9], result_final_9 + GetOffset(idx, TPDispName[9]), idx);
	//		tf_SetResult_UUTOffset(TPName[10], result_final_10 + GetOffset(idx, TPDispName[10]), idx);
	//		tf_SetResult_UUTOffset(TPName[11], result_final_11 + GetOffset(idx, TPDispName[11]), idx);
	//	
	//		/////////////////////////////////

	//		if(!USE_SPI)
	//		{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else
	//		{
	//			ret = RunSPI(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);

	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::flt_fhs_vopen_short2_ttr(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
			double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

			String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";

			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;
			String ^ Vector_File_1		= String::Empty;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;
			Stopwatch swatch1;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->DPINOff(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOn(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);

			//

			//MTX_SMU
			ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->ClampVoltage("MTX_SMU", 1.99);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->OnSmuPin("MTX_SMU", true, false);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			//ret = dm[idx]->DPINOff(Test_Pin_P);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->DPINOn(Test_Pin_P);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			//CheckError(idx, ret, __LINE__);

			////

			//ret = dm[idx]->DPINOff(Test_Pin_N);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			//CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->DPINOn(Test_Pin_N);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			//CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			int Start_Data		= 0;
			int Stop_Data		= 0;
			int Compare_Bit		= 0;
			int Compare_Reg_Addr = 0;

			double result_v_vmr = 0;
			double result_RO_trip = 0;
			double diffp_V = 0;
			double diffn_V = 0;
			double diffpn_V = 0;

			int spi_group = 0;
			int spi_status = 0;
			int readback = 0;
			double spi_clk_freq = 2e6;	//

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			//sweep_reg
			array<int> ^ sweep_step = gcnew array<int>(256);
			array<int> ^ reverse_bits = gcnew array<int>(256);
			array<int> ^ compare_bits = gcnew array<int>(256);
			array<int> ^ compare_value = gcnew array<int>(256);

			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			//query for DiffAmp gain
			double m = 3;
			double c = 0;
			if (Test_Pin_PN == "GRP1_DIFF_SENSE")
			{
				m = _glob->DA_GainError[idx, 0];
				c = _glob->DA_OffsetError[idx, 0];

				ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
				CheckError(idx, ret, __LINE__);
			}
			else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
			{
				m = _glob->DA_GainError[idx, 1];
				c = _glob->DA_OffsetError[idx, 1];

				ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
				CheckError(idx, ret, __LINE__);
			}

			////ML - must include this line to get fhs_vshort pass
			//ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			//CheckError(idx, ret, __LINE__);		

			for (int i=0; i<total_tp; i++)
			{
				Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
				Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
				Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
				Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

				// Load vector file

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}
				}

				//Sweep reg

				////Counter start
				//swatch1.Reset();
				//swatch1.Start();

				spi_wr_byte_length = 2;
				//double spi_clk_freq = 30e6;

				int k = Start_Data;
				//while (k != Stop_Data)
				//{
					int datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
					delay_s_after_byte[0] = 25e-9;
					if(Start_Data < Stop_Data)
					{
						sweep_step[0] = 1;
					}
					else
					{
						sweep_step[0] = -1;
					}
					reverse_bits[0] = 8;
					compare_bits[0] = 0; 
					compare_value[0] = 0;

					spi_data_dir[1] = 0x00000ff; 
					spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
					int max_sweep_loop = 256;
					sweep_step[1] = 0;
					delay_s_after_byte[1] = 0; //100e-9;
					reverse_bits[1] = 0;
					compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
					compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

					ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
					CheckError(idx, ret, __LINE__);

					//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					//CheckError(idx, ret, __LINE__);

					//int run_1 = 0; 
					//if (run_1 == 0)
					//{
					//	ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					//	CheckError(idx, ret, __LINE__);
					//	run_1 = 1;
					//}
					//else 
					//{
					//	ret = dm[idx]->SPI_RERUN("DM_2", spi_group);
					//}

					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
						CheckError(idx, ret, __LINE__);

						if (spi_status == 2) //0=idle, 1=busy, 2=done
							break;

						swatch.Stop();
					}

					int sweep_count = 0;
					ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

					if (spi_status == 2)
					{
						//spi_data_dir[0] = 0x00000ff; 
						//spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						//CheckError(idx, ret, __LINE__);

						//int run_once = 0;
						//if (run_once == 0)
						//{
						//	ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						//	CheckError(idx, ret, __LINE__);
						//	run_once = 1;
						//}
						//else 
						//{
						//	ret = dm[idx]->SPI_RERUN("DM_2", spi_group);
						//}

						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(idx, ret, __LINE__);

						for (int j=0; j<spi_rd_byte_length; j++)
						{
							if (spi_rd_biterror[j] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
							}
							else
							{
								readback = INVALID_RESULT;
							}
						}

						if (readback == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
							CheckError(idx, ret, __LINE__);
							ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
							CheckError(idx, ret, __LINE__);

							result_RO_trip = result_RO_trip * -1;
							result_v_vmr = Math::Abs((diffpn_V-c)/m);

							//break;
						}
						else 
						{
							if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
							{
								Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

								if(!USE_SPI) 
								{
									ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
									CheckError(idx, ret, __LINE__);

									ret = RunVectorFile(idx, Vector_File_1);
									CheckError(idx, ret, __LINE__);

									ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
									CheckError(idx, ret, __LINE__);
								} 
								else
								{
									ret = RunSPI(idx, Vector_File_1);
									CheckError(idx, ret, __LINE__);
								}
				
								//
								spi_wr_byte_length = 1;

								spi_data_dir[0] = 0x00000ff; 
								spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

								ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
								CheckError(idx, ret, __LINE__);

								//int do_once = 0;

								//if (do_once == 0)
								//{
								//	ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
								//	CheckError(idx, ret, __LINE__);
								//	do_once = 1;
								//}
								//else 
								//{
								//	ret = dm[idx]->SPI_RERUN("DM_2", spi_group);
								//}

								ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
								CheckError(idx, ret, __LINE__);

								for (int j=0; j<spi_rd_byte_length; j++)
								{
									if (spi_rd_biterror[j] == 0)
									{
										data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
										readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
									}
									else
									{
										readback = INVALID_RESULT;
									}
								}

								if (readback == ((1 << Compare_Bit) & 0xff))
								{
									ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
									CheckError(idx, ret, __LINE__);
									ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
									CheckError(idx, ret, __LINE__);

									result_RO_trip = result_RO_trip * -1;
									result_v_vmr = Math::Abs((diffpn_V-c)/m);

									//break;
								}
							}
						//}
					}

					//if (Start_Data > Stop_Data)
					//	k--;
					//else
					//	k++;
				}
				
				////Counter end
				//swatch1.Stop();
				//double TotalTime = swatch1.Elapsed.TotalMilliseconds;

				double result_final = 0;
				result_final = result_v_vmr / (result_RO_trip * 16);
	
				if (_util->IsInf(result_final) == false)			
					tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
				else
					tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
			}

			/////////////////////////////////

			if(!USE_SPI) 
			{
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = RunSPI(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);

				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::temp_flt(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			if(!USE_SPI) 
			{
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			} 
			else 
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			}
				
			/////////////////////////////////

			ret = dm[idx]->DPINOff(Test_Pin);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			int Start_Data			= 0;
			int Stop_Data			= 0;
			int Compare_Bit			= 0;
			int Compare_Reg_Addr	= 0;
			int Sweep_Reg_Addr		= 0;

			double atemp_gain		= 184.0;	//2935 - 182.5; //follow catalyst
			double atemp_offset		= 131.7; //follow catalyst
			array<double> ^ result_temp_ref = gcnew array<double>(4);	//ML 2935 double result_temp_ref	= 0;
			double result_Thot_trip = 0;

			int spi_group = 0;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			//sweep_reg
			array<int> ^ sweep_step = gcnew array<int>(256);
			array<int> ^ reverse_bits = gcnew array<int>(256);
			array<int> ^ compare_bits = gcnew array<int>(256);
			array<int> ^ compare_value = gcnew array<int>(256);

			for (int i=0; i<256; i++)	
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			////ML mask
			//ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			//ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); 
			//CheckError(idx, ret, __LINE__);	

			ret = Configure_GNDS_Mux(idx, NPLC);		//
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

					if(!USE_SPI) 
					{
						ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
						CheckError(idx, ret, __LINE__);

						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					} 
					else
					{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}
					
					if (TPName[i]->Contains("V") == true)
					{
						ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_temp_ref[i]);
						CheckError(idx, ret, __LINE__);	

						double volt = 0;
						//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);				
						CheckError(idx, ret, __LINE__);	
						result_temp_ref[i] = result_temp_ref[i] - volt;						
						
					}
					else if (TPName[i]->Contains("S") == true)
					{
						Start_Data			= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
						Stop_Data			= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
						Compare_Bit			= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
						Compare_Reg_Addr	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");
						Sweep_Reg_Addr		= (int)tf_TPCondition_Cast(TPName[i], "Sweep_Reg_Addr");

						////Sweep reg		//ML mask
						//ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
						//CheckError(idx, ret, __LINE__);	

						spi_wr_byte_length = 2;		//1
						int k = Start_Data;

						//for (int k=Start_Data; k<=Stop_Data; k++)
						//{
							int datain = _util->SwapBitSequence(k, 8);

							spi_data_dir[0] = 0x0000000; 
							spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
							delay_s_after_byte[0] = 25e-9;
							if(Start_Data < Stop_Data)
							{
								sweep_step[0] = 1;
							}
							else
							{
								sweep_step[0] = -1;
							}
							reverse_bits[0] = 8;
							compare_bits[0] = 0; 
							compare_value[0] = 0;

							spi_data_dir[1] = 0x00000ff; 
							spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
							int max_sweep_loop = 256;
							sweep_step[1] = 0;
							delay_s_after_byte[1] = 0; //100e-9;
							reverse_bits[1] = 0;
							compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
							compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

							ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
							CheckError(idx, ret, __LINE__);

							spi_status = 0;	
						
							swatch.Reset();
							swatch.Start();
							swatch.Stop();

							while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
							{
								swatch.Start();

								ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
								CheckError(idx, ret, __LINE__);

								if (spi_status == 2) //0=idle, 1=busy, 2=done
									break;

								swatch.Stop();
							}

							int sweep_count = 0;
							ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

							if (spi_status == 2)
							{
								//spi_data_dir[0] = 0x00000ff; 
								//spi_data[0]	= 0x3008000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

								spi_status = 0;
								readback = 0;

								ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
								CheckError(idx, ret, __LINE__);

								for (int m=0; m<spi_rd_byte_length; m++)
								{
									if (spi_rd_biterror[m] == 0)
									{
										data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
										readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
									}
									else
									{
										readback = INVALID_RESULT;
									}
								}
																
								if (readback == ((1 << Compare_Bit) & 0xff))
								{			// sidi add !=
									ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_Thot_trip);
									CheckError(idx, ret, __LINE__);
								
									double volt = 0;
									//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
									ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
									CheckError(idx, ret, __LINE__);
									result_Thot_trip = result_Thot_trip - volt;									

									//break;
								}
							}
						//}
					}
				}
			}

			double result_final_0 = 0;
			double result_final_1 = 0;
			double result_final_2 = 0;

			result_final_0 = (result_temp_ref[0] * atemp_gain) - atemp_offset;
			result_final_1 = (result_temp_ref[1] * atemp_gain) - atemp_offset;
			result_final_2 = (result_Thot_trip * atemp_gain) - atemp_offset;

			tf_SetResult_UUTOffset(TPName[0], result_temp_ref[0] + GetOffset(idx, TPDispName[0]), idx);
			tf_SetResult_UUTOffset(TPName[1], result_temp_ref[1] + GetOffset(idx, TPDispName[1]), idx);
			tf_SetResult_UUTOffset(TPName[2], result_final_0 + GetOffset(idx, TPDispName[2]), idx);
			tf_SetResult_UUTOffset(TPName[3], result_final_1 + GetOffset(idx, TPDispName[3]), idx);
			tf_SetResult_UUTOffset(TPName[4], result_final_2 + GetOffset(idx, TPDispName[4]), idx);			

		/////////////////////////////////

			if(!USE_SPI) 
			{
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			} 
			else 
			{
				ret = RunSPI(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			}

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//void TestProgram::temp_flt(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		
	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));

	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);	

	//		//if(!USE_SPI) 
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else 
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		/////////////////////////////////

	//		ret = dm[idx]->DPINOff(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOn(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////

	//		int Start_Data			= 0;
	//		int Stop_Data			= 0;
	//		int Compare_Bit			= 0;
	//		int Compare_Reg_Addr	= 0;
	//		int Sweep_Reg_Addr		= 0;

	//		double atemp_gain		= 184.0;	//2935 - 182.5; //follow catalyst
	//		double atemp_offset		= 131.7; //follow catalyst
	//		//double result_temp_ref	= 0;		//2935 ori
	//		array<double> ^ result_temp_ref = gcnew array<double>(5);	//ML 2945
	//		double result_Thot_trip = 0;

	//		int spi_group = 0;
	//		//double spi_clk_freq = 2e6;
	//		//int spi_clk_divider = (int)(200e6/spi_clk_freq - 1);
	//		//int cpol = 0;
	//		//int cpha = 0;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);
	//		
	//		for (int i=0; i<256; i++)				//ML change back from 1 to 256		// Will never reach 256. most is 1
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//if (Input_Channel_Delay_s == 0)
	//		//{
	//		//	ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 0);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}
	//		//else if (Input_Channel_Delay_s < 5e-9)
	//		//{
	//		//	ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}
	//		//else
	//		//{
	//		//	ret = dm[idx]->SPI_ConfigureInputDelay("DM_2", spi_group, 2);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		//ret = dm[idx]->SPI_CONFIGURE("DM_2", spi_group, spi_clk_divider, cpol, cpha);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//		//ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); 
	//		//CheckError(idx, ret, __LINE__);	

	//		ret = Configure_GNDS_Mux(idx, NPLC);
	//		CheckError(idx, ret, __LINE__);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

	//				//if(!USE_SPI) 
	//				//{
	//					ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//					CheckError(idx, ret, __LINE__);

	//					ret = RunVectorFile(idx, Vector_File);
	//					CheckError(idx, ret, __LINE__);
	//				//} 
	//				//else
	//				//{
	//				//	ret = RunSPI(idx, Vector_File);
	//				//	CheckError(idx, ret, __LINE__);
	//				//}

	//				if (TPName[i]->Contains("V") == true)
	//				{
	//					ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, result_temp_ref[i]);
	//					CheckError(idx, ret, __LINE__);	

	//					double volt = 0;
	//					//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
	//					ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);				
	//					CheckError(idx, ret, __LINE__);	
	//					result_temp_ref[i] = result_temp_ref[i] - volt;
	//				}
	//				else if (TPName[i]->Contains("S") == true)
	//				{
	//					Start_Data			= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//					Stop_Data			= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//					Compare_Bit			= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//					Compare_Reg_Addr	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");
	//					Sweep_Reg_Addr		= (int)tf_TPCondition_Cast(TPName[i], "Sweep_Reg_Addr");

	//					//Sweep reg
	//					//ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//					//CheckError(ret, __LINE__);	

	//					spi_wr_byte_length = 2;		//orig is 1
	//					int k = Start_Data;

	//					//for (int k=Start_Data; k<=Stop_Data; k++)
	//					//{
	//						int datain = _util->SwapBitSequence(k, 8);

	//						spi_data_dir[0] = 0x0000000; 
	//						spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//						delay_s_after_byte[0] = 25e-9;
	//						if(Start_Data < Stop_Data)
	//						{
	//							sweep_step[0] = 1;
	//						}
	//						else
	//						{
	//							sweep_step[0] = -1;
	//						}
	//						reverse_bits[0] = 8;
	//						compare_bits[0] = 0; 
	//						compare_value[0] = 0;

	//						spi_data_dir[1] = 0x00000ff; 
	//						spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//						int max_sweep_loop = 256;
	//						sweep_step[1] = 0;
	//						delay_s_after_byte[1] = 0; //100e-9;
	//						reverse_bits[1] = 0;
	//						compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//						compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

	//						ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//						CheckError(idx, ret, __LINE__);					
	//						
	//						spi_status = 0;	
	//						//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//						//CheckError(ret, __LINE__);	

	//						swatch.Reset();
	//						swatch.Start();
	//						swatch.Stop();

	//						while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//						{
	//							swatch.Start();

	//							ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//							CheckError(idx, ret, __LINE__);

	//							if (spi_status == 2) //0=idle, 1=busy, 2=done
	//								break;

	//							swatch.Stop();
	//						}

	//						int sweep_count = 0;
	//						ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);
	//						
	//						if (spi_status == 2)
	//						{

	//							//spi_data_dir[0] = 0x00000ff; 
	//							//spi_data[0]	= 0x3008000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//							spi_status = 0;
	//							readback = 0;

	//							//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//							//CheckError(ret, __LINE__);	
	//						
	//							//swatch.Reset();
	//							//swatch.Start();
	//							//swatch.Stop();

	//							//if (spi_status == 2)  { //0=idle, 1=busy, 2=done
	//							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//							CheckError(idx, ret, __LINE__);	

	//							for (int m=0; m<spi_rd_byte_length; m++)
	//							{
	//								if (spi_rd_biterror[m] == 0)
	//								{
	//									data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//								}
	//								else
	//								{
	//									readback = INVALID_RESULT;
	//								}
	//							}
	//							
	//							if (readback == ((1 << Compare_Bit) & 0xff))	//2935 ori (readback == ((1 << Compare_Bit) & 0xff))
	//							{	// sidi add !=
	//								ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_Thot_trip);
	//								CheckError(idx, ret, __LINE__);

	//								double volt = 0;
	//								//ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, volt);
	//								ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//								CheckError(idx, ret, __LINE__);
	//								result_Thot_trip = result_Thot_trip - volt;
	//								
	//								break;
	//							}
	//						}
	//					//}
	//				}
	//			}
	//		}

	//		double result_final_0 = 0;
	//		double result_final_1 = 0;
	//		double result_final_2 = 0;

	//		result_final_0 = (result_temp_ref[0] * atemp_gain) - atemp_offset;
	//		result_final_1 = (result_temp_ref[1] * atemp_gain) - atemp_offset;
	//		result_final_2 = (result_Thot_trip * atemp_gain) - atemp_offset;

	//		tf_SetResult_UUTOffset(TPName[0], result_temp_ref[0] + GetOffset(idx, TPDispName[0]), idx);
	//		tf_SetResult_UUTOffset(TPName[1], result_temp_ref[1] + GetOffset(idx, TPDispName[1]), idx);
	//		tf_SetResult_UUTOffset(TPName[2], result_final_0 + GetOffset(idx, TPDispName[2]), idx);
	//		tf_SetResult_UUTOffset(TPName[3], result_final_1 + GetOffset(idx, TPDispName[3]), idx);
	//		tf_SetResult_UUTOffset(TPName[4], result_final_2 + GetOffset(idx, TPDispName[4]), idx);

	//		/////////////////////////////////

	//		if(!USE_SPI) 
	//		{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else 
	//		{
	//			ret = RunSPI(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//fault 2945
	void TestProgram::dig_faults(Object^ object) //JL: New test
	{
			/*JL: CBit to connect RWN and FLTMux to DM. May need to connect FLTMux to TMU.
				  2 vector files: write_data, write_dig_faults
			
			*/
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;

			String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));// write_dig_faults

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
						
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0; //JL: do we need this?
			Stopwatch swatch; //JL: do we need this?
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			/* 
			ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDX");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDY");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("RWN");
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret = dm[idx]->DPINOn("RWN");

			ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SYNC");
			CheckError(idx, ret, __LINE__);
			 */
			ret = dm[idx]->DPINOff("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			//JL: run Vector file to initialize the test
			/*JL: set default registers for fault tests.
				  enable heat, program rheat/wheat, reset FHS count
			*/
			
			ret = RunVectorFile(idx, Vector_File_Init);
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			int max_faults = 19; //JL: max number of fault types to be tested
			int reg_val = 0;
			array<double> ^  test_result = gcnew array<double>(max_faults);
			int max_flt_masks = 14; //JL: max number of sub-tests for FaultMasks test
			
			//Set fault enable bit, also used for verifying fault status bits.
			int fault_en[] = 
			{
				7, //1. TempFlt
				6, //2. WDataFLoFlt
				5, //3. WShortFlt
				5, //4. WOpenFlt
				3, //5. HOpenFlt
				2, //6. MROpenFlt
				4, //7. OpenFHSFlt, check for SenseFlt
				4, //8. ShortFHSFlt
				4, //9. OpenFHSFlt, check for ShortFHSFlt
				4, //10.SenseFlt, OpenFHSFlt
				4, //11.SenseFlt, OpenFHSFlt
				1, //12.SupplyFlt, VCC
				1, //13.SupplyFlt, VEE
				0  //14.DigSeqFlt
			};
					
			//force_fault: RWTestCtl, RWTestA, RWTestB
			int RWTest[][3] = 
			{
				{0x13, 0x80, 0x80}, //1. Force_TempFlt
				{0x14, 0x00, 0x00}, //2. Force_WriterDataFrqFlt
				{0x14, 0x09, 0x09}, //3. Force_WriterShortGnd1Flt
				{0x14, 0x11, 0x11}, //4. Force_WriterOpenFlt
				{0x02, 0x02, 0x13}, //5. Force_HeaterOpenFlt
				{0x14, 0x41, 0x41}, //6. Force_ReaderOpenFlt
				{0x1e, 0x04, 0x00}, //7. Force_OpenFHSFlt
				{0x1e, 0x08, 0x00}, //8. Force_ShortFHSFlt
				{0x1e, 0x04, 0x00}, //9. Force_OpenFHSFlt
				{0x1e, 0x04, 0x00}, //10.Force_OpenFHSFlt
				{0x1e, 0x08, 0x00}, //11.Force_ShortFHSFlt
				{0x13, 0x40, 0x40}, //12.Force_SupplyVCCFlt
				{0x13, 0x20, 0x20}, //13.Force_SupplyVEEFlt
				{0, 0, 0}//14.Force_DigSeqFlt - causing invalid head select: pg1_reg1=1100_0111
			};
			
			ret = OnOffSPI(idx, 1); 
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(0.5e-3);		//ML
			
			//test param 0 - Fault Masks
			ret = WriteSPI(idx, 1, 7, 0x33); //DFH_En
			ret = WriteSPI(idx, 1, 12, 0x7c);//rheat
			ret = WriteSPI(idx, 1, 13, 0x34);//wheat
			ret = WriteSPI(idx, 2, 4, 0x10); //FHS_En
			ret = WriteSPI(idx, 3, 11, 0xc0); //w_p3_reg11 = d_1100_0000; Always mask MFHS Open, MFHS Short.
			for(int i = 0; i < max_flt_masks; i++)
			{
				//enable specific fault to be tested, mask the rest.			
				ret = WriteSPI(idx, 1, 10, ~(1 << fault_en[i])); 
				
				//force fault event via RWTest
				if( RWTest[i][0] == 0) //handle special case for DigSeqFlt which simply require 1 register write
				{
					WriteSPI(idx, 1, 1, 0xc7); //invalid head select: pg1_reg1=1100_0111
				}
				else
				{
					ret = WriteSPI(idx, 3, 7, RWTest[i][0]);
					ret = WriteSPI(idx, 3, 9, RWTest[i][1]);
					ret = WriteSPI(idx, 3, 10, RWTest[i][2]);
				}
				
				//clear FSR, toggles RWN: 0 > 1 > 0 with 20us wait on each toggle.
				ret = WriteSPI(idx, 1, 8, 0);//w_p1_reg08 = d_0000_0000; write any data to clear FSR

				//check FSR, verify the correct fault status bit is set
				ret = ReadReg(idx, 1, 8, reg_val);//r_p1_reg08; Read fault status register
				
				if(reg_val == (1 << fault_en[i]))
					test_result[i] = 1;
				else
				{
					test_result[i] = -1; 
					break;
				}

				//mask all faults - disable all faults.
				ret = WriteSPI(idx, 1, 10, 0xff);

				//remove fault event via RWTest
				ret = WriteSPI(idx, 3, 7, 0);
				ret = WriteSPI(idx, 3, 9, 0);
				ret = WriteSPI(idx, 3, 10, 0);
				
				//clear FSR.
				ret = WriteSPI(idx, 1, 8, 0);//w_p1_reg08 = d_0000_0000; write any data to clear FSR

				ret = ReadReg(idx, 1, 8, reg_val);//r_p1_reg08; Read fault status register
				//verify FSR = 0.
				if(reg_val == 0)//FSR = 0 after write-to-clear
					test_result[0] = 1;
				else
				{
					test_result[0] = -1;
					break;
				}
				
				CheckError(idx, ret, __LINE__);			
			}
			
			if(test_result[0] == 1) //continue param 0 test if there are no failures from tests above
			{
				//test_result[0] started as 1. If any of the checks below failed, test_result[0] will be cleared to fail this test.
				
				//SupplyVeryLowFlt: RWTestCtl = 0x13, RWTestA=0x10, RWTestB=0x10
				ret = WriteSPI(idx, 3, 7, 0x13);
				ret = WriteSPI(idx, 3, 9, 0x10);
				ret = WriteSPI(idx, 3, 10, 0x10);		
				
				//mask/disable all faults.
				ret = WriteSPI(idx, 1, 10, 0xff);
				
				//clear FSR.
				ret = WriteSPI(idx, 1, 8, 0);//w_p1_reg08 = d_0000_0000; write any data to clear FSR

				ret = ReadReg(idx, 1, 8, reg_val);//r_p1_reg08; Read fault status register
				//verify FSR = 0.
				if(reg_val != 0)//FSR = 0 after write-to-clear
					test_result[0] = 0;
				
				//chk_mode_Rdr_OFF
				ret = WriteSPI(idx, 3, 8, 0x07);
				ret = ReadReg(idx, 3, 5, reg_val);
				reg_val = reg_val & 0x09; //mask all bits except bit 3 and 0.
				if(reg_val != 0x08)
					test_result[0] = 0;
				
				//chk_mode_Wtr_OFF
				ret = WriteSPI(idx, 3, 8, 0x0e);
				ret = ReadReg(idx, 3, 5, reg_val);
				reg_val = reg_val & 0x0c; //mask all bits except bit 3 and 2.
				if(reg_val != 0x00)
					test_result[0] = 0;
				
				//chk_mode_Htr_OFF
				ret = WriteSPI(idx, 3, 8, 0x14);
				ret = ReadReg(idx, 3, 4, reg_val);
				reg_val = reg_val & 0x02; //mask all bits except bit 1.
				if(reg_val != 0x02)
					test_result[0] = 0;
				
				//chk_mode_FHS_OFF
				ret = WriteSPI(idx, 3, 8, 0x05);
				ret = ReadReg(idx, 3, 5, reg_val);
				reg_val = reg_val & 0xef; //mask bit 4 only.
				if(reg_val != 0x01)
					test_result[0] = 0;
				
				//ROTestBus_off
				ret = WriteSPI(idx, 3, 8, 0x00);
				
				/*Added check for unmaskable false supply fault on sleep to active transition fixed in A2*/ 
				ret = WriteSPI(idx, 1, 7, 0x12); //sleep, p1_reg7 = 0x12
				ret = WriteSPI(idx, 1, 7, 0x13); //active, p1_reg7 = 0x13
				
				ret = ReadReg(idx, 1, 8, reg_val);//Read fault status register
				//verify FSR = 0.
				if(reg_val != 0)//FSR = 0 after write-to-clear
					test_result[0] = 0;
			}
			
			//clean up for param 0 test
			//remove fault event via RWTest
			ret = WriteSPI(idx, 3, 7, 0);
			ret = WriteSPI(idx, 3, 9, 0);
			ret = WriteSPI(idx, 3, 10, 0);
			//clear FSR.
			ret = WriteSPI(idx, 1, 8, 0);
			
			CheckError(idx, ret, __LINE__);
			ret=0;
			
			//Return param 0 test result - FaultMasks
			tf_SetResult_UUTOffset(TPName[0], test_result[0] + GetOffset(idx, TPDispName[0]), idx);
			
			
			//Setting up for the rest of the sub-tests
			enum SubTest { 
				TempFlt = 1,        
				SupplyFltVCC,     
				SupplyFltVEE,    
				VeryLowSupplyFlt, 
				WOpenFlt,        
				WShortFlt,       
				WTranFlt,        
				ROpenFlt,        
				HShortFlt,       
				HOpenFlt,        
				DigSeqFlt,       
				FHSOpenFlt,       
				FHSShortFlt,      
				FHSPosFlt,       
				FHSNegFlt,       
				FHSBlankCountPos,
				FHSBlankCountNeg,
				HeaterFalseFlt  		
			};
			
			int fault_en1[] = 
			{
				-1, //for index 0, not used
				7, //1. TempFlt
				1, //2. SupplyFltVCC   
				1, //3. SupplyFltVEE  
				-1,//4. VeryLowSupplyFlt
				5, //5. WOpenFlt       
				5, //6. WShortFlt      
				6, //7. WTranFt       
				2, //8. ROpenFlt       
				3, //9. HShortFlt      
				3, //10.HOpenFlt       
				0, //11.DigSeqFlt      
				4, //12.FHSOpenFlt     
				4, //13.FHSShortFlt    
				4, //14.FHSPosFlt      
				4, //15.FHSNegFlt      
				4, //16.FHSBlankCountPos
				4, //17.FHSBlankCountNeg
				-1 //18.HeaterFalseFlt  
			};
			int RWTest1[][3] = 
			{
				{0x00, 0x00, 0x00}, //for index 0, not used 
				{0x13, 0x80, 0x80}, //1. TempFlt
				{0x13, 0x40, 0x40}, //2. SupplyFltVCC   
				{0x13, 0x20, 0x20}, //3. SupplyFltVEE  
				{0x13, 0x10, 0x10}, //4. VeryLowSupplyFlt
				{0x14, 0x11, 0x11}, //5. WOpenFlt       Force_WriterOpenFlt       
				{0x14, 0x09, 0x09}, //6. WShortFlt      Force_WriterShortGnd1Flt
				{0x00, 0x00, 0x00}, //7. WTranFlt       0
				{0x14, 0x41, 0x41}, //8. ROpenFlt       Force_ReaderOpenFlt  
				{0x13, 0x01, 0x01}, //9. HShortFlt      Force_HeaterShortFlt 
				{0x13, 0x02, 0x02}, //10.HOpenFlt       Force_HeaterOpenFlt
				{0x00, 0x00, 0x00}, //11.DigSeqFlt      0
				{0x1e, 0x04, 0x00}, //12.FHSOpenFlt     Force_OpenFHSFlt 
				{0x1e, 0x08, 0x00}, //13.FHSShortFlt    Force_ShortFHSFlt
				{0x1e, 0x20, 0x00}, //14.FHSPosFlt      Force_PosFHSFlt
				{0x1e, 0x10, 0x00}, //15.FHSNegFlt      Force_NegFHSFlt
				{0x00, 0x00, 0x00}, //16.FHSBlankCountPos 0
				{0x00, 0x00, 0x00}, //17.FHSBlankCountNeg  0
				{0x00, 0x00, 0x00}, //18.HeaterFalseFlt  0
			};
			
			int pin_val = 0;
			
			int FHSBlankCount[] = {0, 1, 2, 4, 8, 16, 32, 64, 128, 255}; 

			for (int i=1; i<total_tp; i++) //JL: loop through each params
			{
				test_result[i] = 1;
				
				ret = RunVectorFile(idx, Vector_File_Init); //load dig_faults default reg settings "pwr_up"
				ret = WriteSPI(idx, 1, 7, 0x33); //DFH_En
				ret = WriteSPI(idx, 1, 12, 0x7c); //rheat
				ret = WriteSPI(idx, 1, 13, 0x34); //wheat
				
				ret = dm[idx]->DrivePin("RWN", 1); //drive RWN=1 start of each test
						
				//TEST SETUP 1: enable FHS? 
				if(    i == SupplyFltVCC
					|| i == VeryLowSupplyFlt
					|| i == FHSOpenFlt
					|| i == FHSShortFlt
				){
					ret = WriteSPI(idx, 2, 4, 0x10); //set FHS_En				
				}
				
				//TEST SETUP 2: additional setup steps for specific tests
				switch(i)
				{
					case SupplyFltVCC:
						ret = WriteSPI(idx, 2, 4, 0x70); //set FHSImode and FHSRdAndWrt	//wrong value 0x50
						ret = WriteSPI(idx, 2, 11, 0x04); //set disfhshold
					case SupplyFltVEE:
					case VeryLowSupplyFlt:
						ret = WriteSPI(idx, 2, 10, 0x39);//enable_rwh_on_supply_flt: set bit 0, 3, 4, 5
						break;
					case FHSOpenFlt:
					case FHSShortFlt:
					case FHSPosFlt:
					case FHSNegFlt:
						//fhs_setup or fhs_setup_w_FHSRdAndWrt. 
						ret = WriteSPI(idx, 2, 2, 0xf4); //FHSFltEn=1, FHSCountEn=1, FHSBias[5:0]=11_0100=52
						ret = WriteSPI(idx, 2, 4, 0x3f); //FHSRdAndWrt=1, FHS_En=1, FHSVth<3:0>=15
						ret = WriteSPI(idx, 2, 11, 0x0c);//FHSDC Disable=1, DisFHSHold=1
						if(i == FHSOpenFlt || i == FHSShortFlt)
						{
							//chk_mode_FHS_ACT
							ret = WriteSPI(idx, 3, 8, 0x05); //ROTestCtl
							ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
							reg_val &= 0xe1;//check bit0(FHS OFF), 5(FHS SBY), 6(FHS ACT), 7(FHS FST)
							if(reg_val != 0x40) //bit0=0, bit5=0, bit6=1, bit7=0
								test_result[i]=-1;
						}
						
						if(i == FHSPosFlt)
						{
							ret = WriteSPI(idx, 2, 12, 0x10); //mask_NegTAFlt: bits[5:4] (FHSDetectPol<1:0>) = 01 (Positive events only detected)
						}
						break;			
					case FHSBlankCountPos:
					case FHSBlankCountNeg:
						//fhs_minBW
						ret = WriteSPI(idx, 2, 3, 0x38); //bits5:3 (FHSLFP<2:0> FHS Low Freq Pole) = 111
						
						//fhs_setup_w_FHSRd
						ret = WriteSPI(idx, 2, 2, 0xf4); //FHSFltEn=1, FHSCountEn=1, FHSBias[5:0]=11_0100=52						
						ret = WriteSPI(idx, 2, 4, 0x9f); //bit7 FHSCountClear=1, bit6 FHSImode=0, bit5 FHSRdAndWrt=0, bit4 FHS_En=1, FHSVth<3:0>=15
						ret = WriteSPI(idx, 2, 15, 0x00);//FHSWrtRdN = 1 to select Write mode when FHSRdAndWrt=0 
						ret = WriteSPI(idx, 2, 11, 0x0c);//FHSDC Disable=1, DisFHSHold=1
						break;
				}
				
				//TEST SETUP 3: enable fault
				if(fault_en1[i] != -1)
					ret = WriteSPI(idx, 1, 10, ~(1 << fault_en1[i])); 
				
				//TEST SETUP 4: force fault event
				if(RWTest1[i][0] > 0)
				{
					ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
					ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
					ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
				}
				
				
				//TEST STEP 1: 
				switch(i)
				{
					case TempFlt: 
						ret = dm[idx]->DrivePin("RWN", 0);
						//check FLTMUX = 1					
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=1)
							test_result[i]=-1*1;//***verify failue 1
						
						//check FSR bit set
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1*2;//***verify failue 2
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						
						//check FLTMUX = 0
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=0)
							test_result[i]=-1*3;//***verify failue 3
						
						//check FSR bit still set after removal of fault event
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1*4;//***verify failue 4
						
						//verify FLTMUX follows RWN in active state, no fault; and clearing FSR does not affect FLTMUX
						//RWN=1
						ret = dm[idx]->DrivePin("RWN", 1);
						//Verify FLTMUX=1					
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=1)
							test_result[i]=-1*5;//***verify failue 5
						
						//check FSR bit still set
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1*6;//***verify failue 6
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//with RWN=1, after clearing FSR, verify FLTMUX=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=1)
							test_result[i]=-1*7;//***verify failue 7
						
						//check FSR all cleared
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1*8;//***verify failue 8
						//mask all faults
						ret = WriteSPI(idx, 1, 10, 0xff);
						
						//verify FLTMUX follows RWN in active state, no fault
						//RWN=1
						ret = dm[idx]->DrivePin("RWN", 1);
						//Verify FLTMUX=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=1)
							test_result[i]=-1*9;//***verify failue 9
						//check FSR all cleared
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1*10;//***verify failue 10
						//RWN=0
						ret = dm[idx]->DrivePin("RWN", 0);
						//Verify FLTMUX=0
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=0)
							test_result[i]=-1*11;//***verify failue 11
						//check FSR all cleared
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1*12;//***verify failue 12
						//RWN=1
						ret = dm[idx]->DrivePin("RWN", 1);
						//Verify FLTMUX=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val!=1)
							test_result[i]=-1*13;//***verify failue 13
						//check FSR all cleared
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1*14;//***verify failue 14
												
						/*Note: for TempFlt, MTempFltPin no longer exist according to 2945 Ref Manually*/				
						break;
					case SupplyFltVCC:					
					case SupplyFltVEE:
					case VeryLowSupplyFlt: //These 3 tests shares common flows
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//verify FLTMUX, FSR & Reader/Writer/Heater/Sensor modes
						//Repeat for RWN=1 (Read mode) and RWN=0 (Write mode)
						for(int rwn=1; rwn>=0; rwn--)
						{
							//Note: from TempFlt test RWN=1. Only need to drive RWN to 0.
							if(rwn == 0)
								ret = dm[idx]->DrivePin("RWN", 0);
							//Check that FLTMUX != RWN.
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val == rwn)
								test_result[i]=-1;

							//check FSR
							ret = ReadReg(idx, 1, 8, reg_val);
							if(i != VeryLowSupplyFlt)
							{//for SupplyFlt for SupplyFltVCC & SupplyFltVEE						
								if(reg_val != (1 << fault_en1[i]))
									test_result[i]=-1;
							}
							else
							{//for VeryLowSupplyFlt, check no bits in FSR are set
								if(reg_val != 0)
									test_result[i]=-1;						
							}
							
							//for all 3 tests:
							//chk_mode_Htr_OFF
							ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
							ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
							reg_val &= 0x02;
							if(reg_val != 0x02) //check bit 1=1, Htr_Disable
								test_result[i]=-1;
							//chk_rdht_wtht_programmed
							ret = ReadReg(idx, 1, 12, reg_val); //rheat
							if(reg_val != 0x7c) //0111_1100b
								test_result[i]=-1;
							ret = ReadReg(idx, 1, 13, reg_val); //wheat
							if(reg_val != 0x34) //0011_0100b
								test_result[i]=-1;
								
							//for SupplyFltVCC
							if(i == SupplyFltVCC)
							{
								//Check Reader mode 
								ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. JL: should this be ROTestA? Bit0=1 (Rdr_ACT), bit3=0(Rdr_OFF)
								reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
								if(rwn == 1 && reg_val != 0x01) //for RWN=1 chk_mode_Rdr_ACT, bit0=1, bit3=0
									test_result[i]=-1;
								if(rwn == 0 && reg_val != 0x08) //for RWN=0. chk_mode_Rdr_SBY, bit0=0, bit3=1	
									test_result[i]=-1;
								//Check Writer mode
								ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl
								if(rwn == 1)	
								{								
									ret = ReadReg(idx, 3, 4, reg_val); //ROTestA. 
									reg_val &= 0x0c;
									if(reg_val != 0x00) //chk_mode_Wtr_SBY. check bit2=0(Wtr_PSV), bit3=0 (Wtr_OFF). JL: why not check bit1=1(Wtr_SBY)?
										test_result[i]=-1;	
								}
								else
								{
									ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
									reg_val &= 0x0c;
									if(reg_val != 0x0c)//for RWN=0. chk_mode_Wtr_ACT, bit2=1(Wtr_WriterOn), bit3=1(Wtr_EnWriteData)
										test_result[i]=-1;
								}							
								//chk_mode_FHS_ACT							
								ret = WriteSPI(idx, 3, 8, 0x05); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
								reg_val &= 0xe1;//check bit0=0, bit5=0, bit6=1, bit7=0
								if(reg_val != 0x40) 
									test_result[i]=-1*99;						
							}				

							//for VeryLowSupplyFlt
							if(i == VeryLowSupplyFlt)
							{
								//chk_mode_Rdr_OFF
								ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
								reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
								if(rwn == 0 && reg_val != 0x08) //verify bit0=0, bit3=1
									test_result[i]=-1;
								//chk_mode_Wtr_OFF
								ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
								reg_val &= 0x0c;//check bit2(Wtr_PSV), bit3(Wtr_OFF). 
								if(reg_val != 0x00) //verify bit2=0, bit3=0
									test_result[i]=-1;
								//chk_mode_FHS_OFF
								ret = WriteSPI(idx, 3, 8, 0x05); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
								reg_val &= 0xef; //mask bit 4.
								if(reg_val != 0x01) //verify bit0=1, bit[3:1]=0, bit[7:5]=0
									test_result[i]=-1;
							}
						}
						
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//Check FLTMUX for both RWN=0 and 1. Currently RWN=0
						for(int rwn=0; rwn<=1; rwn++)
						{
							if(rwn == 1)
								ret = dm[idx]->DrivePin("RWN", 1);
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val == rwn) //fault is active, expect FLTMUX to be opposite of RWN
								test_result[i]=-1;
							
							//check FSR
							ret = ReadReg(idx, 1, 8, reg_val);
							if(i != VeryLowSupplyFlt)
							{//check for SupplyFlt for SupplyFltVCC & SupplyFltVEE
								if(reg_val != (1 << fault_en1[i]))
										test_result[i]=-1;
							}
							else
							{//for VeryLowSupplyFlt, 
								//check no bits in FSR are set
								if(reg_val != 0)
										test_result[i]=-1;	
								//chk_mode_Rdr_OFF
								ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
								reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
								if(rwn == 0 && reg_val != 0x08) //verify bit0=0, bit3=1
									test_result[i]=-1;
								//chk_mode_Wtr_OFF
								ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
								reg_val &= 0x0c;//check bit2(Wtr_PSV), bit3(Wtr_OFF). 
								if(reg_val != 0x00) //verify bit2=0, bit3=0
									test_result[i]=-1;
								//chk_mode_FHS_OFF
								ret = WriteSPI(idx, 3, 8, 0x05); //ROTestCtl
								ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
								reg_val &= 0xef; //mask bit 4.
								if(reg_val != 0x01) //verify bit0=1, bit[3:1]=0, bit[7:5]=0
									test_result[i]=-1;
								//chk_mode_Htr_OFF
								ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
								ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
								reg_val &= 0x02;
								if(reg_val != 0x02) //check bit 1=1, Htr_Disable
									test_result[i]=-1;
								//chk_rdht_wtht_programmed
								ret = ReadReg(idx, 1, 12, reg_val); //rheat
								if(reg_val != 0x7c) //0111_1100b
									test_result[i]=-1;
								ret = ReadReg(idx, 1, 13, reg_val); //wheat
								if(reg_val != 0x34) //0011_0100b
									test_result[i]=-1;
							}
						}	
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						if(i == VeryLowSupplyFlt)
						{//final steps for VeryLowSupplyFlt test
							ret = dm[idx]->DrivePin("RWN", 0);
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != 0)//verify FLTMUX=RWN when fautl event is removed
								test_result[i]=-1;
							
							//check FSR = 0
							ret = ReadReg(idx, 1, 8, reg_val);
							if(reg_val != 0)
								test_result[i]=-1;
							//chk_mode_Rdr_OFF
							ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
							ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
							reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
							if(reg_val != 0x08) //verify bit0=0, bit3=1
								test_result[i]=-1;
							//chk_mode_Wtr_ACT
							ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl
							ret = ReadReg(idx, 3, 5, reg_val); //ROTestA. 
							reg_val &= 0x0c;//check bit2(Wtr_WriterOn), bit3(Wtr_EnWriteData).								
							if(reg_val != 0x0c)//verify bit2=1, bit3=1
								test_result[i]=-1;
							//chk_mode_Htr_OFF
							ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
							ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
							reg_val &= 0x02;
							if(reg_val != 0x02) //check bit 1=1, Htr_Disable
								test_result[i]=-1;
							//chk_rdht_wtht_programmed
							ret = ReadReg(idx, 1, 12, reg_val); //rheat
							if(reg_val != 0x7c) //0111_1100b
								test_result[i]=-1;
							ret = ReadReg(idx, 1, 13, reg_val); //wheat
							if(reg_val != 0x34) //0011_0100b
								test_result[i]=-1;
							//chk_mode_FHS_OFF
							ret = WriteSPI(idx, 3, 8, 0x05); //ROTestCtl
							ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
							reg_val &= 0xef; //mask bit 4.
							if(reg_val != 0x01) //verify bit0=1, bit[3:1]=0, bit[7:5]=0
								test_result[i]=-1;
									
							//clear FSR
							ret = WriteSPI(idx, 1, 8, 0);
							//chk_rdht_wtht_programmed
							ret = ReadReg(idx, 1, 12, reg_val); //rheat
							if(reg_val != 0x7c) //0111_1100b
								test_result[i]=-1;
							ret = ReadReg(idx, 1, 13, reg_val); //wheat
							if(reg_val != 0x34) //0011_0100b
								test_result[i]=-1;
							//enable_heater
							ret = WriteSPI(idx, 1, 7, 0x33);
							//chk_mode_Htr_ON
							ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
							ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
							reg_val &= 0x02;
							if(reg_val != 0x00) //check bit 1=0, Htr_Disable
								test_result[i]=-1;
							//chk_rdht_wtht_programmed
							ret = ReadReg(idx, 1, 12, reg_val); //rheat
							if(reg_val != 0x7c) //0111_1100b
								test_result[i]=-1;
							ret = ReadReg(idx, 1, 13, reg_val); //wheat
							if(reg_val != 0x34) //0011_0100b
								test_result[i]=-1;
						
							tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
							break;
						}
						
						//remaining test steps for SupplyFltVCC & SupplyFltVEE
						ret = RunVectorFile(idx, Vector_File_Init); 
						
						//disable_rwh_on_supply_flt
						ret = WriteSPI(idx, 2, 10, 0);
						//mask_all_ex_SupplyFlt
						ret = WriteSPI(idx, 1, 10, ~(1 << fault_en1[i]));
						//force fault event
						ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
						ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
						ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//RWN=1 from above, expect FLTMUX=0
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//chk_fsr_SupplyFlt
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;						
						//chk_mode_Htr_OFF
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x02) //check bit 1=1, Htr_Disable
							test_result[i]=-1;
						//chk_rdht_wtht_programmed
						ret = ReadReg(idx, 1, 12, reg_val); //rheat
						if(reg_val != 0x7c) //0111_1100b
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 13, reg_val); //wheat
						if(reg_val != 0x34) //0011_0100b
							test_result[i]=-1;
							
						//for SupplyFltVCC Only
						if(i == SupplyFltVCC)
						{
							//chk_mode_Rdr_SBY
							ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
							ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. JL: should this be ROTestA? Bit0=1 (Rdr_ACT), bit3=0(Rdr_OFF)
							reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
							if(reg_val != 0x08) //bit0=0, bit3=1	
								test_result[i]=-1;							
							//chk_mode_Wtr_SBY
							ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl															
							ret = ReadReg(idx, 3, 4, reg_val); //ROTestA. 
							reg_val &= 0x0c;
							if(reg_val != 0x00) //check bit2=0(Wtr_PSV), bit3=0 (Wtr_OFF). 
								test_result[i]=-1;
							//chk_DFH_En_0
							ret = ReadReg(idx, 1, 7, reg_val);
							if(reg_val != 0x13)//verify 0001_0011; JL: check bit5=0
								test_result[i]=-1;
							//chk_mode_FHS_OFF
							ret = WriteSPI(idx, 3, 8, 0x05); //ROTestCtl
							ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
							reg_val &= 0xef; //mask bit 4.
							if(reg_val != 0x01) //verify bit0=1, bit[3:1]=0, bit[7:5]=0
								test_result[i]=-1;
						}
						
						//set RWN=0, check FLTMUX=1
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						//check FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;	
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//check FLTMUX=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)//verify FLTMUX=RWN when fautl event is removed
							test_result[i]=-1;
						//check FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;	
						//set RWN=1, check FLTMUX=0
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						//check FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;	
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
											
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case WOpenFlt:        					
					case WShortFlt:       
						//WOpenShortTimeCntrl - JL: removed from catalyst, simply a return.
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//NoFaultsInRead
						//verify FLTMUX=1 > no fault, as RWN=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 8, reg_val); //verify no fault in FSR
						if(reg_val != 0)
							test_result[i]=-1;
						//RWN=0 > Write mode, WDx/y=11, check FLTMUX=1
						ret = dm[idx]->DrivePin("RWN", 0);
						//JL: not sure if need to toggle WDx/y here, if yes, need to run vector file
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//NoFaultsInWrite
						//verify FLTMUX=0 > no fault in Write mode
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						//NoFaultsInRead, RWN=1, WDx/y=00
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = ReadReg(idx, 1, 8, reg_val); //verify no fault in FSR
						if(reg_val != 0)
							test_result[i]=-1;
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case WTranFlt:       
						//Vector File to drive RWN pin
						ret = dm[idx]->DPINOff("RWN");
						ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
						ret = dm[idx]->DPINOn("RWN");
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//NoFaultsInRead
						//default RWN=1 > read mode. Verify no fault, FLTMUX=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 8, reg_val); //verify no fault in FSR
						if(reg_val != 0)
							test_result[i]=-1;
						
						//NoFaultsInWrite
						//switch to write mode, and toggle WDx/y, then back to read mode.					
						ret = RunVectorFile(idx, "write_data");					
						
						//verify FLTMUX=1 > no fault as RWN=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val); 
						if(pin_val != 1)
							test_result[i]=-1;
						//verify no fault in FSR					
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						/*JL: Note - to investigate further
						  WDataFLoFlt will trigger if RWN0 & WDx/y toggles for >220ns
						  Tried different timingset, same behavior so its not a matter of pulse width.
						  As long as WDx/y toggles for >220ns, WDataFLoFlt will set in FSR.
						*/
						//Restore RWN pin settings
						ret = dm[idx]->DPINOff("RWN");
						ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
						ret = dm[idx]->DPINOn("RWN");
						ret = dm[idx]->DrivePin("RWN", 0);

						//RWN=0 while WDx/y not toggling would cause Write Data Freq Lo Fault
						//check FLTMUX=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						
						

						break;
					case ROpenFlt:   
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//check FLTMUX=0 > fault occured
						ret = dm[idx]->ReadPin("FLTMUX", pin_val); 
						if(pin_val != 0)
							test_result[i]=-1;				
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//switch to write mode, and toggle WDx/y
						ret = dm[idx]->DrivePin("RWN", 0);					
						//check FLTMUX=0 > no fault as RWN=0
						ret = dm[idx]->ReadPin("FLTMUX", pin_val); 
						if(pin_val != 0)
							test_result[i]=-1;	
						
						//Verify FSR bit still set after switch to write mode
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//NoFaultsInWrite					
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 8, reg_val); //verify no fault in FSR
						if(reg_val != 0)
							test_result[i]=-1;
						
						//switch to read mode > RWN=1, fault occured > FLTMUX=0
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case HShortFlt:     					
					case HOpenFlt: 
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//check FLTMUX=0 > fault occured
						ret = dm[idx]->ReadPin("FLTMUX", pin_val); 
						if(pin_val != 0)
							test_result[i]=-1;		
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//chk_mode_Htr_ON
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x00) //check bit 1=0, Htr_Disable
							test_result[i]=-1;
							
						//chk_rdht_wtht_programmed
						ret = ReadReg(idx, 1, 12, reg_val); //rheat
						if(reg_val != 0x7c) //0111_1100b
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 13, reg_val); //wheat
						if(reg_val != 0x34) //0011_0100b
							test_result[i]=-1;
							
						//switch to write mode > RWN=0, verify FLTMUX=1
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//Verify FLTMUX still 1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//chk_mode_Htr_ON
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x00) //check bit 1=0, Htr_Disable
							test_result[i]=-1;
							
						//chk_rdht_wtht_programmed
						ret = ReadReg(idx, 1, 12, reg_val); //rheat
						if(reg_val != 0x7c) //0111_1100b
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 13, reg_val); //wheat
						if(reg_val != 0x34) //0011_0100b
							test_result[i]=-1;
							
						//RWN=1, verify FLTMUX=0
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//chk_mode_Htr_ON
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x00) //check bit 1=0, Htr_Disable
							test_result[i]=-1;
							
						//chk_rdht_wtht_programmed
						ret = ReadReg(idx, 1, 12, reg_val); //rheat
						if(reg_val != 0x7c) //0111_1100b
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 13, reg_val); //wheat
						if(reg_val != 0x34) //0011_0100b
							test_result[i]=-1;
							
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//chk_mode_Htr_ON
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x00) //check bit 1=0, Htr_Disable
							test_result[i]=-1;
							
						//chk_rdht_wtht_programmed
						ret = ReadReg(idx, 1, 12, reg_val); //rheat
						if(reg_val != 0x7c) //0111_1100b
							test_result[i]=-1;
						ret = ReadReg(idx, 1, 13, reg_val); //wheat
						if(reg_val != 0x34) //0011_0100b
							test_result[i]=-1;
							
						//RWN=1, verify FLTMUX=1 > no fault
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						
						if (i == HOpenFlt) //additional test steps for HOpenFlt
						{
							ret = WriteSPI(idx, 2, 9, 0x21); //default bit0=1. set bit5=1 (Power_Rng) > Dynamic fly-height range = high power, 2mW step size 
							ret = WriteSPI(idx, 1, 12, 0x0c); //rheat = 12 (0xc)
							ret = ReadReg(idx, 1, 12, reg_val);
							if(reg_val != 0x0c)
								test_result[i]=-1;
							ret = WriteSPI(idx, 1, 13, 0x0c); //wheat = 12 (0xc)
							ret = ReadReg(idx, 1, 13, reg_val);
							if(reg_val != 0x0c)
								test_result[i]=-1;
							
							//RWN=1, verify FLTMUX=1 > no fault
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != 1)
								test_result[i]=-1;
						
							//Verify FSR = 0
							ret = ReadReg(idx, 1, 8, reg_val);
							if(reg_val != 0)
								test_result[i]=-1;
							
							//Force_HeaterOpenFlt
							ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
							ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
							ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
							
							//RWN=1, verify FLTMUX=1 > no fault
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != 1)
								test_result[i]=-1;
							
							//Verify FSR = 0
							ret = ReadReg(idx, 1, 8, reg_val);
							if(reg_val != 0)
								test_result[i]=-1;
							
							ret = WriteSPI(idx, 1, 12, 0x0d); //rheat = 13 (0xd)
							ret = ReadReg(idx, 1, 12, reg_val);
							if(reg_val != 0x0d)
								test_result[i]=-1;
							ret = WriteSPI(idx, 1, 13, 0x0d); //wheat = 13 (0xd)
							ret = ReadReg(idx, 1, 13, reg_val);
							if(reg_val != 0x0d)
								test_result[i]=-1;
							
							//RWN=1, verify FLTMUX=0 > fault occured
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != 0)
								test_result[i]=-1;
						
							//Verify FSR
							_util->Wait_Sec(0.1e-3);		//ML
							ret = ReadReg(idx, 1, 8, reg_val);
							if(reg_val != (1 << fault_en1[i]))
								test_result[i]=-1;
							
							//remove fault event
							ret = WriteSPI(idx, 3, 7, 0);
							ret = WriteSPI(idx, 3, 9, 0);
							ret = WriteSPI(idx, 3, 10, 0);
							//Clear FSR
							ret = WriteSPI(idx, 1, 8, 0);
						}
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case DigSeqFlt:      
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);

						//RWN=1, verify FLTMUX=1 > No fault 
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
							
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						
						
						/* Test DigSeqFlt due to invalid head select */
						ret = WriteSPI(idx, 1, 1, 0xc7); //set hsel[2:0]=7 invalid value for 2 channel 2945.					
						ret = WriteSPI(idx, 1, 8, 0); //Clear FSR
						ret = dm[idx]->ReadPin("FLTMUX", pin_val); //RWN=1, verify FLTMUX=0 > fault occured
						if(pin_val != 0)
							test_result[i]=-1;					
						ret = ReadReg(idx, 1, 8, reg_val); //Verify FSR
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						//chk_mode_Rdr_OFF
						ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
						ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
						reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
						if(reg_val != 0x08) //verify bit0=0, bit3=1
							test_result[i]=-1;
						//chk_mode_Wtr_OFF
						ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl
						ret = ReadReg(idx, 3, 5, reg_val); //ROTestB.
						reg_val &= 0x0c;//check bit2(Wtr_PSV), bit3(Wtr_OFF). 
						if(reg_val != 0x00) //verify bit2=0, bit3=0
							test_result[i]=-1;
						//chk_mode_Htr_ON
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x00) //check bit 1=0, Htr_Disable
							test_result[i]=-1;
							
						//hd_0
						ret = WriteSPI(idx, 1, 1, 0xc0); //set hsel[2:0]=0
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//RWN=1, verify FLTMUX=1 > No fault 
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
							
						//chk_mode_Rdr_ACT
						ret = WriteSPI(idx, 3, 8, 0x07); //ROTestCtl
						ret = ReadReg(idx, 3, 5, reg_val); //ROTestB. 
						reg_val &= 0x09;//check bit0(Rdr_Read), bit3(Rdr_Squelch)
						if(reg_val != 0x01) //for RWN=1 chk_mode_Rdr_ACT, bit0=1, bit3=0
							test_result[i]=-1;
						//chk_mode_Wtr_SBY
						ret = WriteSPI(idx, 3, 8, 0x0e); //ROTestCtl															
							ret = ReadReg(idx, 3, 4, reg_val); //ROTestA. 
							reg_val &= 0x0c;
							if(reg_val != 0x00) //check bit2=0(Wtr_PSV), bit3=0 (Wtr_OFF). 
								test_result[i]=-1;
						//chk_mode_Htr_ON
						ret = WriteSPI(idx, 3, 8, 0x14); //ROTestCtl
						ret = ReadReg(idx, 3, 4, reg_val); //ROTestA
						reg_val &= 0x02;
						if(reg_val != 0x00) //check bit 1=0, Htr_Disable
							test_result[i]=-1;
							
						/* Test DigSeqFlt due to ServoW0 != ServoW1 */
						//serveWx_notequal
						ret = WriteSPI(idx, 1, 14, 0x80); //set ServoW1=1
						ret = WriteSPI(idx, 2, 0, 0); //ServoW0=0
						
						//RWN=1, verify FLTMUX=0 > fault occured
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//serveWx_equal
						ret = WriteSPI(idx, 1, 14, 0); //set ServoW1=0
						//ServoW0 already 0.
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//RWN=1, verify FLTMUX=1 > No fault 
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						
						/* Test DigSeqFlt due to writing with DFH_En=0 while rheat > 0 */
						//RdHeat_128
						ret = WriteSPI(idx, 1, 12, 0x80);					
						//wait 40us
						_util->Wait_Sec(40e-6);
						
						//disable_heater
						ret = WriteSPI(idx, 1, 7, 0x13); //bit5 (DFH_En)=0	
						
						//set RWN=0, verify FLTMUX=1 > fault occured
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//enable_heater
						ret = WriteSPI(idx, 1, 7, 0x33); //bit5 (DFH_En)=1	
						//wait 40us
						_util->Wait_Sec(40e-6);
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						/* Test DigSeqFlt due to RWN=0 when writer not active (ModeConfig1=1) */
						//mode_cnfg_1
						ret = WriteSPI(idx, 1, 7, 0xb3); //set bit[7:6](ConfigMode)=10, ModeConfig1=1 writer off. JL: see 2945 Ref Manual Table 11 Operating Modes
						
						//set RWN=0, verify FLTMUX=1 > fault occured
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
												
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case FHSOpenFlt: 					
					case FHSShortFlt: 
						if (i == FHSOpenFlt)
							ret = WriteSPI(idx, 3, 11, 0x40); //bit7 - Mask FHS Open fault, bit6 - Mask FHS short fault,
						else //FHSShortFlt
							ret = WriteSPI(idx, 3, 11, 0x80);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//RWN=1, FLTMUX=0 > fault occured
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//set RWN=0, togglet WDx/y, FLTMUX = 1 > fault occured
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						_util->Wait_Sec(0.1e-3);		//ML
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//verify FLTMUX = 1 > fault occured
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//set RWN=1, check FLTMUX=0
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//Verify FSR
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != (1 << fault_en1[i]))
							test_result[i]=-1;
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//Verify FLTMUX=1, no fault with RWN=1
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR = 0
						_util->Wait_Sec(0.1e-3);		//ML
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);

						ret = WriteSPI(idx, 3, 11, 0xc0);//mask FHS Open/short fault

						break;
					case FHSPosFlt: 
					case FHSNegFlt:  
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//with RWN=1, check FLTMUX=0 > Fault occured
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//Set RWN=0, check FLTMUX=1
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						
						//RWN=0, check FLTMUX=0 > no fault
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//set RWN=1, check FLTMUX=1 > no fault
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						if(i == FHSPosFlt)
						{
							ret = WriteSPI(idx, 2, 12, 0x20); //mask_PosTAFlt: bits[5:4] (FHSDetectPol<1:0>) = 10 (Negative events only detected)
						}
						else //FHSNegFlt
						{
							ret = WriteSPI(idx, 2, 12, 0x10); //mask_NegTAFlt: bits[5:4] (FHSDetectPol<1:0>) = 01 (Possitive events only detected)
						}
						
						//force fault event
						ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
						ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
						ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
						
						//check FLTMUX=1 > no fault, as either positive or negetive events are masked 
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						
						//Set RWN=0, check FLTMUX=0
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1;
						
						//mask_NoTAFlt, enable both Posotive and Negative event detection
						ret = WriteSPI(idx, 2, 12, 0x30); //mask_NegTAFlt: bits[5:4] (FHSDetectPol<1:0>) = 11 (Both polarities detected)
						
						//force fault event
						ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
						ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
						ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
							
						//set RWN=1, check FLTMUX=0
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//set RWN=0, check FLTMUX=1
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//MTAFltPin_1, FHS fault will not be reported on FLTMUX pin
						ret = WriteSPI(idx, 2, 2, 0x74); //bit[5:0] (FHSBias) = 11_0100; bit[6]  (FHSCountEn)=1; bit7(FHSFltEn)=0
						
						//force fault event
						ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
						ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
						ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
							
						//set RWN=1, check FLTMUX=1 > no fault
						ret = dm[idx]->DrivePin("RWN", 1);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1;
						
						//set RWN=0, check FLTMUX=0 > no fault
						ret = dm[idx]->DrivePin("RWN", 0);
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
						
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//Clear FSR
						ret = WriteSPI(idx, 1, 8, 0);
						
						//MTAFltPin_0, FHS fault is reported on FLTMUX pin
						ret = WriteSPI(idx, 2, 2, 0xf4); //bit[5:0] (FHSBias) = 11_0100; bit[6]  (FHSCountEn)=1; bit7(FHSFltEn)=1
						
						for(int j=0; i<=1; j++)
						{
							//fhs_setup_w_FHSRd
							ret = WriteSPI(idx, 2, 2, 0xf4); //FHSFltEn=1, FHSCountEn=1, FHSBias[5:0]=11_0100=52
							if(j == 0)
								ret = WriteSPI(idx, 2, 4, 0x9f); //bit7 FHSCountClear=1, bit6 FHSImode=0, bit5 FHSRdAndWrt=0, bit4 FHS_En=1, FHSVth<3:0>=15
							else
							{
								ret = WriteSPI(idx, 2, 4, 0x1f); //bit7 FHSCountClear=0, bit6 FHSImode=0, bit5 FHSRdAndWrt=0, bit4 FHS_En=1, FHSVth<3:0>=15
								ret = WriteSPI(idx, 2, 15, 0x80);//FHSWrtRdN = 1 to select Write mode when FHSRdAndWrt=0 
							}
							ret = WriteSPI(idx, 2, 11, 0x0c);//FHSDC Disable=1, DisFHSHold=1
							
							//enable fault
							if(fault_en1[i] != -1)
								ret = WriteSPI(idx, 1, 10, ~(1 << fault_en1[i])); 
							
							//force fault event					
							ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
							ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
							ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
											
							//Clear FSR
							ret = WriteSPI(idx, 1, 8, 0);
							
							if(j == 0)
							{
								//as RWN=1, check FLTMUX=0 > fault occured
								ret = dm[idx]->ReadPin("FLTMUX", pin_val);
								if(pin_val != 0)
									test_result[i]=-1;
							}
							else
							{
								//as RWN=0, check FLTMUX=1 > fault occured
								ret = dm[idx]->ReadPin("FLTMUX", pin_val);
								if(pin_val != 1)
									test_result[i]=-1;
							}
							
							//remove fault event
							ret = WriteSPI(idx, 3, 7, 0);
							ret = WriteSPI(idx, 3, 9, 0);
							ret = WriteSPI(idx, 3, 10, 0);
							
							//set RWN=j. 
							ret = dm[idx]->DrivePin("RWN", j);
							
							//force fault event					
							ret = WriteSPI(idx, 3, 7, RWTest1[i][0]);
							ret = WriteSPI(idx, 3, 9, RWTest1[i][1]);
							ret = WriteSPI(idx, 3, 10, RWTest1[i][2]);
							
							//Clear FSR
							ret = WriteSPI(idx, 1, 8, 0);
							
							//check FLTMUX=j 
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != j)
								test_result[i]=-1;
						
							//remove fault event
							ret = WriteSPI(idx, 3, 7, 0);
							ret = WriteSPI(idx, 3, 9, 0);
							ret = WriteSPI(idx, 3, 10, 0);
						}
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case FHSBlankCountPos:					
					case FHSBlankCountNeg:	
						//---for FHS Blank count = 0
						
						//read_counter - read to clear FHS Count. 
						ret = ReadReg(idx, 1, 9, reg_val); //FHSCount, read to clear
						ret = ReadReg(idx, 1, 9, reg_val); //read again to verify cleared.
						if(reg_val != 0) //verify FHSCount = 0
							test_result[i]=-1;
							
						//fhs_blank0	
						ret = WriteSPI(idx, 2, 6, 0);
						
						//fault event
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						
						//wait 10us
						_util->Wait_Sec(10e-6);
						
						//force 1 FHS Pos/Neg event
						ret = WriteSPI(idx, 3, 7, 0x1e);
						if(i == FHSBlankCountPos) //fault_event_pos
							ret = WriteSPI(idx, 3, 9, 0x20); //Event_Detect_FHSPositive
						else //Force_NegFHSFlt
							ret = WriteSPI(idx, 3, 9, 0x10); //Event_Detect_FHSNegative			
						
						//check FLTMUX=0, as RWN=1.
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 0)
							test_result[i]=-1;
							
						//remove fault event
						ret = WriteSPI(idx, 3, 7, 0);
						ret = WriteSPI(idx, 3, 9, 0);
						ret = WriteSPI(idx, 3, 10, 0);
						//---end FHS Blank count = 0
						
						for(int fb=1; fb < sizeof(FHSBlankCount)/ sizeof(int); fb++) //fb = fhs_blank
						{
							//fhs_blankX - set FHS FltBlank to previous test value + 1
							ret = WriteSPI(idx, 2, 6, FHSBlankCount[fb-1] + 1);
							
							//clear FHS Count. read_counter
							ret = ReadReg(idx, 1, 9, reg_val); //FHSCount. read to clear
							
							//fhs_blankX - set FHS FltBlank 
							ret = WriteSPI(idx, 2, 6, FHSBlankCount[fb]);
							
							for(int j=0; j< FHSBlankCount[fb]; j++)
							{
								//remove fault event
								ret = WriteSPI(idx, 3, 7, 0);
								ret = WriteSPI(idx, 3, 9, 0);
								ret = WriteSPI(idx, 3, 10, 0);
								
								//wait 10us
								_util->Wait_Sec(10e-6);
								
								//force 1 FHS Pos/Neg event
								ret = WriteSPI(idx, 3, 7, 0x1e);
								if(i == FHSBlankCountPos) //fault_event_pos
									ret = WriteSPI(idx, 3, 9, 0x20); //Event_Detect_FHSPositive
								else //Force_NegFHSFlt
									ret = WriteSPI(idx, 3, 9, 0x10); //Event_Detect_FHSNegative							
							}
							//check FLTMUX=1 > no fault, as RWN=1
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != 1)
								test_result[i]=-1;
							
							//---increment FHS event once more---
							//remove fault event
							ret = WriteSPI(idx, 3, 7, 0);
							ret = WriteSPI(idx, 3, 9, 0);
							ret = WriteSPI(idx, 3, 10, 0);
							
							//wait 10us
							_util->Wait_Sec(10e-6);
							
							//force 1 FHS Pos/Neg event
							ret = WriteSPI(idx, 3, 7, 0x1e);
							if(i == FHSBlankCountPos) //fault_event_pos
								ret = WriteSPI(idx, 3, 9, 0x20); //Event_Detect_FHSPositive
							else //Force_NegFHSFlt
								ret = WriteSPI(idx, 3, 9, 0x10); //Event_Detect_FHSNegative		
							//---end increment FHS event---------
							
							//check FLTMUX=0 > fault occured, as RWN=1
							ret = dm[idx]->ReadPin("FLTMUX", pin_val);
							if(pin_val != 0)
								test_result[i]=-1;
							
							//remove fault event
							ret = WriteSPI(idx, 3, 7, 0);
							ret = WriteSPI(idx, 3, 9, 0);
							ret = WriteSPI(idx, 3, 10, 0);
						}
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
					case HeaterFalseFlt:  
						//RdHeat_255
						ret = WriteSPI(idx, 1, 12, 0xff); //RHeat
						
						//enable all faults
						ret = WriteSPI(idx, 1, 10, 0);
						ret = WriteSPI(idx, 3, 11, 0);
						
						//RWN=1, check FLTMUX=1 > no faults
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1*1; //***verify failue 1
						
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1*2; //***verify failue 2
						
						//RdHeat_0
						ret = WriteSPI(idx, 1, 12, 0); //RHeat
						
						//RWN=1, check FLTMUX=1 > no faults
						ret = dm[idx]->ReadPin("FLTMUX", pin_val);
						if(pin_val != 1)
							test_result[i]=-1*3; //***verify failue 3
						
						//Verify FSR = 0
						ret = ReadReg(idx, 1, 8, reg_val);
						if(reg_val != 0)
							test_result[i]=-1*4; //***verify failue 4
						
						tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
						break;
				}
				//Cleanup test
				//remove fault event
				ret = WriteSPI(idx, 3, 7, 0);
				ret = WriteSPI(idx, 3, 9, 0);
				ret = WriteSPI(idx, 3, 10, 0);
				
				//clear FSR
				ret = WriteSPI(idx, 1, 8, 0);
				
				//RWN=0
				//ret = dm[idx]->DrivePin("RWN", 0);
				
				tf_SetResult_UUTOffset(TPName[i], test_result[i] + GetOffset(idx, TPDispName[i]), idx);
			}
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			//if(USE_SPI)
			//{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			//}
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}   
	//void TestProgram::flt_ireader_open(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

	//		String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";
	//		
	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		String ^ Vector_File_1		= String::Empty;

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		//if(!USE_SPI)
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		
	//		ret = dm[idx]->DPINOff(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);
	//		//

	//		ret = dm[idx]->DPINOff(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		double result_v_vmr = 0;
	//		double result_RO_trip = 0;
	//		double diffp_V = 0;
	//		double diffn_V = 0;
	//		double diffpn_V = 0;		//

	//		int spi_group = 0;
	//		//double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg -- new
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);
	//		
	//		for (int i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//	
	//		//ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//		//CheckError(idx, ret, __LINE__);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			// Load vector file

	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

	//				//if(!USE_SPI)
	//				//{
	//					ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);	//ML add in 
	//					CheckError(idx, ret, __LINE__);

	//					ret = RunVectorFile(idx, Vector_File);
	//					CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//					CheckError(idx, ret, __LINE__);
	//				//} 
	//				//else 
	//				//{
	//				//	ret = RunSPI(idx, Vector_File);
	//				//	CheckError(idx, ret, __LINE__);
	//				//}
	//			}

	//			//Sweep reg

	//			spi_wr_byte_length = 2;		//1

	//			int k = Start_Data;
	//			//while (k != Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 0; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);
	//				
	//				//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);
	//									
	//				if (spi_status == 2)
	//				{
	//					//spi_data_dir[0] = 0x00000ff; 
	//					//spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//					//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//					//CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);

	//					for (int j=0; j<spi_rd_byte_length; j++)
	//					{
	//						if (spi_rd_biterror[j] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}

	//					if (readback == ((1 << Compare_Bit) & 0xff))
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//						CheckError(idx, ret, __LINE__);						
	//						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//						CheckError(idx, ret, __LINE__);
	//						result_RO_trip = Math::Abs(diffp_V - diffn_V);
	//					
	//						break;
	//					}
	//					else 
	//					{
	//						if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
	//						{
	//							Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

	//							//if(!USE_SPI) 
	//							//{
	//								ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//								CheckError(idx, ret, __LINE__);

	//								ret = RunVectorFile(idx, Vector_File_1);
	//								CheckError(idx, ret, __LINE__);

	//								ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//								CheckError(idx, ret, __LINE__);
	//							//} 
	//							//else
	//							//{
	//							//	ret = RunSPI(idx, Vector_File_1);
	//							//	CheckError(idx, ret, __LINE__);
	//							//}
	//			
	//							//
	//							spi_wr_byte_length = 1;
	//							
	//							spi_data_dir[0] = 0x00000ff; 
	//							spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//							ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//							CheckError(idx, ret, __LINE__);

	//							//for (int m=0; m<spi_rd_byte_length; m++)
	//							//{
	//							//	if (spi_rd_biterror[m] == 0)
	//							//	{
	//							//		data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//							//		readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;	
	//							//	}
	//							//	else
	//							//	{
	//							//		readback = -999;
	//							//	}
	//							//}
	//							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//							CheckError(idx, ret, __LINE__);
	//							
	//							//add in rev54
	//							for (int j=0; j<spi_rd_byte_length; j++)
	//							{
	//								if (spi_rd_biterror[j] == 0)
	//								{
	//									data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//								}
	//								else
	//								{
	//									readback = INVALID_RESULT;
	//								}
	//							}								
	//							
	//							if (readback == ((1 << Compare_Bit) & 0xff))	
	//							{
	//								ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//								CheckError(idx, ret, __LINE__);								
	//								ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//								CheckError(idx, ret, __LINE__);
	//								result_RO_trip = Math::Abs(diffp_V - diffn_V);

	//								break;
	//							}
	//						}
	//					}
	//				}

	//				//if (Start_Data > Stop_Data)
	//				//	k--;
	//				//else
	//				//	k++;
	//			//}

	//			double result_final = 0;
	//			result_final = result_RO_trip;

	//			if (_util->IsInf(result_final) == false)			
	//				tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
	//			else
	//				tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
	//		}

	//		/////////////////////////////////

	//		//if(!USE_SPI) 
	//		//{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = RunSPI(idx, Vector_File_End);
	//		//	CheckError(idx, ret, __LINE__);

	//		//	ret = OnOffSPI(idx, 0);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::flt_ireader_open(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;
			String ^ Vector_File_1		= String::Empty;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			}

			/////////////////////////////////

			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(idx, ret, __LINE__);
			//

			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			int Start_Data		= 0;
			int Stop_Data		= 0;
			int Compare_Bit		= 0;
			int Compare_Reg_Addr = 0;

			double result_v_vmr = 0;
			double result_RO_trip = 0;
			double diffp_V = 0;
			double diffn_V = 0;

			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
				Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
				Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
				Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

				//Sweep reg

				spi_wr_byte_length = 1;

				int k = Start_Data;
				while (k != Stop_Data)
				{
					int datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

					ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(idx, ret, __LINE__);

					if (spi_status == 2)
					{
						spi_data_dir[0] = 0x00000ff; 
						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(idx, ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
							}
							else
							{
								readback = -999;
							}
						}

						if (readback == ((1 << Compare_Bit) & 0xff))
						{
							ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
							CheckError(idx, ret, __LINE__);

							result_RO_trip = Math::Abs(diffp_V - diffn_V);

							break;
						}
					}

					if (Start_Data > Stop_Data)
						k--;
					else
						k++;
				}

				double result_final = 0;
				result_final = result_RO_trip;

				if (_util->IsInf(result_final) == false)			
					tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
				else
					tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
			}

				/////////////////////////////////

			if(!USE_SPI) 
			{
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = RunSPI(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);

				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	
	//void TestProgram::flt_ireader_open(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

	//		String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";
	//		
	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		String ^ Vector_File_1		= String::Empty;

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		//if(!USE_SPI)
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		//MTX_SMU
	//		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampVoltage("MTX_SMU", 1.99);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->OnSmuPin("MTX_SMU", true, false);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);
	//		
	//		/*ret = dm[idx]->DPINOff(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOn(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		//

	//		ret = dm[idx]->DPINOff(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOn(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);  */

	//		/////////////////////////////////

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		double result_v_vmr = 0;
	//		double result_RO_trip = 0;
	//		double diffp_V = 0;
	//		double diffn_V = 0;
	//		double diffpn_V = 0;		//

	//		int spi_group = 0;
	//		//double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg -- new
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);
	//		
	//		for (int i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//query for DiffAmp gain
	//		double m = 3;
	//		double c = 0;
	//		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
	//		{
	//			m = _glob->DA_GainError[idx, 0];
	//			c = _glob->DA_OffsetError[idx, 0];

	//			ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
	//		{
	//			m = _glob->DA_GainError[idx, 1];
	//			c = _glob->DA_OffsetError[idx, 1];

	//			ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		
	//		//ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//		//CheckError(idx, ret, __LINE__);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			// Load vector file

	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

	//				//if(!USE_SPI)
	//				//{
	//					ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);	//ML add in 
	//					CheckError(idx, ret, __LINE__);

	//					ret = RunVectorFile(idx, Vector_File);
	//					CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//					CheckError(idx, ret, __LINE__);
	//				//} 
	//				//else 
	//				//{
	//				//	ret = RunSPI(idx, Vector_File);
	//				//	CheckError(idx, ret, __LINE__);
	//				//}
	//			}

	//			//Sweep reg

	//			spi_wr_byte_length = 2;		//1

	//			int k = Start_Data;
	//			//while (k != Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 0; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);
	//				
	//				//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);
	//									
	//				if (spi_status == 2)
	//				{
	//					//spi_data_dir[0] = 0x00000ff; 
	//					//spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//					//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//					//CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);

	//					for (int j=0; j<spi_rd_byte_length; j++)
	//					{
	//						if (spi_rd_biterror[j] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}

	//					if (readback == ((1 << Compare_Bit) & 0xff))
	//					{
	//						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//						CheckError(idx, ret, __LINE__);

	//						result_RO_trip = Math::Abs((diffpn_V-c)/m);

	//						break;
	//					}
	//					else 
	//					{
	//						if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
	//						{
	//							Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

	//							//if(!USE_SPI) 
	//							//{
	//								ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//								CheckError(idx, ret, __LINE__);

	//								ret = RunVectorFile(idx, Vector_File_1);
	//								CheckError(idx, ret, __LINE__);

	//								ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//								CheckError(idx, ret, __LINE__);
	//							//} 
	//							//else
	//							//{
	//							//	ret = RunSPI(idx, Vector_File_1);
	//							//	CheckError(idx, ret, __LINE__);
	//							//}
	//			
	//							//
	//							spi_wr_byte_length = 1;
	//							
	//							spi_data_dir[0] = 0x00000ff; 
	//							spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//							ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//							CheckError(idx, ret, __LINE__);

	//							//for (int m=0; m<spi_rd_byte_length; m++)
	//							//{
	//							//	if (spi_rd_biterror[m] == 0)
	//							//	{
	//							//		data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//							//		readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;	
	//							//	}
	//							//	else
	//							//	{
	//							//		readback = -999;
	//							//	}
	//							//}
	//							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//							CheckError(idx, ret, __LINE__);
	//							
	//							//add in rev54
	//							for (int j=0; j<spi_rd_byte_length; j++)
	//							{
	//								if (spi_rd_biterror[j] == 0)
	//								{
	//									data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//								}
	//								else
	//								{
	//									readback = INVALID_RESULT;
	//								}
	//							}								
	//							
	//							if (readback == ((1 << Compare_Bit) & 0xff))	
	//							{
	//								ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//								CheckError(idx, ret, __LINE__);

	//								result_RO_trip = Math::Abs((diffpn_V-c)/m);

	//								break;
	//							}
	//						}
	//					}
	//				}

	//				//if (Start_Data > Stop_Data)
	//				//	k--;
	//				//else
	//				//	k++;
	//			//}

	//			double result_final = 0;
	//			result_final = result_RO_trip;

	//			if (_util->IsInf(result_final) == false)			
	//				tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
	//			else
	//				tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
	//		}

	//		/////////////////////////////////

	//		//if(!USE_SPI) 
	//		//{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = RunSPI(idx, Vector_File_End);
	//		//	CheckError(idx, ret, __LINE__);

	//		//	ret = OnOffSPI(idx, 0);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::IDCcancelDAC(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{		
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
								
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff("FLTMUX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", 0.002);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("FLTMUX");
			CheckError(idx, ret, __LINE__);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			ret = RunVectorFile(idx, "write_default_reg");	//JL: run Vector file to initialize the test
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			array<double> ^ IDCcancelDac = gcnew array<double>(12);
			array<double> ^ IDCcancelRng = gcnew array<double>(4);
			array<int> ^ prox_part_dac={0,1,2,3,4,7,8,15,16,31,32,63};		
			ret = OnOffSPI(idx, 1); 
			CheckError(idx, ret, __LINE__);
			
			//pg2_reg4 bit6 FHSIMODE=1, bit4 FHSEN=1 
			ret = WriteSPI(idx, 2, 4, 0x50); 
			CheckError(idx, ret, __LINE__);
			
			//AMUX=45, pg1_reg15 bit7=0, bit6=DMUXAMUXN=0, bit5:0=MUX[5:0]=10_1101 ; pg3_reg13[6]=MUX[6]=0
			//Select Amux: FOS Fault Test Mode
			ret = WriteSPI(idx, 1, 15, 0x2d);
			CheckError(idx, ret, __LINE__);
			ret = WriteSPI(idx, 3, 13, 0x00);
			CheckError(idx, ret, __LINE__);
			
			//JL: FHSDC Disable pg2_reg11[3] is default 0 > enable DHS DC mode		
			
			//Test Param 0 - 11; Rng=0, Dac=i
			for(int i=0; i<12; i++)
			{
				//FHSDCCANCELRNG<1:0>, pg2_reg6[7:6] = 0
				//FHSDCCANCELDAC<5:0>, pg2_reg6[5:0] = i
				ret = WriteSPI(idx, 2, 6, prox_part_dac[i]);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, IDCcancelDac[i]);
				
				tf_SetResult_UUTOffset(TPName[i], IDCcancelDac[i] + GetOffset(idx, TPDispName[i]), idx);
			}
			
			//Test Param 12 - 14; Rng=i, Dac=0
			for(int i=1; i<4; i++)
			{
				//FHSDCCANCELRNG<1:0>, pg2_reg6[7:6] = i
				//FHSDCCANCELDAC<5:0>, pg2_reg6[5:0] = 0
				ret = WriteSPI(idx, 2, 6, (i << 6));
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASURECURRENT, IDCcancelRng[i]);
				
				tf_SetResult_UUTOffset(TPName[i+11], IDCcancelRng[i] + GetOffset(idx, TPDispName[i+11]), idx);
			}
			
			//Test Param 15, 16
			 /*
			line_fit(prox_part_dac,IDCcancelDac,PART_PROX_DAC,&slope,&offset);
			test slope;
			test offset;
			*/		
			double slope = 0;
			double offset = 0;

			_util->line_fit(prox_part_dac,IDCcancelDac,12,slope,offset);
					
			tf_SetResult_UUTOffset(TPName[15], slope + GetOffset(idx, TPDispName[15]), idx);
			tf_SetResult_UUTOffset(TPName[16], offset + GetOffset(idx, TPDispName[16]), idx);
			
			//Test Param 17, 18
			/*
			mono_step=monotonicity(IDCcancelDac,PART_PROX_DAC,0,&mono);
			mono/=slope;        // Convert to LSBs
			test prox_part_dac[mono_step];
			test mono;
			*/
			int mono_step = 0;
			double mono = 0;

			mono_step = _util->monotonicity(IDCcancelDac,12,0,mono);
			mono /= slope;
			
			tf_SetResult_UUTOffset(TPName[17], (int)(prox_part_dac[mono_step] + GetOffset(idx, TPDispName[17])), idx);
			tf_SetResult_UUTOffset(TPName[18], mono + GetOffset(idx, TPDispName[18]), idx);
			
			//Test Param 19, 20
			/*
			lin_step=linearity(prox_part_dac,IDCcancelDac,PART_PROX_DAC,slope,offset,&lin);
			lin/=slope;        // Convert to LSBs 
			test prox_part_dac[lin_step];
			test lin;
			*/
			double ideal = 0;
			double lin_max = 0;
			int lin_step = 0;
			double lin = 0;
			ideal = slope * prox_part_dac[0] + offset;
			lin_max = IDCcancelDac[0] - ideal;
			
			for(int i=1; i<12; i++)
			{
				ideal = slope * prox_part_dac[i] + offset;
				lin = IDCcancelDac[i] - ideal;
				if(fabs(lin) > fabs(lin_max))
				{
					lin_max = lin;
					lin_step = i;
				}			
			}
			lin_max /= slope;

			tf_SetResult_UUTOffset(TPName[19], (int)(prox_part_dac[lin_step] + GetOffset(idx, TPDispName[19])), idx);
			tf_SetResult_UUTOffset(TPName[20], lin_max + GetOffset(idx, TPDispName[20]), idx);
			
			/////////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
						
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}  
//void TestProgram::flt_ireader_open(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		String ^ Vector_File_1		= String::Empty;

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		if(!USE_SPI)
	//		{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else
	//		{
	//			ret = OnOffSPI(idx, 1);
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunSPI(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		/////////////////////////////////

	//		ret = dm[idx]->DPINOff(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);
	//		//

	//		ret = dm[idx]->DPINOff(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		double result_v_vmr = 0;
	//		double result_RO_trip = 0;
	//		double diffp_V = 0;
	//		double diffn_V = 0;

	//		int spi_group = 0;
	//		double spi_clk_freq = 2e6;	//
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);
	//		
	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);			

	//		for (int i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);	//ML - hv to include, with spi_sweep method
	//		CheckError(idx, ret, __LINE__);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			//Sweep reg
	//			spi_wr_byte_length = 2;	//1

	//			int k = Start_Data;
	//			//while (k != Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 0; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

	//				if (spi_status == 2)
	//				{
	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);

	//					for (int j=0; j<spi_rd_byte_length; j++)
	//					{
	//						if (spi_rd_biterror[j] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}

	//					if (readback == ((1 << Compare_Bit) & 0xff))
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//						CheckError(idx, ret, __LINE__);
	//						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//						CheckError(idx, ret, __LINE__);

	//						result_RO_trip = Math::Abs(diffp_V - diffn_V);

	//						//break;
	//					}
	//				}

	//			//	if (Start_Data > Stop_Data)
	//			//		k--;
	//			//	else
	//			//		k++;
	//			//}

	//			double result_final = 0;
	//			result_final = result_RO_trip;

	//			if (_util->IsInf(result_final) == false)			
	//				tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
	//			else
	//				tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
	//		}

	//		/////////////////////////////////

	//		if(!USE_SPI) 
	//		{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else
	//		{
	//			ret = RunSPI(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);

	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::sply_flt(Object^ object) //JL: new test
	{
			/*
				JL: DM_Setting - RWN = 1
					CBit - Connect FLTMUX, W0x/y, RWN & SPE to DM.
			*/
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{			
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;
			String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N")); //W0Y_F
			String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P")); //W0X_F
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
				
			ret = dm[idx]->DPINOff("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDX", 1.8, 1.3, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDX");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDY", 1.8, 1.3, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDY");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			ret = RunVectorFile(idx, "write_default_reg");	//JL: run Vector file to initialize the test
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////////
			//ret = OnOffSPI(idx, 1);		//ML mask
			//CheckError(idx, ret, __LINE__);
			
			double vee_nom=-3.0;
			double vcc_nom=5;
			double vee_flt=-2.1;
			double vcc_flt=3.4;
			
			double vcc_up = 0;
			double vcc_down = 0;
			double vee_up = 0;
			double vee_down = 0;
			
			double w0x_v = 0;
			double w0y_v = 0;
			double iw = 0;
			double vdiff = 0;

			ret = dm[idx]->DPINOff("FLTMUX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", 0.002);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("FLTMUX");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			
			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			//Param 0 - 5 VEE Low Threshold=0 (-2.5V): spec range -2.59V - -2.39V;
			//Note: Vcc fault spec range 3.65V - 3.95V

			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);
			ret = RunVectorFile(idx, "write_sply_flt");
			CheckError(idx, ret, __LINE__);

			//int va0, va1, va2, va3, va4, va5, va6 =0;
			//ret = OnOffSPI(idx, 1);	//ML to read back from reg
			//ret = ReadReg(idx, 1, 10, va0);
			//ret = ReadReg(idx, 3, 11, va1);
			//ret = ReadReg(idx, 1, 8, va2);
			//ret = ReadReg(idx, 2, 10, va3);

			//ret = OnOffSPI(idx, 0);
			//CheckError(idx, ret, __LINE__);
			//ret = ReadVector(idx, "read_p1_reg10", va4);
			//ret = ReadVector(idx, "read_p1_reg8", va5);
			//ret = ReadVector(idx, "read_p2_reg10", va6);

			//ret = WriteSPI(idx, 1, 10, 0xfd); //enable supply fault, bit1=0; disable all other faults
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 3, 11, 0xc0); //disable FHS Open/Short fault.
			//CheckError(idx, ret, __LINE__);
			////ret = WriteSPI(idx, 2, 10, 0x00); //VEE Low Threshold, pg2_reg10[7]=0; JL: same as default value, skip.
			//ret = WriteSPI(idx, 1, 8, 0x00); //clear FSR
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 2, 10, 0x31);//enable reader, writer, heater on supply fault. pg2_reg10 bit0=1, bit4=1, bit5=1
			//CheckError(idx, ret, __LINE__);

			//Set hsel accodring to Test_Pin_P/N
			if(Test_Pin_P->CompareTo("W1X_F")) 
				ret = RunVectorFile(idx, "write_p1_reg1_hsel_1");  
				//ret = WriteSPI(idx, 1, 1, 0xc1); //select hsel=1

			//** Read mode: RWN=1 - default setting
			vcc_down = supply_thr_ppmu(idx, "VCC", vcc_nom, vcc_flt, 0);
			vcc_up = supply_thr_ppmu(idx, "VCC", vcc_flt, vcc_nom, 1);
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V-0.1);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(100e-6);		//100e-6

			vee_down = supply_thr_ppmu(idx, "VEE", vee_nom, vee_flt, 0);
			vee_up = supply_thr_ppmu(idx, "VEE", vee_flt, vee_nom, 1);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V+0.1);		//ML orig from JL Drive_Vee_V-0.1
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(100e-6);	//100e-6

			//return results
			tf_SetResult_UUTOffset(TPName[0], vcc_down + GetOffset(idx, TPDispName[0]), idx);
			tf_SetResult_UUTOffset(TPName[1], vcc_up + GetOffset(idx, TPDispName[1]), idx);
			tf_SetResult_UUTOffset(TPName[2], (vcc_up - vcc_down) + GetOffset(idx, TPDispName[2]), idx);
			
			tf_SetResult_UUTOffset(TPName[3], vee_down + GetOffset(idx, TPDispName[3]), idx);
			tf_SetResult_UUTOffset(TPName[4], vee_up + GetOffset(idx, TPDispName[4]), idx);
			tf_SetResult_UUTOffset(TPName[5], (vee_down - vee_up) + GetOffset(idx, TPDispName[5]), idx);
			
			//Param 6 - 8 VEE Low Threshold=1 (-2.3V): spec range -2.39V - -2.19V
			////ret = OnOffSPI(idx, 1);		//ML mask
			////CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 2, 10, 0xb1);//VEE Low Threshold, pg2_10[7]=1
			//CheckError(idx, ret, __LINE__);

			ret = RunVectorFile(idx, "write_sply_veelowthreshold");
			CheckError(idx, ret, __LINE__);
			
			//** Write mode: RWN=0, WDx/y toggles
			ret = dm[idx]->DrivePin("RWN", 0);
			CheckError(idx, ret, __LINE__);
			
			//vee_down = supply_thr_ppmu(idx, "VEE", vee_nom, vee_flt, 1);
			//vee_up = supply_thr_ppmu(idx, "VEE", vee_flt, vee_nom, 0);

			//added by CB
			double flt_pin,k,a;
			for( k = (vee_nom+0.6); k<vee_flt; k+=0.005)
			{
				ret = smu[idx]->DriveVoltage("VEE", fabs(k));
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);

				if(flt_pin > 1) 
				break;
			}

			for(a = (vee_flt-0.1); k>vee_nom; a-=0.005)
			{
				ret = smu[idx]->DriveVoltage("VEE", fabs(a));
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);

				if(flt_pin < 1) 
				break;
			}

			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V-0.1);
			CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(100e-6);	//100e-6

			vee_down =k;	//
			vee_up = a;	//

			tf_SetResult_UUTOffset(TPName[6], vee_down + GetOffset(idx, TPDispName[6]), idx);
			tf_SetResult_UUTOffset(TPName[7], vee_up + GetOffset(idx, TPDispName[7]), idx);
			tf_SetResult_UUTOffset(TPName[8], (vee_down - vee_up) + GetOffset(idx, TPDispName[8]), idx);
			
			//Param 9 - SleepN bit reset (=0) on low VEE
			double supply = 0;
			//from Catalyst: veeBO_sh=-(veeBO_target-200mV); veeBO_target = 2V
			double veeB0_sh = -1.8;
			double vee_B0 = 0;
			//double flt_pin = 0;

			ret = RunVectorFile(idx, "write_sply_sleeponlowvee");
			CheckError(idx, ret, __LINE__);

			//ret = WriteSPI(idx, 1, 8, 0x00); //clear FSR
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 2, 10, 0x31);//enable reader, writer, heater on supply fault. pg2_reg10 bit0=1, bit4=1, bit5=1
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 1, 14, 0x42);//pg1_reg14[6](SleepOnLowVEE)=1, bit1=1 default val.
			//CheckError(idx, ret, __LINE__);
			  
			//** Read mode: RWN=1
			ret = dm[idx]->DrivePin("RWN", 1);
			
			for(supply = vee_nom; supply <= (vee_down + 0.05); supply += 0.05)
			{
				ret = smu[idx]->DriveVoltage("VEE", fabs(supply));
				_util->Wait_Sec(0.1e-3);	//100e-6
			}
			
			//JL: at this point, FLTMUX=0 due to Sply fault when Vee > Vee_down
			
			for(supply = (vee_down - 0.05); supply <= (veeB0_sh + 0.1); supply += 0.005)	
			{
				ret = smu[idx]->DriveVoltage("VEE", fabs(supply));
				_util->Wait_Sec(0.1e-3);	//100e-6
				
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);

				//check for FLTMUX=1 after Vee Low causes SleepN=0
				if(flt_pin > 1)
				{
					vee_B0 = supply;
					break;
				}
			}			
			
			//restore VEE to nominal value, gradually
			for(; supply >= vee_nom; supply -= 0.05)
				ret = smu[idx]->DriveVoltage("VEE", fabs(supply));
			ret = smu[idx]->DriveVoltage("VEE", fabs(vee_nom));	

			tf_SetResult_UUTOffset(TPName[9], vee_B0 + GetOffset(idx, TPDispName[9]), idx);
			
			//Param 10
			/*OnOffSPI(idx, 1);		//ML turn off SPI to avoid causing next test fail
			CheckError(idx, ret, __LINE__);

			ret = WriteSPI(idx, 1, 7, 0x13);//reenable SleepN=1, operating mode	//0x13 */
	
			ret = RunVectorFile(idx, "write_p1_reg7_mode_active");	
			CheckError(idx, ret, __LINE__);

			//** Write mode: RWN=0
			int abc;
			//ret = ReadReg(idx,1,2, abc);
			ret = dm[idx]->DrivePin("RWN", 0);
			ret = dm[idx]->DrivePin("WDX", 1);
			//ret = dm[idx]->DrivePin("WDX", 0);	//ML comment

			_util->Wait_Sec(10e-3);	//ML comment out
			
			//Read  w0x/w0y voltages		
			ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, w0x_v);
			ret = DriveCBit(idx, TPDispName[0],1);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0],1);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, w0y_v);

			OnOffSPI(idx, 0);		//ML turn off SPI to avoid causing next test fail	
	
			vdiff = fabs(w0x_v-w0y_v);
			iw = vdiff / CONST_Rw; //JL: 3.0 = writer load/write head resistance	//ML change from 3 to CONST_Rw
			
			iw = iw * (1-0.09*iw/70e-3); //JL: according to Catalyst program
	  
			tf_SetResult_UUTOffset(TPName[10], iw + GetOffset(idx, TPDispName[10]), idx);
			
			/////////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
						
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//void TestProgram::flt_fhs_iopen(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

	//		String ^ Test_Pin_PN	= "GRP1_DIFF_SENSE";
	//		
	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		String ^ Vector_File_1		= String::Empty;

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		//if(!USE_SPI)
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}

	//		//MTX_SMU
	//		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampVoltage("MTX_SMU", 1.99);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->OnSmuPin("MTX_SMU", true, false);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);
	//		
	//		/////////////////////////////////

	//		//ret = dm[idx]->DPINOff(Test_Pin_P);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->DPINOn(Test_Pin_P);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
	//		//CheckError(idx, ret, __LINE__);

	//		////

	//		//ret = dm[idx]->DPINOff(Test_Pin_N);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->DPINOn(Test_Pin_N);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		//ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
	//		//CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////
	//////ML added
	////		unsigned int moduleType  = 0;
	////		unsigned int TestPinP_moduleType  = 0;
	////		unsigned int TestPinN_moduleType  = 0;
	////			// DICV pin 
	////			try
	////			{
	////				ret = smu[idx]->QueryModuleType(Test_Pin_P, TestPinP_moduleType);
	////				CheckError(idx, ret, __LINE__);
	////			}
	////			catch (Exception ^) //not a smu resource if exception occurs
	////			{
	////				TestPinP_moduleType = DM_CONST_MODULE_TYPE;
	////			}

	////			if (Debug_Enable == true)
	////			{
	////				sb->AppendLine("QueryModuleType returns " + ret.ToString());
	////				sb->AppendLine("Test_Pin module type=" + TestPinP_moduleType.ToString("X"));
	////			}

	////			if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
	////			{
	////				ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2); //
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->DPINOn(Test_Pin_P);
	////				CheckError(idx, ret, __LINE__);
	////			}
	////			else //smu
	////			{
	////				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
	////				CheckError(idx, ret, __LINE__);
	////				ret = smu[idx]->ClampVoltage(Test_Pin_P, Clamp_Vo_V);
	////				CheckError(idx, ret, __LINE__);
	////				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
	////				CheckError(idx, ret, __LINE__);
	////				ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
	////				CheckError(idx, ret, __LINE__);
	////			}
	////			
	////			// DICV pin (WRxN)
	////			try
	////			{
	////				ret = smu[idx]->QueryModuleType(Test_Pin_N, TestPinN_moduleType);
	////				CheckError(idx, ret, __LINE__);
	////			}
	////			catch (Exception ^) //not a smu resource if exception occurs
	////			{
	////				TestPinN_moduleType = DM_CONST_MODULE_TYPE;
	////			}

	////			if (Debug_Enable == true)
	////			{
	////				sb->AppendLine("QueryModuleType returns " + ret.ToString());
	////				sb->AppendLine("Test_Pin module type=" + TestPinN_moduleType.ToString("X"));
	////			}

	////			if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
	////			{
	////				ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2); 
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	////				CheckError(idx, ret, __LINE__);
	////				ret = dm[idx]->DPINOn(Test_Pin_N);
	////				CheckError(idx, ret, __LINE__);
	////			}
	////			else //smu
	////			{
	////				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
	////				CheckError(idx, ret, __LINE__);
	////				ret = smu[idx]->ClampVoltage(Test_Pin_N, Clamp_Vo_V);
	////				CheckError(idx, ret, __LINE__);
	////				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
	////				CheckError(idx, ret, __LINE__);
	////				ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
	////				CheckError(idx, ret, __LINE__);
	////			}
	//////ML added end

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		double result_v_vmr = 0;
	//		double result_RS_trip = 0;
	//		double diffp_V = 0;
	//		double diffn_V = 0;
	//		double diffpn_V = 0;

	//		int spi_group = 0;
	//		//double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);
	//		
	//		for (int i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//query for DiffAmp gain
	//		double m = 3;
	//		double c = 0;
	//		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
	//		{
	//			m = _glob->DA_GainError[idx, 0];
	//			c = _glob->DA_OffsetError[idx, 0];

	//			ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
	//		{
	//			m = _glob->DA_GainError[idx, 1];
	//			c = _glob->DA_OffsetError[idx, 1];

	//			ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		
	//		//ret = SPI_Configure(spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//		//CheckError(idx, ret, __LINE__);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			// Load vector file

	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

	//				//if(!USE_SPI)
	//				//{
	//					ret = RunVectorFile(idx, Vector_File);
	//					CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//				//	CheckError(idx, ret, __LINE__);
	//				//} 
	//				//else 
	//				//{
	//				//	ret = RunSPI(idx, Vector_File);
	//				//	CheckError(idx, ret, __LINE__);
	//				//}
	//			}

	//			//Sweep reg

	//			spi_wr_byte_length = 2;	//1

	//			int k = Start_Data;
	//			//while (k != Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}					
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 0; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);
	//				
	//				//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);					
	//				
	//				if (spi_status == 2)
	//				{
	//					//spi_data_dir[0] = 0x00000ff; 
	//					//spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//					//ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//					//CheckError(idx, ret, __LINE__);

	//					//ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					//CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);
	//										
	//					for (int j=0; j<spi_rd_byte_length; j++)
	//					{
	//						if (spi_rd_biterror[j] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//							//readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;	//ML
	//							readback = (data & (Compare_Bit & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}

	//					//if (readback == ((1 << Compare_Bit) & 0xff))	//ML fail if use this
	//					if (readback == (Compare_Bit & 0xff))
	//					{
	//						//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//						//CheckError(idx, ret, __LINE__);
	//						//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//						//CheckError(idx, ret, __LINE__);
	//						ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//						CheckError(idx, ret, __LINE__);							

	//						result_RS_trip = Math::Abs((diffpn_V-c)/m);		//Math::Abs(diffp_V - diffn_V);

	//						break;
	//					}
	//					else 
	//					{
	//						if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
	//						{
	//							Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

	//							//if(!USE_SPI) 
	//							//{
	//								ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//								CheckError(idx, ret, __LINE__);

	//								ret = RunVectorFile(idx, Vector_File_1);
	//								CheckError(idx, ret, __LINE__);

	//								ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//								CheckError(idx, ret, __LINE__);
	//							//} 
	//							//else
	//							//{
	//							//	ret = RunSPI(idx, Vector_File_1);
	//							//	CheckError(idx, ret, __LINE__);
	//							//}
	//		
	//							//
	//							spi_wr_byte_length = 1;

	//							spi_data_dir[0] = 0x00000ff; 
	//							spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

	//							ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//							CheckError(idx, ret, __LINE__);

	//							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//							CheckError(idx, ret, __LINE__);

	//							for (int j=0; j<spi_rd_byte_length; j++)
	//							{
	//								if (spi_rd_biterror[j] == 0)
	//								{
	//									data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//									//readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;	//ML this line get pass result too
	//									readback = (data & ( Compare_Bit & 0xff)) & 0xff;	
	//								}
	//								else
	//								{
	//									readback = INVALID_RESULT;
	//								}
	//							}

	//							//if (readback == ((1 << Compare_Bit) & 0xff))	//ML this line get pass result too
	//							if (readback == (Compare_Bit & 0xff))
	//							{
	//								//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//								//CheckError(idx, ret, __LINE__);
	//								//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//								//CheckError(idx, ret, __LINE__);
	//								ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//								CheckError(idx, ret, __LINE__);

	//								result_RS_trip = Math::Abs((diffpn_V-c)/m);			//Math::Abs(diffp_V - diffn_V);

	//								break;
	//							}
	//						}
	//					}
	//				}

	//				//if (Start_Data > Stop_Data)
	//				//	k--;
	//				//else
	//				//	k++;
	//			//}

	//			double result_final = 0;
	//			result_final = result_RS_trip;

	//			if (_util->IsInf(result_final) == false)			
	//				tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
	//			else
	//				tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);				

	//		}

	//		/////////////////////////////////

	//		if(!USE_SPI) 
	//		{
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else
	//		{
	//			ret = RunSPI(idx, Vector_File_End);
	//			CheckError(idx, ret, __LINE__);

	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::flt_fhs_iopen(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;
			String ^ Vector_File_1		= String::Empty;

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			if(!USE_SPI)
			{
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			}

			/////////////////////////////////
	//ML added
			unsigned int moduleType  = 0;
			unsigned int TestPinP_moduleType  = 0;
			unsigned int TestPinN_moduleType  = 0;
			// DICV pin (WRxP)
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_P, TestPinP_moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				TestPinP_moduleType = DM_CONST_MODULE_TYPE;
			}

			if (TestPinP_moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2); //
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_P);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_P, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_P, Clamp_Vo_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_P, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_P, false, false);
				CheckError(idx, ret, __LINE__);
			}
			
			// DICV pin (WRxN)
			try
			{
				ret = smu[idx]->QueryModuleType(Test_Pin_N, TestPinN_moduleType);
				CheckError(idx, ret, __LINE__);
			}
			catch (Exception ^) //not a smu resource if exception occurs
			{
				TestPinN_moduleType = DM_CONST_MODULE_TYPE;
			}

			if (TestPinN_moduleType == DM_CONST_MODULE_TYPE) //dm
			{
				ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2); 
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINOn(Test_Pin_N);
				CheckError(idx, ret, __LINE__);
			}
			else //smu
			{
				ret = smu[idx]->ConfigureSamplingTime(Test_Pin_N, NPLC, AM_CONST_PLC);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->ClampVoltage(Test_Pin_N, Clamp_Vo_V);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->DriveCurrent(Test_Pin_N, 0);
				CheckError(idx, ret, __LINE__);
				ret = smu[idx]->OnSmuPin(Test_Pin_N, false, false);
				CheckError(idx, ret, __LINE__);
			}
	//ML added end

			int Start_Data		= 0;
			int Stop_Data		= 0;
			int Compare_Bit		= 0;
			int Compare_Reg_Addr = 0;

			double result_v_vmr = 0;
			double result_RS_trip = 0;
			double diffp_V = 0;
			double diffn_V = 0;

			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			for (int i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				Start_Data	= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
				Stop_Data	= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
				Compare_Bit	= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
				Compare_Reg_Addr = (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

				// Load vector file

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

					if(!USE_SPI)
					{
						ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);	//ML add in 
						CheckError(idx, ret, __LINE__);

						ret = RunVectorFile(idx, Vector_File);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
						CheckError(idx, ret, __LINE__);
					} 
					else 
					{
						ret = RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}
				}

				//Sweep reg
				spi_wr_byte_length = 1;

				int k = Start_Data;
				while (k != Stop_Data)
				{
					int datain = _util->SwapBitSequence(k, 8);

					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

					ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(idx, ret, __LINE__);

					if (spi_status == 2)
					{
						spi_data_dir[0] = 0x00000ff; 
						spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

						ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
						CheckError(idx, ret, __LINE__);

						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
						CheckError(idx, ret, __LINE__);

						for (int m=0; m<spi_rd_byte_length; m++)
						{
							if (spi_rd_biterror[m] == 0)
							{
								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
								//readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;	//ML
								readback = (data & (Compare_Bit & 0xff)) & 0xff;
							}
							else
							{
								readback = -999;
							}
						}

						//if (readback == ((1 << Compare_Bit) & 0xff))	//ML fail if use this
						if (readback == (Compare_Bit & 0xff))
						{
							ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
							CheckError(idx, ret, __LINE__);
							ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
							CheckError(idx, ret, __LINE__);

							result_RS_trip = Math::Abs(diffp_V - diffn_V);

							break;
						}
						else 
						{
							if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
							{
								Vector_File_1 = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File_1");

								if(!USE_SPI) 
								{
									ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
									CheckError(idx, ret, __LINE__);

									ret = RunVectorFile(idx, Vector_File_1);
									CheckError(idx, ret, __LINE__);

									ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
									CheckError(idx, ret, __LINE__);
								} 
								else
								{
									ret = RunSPI(idx, Vector_File_1);
									CheckError(idx, ret, __LINE__);
								}
			
								//

								spi_data_dir[0] = 0x00000ff; 
								spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS

								ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
								CheckError(idx, ret, __LINE__);

								ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
								CheckError(idx, ret, __LINE__);

								for (int m=0; m<spi_rd_byte_length; m++)
								{
									if (spi_rd_biterror[m] == 0)
									{
										data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
										//readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;	//ML this line get pass result too
										readback = (data & ( Compare_Bit & 0xff)) & 0xff;	
									}
									else
									{
										readback = -999;
									}
								}

								//if (readback == ((1 << Compare_Bit) & 0xff))	//ML this line get pass result too
								if (readback == (Compare_Bit & 0xff))
								{
									ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
									CheckError(idx, ret, __LINE__);
									ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
									CheckError(idx, ret, __LINE__);

									result_RS_trip = Math::Abs(diffp_V - diffn_V);

									break;
								}
							}
						}
					}

					if (Start_Data > Stop_Data)
						k--;
					else
						k++;
				}

				double result_final = 0;
				result_final = result_RS_trip;

				if (_util->IsInf(result_final) == false)			
					tf_SetResult_UUTOffset(TPName[i], result_final + GetOffset(idx, TPDispName[i]), idx);
				else
					tf_SetResult_UUTOffset(TPName[i], (double)INVALID_RESULT, idx);
			}

			/////////////////////////////////

			if(!USE_SPI) 
			{
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);
			} 
			else
			{
				ret = RunSPI(idx, Vector_File_End);
				CheckError(idx, ret, __LINE__);

				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);

			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::flt_reader_open(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;
			int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
			double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

			String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
			String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
			String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
	//		_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			ret = dm[idx]->DPINOff(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOn(Test_Pin_flt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			/////////////////////////////////

			if(!USE_SPI) 
			{
				ret = RunVectorFile(idx, "write_default_reg");	
				CheckError(idx, ret, __LINE__);				
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			} 
			else 
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);				
				ret = RunSPI(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			}

			int Start_Data		= 0;
			int Stop_Data		= 0;
			int Compare_Bit		= 0;
			int Compare_Reg_Addr = 0;

			double result_v_vmr = 0;
			double result_RO_trip = 0;
			double diffp_V = 0;
			double diffn_V = 0;

			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);
			array<double> ^ result_final = gcnew array<double>(total_tp);


			//sweep_reg
			array<int> ^ sweep_step = gcnew array<int>(256);
			array<int> ^ reverse_bits = gcnew array<int>(256);
			array<int> ^ compare_bits = gcnew array<int>(256);
			array<int> ^ compare_value = gcnew array<int>(256);

			for (int i=0; i<256; i++)			// EW: will never use up 256
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); CheckError(idx, ret, __LINE__);				
			CheckError(idx, ret, __LINE__);

			//Sweep reg

			for (int i=0; i<total_tp; i++)
			{
			Start_Data				= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
			Stop_Data				= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
			Compare_Bit				= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
			Compare_Reg_Addr		= (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");



			int k = Start_Data;
					if(Start_Data < Stop_Data)
						sweep_step[0] = 1;
					else
						sweep_step[0] = -1;

			//spi_wr_byte_length = 1;
			spi_wr_byte_length = 2;

			//while (k <= Stop_Data)
			//{
				int datain = _util->SwapBitSequence(k, 8);
				spi_data_dir[0] = 0x0000000; 
				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4, then deassert NCS
					delay_s_after_byte[0] = 25e-9;
					reverse_bits[0] = 8;
					compare_bits[0] = 0; 
					compare_value[0] = 0;

					spi_data_dir[1] = 0x00000ff; 
					spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
					int max_sweep_loop = 256;
					sweep_step[1] = 0;
					delay_s_after_byte[1] = 0; //100e-9;
					reverse_bits[1] = 0;
					compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
					//compare_value[1] = 0;
					compare_value[1] = (0 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

					ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
					CheckError(idx, ret, __LINE__);

					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
						CheckError(idx, ret, __LINE__);

						if (spi_status == 2) //0=idle, 1=busy, 2=done
							break;

						swatch.Stop();
					}

					int sweep_count = 0;
					ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);


				//ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
				//CheckError(idx, ret, __LINE__);

				if (spi_status == 2)
				{
					spi_data_dir[0] = 0x00000ff; 
					spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4, then read back 8 bits, then deassert NCS
					ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
					CheckError(idx, ret, __LINE__);

					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					//ret = dm[idx]->SPI_SWEEP_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
					CheckError(idx, ret, __LINE__);

					for (int m=0; m<spi_rd_byte_length; m++)
					{
						if (spi_rd_biterror[m] == 0)
						{
							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
						}
						else
						{
							readback = -999;
						}
					}

					if (readback != ((1 << Compare_Bit) & 0xff))						
					{
						ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
						CheckError(idx, ret, __LINE__);
						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
						CheckError(idx, ret, __LINE__);

						result_RO_trip = result_RO_trip * -1;
						result_v_vmr = Math::Abs(diffp_V - diffn_V);

//						break;
					}
					
				}

			//	if (Start_Data > Stop_Data)
			//		k--;
			//	else
			//		k++;
			//}
		
			switch(i) {
			case 0: result_final[0] = result_v_vmr / (result_RO_trip * 8); break;
			case 1: result_final[1] = result_v_vmr / (result_RO_trip * 8); break;
			case 2: result_final[2] = result_v_vmr / (result_RO_trip * 4); break;
			case 3: result_final[3] = result_v_vmr / (result_RO_trip * 2); break;
			case 4: result_final[4] = result_v_vmr / (result_RO_trip * 1); break;
			case 5: result_final[5] = result_v_vmr / (result_RO_trip * 0.5); break;
				}

				tf_SetResult_UUTOffset(TPName[i], result_final[i] + GetOffset(idx, TPDispName[i]), idx);			
				}
		
		/////////////////////////////////

			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}
			
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//void TestProgram::flt_reader_open(Object^ object)		//fail spi_sweep
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
	//		double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
	//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

	//		String ^ Test_Pin_PN	= "GRP2_DIFF_SENSE";

	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);
	//		
	////		_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////

	//		ret = dm[idx]->DPINOff(Test_Pin_flt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
	//		CheckError(idx, ret, __LINE__);

	////		_util->Wait_Sec(On_Delay_s);
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->DPINOn(Test_Pin_flt);
	//		CheckError(idx, ret, __LINE__);

	//		//MTX_SMU
	//		ret = smu[idx]->ConfigureSamplingTime("MTX_SMU", NPLC, AM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampVoltage("MTX_SMU", 1.99);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveCurrent("MTX_SMU", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->OnSmuPin("MTX_SMU", true, false);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);

	////		ret = dm[idx]->DPINOff(Test_Pin_P);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->DPINOn(Test_Pin_P);
	////		CheckError(idx, ret, __LINE__);

	//////		_util->Wait_Sec(On_Delay_s);
	////		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
	////		CheckError(idx, ret, __LINE__);

	////		ret = dm[idx]->DPINOff(Test_Pin_N);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	////		CheckError(idx, ret, __LINE__);
	////		ret = dm[idx]->DPINOn(Test_Pin_N);
	////		CheckError(idx, ret, __LINE__);

	//////		_util->Wait_Sec(On_Delay_s);
	////		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
	////		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		/////////////////////////////////

	//		if(!USE_SPI) 
	//		{
	//			ret = RunVectorFile(idx, "write_default_reg");	
	//			CheckError(idx, ret, __LINE__);				
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else 
	//		{
	//			ret = OnOffSPI(idx, 1);
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunSPI(idx, "write_default_reg");
	//			CheckError(idx, ret, __LINE__);				
	//			ret = RunSPI(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		double result_v_vmr = 0;
	//		double result_RO_trip = 0;
	//		double diffp_V = 0;
	//		double diffn_V = 0;
	//		double diffpn_V = 0;

	//		double spi_clk_freq = 2e6;
	//		int spi_group = 0;			
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);
	//		array<double> ^ result_final = gcnew array<double>(total_tp);

	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);

	//		for (int i=0; i<256; i++)			// EW: will never use up 256
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//query for DiffAmp gain
	//		double m = 3;
	//		double c = 0;
	//		if (Test_Pin_PN == "GRP1_DIFF_SENSE")
	//		{
	//			m = _glob->DA_GainError[idx, 0];
	//			c = _glob->DA_OffsetError[idx, 0];

	//			ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT2, 1); //Connect to AM430e via switch matrix
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else if (Test_Pin_PN == "GRP2_DIFF_SENSE")
	//		{
	//			m = _glob->DA_GainError[idx, 1];
	//			c = _glob->DA_OffsetError[idx, 1];

	//			ret = OnOffCbit(idx, CBIT_D_Sx_MTX_IN0_OUT5, 1); //Connect to AM430e via switch matrix
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		////ML mask
	//		//ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//		//CheckError(idx, ret, __LINE__);				
	//		//ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); 
	//		//CheckError(idx, ret, __LINE__);

	//		//Sweep reg

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Start_Data				= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data				= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit				= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr		= (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			spi_wr_byte_length = 2;	//1

	//			int k = Start_Data;
	//			//while (k <= Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);
	//				
	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 0; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);
	//				
	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}
	//				
	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);

	//			if (spi_status == 2)
	//			{
	//				ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//				CheckError(idx, ret, __LINE__);

	//				for (int j=0; j<spi_rd_byte_length; j++)
	//				{
	//					if (spi_rd_biterror[j] == 0)
	//					{
	//						data = _util->SwapBitSequence(spi_rd_data[j], CONST_SERIAL_DATA_WIDTH);
	//						readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//					}
	//					else
	//					{
	//						readback = INVALID_RESULT;
	//					}
	//				}

	//				if (readback != ((1 << Compare_Bit) & 0xff))	
	//				{
	//					ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
	//					CheckError(idx, ret, __LINE__);
	//					//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//					//CheckError(idx, ret, __LINE__);
	//					//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//					//CheckError(idx, ret, __LINE__);
	//					ret = smu[idx]->ReadVoltage("MTX_SMU", diffpn_V);
	//					CheckError(idx, ret, __LINE__);


	//					result_RO_trip = result_RO_trip * -1;
	//					result_v_vmr = Math::Abs((diffpn_V-c)/m);	//result_v_vmr = Math::Abs(diffp_V - diffn_V);

	//					//break;
	//				}
	//				
	//			}

	//			//if (Start_Data > Stop_Data)
	//			//	k--;
	//			//else
	//			//	k++;
	//		//}
	//	
	//		switch(i) {
	//		case 0: result_final[0] = result_v_vmr / (result_RO_trip * 8); break;
	//		case 1: result_final[1] = result_v_vmr / (result_RO_trip * 8); break;
	//		case 2: result_final[2] = result_v_vmr / (result_RO_trip * 4); break;
	//		case 3: result_final[3] = result_v_vmr / (result_RO_trip * 2); break;
	//		case 4: result_final[4] = result_v_vmr / (result_RO_trip * 1); break;
	//		case 5: result_final[5] = result_v_vmr / (result_RO_trip * 0.5); break;
	//			}

	//			tf_SetResult_UUTOffset(TPName[i], result_final[i] + GetOffset(idx, TPDispName[i]), idx);			
	//		}
	//	
	//	/////////////////////////////////

	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//void TestProgram::flt_reader_open(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;
	//		int Sweep_Reg_Addr		= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));
	//		double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));
	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));

	//		String ^ Test_Pin_flt	= (String ^)(tf_TestItemCondition_Cast("Test_Pin_flt"));
	//		String ^ Test_Pin_P		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P"));
	//		String ^ Test_Pin_N		= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N"));

	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);
	//		
	////		_util->Wait_Sec(On_Delay_s);


	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0);
	//		CheckError(idx, ret, __LINE__);			
	//		ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);			
	//		ret = dm[idx]->DPINOn("RWN");
	//		CheckError(idx, ret, __LINE__);			
	//		
	//		ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);			
	//		ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);			
	//		ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);			
	//		ret = dm[idx]->DPINOn("WDX");
	//		CheckError(idx, ret, __LINE__);			
	//		
	//		ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("WDY");
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->Force("MODE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("MODE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("MODE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("MODE");
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////

	//		ret = dm[idx]->DPINOff(Test_Pin_flt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_flt, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_flt, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_flt, DM_CONST_DVCI);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_flt, Clamp_flt_A);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_flt);		//ML interchange seq with line below
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, Drive_flt_V);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOff(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_P);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->DPINOff(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn(Test_Pin_N);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		/////////////////////////////////

	//		//if(!USE_SPI) 
	//		//{
	//			ret = RunVectorFile(idx, "write_default_reg");	
	//			CheckError(idx, ret, __LINE__);				
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else 
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, "write_default_reg");
	//		//	CheckError(idx, ret, __LINE__);				
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}
	//		
	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		double result_v_vmr = 0;
	//		double result_RO_trip = 0;
	//		double diffp_V = 0;
	//		double diffn_V = 0;

	//		int spi_group = 0;
	//		double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);
	//		array<double> ^ result_final = gcnew array<double>(total_tp);
	//		
	//		//sweep_reg -- new in rev54
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);
	//		
	//		for (int i=0; i<256; i++)			// EW: will never use up 256		//ML change back from 1 to 256
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//if(USE_SPI)		//ML mask
	//		//{			
	//			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); 
	//			CheckError(idx, ret, __LINE__);
	//		//}
	//		
	//		//Sweep reg
	//		for (int i=0; i<total_tp; i++)
	//		{
	//			Start_Data				= (int)tf_TPCondition_Cast(TPName[i], "Start_Data");
	//			Stop_Data				= (int)tf_TPCondition_Cast(TPName[i], "Stop_Data");
	//			Compare_Bit				= (int)tf_TPCondition_Cast(TPName[i], "Compare_Bit");
	//			Compare_Reg_Addr		= (int)tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr");

	//			spi_wr_byte_length = 2;	//1
	//			int k = Start_Data;
	//			//while (k <= Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);
	//				
	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;

	//				spi_data_dir[1] = 0x00000ff; 
	//				spi_data[1]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 5e-9; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				if(i == 0)
	//				{
	//					compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}
	//				else if(i == 1)
	//				{
	//					compare_value[1] = 0; //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);
	//				
	//				//ret += SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();
	//				swatch.Start();
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status);
	//					CheckError(idx, ret, __LINE__);

	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;

	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);				

	//				if (spi_status == 2)
	//				{
	//					spi_status = 0;
	//					readback = 0;
	//					
	//					//spi_data_dir[0] = 0x00000ff; 
	//					//spi_data[0]	= 0x3000000 | ((Compare_Reg_Addr << 8) & 0xff00);  //write (MSB->LSB) for RW->PG->A0-A4, then read back 8 bits, then deassert NCS
	//					//ret += SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status);
	//					//CheckError(idx, ret, __LINE__);

	//					ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror);
	//					CheckError(idx, ret, __LINE__);

	//					for (int m=0; m<spi_rd_byte_length; m++)
	//					{
	//						if (spi_rd_biterror[m] == 0)
	//						{
	//							data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//							readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//						}
	//						else
	//						{
	//							readback = INVALID_RESULT;
	//						}
	//					}

	//					if (readback != ((1 << Compare_Bit) & 0xff))						
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin_flt, DM_CONST_MEASURECURRENT, result_RO_trip);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, diffp_V);
	//						CheckError(idx, ret, __LINE__);
	//						ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, diffn_V);
	//						CheckError(idx, ret, __LINE__);

	//						result_RO_trip = result_RO_trip * -1;
	//						result_v_vmr = Math::Abs(diffp_V - diffn_V);

	//						break;
	//					}
	//					
	//				}

	//				//if (Start_Data > Stop_Data)
	//				//	k--;
	//				//else
	//				//	k++;
	//			//}
	//	
	//		switch(i) {
	//		case 0: result_final[0] = result_v_vmr / (result_RO_trip * 8); break;
	//		case 1: result_final[1] = result_v_vmr / (result_RO_trip * 8); break;
	//		case 2: result_final[2] = result_v_vmr / (result_RO_trip * 4); break;
	//		case 3: result_final[3] = result_v_vmr / (result_RO_trip * 2); break;
	//		case 4: result_final[4] = result_v_vmr / (result_RO_trip * 1); break;
	//		case 5: result_final[5] = result_v_vmr / (result_RO_trip * 0.5); break;
	//			}

	//		tf_SetResult_UUTOffset(TPName[i], result_final[i] + GetOffset(idx, TPDispName[i]), idx);
	//		}
	//	
	//	/////////////////////////////////
	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_flt, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_P, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_N, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//void TestProgram::vlo_vee_sply_flt(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{

	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow			
	//		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel				= _glob->SPD_Channel_Number;

	//		String ^ Test_Pin			= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
	//		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
	//			
	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		int Sweep_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		
	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	//		
	//		double result				= 0;
	//		double result_vcc_ref		= 0;	//ML
	//		double result_vcc_trip_dn 	= 0;
	//		double result_vcc_trip_up 	= 0;
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		int i;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s); CheckError(idx, ret, __LINE__);
	//		CheckError(idx, ret, __LINE__);

	//		//if(!USE_SPI)
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}			
	//		/////////////////////////////////
	//		ret = dm[idx]->DPINOff(Test_Pin); 
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->DPINOn(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);

	//		/////////////////////////////////

	//		int spi_group = 0;
	//		double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		for (i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		int Start_Data;
	//		int Stop_Data;
	//		int Compare_Bit;
	//		int Compare_Reg_Addr;

	//		ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//		ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); CheckError(idx, ret, __LINE__);				

	//	for (int i=0; i<total_tp - 1; i++)		// Last test is a calculation test so skipping all these codes
	//	{
	//		if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
	//		{
	//			Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");
	//			
	//			//if(!USE_SPI) {
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, Vector_File);
	//			CheckError(idx, ret, __LINE__);

	//			ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//			CheckError(idx, ret, __LINE__);
	//			//} else {
	//			//ret = RunSPI(idx, Vector_File);
	//			//CheckError(idx, ret, __LINE__);
	//			//}
	//
	//			swatch.Reset();
	//			swatch.Start();	
	//			swatch.Stop();

	//			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//			{
	//				swatch.Start();

	//				ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); CheckError(idx, ret, __LINE__);
	//				if (spi_status == 2) { //0=idle, 1=busy, 2=done
	//					if(i == 0) 
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_ref); 
	//						CheckError(idx, ret, __LINE__);
	//						
	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt); 
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						result_vcc_ref = result_vcc_ref - volt;
	//					}	
	//					break;
	//				}
	//				swatch.Stop();
	//			}
	//		}

	//		Start_Data				= (int)(tf_TPCondition_Cast(TPName[i], "Start_Data"));
	//		Stop_Data				= (int)(tf_TPCondition_Cast(TPName[i], "Stop_Data"));
	//		Compare_Bit				= (int)(tf_TPCondition_Cast(TPName[i], "Compare_Bit"));
	//		Compare_Reg_Addr		= (int)(tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr"));

	//		readback = -999;		// Ensuring Default value	

	//		//Sweep reg
	//		spi_wr_byte_length = 1;

	//		int k = Start_Data;
	//		while(k != Stop_Data)
	//		{
	//			int datain = _util->SwapBitSequence(k, 8);

	//			spi_data_dir[0] = 0x0000000; 
	//			spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

	//			spi_status = 0;
	//		// EW: Can use this alternative	
	//		//  ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status) 
	//		//	CheckError(idx, ret, __LINE__);
	//							
	//			ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
	//			CheckError(idx, ret, __LINE__);

	//			swatch.Reset();	
	//			swatch.Start();	
	//			swatch.Stop();

	//			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//			{
	//				swatch.Start();
	//				ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); 
	//				CheckError(idx, ret, __LINE__);
	//				
	//				if (spi_status == 2) //0=idle, 1=busy, 2=done
	//					break;
	//				swatch.Stop();
	//			}

	//			if (spi_status == 2)
	//			{
	//				spi_data_dir[0] = 0x00000ff; 
	//				spi_data[0]	= 0x3008000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				spi_status = 0;
	//		// EW: Can use this alternative	
	//		//  ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status) 
	//		//	CheckError(idx, ret, __LINE__);
	//				
	//				ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
	//				CheckError(idx, ret, __LINE__);
	//			
	//				swatch.Reset();	
	//				swatch.Start();	
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();
	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); CheckError(idx, ret, __LINE__);
	//					if (spi_status == 2) { //0=idle, 1=busy, 2=done
	//						ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror); CheckError(idx, ret, __LINE__);
	//						
	//						for (int m=0; m<spi_rd_byte_length; m++)
	//						{
	//							if (spi_rd_biterror[m] == 0)
	//							{
	//								data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//								readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//							}
	//							// else
	//							//	readback = -999;
	//						}
	//							break;
	//					}	
	//					swatch.Stop();
	//				}

	//				if (i == 0 && readback == ((1 << Compare_Bit) & 0xff))			// vlo_vee_sply_flt DOWN
	//				{
	//					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_trip_dn);
	//					CheckError(idx, ret, __LINE__);

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);

	//						result_vcc_trip_dn = result_vcc_trip_dn - volt;

	//					break;
	//				}
	//				else if (i == 1 && readback != ((1 << Compare_Bit) & 0xff))			// vlo_vee_sply_flt UP	
	//				{
	//					ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_trip_up);
	//					CheckError(idx, ret, __LINE__);

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);

	//						result_vcc_trip_up = result_vcc_trip_up - volt;

	//					break;
	//				}							
	//			}
	//			if (Start_Data > Stop_Data)
	//				k--; 
	//			else
	//				k++;
	//		}	//end of while loop		
	//	}

	//	double result_final_0 = 0;
	//	double result_final_1 = 0;
	//	double result_final_2 = 0;

	//	result_final_0 = (-3 * result_vcc_trip_dn) / result_vcc_ref;	
	//	result_final_1 = (-3 * result_vcc_trip_up) / result_vcc_ref;	
	//	result_final_2 = result_final_0 - result_final_1;
	//	
	//	tf_SetResult_UUTOffset(TPName[0], result_final_1 + GetOffset(idx, TPDispName[0]), idx);
	//	tf_SetResult_UUTOffset(TPName[1], result_final_0 + GetOffset(idx, TPDispName[1]), idx);
	//	tf_SetResult_UUTOffset(TPName[2], result_final_2 + GetOffset(idx, TPDispName[2]), idx);		

	//	/////////////////////////////////
	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		//ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::vlo_vee_sply_flt(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{

			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow			
			int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel				= _glob->SPD_Channel_Number;

			String ^ Test_Pin			= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
			double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
			double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
				
			String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
			String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
			String ^ Vector_File		= String::Empty;
			int Sweep_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
			
			double result				= 0;
			double result_vcc_ref		= 0;	//ML
			double result_vcc_trip_dn 	= 0;
			double result_vcc_trip_up 	= 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			int data = 0;
			int i;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s); CheckError(idx, ret, __LINE__);
			CheckError(idx, ret, __LINE__);

			//if(!USE_SPI)
			//{
				ret = RunVectorFile(idx, Vector_File_Start);
				CheckError(idx, ret, __LINE__);
			//} 
			//else
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File_Start);
			//	CheckError(idx, ret, __LINE__);
			//}			
			/////////////////////////////////
			ret = dm[idx]->DPINOff(Test_Pin); 
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOn(Test_Pin);
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			_util->Wait_Sec(On_Delay_s);

			/////////////////////////////////

			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_status = 0;
			int readback = 0;

			int spi_wr_byte_length = 0;
			int spi_rd_byte_length = 0;

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			for (i=0; i<256; i++)
			{
				spi_data[i] = 0;
				delay_s_after_byte[i] = 0;
				spi_rd_data[i] = 0;
				spi_rd_biterror[i] = 0;
			}

			int Start_Data;
			int Stop_Data;
			int Compare_Bit;
			int Compare_Reg_Addr;

			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
			ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); CheckError(idx, ret, __LINE__);				

		for (int i=0; i<total_tp - 1; i++)		// Last test is a calculation test so skipping all these codes
		{
			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
			{
				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");
				
				//if(!USE_SPI) {
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
				CheckError(idx, ret, __LINE__);
				//} else {
				//ret = RunSPI(idx, Vector_File);
				//CheckError(idx, ret, __LINE__);
				//}
	
				swatch.Reset();
				swatch.Start();	
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); CheckError(idx, ret, __LINE__);
					if (spi_status == 2) { //0=idle, 1=busy, 2=done
						if(i == 0) 
						{
							ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_ref); 
							CheckError(idx, ret, __LINE__);
							
							double volt = 0;
							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt); 
							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(idx, ret, __LINE__);
							result_vcc_ref = result_vcc_ref - volt;
						}	
						break;
					}
					swatch.Stop();
				}
			}

			Start_Data				= (int)(tf_TPCondition_Cast(TPName[i], "Start_Data"));
			Stop_Data				= (int)(tf_TPCondition_Cast(TPName[i], "Stop_Data"));
			Compare_Bit				= (int)(tf_TPCondition_Cast(TPName[i], "Compare_Bit"));
			Compare_Reg_Addr		= (int)(tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr"));

			readback = -999;		// Ensuring Default value	

			//Sweep reg
			spi_wr_byte_length = 1;

			int k = Start_Data;
			while(k != Stop_Data)
			{
				int datain = _util->SwapBitSequence(k, 8);

				spi_data_dir[0] = 0x0000000; 
				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS

				spi_status = 0;
			// EW: Can use this alternative	
			//  ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status) 
			//	CheckError(idx, ret, __LINE__);
								
				ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
				CheckError(idx, ret, __LINE__);

				swatch.Reset();	
				swatch.Start();	
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();
					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); 
					CheckError(idx, ret, __LINE__);
					
					if (spi_status == 2) //0=idle, 1=busy, 2=done
						break;
					swatch.Stop();
				}

				if (spi_status == 2)
				{
					spi_data_dir[0] = 0x00000ff; 
					spi_data[0]	= 0x3008000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
					spi_status = 0;
			// EW: Can use this alternative	
			//  ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status) 
			//	CheckError(idx, ret, __LINE__);
					
					ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
					CheckError(idx, ret, __LINE__);
				
					swatch.Reset();	
					swatch.Start();	
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();
						ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); CheckError(idx, ret, __LINE__);
						if (spi_status == 2) { //0=idle, 1=busy, 2=done
							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror); CheckError(idx, ret, __LINE__);
							
							for (int m=0; m<spi_rd_byte_length; m++)
							{
								if (spi_rd_biterror[m] == 0)
								{
									data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
								}
								// else
								//	readback = -999;
							}
								break;
						}	
						swatch.Stop();
					}

					if (i == 0 && readback == ((1 << Compare_Bit) & 0xff))			// vlo_vee_sply_flt DOWN
					{
						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_trip_dn);
						CheckError(idx, ret, __LINE__);

							double volt = 0;
							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(idx, ret, __LINE__);

							result_vcc_trip_dn = result_vcc_trip_dn - volt;

						break;
					}
					else if (i == 1 && readback != ((1 << Compare_Bit) & 0xff))			// vlo_vee_sply_flt UP	
					{
						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_trip_up);
						CheckError(idx, ret, __LINE__);

							double volt = 0;
							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
							CheckError(idx, ret, __LINE__);

							result_vcc_trip_up = result_vcc_trip_up - volt;

						break;
					}							
				}
				if (Start_Data > Stop_Data)
					k--; 
				else
					k++;
			}	//end of while loop		
		}

		double result_final_0 = 0;
		double result_final_1 = 0;
		double result_final_2 = 0;

		result_final_0 = (-3 * result_vcc_trip_dn) / result_vcc_ref;	
		result_final_1 = (-3 * result_vcc_trip_up) / result_vcc_ref;	
		result_final_2 = result_final_0 - result_final_1;
		
		tf_SetResult_UUTOffset(TPName[0], result_final_1 + GetOffset(idx, TPDispName[0]), idx);
		tf_SetResult_UUTOffset(TPName[1], result_final_0 + GetOffset(idx, TPDispName[1]), idx);
		tf_SetResult_UUTOffset(TPName[2], result_final_2 + GetOffset(idx, TPDispName[2]), idx);		

		/////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);

			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
			CheckError(idx, ret, __LINE__);
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//void TestProgram::vlo_vee_sply_flt(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow			
	//		int Bandwidth				= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V			= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V			= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s			= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s		= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s		= (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable				= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC					= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel				= _glob->SPD_Channel_Number;

	//		String ^ Test_Pin			= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
	//		double Drive_Io_A			= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V			= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
	//			
	//		String ^ Vector_File_Start	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Start"));
	//		String ^ Vector_File_End	= (String ^)(tf_TestItemCondition_Cast("Vector_File_End"));
	//		String ^ Vector_File		= String::Empty;
	//		int Sweep_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
	//		
	//		double result				= 0;
	//		double result_vcc_ref		= 0;	//ML
	//		double result_vcc_trip_dn 	= 0;
	//		double result_vcc_trip_up 	= 0;
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		int data = 0;
	//		int i;
	//		array<int>^ HistoryRam = gcnew array<int>(256);

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		/*ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("RWN");
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("WDX");
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
	//		ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
	//		ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		ret = dm[idx]->DPINOn("WDY");
	//		
	//		ret = dm[idx]->Force("MODE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("MODE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("MODE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("MODE");
	//		CheckError(idx, ret, __LINE__); */

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		//if(!USE_SPI)
	//		//{
	//			ret = RunVectorFile(idx, Vector_File_Start);
	//			CheckError(idx, ret, __LINE__);
	//		//} 
	//		//else
	//		//{
	//		//	ret = OnOffSPI(idx, 1);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = RunSPI(idx, Vector_File_Start);
	//		//	CheckError(idx, ret, __LINE__);
	//		//}			

	//		ret = dm[idx]->DPINOff(Test_Pin); 
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Clamp_Vo_V, -2);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = dm[idx]->DPINOn(Test_Pin);
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		_util->Wait_Sec(On_Delay_s);
	//	
	//		/////////////////////////////////

	//		int Start_Data		= 0;
	//		int Stop_Data		= 0;
	//		int Compare_Bit		= 0;
	//		int Compare_Reg_Addr = 0;

	//		int spi_group = 0;
	//		double spi_clk_freq = 2e6;
	//		int spi_status = 0;
	//		int readback = 0;

	//		int spi_wr_byte_length = 0;
	//		int spi_rd_byte_length = 0;

	//		array<int> ^ spi_data = gcnew array<int>(256);
	//		array<int> ^ spi_data_dir = gcnew array<int>(256);
	//		array<int> ^ spi_rd_data = gcnew array<int>(256);
	//		array<int> ^ spi_rd_biterror = gcnew array<int>(256);
	//		array<double> ^ delay_s_after_byte = gcnew array<double>(256);

	//		//sweep_reg
	//		array<int> ^ sweep_step = gcnew array<int>(256);
	//		array<int> ^ reverse_bits = gcnew array<int>(256);
	//		array<int> ^ compare_bits = gcnew array<int>(256);
	//		array<int> ^ compare_value = gcnew array<int>(256);
	//		
	//		for (i=0; i<256; i++)
	//		{
	//			spi_data[i] = 0;
	//			delay_s_after_byte[i] = 0;
	//			spi_rd_data[i] = 0;
	//			spi_rd_biterror[i] = 0;
	//		}

	//		//if(USE_SPI)	//mask by ML
	//		//{			
	//			ret = SPI_Configure(idx, spi_group, spi_clk_freq, "SPC", "SPE", "SPD", "SPD", Input_Channel_Delay_s);
	//			ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD"); CheckError(idx, ret, __LINE__);				
	//		//}
	//		
	//		for (int i=0; i<total_tp-1; i++)		// Last test is a calculation test so skipping all these codes
	//		{
	//			Start_Data				= (int)(tf_TPCondition_Cast(TPName[i], "Start_Data"));
	//			Stop_Data				= (int)(tf_TPCondition_Cast(TPName[i], "Stop_Data"));
	//			Compare_Bit				= (int)(tf_TPCondition_Cast(TPName[i], "Compare_Bit"));
	//			Compare_Reg_Addr		= (int)(tf_TPCondition_Cast(TPName[i], "Compare_Reg_Addr"));			
	//			
	//			if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)		//ML do cleanup on code, remove vector_file_start as run earlier
	//			{
	//				Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");
	//				
	//				//if(!USE_SPI) {
	//				ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
	//				CheckError(idx, ret, __LINE__);

	//				ret = RunVectorFile(idx, Vector_File);
	//				CheckError(idx, ret, __LINE__);

	//				ret = dm[idx]->SPI_CHSEL("DM_2", spi_group, "SPC", "SPE", "SPD", "SPD");
	//				//CheckError(idx, ret, __LINE__);
	//				//} else {
	//				//ret = RunSPI(idx, Vector_File);
	//				//CheckError(idx, ret, __LINE__);
	//				//}

	//				swatch.Reset();	
	//				swatch.Start();	
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();

	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); 
	//					CheckError(idx, ret, __LINE__);
	//					
	//					if (spi_status == 2) { //0=idle, 1=busy, 2=done
	//						if(i == 0) 
	//						{
	//							ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_ref); 
	//							CheckError(idx, ret, __LINE__);
	//								
	//							double volt = 0;
	//							//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt); 
	//							ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//							CheckError(idx, ret, __LINE__);
	//							result_vcc_ref = result_vcc_ref - volt;	
	//						}	
	//						break;
	//					}
	//					swatch.Stop();
	//				}
	//			}

	//			readback = -999;		// Ensuring Default value	

	//			//Sweep reg
	//			spi_wr_byte_length = 2;		//1

	//			int k = Start_Data;
	//			//while(k != Stop_Data)
	//			//{
	//				int datain = _util->SwapBitSequence(k, 8);

	//				spi_data_dir[0] = 0x0000000; 
	//				spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4->T, then deassert NCS
	//				delay_s_after_byte[0] = 25e-9;
	//				if(Start_Data < Stop_Data)
	//				{
	//					sweep_step[0] = 1;
	//				}
	//				else
	//				{
	//					sweep_step[0] = -1;
	//				}
	//				
	//				reverse_bits[0] = 8;
	//				compare_bits[0] = 0; 
	//				compare_value[0] = 0;
	//				
	//				spi_data_dir[1] = 0x00000ff; 		//ML to check next line - 0x3008 or 0x3000
	//				spi_data[1]	= 0x3080000 | ((Compare_Reg_Addr << 8) & 0xff00); //write (MSB->LSB) for RW->PG->A0-A4->T, then read back 8 bits, then deassert NCS
	//				int max_sweep_loop = 256;
	//				sweep_step[1] = 0;
	//				delay_s_after_byte[1] = 5e-9; //100e-9;
	//				reverse_bits[1] = 0;
	//				compare_bits[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit)); 
	//				if(i == 0)
	//				{
	//					compare_value[1] = (1 << (7-Compare_Bit)); //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}
	//				else if(i == 1)
	//				{
	//					compare_value[1] = 0; //((1 << Compare_Bit) & 0xff); //(1 << (8-Compare_Bit));
	//				}

	//				ret = dm[idx]->SPI_SWEEP("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, max_sweep_loop, sweep_step, reverse_bits, compare_bits, compare_value);
	//				CheckError(idx, ret, __LINE__);
	//				
	//					
	//			//	spi_status = 0;
	//			// 	EW: Can use this alternative	
	//			//  ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status) 
	//			//	CheckError(idx, ret, __LINE__);
	//								
	//				//ret = dm->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
	//				//CheckError(idx, ret, __LINE__);

	//				swatch.Reset();	
	//				swatch.Start();	
	//				swatch.Stop();

	//				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//				{
	//					swatch.Start();
	//					
	//					ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); 
	//					CheckError(idx, ret, __LINE__);
	//					
	//					if (spi_status == 2) //0=idle, 1=busy, 2=done
	//						break;
	//						
	//					swatch.Stop();
	//				}

	//				int sweep_count = 0;
	//				ret = dm[idx]->SPI_GET_SWEEP_COUNT("DM_2", spi_group, sweep_count);
	//				
	//				if (spi_status == 2)
	//				{
	//					spi_status = 0;
	//					readback =0;
	//					
	//					// EW: Can use this alternative	
	//					//  ret = SPI(spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status) 
	//					//	CheckError(idx, ret, __LINE__);
	//					
	//					ret = dm[idx]->SPI_RUN("DM_2", spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir);
	//					CheckError(idx, ret, __LINE__);
	//				
	//					swatch.Reset();	
	//					swatch.Start();	
	//					swatch.Stop();

	//					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//					{
	//						swatch.Start();
	//						ret = dm[idx]->SPI_STATUS("DM_2", spi_group, spi_status); 
	//						CheckError(idx, ret, __LINE__);
	//						
	//						if (spi_status == 2) 
	//						{ //0=idle, 1=busy, 2=done
	//							ret = dm[idx]->SPI_RETRIEVE("DM_2", spi_group, spi_rd_byte_length, spi_rd_data, spi_rd_biterror); 
	//							CheckError(idx, ret, __LINE__);
	//							
	//							for (int m=0; m<spi_rd_byte_length; m++)
	//							{
	//								if (spi_rd_biterror[m] == 0)
	//								{
	//									data = _util->SwapBitSequence(spi_rd_data[m], CONST_SERIAL_DATA_WIDTH);
	//									readback = (data & ((1 << Compare_Bit) & 0xff)) & 0xff;
	//								}
	//								// else
	//								//	readback = -999;
	//							}
	//								break;
	//						}	
	//						swatch.Stop();
	//					}

	//					if (i == 0 && readback == ((1 << Compare_Bit) & 0xff))			// vlo_vee_sply_flt DOWN
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_trip_dn);
	//						CheckError(idx, ret, __LINE__);

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						result_vcc_trip_dn = result_vcc_trip_dn - volt;

	//						break;
	//					}
	//					else if (i == 1 && readback != ((1 << Compare_Bit) & 0xff))			// vlo_vee_sply_flt UP	
	//					{
	//						ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result_vcc_trip_up);
	//						CheckError(idx, ret, __LINE__);

	//						double volt = 0;
	//						//ret = Measure_GNDS_Voltage(site, NPLC, Measure_Delay_s, volt);
	//						ret = smu[idx]->ReadVoltage("GND_MUX_SENSE", volt);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						result_vcc_trip_up = result_vcc_trip_up - volt;

	//						break;
	//					}							
	//				}
	//				//if (Start_Data > Stop_Data)
	//				//	k--; 
	//				//else
	//				//	k++;
	//			//}	//end of while loop	
	//				
	//		}

	//		double result_final_0 = 0;
	//		double result_final_1 = 0;
	//		double result_final_2 = 0;

	//		result_final_0 = (-3 * result_vcc_trip_dn) / result_vcc_ref;	
	//		result_final_1 = (-3 * result_vcc_trip_up) / result_vcc_ref;	
	//		result_final_2 = result_final_0 - result_final_1;

	//		tf_SetResult_UUTOffset(TPName[0], result_final_0 + GetOffset(idx, TPDispName[0]), idx);
	//		tf_SetResult_UUTOffset(TPName[1], result_final_1 + GetOffset(idx, TPDispName[1]), idx);
	//		tf_SetResult_UUTOffset(TPName[2], result_final_2 + GetOffset(idx, TPDispName[2]), idx);

	//		/////////////////////////////////
	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		//ret = dm->SPI_CH_UNSEL("DM_2", spi_group);

	//		ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	void TestProgram::iwth(Object^ object) //JL: add new test = Iwth
	{
			//JL: DM_Setting:
			//	  RWN = 0, WDX = 1, WDY = 0
			//    CBIT:
			//    RWN > DM; CBIT 20
			//	  W1X > DM; CBIT 14
			//	  W1Y > DM; direct
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{			
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;

			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File")); //iwth.txt
			String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1")); //iwth_1.txt

			String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P")); //W1X			
			String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N")); //W1Y

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			int vector_engine_status = 0; //JL: do we need this?

			Stopwatch swatch; //JL: do we need this?
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			//JL: Disable pins not used in test? Only RWN/WDX/WDY is needed.
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDX");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDY");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);
			
			/*ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SYNC");
			CheckError(ret, __LINE__);*/
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			//JL: run Vector file iwth.txt
			/*JL: Vector file summary:
			Load default vector		
			Program Fault Mask:  p1_reg10 = 1111 1101b (clear bit 1, Enable power supply fault; low Vcc and low Vee fault detection), p3_reg11 = 1100 0000 (bit 5:0 of p3_req11 defaults to 0)
			Set Fault Status = 0: p1_reg8 = 0; write any value to reset fault status register		
			Program HSEL=1; select Head 1
			*/
			
			if(!USE_SPI)
			{
				ret = OnOffSPI(idx, 0);  // sidi_iwth
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			} 
			else 
			{
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}
			
			/////////////////////////////////////
					
			const double VEE_N = 3.0; //JL: Nominal Vee value
			const double VCC_N = 5.0; //JL: Nominal Vcc value
			//Test variables
			double vee, vcc;
			double vee_v = 0; 
			double w1x_v = 0;
			double w1y_v = 0;
			double vdiff = 0;
			double wrt = 0;
			double vcc_por = 0;
			double jl_debug = 0; //JL: for debug only

			//Param 0 test
			
			//Setup DM to measure voltage difference between W1X/W1Y
			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			
			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);

			//Increase Vee voltage from VEE_N(-3V) to -2.79V, in +0.1V step at 500us interval per step 
			for(vee=VEE_N; vee>=2.79; vee-=0.1)
			{
				ret = smu[idx]->DriveVoltage("VEE", vee);
				CheckError(idx, ret, __LINE__);
				
				//_util->Wait_Sec(0.5e-6);
			}
			
			//Continue to increase Vee voltage to -2.29V, in +0.02V step at 500us interval per step. *Vee depends on VEELowThreshold (pg2_reg10 bit 7, 0=Vee fault threshold Vf_Vee=-2.59, 1=Vf_Vee=-2.39), default of this bit is 0. 
			//a. Read DC Volt Meter result. 
			//b. Take the absolute value (drop the - sign), devide by Writer Load value (3.0 - *note: could be different load value on Aemulus); store result as wrt. Vdiff/Load = current, is this Iw_flt?
			//c. If wrt <5m, break from the loop
			
			for(; vee>=2.29; vee-=0.02)
			{
				ret = smu[idx]->DriveVoltage("VEE", vee);
				CheckError(idx, ret, __LINE__);
				
				//_util->Wait_Sec(0.5e-6);
				
				//Read  w1x/w1y voltages
				ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, w1x_v);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, w1y_v);
				CheckError(idx, ret, __LINE__);
				
				vdiff = fabs(w1x_v-w1y_v);
				wrt = vdiff / 3.0; //JL: 3.0 = writer load/write head resistance
				
				if(wrt < 5e-3)
				{
					vee_v = vee; //Store the corresponding Vee where the wrt first cross < 5m
					break;
				}
			}
			//Return Vee as result to param 0. If wrt never met < 5m, return  0.
			tf_SetResult_UUTOffset(TPName[0], (vee_v*-1) + GetOffset(idx, TPDispName[0]), idx);
			
			//Reset Vee voltage to VEE_N(-3V)
			ret = smu[idx]->DriveVoltage("VEE", VEE_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(0.1e-3);			//ML old 10e-3
			//smu->Measure("VEE", AM_CONST_DICV,read_vee);//JL: double check VEE
			
			
			/////////////////////////////////////
			//Param 1 test
			//Test if writes resume with fault is removed.
			//Read  w1x/w1y voltages. wrt_resume = absolute value of the result / 3.0 (Writer Load). 

			ret = dm[idx]->DrivePin("WDX", 1);  // sidi_iwth
			CheckError(idx, ret, __LINE__);   //sidi_iwth
			
			ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, w1x_v);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, w1y_v);
			CheckError(idx, ret, __LINE__);
				
			vdiff = fabs(w1x_v-w1y_v);
			wrt = vdiff / 3.0; //JL: 3.0 = writer load/write head resistance
			
			//JL: according to Catalyst program: wrt_resume = wrt_resume*(1-0.09*wrt_resume/70mA); *Iw = 40mW +/- 2mA
			wrt = wrt * (1-0.09*wrt/70e-3);
			
			//Return wrt_resume as result to param 1.
			tf_SetResult_UUTOffset(TPName[1], wrt + GetOffset(idx, TPDispName[1]), idx);
			
			/////////////////////////////////////
			//Param 2 test
			//Run vector file Vector_File_1: Enable writer on supply fault
			ret = RunVectorFile(idx, Vector_File_1);
			CheckError(idx, ret, __LINE__);
			
			//Raise Vee from VEE_N? (-3V) to param 0 value (vee_v) + 100mV, in 100mV step. No explicit time delay in code.
			for(vee=VEE_N; vee>=(vee_v - 0.1); vee-=0.1)
			{
				ret = smu[idx]->DriveVoltage("VEE", vee);
				CheckError(idx, ret, __LINE__);
				
				//_util->Wait_Sec(0.5e-6);
			}
			//Lower Vcc from VCC_N? (5V) to 3.6V in 100mW step. No explicit time delay in code.
			for(vcc=VCC_N; vcc>=3.6; vcc-=0.1)
			{
				ret = smu[idx]->DriveVoltage("VCC", vcc);
				CheckError(idx, ret, __LINE__);
				
				//_util->Wait_Sec(0.5e-6);
			}
			
			//toggle RWN
			//JL: Catalyst code toggle RWN=1. However this seems to means turn on Writer
			//    
			/*ret = dm[idx]->DPINOff("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_DIO);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 0, 0, 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DrivePin("RWN", 1);
			CheckError(ret, __LINE__);*/

			//Read  w1x/w1y voltages
			ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, w1x_v);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, w1y_v);
			CheckError(idx, ret, __LINE__);
				
			//Take the absolute value (drop the - sign), devide by Writer Load value (3.0 - *note: could be different load value on Aemulus); store result as wrt.
			vdiff = fabs(w1x_v-w1y_v);
			wrt = vdiff / 3.0; //JL: 3.0 = writer load/write head resistance
			
			//Wrt=wrt*(1-0.09*wrt_resume/70mA);
			wrt = wrt * (1-0.09*wrt/70e-3); //JL: according to Catalyst program
			
			//Return wrt as result to param 2.
			tf_SetResult_UUTOffset(TPName[2], wrt + GetOffset(idx, TPDispName[2]), idx);
			
			//Set Vee to VEE_N? (-3V). Wait 3ms.
			ret = smu[idx]->DriveVoltage("VEE", VEE_N);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(3e-3); //JL: may not need to wait
			
			/////////////////////////////////////
			//Param 3 test
			//Read low limit of param 3; 2.55V 
			vcc_por = (double)(tf_TestParameter_MinLimit(TPName[3]));
			
			//Modify vcc_por to 90%; vcc_port *= 0.9
			vcc_por *= 0.9;
			
			//Further reduce Vcc from current value down to vcc_por obtained from step 3 above, in -10mV step.
			for(; vcc>=vcc_por; vcc-=0.1)
			{
				ret = smu[idx]->DriveVoltage("VCC", vcc);
				CheckError(idx, ret, __LINE__);
				
				//_util->Wait_Sec(0.0005);	//ML enable
				
				//Read  w1x/w1y voltages, take absolute and divide by 3.0 (Writer Load). 
				ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, w1x_v);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, w1y_v);
				CheckError(idx, ret, __LINE__);
				//_util->Wait_Sec(0.0005);	//Ml add
				
				vdiff = fabs(w1x_v-w1y_v);
				wrt = vdiff / 3.0; //JL: 3.0 = writer load/write head resistance
				//Stop reducing once the value reaches <5mA.
				if( wrt < 5e-3)
				{
					break;
				}
			}
			
			//Return this Vcc value to param 3.
			tf_SetResult_UUTOffset(TPName[3], vcc + GetOffset(idx, TPDispName[3]), idx);
			
			//Set Vcc to VCC_N? (5V). Wait 500us.
			ret = smu[idx]->DriveVoltage("VCC", VCC_N);
			CheckError(idx, ret, __LINE__);
			
			//_util->Wait_Sec(3e-3); //JL: may not need to wait
			
			/////////////////////////////////////
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}			
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::por_flt(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{			
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;
			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
			
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff("FLTMUX");
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			
			//for measuring current
			//ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", 0.002);
			//ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", 0);
			//for measuring voltage
			ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit("FLTMUX", Clamp_Vo_V, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel("FLTMUX", 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("FLTMUX");
			CheckError(idx, ret, __LINE__);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//JL: run Vector file to initialize the test
			//ML convert to vector method
			if(!USE_SPI) {
				ret = RunVectorFile(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);

			} else {
				ret = OnOffSPI(idx, 1);
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, "write_default_reg");
				CheckError(idx, ret, __LINE__);
				ret = RunSPI(idx, Vector_File);
				CheckError(idx, ret, __LINE__);
			}

			
			//ret = RunVectorFile(idx, "write_default_reg");
			//CheckError(idx, ret, __LINE__);
			//
			//ret = OnOffSPI(idx, 1);
			//CheckError(idx, ret, __LINE__);
			//
			///////////////////////////////////////
			//ret = WriteSPI(idx, 1, 10, 0xfd); //enable supply fault, bit1=0; disable all other faults
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 3, 11, 0xc0); //disable FHS Open/Short fault.
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 1, 8, 0x00); //clear FSR
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 2, 4, 0x00);  //Bias mode = VBias,pg2_reg4[6]=0
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 1, 5, 0xfc);//Reader VBias MRBias = 252 (0xfc), pg1_reg5
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 2, 10, 0x10);//Enable reader on supply fault, pg2_reg10[4]=1		
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 1, 14, 0x42);//SleepOnLowVEE = 0, pg1_reg14[6], default bit1=1 
			//CheckError(idx, ret, __LINE__);
			////SupplyVeryLowFlt: RWTestCtl = 0x01, RWTestA=0x30, RWTestB=3+(2<<6) = 1000_0011
			//ret = WriteSPI(idx, 3, 7, 0x01);
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 3, 9, 0x30); //Bypass AMUX; set IO_FLT_AMux_Bypass, IO_FLT_AMux_Select
			//CheckError(idx, ret, __LINE__);
			//ret = WriteSPI(idx, 3, 10, 0x83);//Enable AMUX, BandGapTest; 
			//CheckError(idx, ret, __LINE__);
				
			double lim_vcc = (double)tf_TestParameter_MinLimit(TPName[1]); //get low limit of Vcc from Techflow param 1. 
			lim_vcc *= 0.9;
			double hilim_vcc = (double)tf_TestParameter_MaxLimit(TPName[1]); //get high limit of Vcc from Techflow param 1. 
			hilim_vcc *= 1.01;
			double por_event = 0;
			double vcc_save = 0;
			double vcc_por = 10;
			double vbg = 0;
			double vcc = 0;
			int j = 0;
			array<double> ^ values = gcnew array<double>(500);		//200 by JL
			
			for(j=0;j<500; j++)	//ori 200
				values[j] = 0;		
			
			for(vcc=Drive_Vcc_V; vcc >= hilim_vcc; vcc -=0.1, j++)	//remove i++
				ret = smu[idx]->DriveVoltage("VCC", vcc);
					
			for(j = 0; vcc >= lim_vcc; vcc -=0.01, j++)	//remove i++
			{
				ret = smu[idx]->DriveVoltage("VCC", vcc);
				smu[idx]->Measure("VCC", AM_CONST_DICV, vcc);
				ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, vbg);
				values[j++] = vbg;	//JL values[j]
				if(j>2)
				{
					por_event = vbg - values[j-2];

					if(fabs(por_event) > 0.05)
						break;
					else
					{				
						vcc_save = values[j];
						//break;	//ML add
					}
				}			
				
			}
			vcc_por = vcc;
			
			tf_SetResult_UUTOffset(TPName[0], vcc_save + GetOffset(idx, TPDispName[0]), idx); 
			tf_SetResult_UUTOffset(TPName[1], vcc_por + GetOffset(idx, TPDispName[1]), idx); 

			/////////////////////////////////////

			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//if(Debug_Enable == true)
			//{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			//}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::fhs_ishort(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{	
			//Get test param from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();
			
			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
			double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
			double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
			double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));//
			double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));//
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
			int SPD_Channel			= _glob->SPD_Channel_Number;
			String ^ Test_Pin_N			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_N")); //S0N_F
			String ^ Test_Pin_P			= (String ^)(tf_TestItemCondition_Cast("Test_Pin_P")); //S0P_F
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;
			
			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);		
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			
			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;
			
			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);
			
			//ret = dm[idx]->DPINOff("FLTMUX");
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DVCI);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange("FLTMUX", Clamp_flt_A);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUVoltageLevel("FLTMUX", Drive_flt_V);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("FLTMUX");
			//CheckError(idx, ret, __LINE__);
			
			//ret = dm[idx]->DPINOff(Test_Pin_P);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);		
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);	
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DVCI);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_P, 0.02);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_P, 0);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn(Test_Pin_P);
			//CheckError(idx, ret, __LINE__);
			//
			//ret = dm[idx]->DPINOff(Test_Pin_N);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DVCI);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_P, 0.02);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUVoltageLevel(Test_Pin_P, 0);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn(Test_Pin_N);
			//CheckError(idx, ret, __LINE__);
		
			
			_util->Wait_Sec(On_Delay_s);
			
			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//JL: run Vector file to initialize the test
			
			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////////
			int reg_val = 0;
			double vdiff = 0;
			double sp_v = 0;
			double sn_v = 0;
			double Rfhs = 5.11 + 2*37.4; //JL: Rfhs = R31 + 2*R30; 
										 //    R31=5.11;        /* Transmission line divider shunt */
										 //    R30=37.4;        /* Fly height head load /2 */
			double RS_base = 0;
			double RS_trip_safe = 0;
			double RS_trip_fail = 0;
			
			//FHS IBias = 12 = 1100b, IBias[6:0]: pg2_reg2[5:0] + pg2_reg12[3]
			ret = WriteSPI(idx, 2, 4, 0x40);
			ret = WriteSPI(idx, 2, 2, 0x06); 
			ret = WriteSPI(idx, 2, 12, 0x00);  
			//FHS Imode=1, pg2_reg4[6]=1
			//FHS Enable, pg2_reg4[4]=1
			ret = WriteSPI(idx, 2, 4, 0x50);  
			
			//enable sense fault, pg1_reg10[4]=0
			ret = WriteSPI(idx, 1, 10, 0xef);
			//ret = WriteSPI(idx, 3, 11, 0xc0);
			//clear FSR
			ret = WriteSPI(idx, 1, 8, 0x00);
			
			//ROTestCtl = 26
			ret = WriteSPI(idx, 3, 8, 26);
			ret = ReadReg(idx, 3, 8, reg_val);
			//param 0
			//read pg3_reg4, verify bit1 = 0 (Fault_Filtered_FHSShort)
			ret = ReadReg(idx, 3, 4, reg_val);
			reg_val &= 0x02;	//0x02
			if(reg_val == 0)
				tf_SetResult_UUTOffset(TPName[0], 1 + GetOffset(idx, TPDispName[0]), idx); //pass
			else
				tf_SetResult_UUTOffset(TPName[0], 0 + GetOffset(idx, TPDispName[0]), idx); //fail
			
			//Param 1
			//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, sp_v);
			//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, sn_v);
			ret = dm[idx]->DPINOff("GRP1_DIFF_SENSE");
			ret = dm[idx]->Force("GRP1_DIFF_SENSE", DM_CONST_FORCE_STATE_PMU);		
			ret = dm[idx]->ConfigurePMUSamplingTime("GRP1_DIFF_SENSE", NPLC, DM_CONST_PLC);	
			ret = dm[idx]->ConfigurePMUOutputFunction("GRP1_DIFF_SENSE", DM_CONST_DICV);
			ret = dm[idx]->ConfigurePMUVoltageLimit("GRP1_DIFF_SENSE", 0.5, 0);
			ret = dm[idx]->ConfigurePMUCurrentLevel("GRP1_DIFF_SENSE", 0);
			ret = dm[idx]->DPINOn("GRP1_DIFF_SENSE");
			_util->Wait_Sec(On_Delay_s);
			ret = dm[idx]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, RS_base);
			RS_base = fabs(RS_base);
			//RS_base = fabs(sp_v - sn_v);
			RS_trip_safe = fabs((35.75e-3 - RS_base)/CONST_Rfhs); //35.75mV = upper limit for the fault
			
			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 2, -2);		//ML change from -5 to -2
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, RS_trip_safe); 
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_P, -0.002);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 2, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, -RS_trip_safe); 
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_P, 0.002);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			
			//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, sp_v);
			//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, sn_v);
			ret = dm[idx]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, vdiff);
			CheckError(idx, ret, __LINE__);

			//Ml add
			if(Test == TEST_QS_BLKDGN_DUT || Test == TEST_QS_BLKDGN_DUT_IF2)
				vdiff = _glob->PolRD_DUT[0, idx]*vdiff;
			else 
				vdiff = _glob->PolRD_PROBE[0, idx]*vdiff;
			
			//vdiff = fabs(sp_v - sn_v);
			RS_trip_safe = vdiff;
			
			tf_SetResult_UUTOffset(TPName[1], RS_trip_safe + GetOffset(idx, TPDispName[1]), idx); 
			
			//Param 2
			//read pg3_reg4, verify bit1 = 0 (Fault_Filtered_FHSShort)				
			ret = ReadReg(idx, 3, 4, reg_val);
			reg_val &= 0x02;
			if(reg_val == 0)
				tf_SetResult_UUTOffset(TPName[2], 1 + GetOffset(idx, TPDispName[2]), idx); //pass
			else
				tf_SetResult_UUTOffset(TPName[2], 0 + GetOffset(idx, TPDispName[2]), idx); //fail
			
			//Param 3
			RS_trip_fail = fabs((10.25e-3 - RS_base)/CONST_Rfhs); //10.25mV = the lower limit for the fault

			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_P, DM_CONST_FORCE_STATE_PMU);		
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_P, NPLC, DM_CONST_PLC);	
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_P, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_P, 2, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, -RS_trip_fail); 		
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_P, -RS_trip_fail);
			ret = dm[idx]->DPINOn(Test_Pin_P);
			CheckError(idx, ret, __LINE__);
			
			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->Force(Test_Pin_N, DM_CONST_FORCE_STATE_PMU);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin_N, NPLC, DM_CONST_PLC);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin_N, DM_CONST_DICV);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin_N, 2, -2);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, RS_trip_fail); 
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePMUCurrentLimitRange(Test_Pin_P, RS_trip_fail);
			ret = dm[idx]->DPINOn(Test_Pin_N);
			CheckError(idx, ret, __LINE__);
			_util->Wait_Sec(On_Delay_s);
			
			//ret = dm[idx]->PMUMeasure(Test_Pin_P, DM_CONST_MEASUREVOLTAGE, sp_v);
			//ret = dm[idx]->PMUMeasure(Test_Pin_N, DM_CONST_MEASUREVOLTAGE, sn_v);
			//vdiff = fabs(sp_v - sn_v);
			ret = dm[idx]->PMUMeasure("GRP1_DIFF_SENSE", DM_CONST_MEASUREVOLTAGE, vdiff);
			CheckError(idx, ret, __LINE__);
			RS_trip_fail = fabs(vdiff);
			
			tf_SetResult_UUTOffset(TPName[3], RS_trip_fail + GetOffset(idx, TPDispName[3]), idx);
			
			//Param 4
			//read pg3_reg4, verify bit1 = 1 (Fault_Filtered_FHSShort)	
			//ret = WriteSPI(idx, 3, 8, 26);
			ret = ReadReg(idx, 3, 4, reg_val);
			reg_val &= 0x02;
			if(reg_val == 2)
				tf_SetResult_UUTOffset(TPName[4], 1 + GetOffset(idx, TPDispName[4]), idx); //pass
			else
				tf_SetResult_UUTOffset(TPName[4], 0 + GetOffset(idx, TPDispName[4]), idx); //fail
			
			//clean up
			
			/*****Power down*****/
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_P, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff(Test_Pin_P);
			CheckError(idx, ret, __LINE__);		
			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin_N, 0);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOff(Test_Pin_N);
			CheckError(idx, ret, __LINE__);						
			
			if(USE_SPI)
			{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::wr_flt_timing(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;

			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);
			int data = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			
			/////////////////////////////////

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			vih = 1.8;
			ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDX");
			CheckError(idx, ret, __LINE__);

			vih = 1.5;
			ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDY");
			CheckError(idx, ret, __LINE__);

			//if(!USE_SPI) 
			//{
			//	ret = RunVectorFile(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//} 
			//else 
			//{
			//	ret = OnOffSPI(idx, 1);
			//	CheckError(idx, ret, __LINE__);
			//	ret = RunSPI(idx, Vector_File);
			//	CheckError(idx, ret, __LINE__);
			//}

			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);
			
			/* Code for 2935, different test flow on 2945
			for(int j=30; j<50; j++) //Catalyst's result is i=38, freq=3.44828MHz
			{
				//In Aemulus test, a full cycle consist 2 pulses (high - low).
				//In Catalyst test, a full cycle consist of 4 pulses (high - low - high - low). That means whatever freq set in Catalyst need to times 2 for Aemulus. Proved by observing scope shot. 
				freq	= 1/(100e-9 + 5e-9*j); //start with 4MHz, follow catalyst
				period	= 1/(freq*2);//times 2 is because 8 MHz for Aemulus.
				
				ret = dm[idx]->DPINPeriod("DM_2", 99, period); //always change no set 99 only
				CheckError(idx, ret, __LINE__);
			
				//sweep WDX and WDY freq
				ret = dm[idx]->SPI_CH_UNSEL("DM_2", 0);
				CheckError(idx, ret, __LINE__);

				ret = RunVectorFile(idx, "WDX_WDY_6400bits");
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->SPI_CHSEL("DM_2", 0, "SPC", "SPE", "SPD", "SPD");
				CheckError(idx, ret, __LINE__);

				//Read p1_reg6 and check for bit1 status
				#ifndef USE_SPI
				ret = ReadVector("read_p1_reg6_wr_flt_timing", data);
				CheckError(idx, ret, __LINE__);
				#else
				ret = ReadSPI("read_p1_reg6_wr_flt_timing", data);
				CheckError(idx, ret, __LINE__);
				#endif
				
				result_adc = data & 0x02;

				//Read p1_reg8 and check for bit2 status
				#ifndef USE_SPI
				ret = ReadVector("read_p1_reg8_wr_flt_timing", data);
				CheckError(idx, ret, __LINE__);
				#else
				ret = ReadSPI("read_p1_reg8_wr_flt_timing", data);
				CheckError(idx, ret, __LINE__);
				#endif

				result_adc2 = data & 0x04;

				if((result_adc == 2) && (result_adc2 == 4)) //if any of the FLT bit is triggered, then break
				{
					break;
				}
				else //reset & loop
				{
					result_adc	= 0;
					result_adc2 = 0;
				}
			} 

			result_wr_timing = period;
			*/
			int lolim_result = 0; //0 indicate test pass, 1 fail.
			int hilim_result = 0; 
			double lolim = 50e-9; //50ns
			double hilim = 100e-9; //100ns
			int pin_val = 0;
			int reg_val = 0;
			int test_result = 0; //0 indicate test pass, 1 fail.
			double period = 0;
			double freq = 0;
			
			//pwr_up
			ret = RunVectorFile(idx, "write_dig_faults"); //JL: write_dig_faults is the same as Catalyst vector "pwr_up"
			CheckError(idx, ret, __LINE__);
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);

			//enable WDataFLoFlt
			ret = WriteSPI(idx, 1, 10, 0xbf);
			CheckError(idx, ret, __LINE__);
			//clear_fsr
			ret = WriteSPI(idx, 1, 8, 0);
			CheckError(idx, ret, __LINE__);

			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);
			
			for(int i=0; i<2; i++) //i=1 test lolim, i=2 test hilim
			{	
				if(i==0)//lolim settings
				{
					freq = 1/lolim/2.0;
				}	
				else //hilim settings
				{
					freq = 1/hilim/2.0;
				}
				//In Aemulus test, a full cycle consist 2 pulses (high - low).
				//In Catalyst test, a full cycle consist of 4 pulses (high - low - high - low). That means whatever freq set in Catalyst need to times 2 for Aemulus. Proved by observing scope shot. 
				
				period	= 1/(freq*2);//times 2 is because 8 MHz for Aemulus.
				
				ret = dm[idx]->DPINPeriod("DM_2", 99, period); //always change no set 99 only
				CheckError(idx, ret, __LINE__);		
				
				//enable writer: RWN=0, toggles WDX/WDY
				ret = RunVectorFile(idx, "WDX_WDY_6400bits");
				CheckError(idx, ret, __LINE__);
				//by end of the vector file, RWN=1
				
				//check FLTMUX, verify no fault
				//default RWN=1 > read mode. Verify no fault, FLTMUX=1
				//JL: too late to check FLTMUX pin in test program, fault removed at the end of vector.
				//    Best is to check in vector file, or not checking this at all.
				/*ret = dm[idx]->ReadPin("FLTMUX", pin_val);
				if(pin_val != 1)
					test_result=1;	*/

				ret = OnOffSPI(idx, 1);	
				CheckError(idx, ret, __LINE__);				
				//chk_fsr_NoFaults
				ret = ReadReg(idx, 1, 8, reg_val); //verify no fault in FSR
				CheckError(idx, ret, __LINE__);
				if(reg_val != 0)
					test_result=1;
				
				//clear_fsr
				ret = WriteSPI(idx, 1, 8, 0);
				CheckError(idx, ret, __LINE__);
							
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);

				if(i==0)//set lolim result
					lolim_result = test_result;
				else //set hilim result
					hilim_result = test_result;
			}
			ret = OnOffSPI(idx, 1);
			CheckError(idx, ret, __LINE__);
			//mask all faults
			ret = WriteSPI(idx, 1, 10, 0xff);
			CheckError(idx, ret, __LINE__);
			ret = OnOffSPI(idx, 0);
			CheckError(idx, ret, __LINE__);
			
			tf_SetResult_UUTOffset(TPName[0], (hilim_result && !lolim_result) + GetOffset(idx, TPDispName[0]), idx); //expect hilim to fail, lolim to pass. Return 1 if meeting expected results.
		
			/////////////////////////////////
			//if(USE_SPI)
			//{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			//}
			
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::flt_timing(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test param name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Hsel = gcnew array<String ^>(total_tp);
			array<String ^> ^ Vector_File_Fault = gcnew array<String ^>(total_tp);
			array<int> ^ Fault_Type = gcnew array<int>(total_tp);
			
			
			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				Vector_File_Hsel[i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_Hsel"));
				Vector_File_Fault[i] = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_Fault"));
				Fault_Type[i] = (int)(tf_TPCondition_Cast(TPName[i], "Fault_Type"));
			}

			//JL: max/min_limit[0]: STU limits; max/min_limit[1]:UTS limits
			array<double> ^ max_limit = gcnew array<double>(2);
			array<double> ^ min_limit = gcnew array<double>(2);
			
			//JL: Since there are only 2 sets of limits (STU and UTS) for this test,
			//    will only look for the first (param index=0) and 3rd param (param index 2) 
			//    to get these 2 sets of limits for the interest of test time.
			for (int i=0; i<2; i++)
			{
				max_limit[i] = (double)(tf_TPHighLimit_Cast(TPName[i*2]));
				min_limit[i] = (double)(tf_TPLowLimit_Cast(TPName[i*2]));
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			int SPD_Channel			= _glob->SPD_Channel_Number;

			String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
			
			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

			double timing_result = 0;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			double tmu_start_threshold = 0;
			double tmu_stop_threshold = 0;
			double tmu_start_hysteresis = 0;
			double tmu_stop_hysteresis = 0;
			int number_of_samples = 0;
			double tmu_timeout = 0;
			int returned_sample_count = 0;
			array<double> ^ sampled_result;
			int retest_count = 0;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDX");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("WDY");
			CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("RWN");
			//CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SYNC");
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//Must use vector method
			//JL: run Vector file write_flt_timing_0
			/*JL: Vector file summary:
			Load default vector
			Program HSEL=0; select Head 0
			Program Fault Mask:  p1_reg10 = 1011 1111b, p3_reg11 = 1100 0000 (bit 5:0 of p3_req11 defaults to 0)
			Set Fault Status = 0: p1_reg8 = 0; write any value to reset fault status register
			*/
			ret = RunVectorFile(idx, Vector_File);
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			tmu_start_threshold = 0.2; //JL: changed to 0.2 per latest 2935_47S source code; original value was 0.8. Note, these init value is not used, both start/stop theshold will change to diff value for STU and UTS.
			tmu_stop_threshold = 0.2; //JL: changed to 0.2 per latest 2935_47S source code; original value was 0.8
			tmu_start_hysteresis = 0.02;//0.2;
			tmu_stop_hysteresis = 0.02;//0.2;
			number_of_samples = 1;
			tmu_timeout = 10e-3;
			sampled_result = gcnew array<double>(number_of_samples);
			retest_count = 0;

			for (int i=0; i<number_of_samples; i++)
			{
				sampled_result[i] = 0;
			}

			/////////////////////////////////
			/*
			JL: Referring to 2935_47S source code, it uses different TMU start stop threshold. 
				After I corrected the STU/UTS vector files for WDX/WDY to match
				Catalyst's vector, there is no need to use different TMU
				start/stop threshold value for STU/UTS vectors. Able to consistently
				capture the correct timing on first run after multiple characterization,
				never when into retries; test passed with retest_count=0 consistently.
			*/
			tmu_start_threshold = 0.8;
			tmu_stop_threshold = 0.8;

			for (int i=0; i<total_tp; i++) //JL: loop through each params
			{
				//JL: Select head
				//JL: run vector file write_hsel_0: w_p1_reg10 = 1000 0000b: Select Head 0
				//JL: run vector file write_hsel_1: w_p1_reg10 = 1000 0001b: Select Head 1
				ret = RunVectorFile(idx, Vector_File_Hsel[i]);
				CheckError(idx, ret, __LINE__);
				
				if(Fault_Type[i] == 0) //STU
				{
					//JL: Safe to Unsafe - tD1: transition of WDX/WDY followed by no transition for 60-100ns
					ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
					//CheckError(idx, ret, __LINE__);		//ML comment for 47S "unknown error"
					
					ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
					//CheckError(idx, ret, __LINE__);		//ML comment out

					//_util->Wait_Sec(0.5e-3);				
				}
				else //UTS
				{				
					//JL: Unsafe to save - tD2: transition of WDX/WDY to WDFL (Write data Freq Low) safe
					ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
					CheckError(idx, ret, __LINE__);
					ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
					CheckError(idx, ret, __LINE__);
					
					//_util->Wait_Sec(1e-3);
				}
			
				retest_count = 0;

				while(retest_count < TIMING_RESET_COUNT)
				{
					ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(1e-3);	//ML

					//JL: Run vector "write_flt_stu"
					//JL: Begin with WDx/WDy toggling at 100ns (10Mhz), while SYNC remains 0.
					//JL: SYNC transition from 0>1 (start TMU)at the point of last transition of WDx/WDy
					//JL: TMU will stop at FLTMUX transition from 0>1 when WDx/WDy stop transitioning for > 60ns
					ret = RunVectorFile(idx, Vector_File_Fault[i]);
					CheckError(idx, ret, __LINE__);

					//_util->Wait_Sec(0.1e-3);
				
					ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
					if(ret)
					{
						ret = 0;
						retest_count++;
					}
					else
					{					
						if ((sampled_result[0] < min_limit[Fault_Type[i]]) || (sampled_result[0] > max_limit[Fault_Type[i]]))
							retest_count++;
						else
							break;
					}
				
				}

				if (Double::IsNaN(sampled_result[0]) == false)
					timing_result = sampled_result[0];
					
				tf_SetResult_UUTOffset(TPName[i], timing_result + GetOffset(idx, TPDispName[i]), idx);
			}

			/*****Power down*****/
			//if(USE_SPI)
			//{
				ret = OnOffSPI(idx, 0);
				CheckError(idx, ret, __LINE__);
			//}

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			if(Debug_Enable == true)
			{
				ret = ResetDMPin(idx, TPDispName[0]);
				CheckError(idx, ret, __LINE__);

				//IO setting
				ret = ResetCBit(idx);
				CheckError(idx, ret, __LINE__);
				ret = ResetMuxIO(idx);
				CheckError(idx, ret, __LINE__);
			}
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	void TestProgram::fhs_dcdet_flt(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
			String ^ Vector_File	= "";

			String ^ Vector_File_Rd	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Rd"));
			int Start_Data				= (int)(tf_TestItemCondition_Cast("Start_Data"));
			int Stop_Data				= (int)(tf_TestItemCondition_Cast("Stop_Data"));
			int Sweep_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Sweep_Reg_Addr"));
			int Comp_Reg_Addr			= (int)(tf_TestItemCondition_Cast("Comp_Reg_Addr"));

			if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
				Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
					
			double vih = 2.5;
			double vil = 0.00;
			double voh = 0.75; 
			double vol = 0.75;
			double ioh = 0.002;
			double iol = 0.002;
			double vch = 6;
			double vcl = -0.1;
			double vt = 0;

			int vector_engine_status = 0;
			int data = 0;
			array<int>^ HistoryRam = gcnew array<int>(256);

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			ret += DriveCBit(idx, TPDispName[0]);
			ret += smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);

			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPE");
			ret += dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPD");
			ret += dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("SPC");
					
			ret += dm[idx]->DPINOff("FLTMUX");
			ret += dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_VECTOR);
			ret += dm[idx]->ConfigurePEAttribute("FLTMUX", 1, 0, 0, 0); 
			ret += dm[idx]->DPINLevel("FLTMUX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			ret += dm[idx]->DPINOn("FLTMUX");

		//ret += dm[idx]->DPINOff("FLTMUX");
		//ret += dm[idx]->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
		//ret += dm[idx]->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
		//ret += dm[idx]->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
		//ret += dm[idx]->ConfigurePMUVoltageLimit("FLTMUX", 6, -2);
		//ret += dm[idx]->ConfigurePMUCurrentLevel("FLTMUX", 0);
		//ret += dm[idx]->DPINOn("FLTMUX");

			//Configure Input Delay
			ret += dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			ret = DriveDMPin(idx, TPDispName[0]); 		
			CheckError(idx, ret, __LINE__);

			/////////////////////////////////

			double result_adc = 0;
			int spi_group = 0;
			double spi_clk_freq = 2e6;
			int spi_status = 0;
			int spi_wr_byte_length = 1;
			int spi_rd_byte_length = 0;
			int k = Start_Data;
			int idxc = 0;
			double flt_voh = 0.75;				// setting FLTMUX VOH = 1V

			array<int> ^ spi_data = gcnew array<int>(256);
			array<int> ^ spi_data_dir = gcnew array<int>(256);
			array<int> ^ spi_rd_data = gcnew array<int>(256);
			array<int> ^ spi_rd_biterror = gcnew array<int>(256);
			array<double> ^ delay_s_after_byte = gcnew array<double>(256);

			array<int> ^ my_spi_rd_data = gcnew array<int>(256);

			ret = OnOffSPI(idx, 1);

			for (int i=0; i<total_tp ; i++)		
			{
			idxc = 0;	//EW: resetting fltmux measurement counters
			int myresult=0; 

				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					//Load setting
					Vector_File = (String ^)tf_TPCondition_Cast(TPName[i], "Vector_File");

					if(!USE_SPI) 
					{
						ret = OnOffSPI(idx, 0);
						ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
						ret = RunVectorFile(idx, "write_default_reg");
						ret = RunVectorFile(idx, Vector_File);
					} 
					else 
					{
						ret = OnOffSPI(idx, 1);
						ret += RunSPI(idx, "write_default_reg");
						ret += RunSPI(idx, Vector_File);
						CheckError(idx, ret, __LINE__);
					}

//myresult = 0; ret = ReadReg(idx, 1, 11, myresult); 
//myresult = 0; ret = ReadReg(idx, 2, 2, myresult); 
//myresult = 0; ret = ReadReg(idx, 2, 4, myresult); 
//myresult = 0; ret = ReadReg(idx, 2, 5, myresult); 
//myresult = 0; ret = ReadReg(idx, 2, 6, myresult); 
//myresult = 0; ret = ReadReg(idx, 2, 11, myresult); 
//myresult = 0; ret = ReadReg(idx, 2, 12, myresult); 

						ret = dm[idx]->AcquireVectorFailCount("DM_2", myresult); 
						CheckError(idx, ret, __LINE__);

					for (int m=0; m<256; m++) 	
					{
						spi_data[m] = 0;
						delay_s_after_byte[m] = 0;
						spi_rd_data[m] = 0;
						spi_rd_biterror[m] = 0;
						my_spi_rd_data[m] = 0;
					}

					spi_status = 0;
					result_adc = -999;

					k = Start_Data;
					while (k <= Stop_Data && idxc < 256) 
					{
					int datain = _util->SwapBitSequence(k, 8);
					spi_data_dir[0] = 0x0000000; 
					spi_data[0]	= 0x2000000 | ((Sweep_Reg_Addr << 8) & 0xff00) | (datain & 0xff); //write (MSB->LSB) for RW->PG->A0-A4, then deassert NCS

					spi_status = 0;
					ret = SPI(idx, spi_group, spi_data, spi_wr_byte_length, delay_s_after_byte, CONST_SERIAL_BIT_WIDTH, spi_data_dir, spi_status); 
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(On_Delay_s);

					swatch.Reset();	
					swatch.Start();	
					swatch.Stop();
					
					if (spi_status == 2)
					{
						// PMU
						double flt_pin = -999;
						//int flt_dummy = -999;

						ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
						//ret = dm[idx]->ReadPin("FLTMUX", flt_dummy);

						if(flt_pin > flt_voh) 
						{
							idxc ++;
						} else {
							idxc = 0;
						}
						if(idxc > 5) 
						{
							result_adc = k-2;		//EW: when you reached here, you have 5 fltmux HI readout. Taking 2 steps back.
							idxc = 256;
							break;
						}

						swatch.Reset();	
						swatch.Start();	
						swatch.Stop();
					}

					if (Start_Data > Stop_Data) 
					{
						k--;
					} 
					else 
					{ 
						k++; 
					}
				}

				if(myresult < 255)
					myresult = myresult + 3;
				result[i] = (myresult) * 1e-3;

				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
				}
			}
					
			/////////////////////////////////
//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", spi_group);
			ret = OnOffSPI(idx, 0);			//EW: standardizing
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
		
			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);
				
			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}

		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}
	//Trimming tests
	//void TestProgram::mux_offset(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//		array<double> ^ result = gcnew array<double>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//			result[i] = 0;
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

	//		String ^ Test_Pin		= (String ^)(tf_TestItemCondition_Cast("Test_Pin"));
	//		double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));
	//		double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));
	//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
	//		String ^ Vector_File_1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_1"));
	//		String ^ Vector_File_2  = (String ^)(tf_TestItemCondition_Cast("Vector_File_2"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;
	//		
	//		int vector_engine_status = 0;

	//		double result1 = 0;
	//		double result2 = 0;

	//		Stopwatch swatch;

	//		IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		Setup Power supplies
	//		ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		CheckError(idx, ret, __LINE__);

	//		ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VEE", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		/*ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		CheckError(idx, ret, __LINE__);
	//		_util->Wait_Sec(On_Delay_s);*/

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		_util->Wait_Sec(On_Delay_s);

	//		unsigned int moduleType = 0;

	//		 Check whether resource is SMU or DM
	//		try
	//		{
	//			ret = smu[idx]->QueryModuleType(Test_Pin, moduleType);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		catch (Exception ^) //not a smu resource if exception occurs
	//		{
	//			moduleType = DM_CONST_MODULE_TYPE;
	//		}

	//		double gnds_volt = 0.0;
	//		ret = Measure_GNDS_Voltage(idx, NPLC, Measure_Delay_s, gnds_volt);

	//		if (moduleType == DM_CONST_MODULE_TYPE) //dm
	//		{
	//			ret = dm[idx]->Force(Test_Pin, DM_CONST_FORCE_STATE_PMU);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->ConfigurePMUOutputFunction(Test_Pin, DM_CONST_DICV);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->ConfigurePMUVoltageLimit(Test_Pin, Math::Abs(Clamp_Vo_V), -2);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, 0);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->ConfigurePMUSamplingTime(Test_Pin, NPLC, DM_CONST_PLC);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->DPINOn(Test_Pin);
	//			CheckError(idx, ret, __LINE__);
	//			_util->Wait_Sec(On_Delay_s);
	//			ret = dm[idx]->ConfigurePMUCurrentLevel(Test_Pin, Drive_Io_A);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else //smu
	//		{
	//			OnOffCbit(idx, 11,1);
	//			OnOffCbit(idx, 42,1);

	//			ret = smu[idx]->ConfigureSamplingTime(Test_Pin, NPLC, AM_CONST_PLC);
	//			CheckError(idx, ret, __LINE__);
	//			ret = smu[idx]->ClampVoltage(Test_Pin, Math::Abs(Clamp_Vo_V));
	//			CheckError(idx, ret, __LINE__);
	//			ret = smu[idx]->DriveCurrent(Test_Pin, 0);
	//			CheckError(idx, ret, __LINE__);
	//			ret = smu[idx]->OnSmuPin(Test_Pin, false, false);
	//			CheckError(idx, ret, __LINE__);
	//			_util->Wait_Sec(On_Delay_s);
	//			ret = smu[idx]->DriveCurrent(Test_Pin, Drive_Io_A);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		if(!USE_SPI) 
	//		{
	//			ret = RunVectorFile(idx, "write_default_reg");
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunVectorFile(idx, Vector_File);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else 
	//		{
	//			ret = OnOffSPI(idx, 1);
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunSPI(idx, "write_default_reg");
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunSPI(idx, Vector_File);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		_util->Wait_Sec(Measure_Delay_s);

	//		if (moduleType == DM_CONST_MODULE_TYPE) //dm
	//		{
	//			ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result1);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else
	//		{
	//			ret = smu[idx]->ReadVoltage(Test_Pin, result1);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		//Unbuffered muxoffset

	//		if(!USE_SPI)
	//		{
	//			ret = RunVectorFile(idx, Vector_File_1);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else 
	//		{
	//			ret = RunSPI(idx, Vector_File_1);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		_util->Wait_Sec(Measure_Delay_s);

	//		if (moduleType == DM_CONST_MODULE_TYPE) //dm
	//		{
	//			ret = dm[idx]->PMUMeasure(Test_Pin, DM_CONST_MEASUREVOLTAGE, result2);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else
	//		{

	//			 
	//			ret = smu[idx]->ReadVoltage(Test_Pin, result2);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		
	//		_glob->mux_offset[idx] = result1 - result2;
	//		tf_SetResult_UUTOffset(TPName[0], _glob->mux_offset[idx] + GetOffset(idx, TPDispName[0]), idx);

	//		Clean up
	//		if(!USE_SPI)
	//		{
	//			ret = RunVectorFile(idx, Vector_File_2);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		else
	//		{
	//			ret = RunSPI(idx, Vector_File_2);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		if(USE_SPI) 
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}		

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		if(0)
	//		{
	//			debugcode 
	//			ofstream myfile;
	//			myfile.open("C://Aemulus/Debug/muxoffset.txt",  std::ofstream::out | std::ofstream::app);
	//			myfile << idx << "\t" << _glob->mux_offset[idx] << "\n" ;
	//			myfile.close();
	//		}

	//		Power down supplies
	//		ret = smu[idx]->DriveVoltage("VEE", 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//2945 tests
	//int TestProgram::seq_digfunc(Site ^ site)
	//{
	//	if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}

	//	int ret = 0;

	//	//Get test name from techFlow
	//	int total_tp = (int)tf_TPCount();
	//	array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//	array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//	for (int i=0; i<total_tp; i++)
	//	{
	//		TPDispName[i] = tf_TestParameter_DisplayName(i);
	//		TPName[i] = tf_TestParameter_Name(i);
	//	}

	//	String ^ TIDispName = tf_TestItem_DisplayName();

	//	//Get test condition from techFlow
	//	int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//	double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//	double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//	double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//	double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//	double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//	Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//	double Input_Channel_Delay_s = 0;
	//	double Input_Channel_Delay_norm_s = 0;
	//	bool isCurrentTPBypassed = false;
	//	Debug_Enable = true;

	//	if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_40"))
	//		Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_40"][testSite];

	//	if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//		Input_Channel_Delay_norm_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];

	//	double _Input_Channel_Delay_s = 0;

	//	if (Debug_Enable == true)
	//	{
	//		sb = gcnew StringBuilder();
	//		sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
	//	}
	//			
	//	double vih;
 //       double vil;
 //       double voh; 
 //       double vol;
 //       double ioh;
	//	double iol;
 //       double vch;
 //       double vcl;
	//	double vt;
	//	
	//	int vector_engine_status = 0;
	//	int data = 0;

	//	Stopwatch swatch;

	//	//IO setting
	//	ret = SetupDigital(site);
	//	CheckError(ret, __LINE__);
	//	//ret = DriveDIOPin(TPDispName[0]);
	//	//CheckError(ret, __LINE__);
	//	ret = DriveCBit(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = DriveMuxIO(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	
	//	ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
	//	CheckError(ret, __LINE__);
	//	ret = smu->DriveVoltage("VEE", Drive_Vee_V);
	//	CheckError(ret, __LINE__);
	//	
	//	vih = 2.5;
 //       vil = 0.00;
 //       voh = 0.75; 
 //       vol = 0.75;
 //       ioh = 0.002;
	//	iol = 0.002;
 //       vch = 6;
 //       vcl = -0.1;
	//	vt = 0;

	//	ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPE");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPD");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("SPC");
	//	CheckError(ret, __LINE__);

	//	ret = DriveDMPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("RWN", DM_CONST_FORCE_STATE_DIO);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("RWN", 0, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->SetPinDirection("RWN", DM_CONST_DIR_OUTPUT);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("RWN");
	//	CheckError(ret, __LINE__);

	//	ret = dm->Force("MODE", DM_CONST_FORCE_STATE_DIO);
	//	CheckError(ret, __LINE__);
	//	ret = dm->ConfigurePEAttribute("MODE", 0, 0, 0, 0); 
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINLevel("MODE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//	CheckError(ret, __LINE__);
	//	ret = dm->SetPinDirection("MODE", DM_CONST_DIR_OUTPUT);
	//	CheckError(ret, __LINE__);
	//	ret = dm->DPINOn("MODE");
	//	CheckError(ret, __LINE__);

	//	if (Debug_Enable == true)
	//	{
	//		sb->AppendLine("-----------------------------------------------------------------------");
	//		sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
	//		sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
	//		sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
	//		sb->AppendLine("On_Delay_s=" + On_Delay_s);
	//	}

	//	ret = RunVectorFile("write_dig_faults"); //JL: write_dig_faults is the same as Catalyst vector "pwr_up"
	//	////////////////////////////////////////////
	//	ret = OnOffSPI(1); 
	//	int result = 0; //initialize test result to 0 - pass. Assigned -ve value to indicate test failures.
	//	int fail = 0;
	//	int i = 0;
	//	int mode_config[]={0x33, 0x73, 0xb3, 0xf3};//mode pg1_reg7[7:6]=00, 01,10,11
	//	int reg_val = 0;
	//	
	//	//1. digfunc_modes
	//	if (Debug_Enable == true)
	//	{
	//		sb->AppendLine("1. digfunc_modes");
	//		sb->AppendLine("   ChipBias_OFF = 0x40, ChipBias_ON = 0x80");
	//		sb->AppendLine("   Writer_OFF = 0x8, Writer_PSV = 0x4, Writer_SBY = 0x2, Writer_ACT = 0x1");
	//		sb->AppendLine("   Reader_OFF = 0x8, Reader_PSV = 0x4, Reader_SBY = 0x2, Reader_ACT = 0x1");
	//		sb->AppendLine("   Heater_OFF = 0x3, Heater_ACT = 0x1");
	//		sb->AppendLine("   Fhs_OFF = 0xc0,   Fhs_FST = 0x20,   Fhs_SBY = 0x40,   Fhs_ACT = 0x00");

	//	}
	//	//Registers value defines
	//	enum {ChipBias_ROTestCtl = 0x4,ChipBias_Mask = 0xc0, ChipBias_OFF = 0x40, ChipBias_ON = 0x80}; //ROTestCtl = p3_r8=0x4, ROTestA = p3_r4[7:6]
	//	enum {Writer_ROTestCtl = 0xe, Writer_Mask = 0x0f, Writer_OFF = 0x8, Writer_PSV = 0x4, Writer_SBY = 0x2, Writer_ACT = 0x1}; //ROTestCtl = p3_r8=0xe, ROTestA = p3_r4[3:0]
	//	enum {Reader_ROTestCtl = 0x7, Reader_Mask = 0x0f, Reader_OFF = 0x8, Reader_PSV = 0x4, Reader_SBY = 0x2, Reader_ACT = 0x1}; //ROTestCtl = p3_r8=0x7, ROTestA = p3_r4[3:0]
	//	enum {Heater_ROTestCtl = 0x14,Heater_Mask = 0x03, Heater_OFF = 0x3, Heater_ACT = 0x1}; //ROTestCtl = p3_r8=0x14, ROTestA = p3_r4[1:0]
	//	enum {Fhs_ROTestCtl = 0x5,    Fhs_Mask = 0xe0,    Fhs_OFF = 0xc0,   Fhs_FST = 0x20,   Fhs_SBY = 0x40,   Fhs_ACT = 0x00}; //ROTestCtl = p3_r8=0x5, ROTestA = p3_r4[7:5]
	//	
	//	//Test setup matrix
	//	enum {Pin_Rwn, Pin_Mode, Reg_Modes, Reg_Servo1, Reg_Servo2, Reg_Fhs1, Reg_Fhs2}; //8 items
	//	array<int, 2> ^ setup_m = 
	//	{//Pin_Rwn, Pin_Mode, Reg_Modes, Reg_Servo1, Reg_Servo2, Reg_Fhs1, Reg_Fhs2. -1 = skip, same setting as previous test line
	//		{ 0,     0,        0x30,      0x00,      0xc4,       0x90,     -1}, //0
	//		{-1,    -1,        0x11,      -1,        -1,         -1,       -1}, //1
	//		{-1,    -1,        0x31,      -1,        -1,         0x80,     -1}, //2
	//		{-1,    -1,        -1,        -1,        -1,         0x90,     -1}, //3
	//		{-1,    -1,        0x33,      -1,        -1,         -1,       -1}, //4
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //5
	//		{ 0,     1,        -1,        -1,        -1,         -1,       -1}, //6
	//		{ 1,     1,        -1,        -1,        -1,         -1,       -1}, //7
	//		
	//		{ 0,     0,        0x73,      -1,        -1,         -1,       -1}, //8
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //9
	//		{ 0,     1,        -1,        -1,        -1,         -1,       -1}, //10
	//		                                                            
	//		{ 1,     1,        -1,        -1,        -1,         -1,       -1}, //11
	//		{ 0,     0,        0xb3,      -1,        -1,         -1,       -1}, //12
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //13
	//		{ 0,     1,        -1,        -1,        -1,         -1,       -1}, //14
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //15
	//		{ 0,     0,        0xf3,      -1,        -1,         -1,       -1}, //16
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //17
	//		{ 0,     1,        -1,        -1,        -1,         -1,       -1}, //18
	//		{ 1,     1,        -1,        -1,        -1,         -1,       -1}, //19
	//		                                                            
	//		{ 0,     1,        -1,        0x80,      0xc6,       -1,       -1}, //20*
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //21
	//		
	//		{ 0,     0,        -1,        -1,        0xce,       -1,       -1}, //22
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //23
	//		{ 0,     1,        -1,        -1,        -1,         -1,       -1}, //24
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //25
	//		
	//		{ 0,     0,        -1,        -1,        0xd6,       -1,       -1}, //26
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //27
	//		{ 0,     1,        -1,        -1,        -1,         -1,       -1}, //28
	//		{ 1,    -1,        -1,        -1,        -1,         -1,       -1}, //29
	//		
	//		{-1,     0,         0x33,      0x00,      0xc4,      -1,       -1}, //30
	//		{-1,     1,         -1,        -1,        -1,        -1,       -1}, //31*
	//		{-1,     0,         0x73,      -1,        -1,        -1,       -1}, //32
	//		{-1,     1,         -1,        -1,        -1,        -1,       -1}, //33
	//		{-1,    -1,         -1,        0x80,      0xc6,      -1,       -1}, //34
	//		{-1,     0,         -1,        -1,        0xce,      -1,       -1}, //35
	//		{-1,     1,         -1,        -1,        -1,        -1,       -1}, //36
	//		{-1,     0,         -1,        -1,        0xd6,      -1,       -1}, //37
	//		{-1,     1,         -1,        -1,        -1,        -1,       -1}, //38
	//		
	//		{ 0,     0,         0x30,      0x00,      0xc4,      0x80,     -1}, //39
	//		{-1,    -1,         0x31,      -1,        -1,        -1,       -1}, //40
	//		{-1,    -1,         -1,        -1,        -1,        0x90,     -1}, //41
	//		{-1,    -1,         -1,        -1,        -1,        -1,     0x20}, //42
	//		{-1,    -1,         0x33,      -1,        -1,        0x80,   0x00}, //43
	//		{-1,    -1,         -1,        -1,        -1,        0x90,     -1}, //44
	//		{ 1,    -1,         -1,        -1,        -1,        -1,       -1}, //45
	//		{ 0,    -1,         -1,        -1,        -1,        -1,     0x20}, //46
	//		{ 1,    -1,         -1,        -1,        -1,        -1,       -1}, //47
	//		{ 0,    -1,         -1,        -1,        -1,        0xb0,   0x00}, //48
	//		{ 1,    -1,         -1,        -1,        -1,        -1,       -1}, //49
	//		{ 0,    -1,         -1,        -1,        -1,        -1,     0x20}, //50
	//		{ 1,    -1,         -1,        -1,        -1,        -1,       -1}, //51
	//	};
	//	//Test verification matrix
	//	enum {ChipBias, Writer, Reader, Heater, Fhs, Fsr}; //6 items
	//	array<int ,2> ^ ver_m =
	//	{  //ChipBias,     Writer,     Reader,     Heater,     Fhs,     Fsr. -1 = skip verification
	//		{ChipBias_OFF, Writer_OFF, Reader_OFF, Heater_OFF, Fhs_OFF, -1}, //0
	//		{ChipBias_ON,  Writer_OFF, Reader_OFF, Heater_OFF, Fhs_SBY, -1}, //1
	//		{ChipBias_ON,  Writer_OFF, Reader_OFF, Heater_ACT, Fhs_OFF, -1}, //2
	//		{ChipBias_ON,  Writer_OFF, Reader_OFF, Heater_ACT, Fhs_SBY, -1}, //3
	//		{ChipBias_ON,  Writer_ACT, Reader_SBY, Heater_ACT, Fhs_SBY, -1}, //4
	//		{ChipBias_ON,  Writer_SBY, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //5
	//		{ChipBias_ON,  Writer_ACT, Reader_PSV, Heater_ACT, Fhs_SBY, -1}, //6
	//		{ChipBias_ON,  Writer_SBY, Reader_PSV, Heater_ACT, Fhs_ACT, -1}, //7
	//		
	//		{ChipBias_ON,  Writer_ACT, Reader_SBY, Heater_ACT, Fhs_SBY, -1}, //8
	//		{ChipBias_ON,  Writer_SBY, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //9
	//		{ChipBias_ON,  Writer_ACT, Reader_PSV, Heater_ACT, Fhs_SBY, -1}, //10
	//		
	//		{ChipBias_ON,  Writer_SBY, Reader_SBY, Heater_ACT, Fhs_ACT,  0}, //11
	//		{ChipBias_ON,  Writer_OFF, Reader_SBY, Heater_ACT, Fhs_SBY,  1}, //12
	//		{ChipBias_ON,  Writer_OFF, Reader_ACT, Heater_ACT, Fhs_ACT,  0}, //13
	//		{ChipBias_ON,  Writer_OFF, Reader_OFF, Heater_ACT, Fhs_SBY,  1}, //14
	//		{ChipBias_ON,  Writer_OFF, Reader_OFF, Heater_ACT, Fhs_ACT,  0}, //15
	//		{ChipBias_ON,  Writer_OFF, Reader_SBY, Heater_ACT, Fhs_SBY,  1}, //16
	//		{ChipBias_ON,  Writer_OFF, Reader_ACT, Heater_ACT, Fhs_ACT,  0}, //17
	//		{ChipBias_ON,  Writer_OFF, Reader_SBY, Heater_ACT, Fhs_SBY,  1}, //18
	//		{ChipBias_ON,  Writer_OFF, Reader_SBY, Heater_ACT, Fhs_ACT,  0}, //19
	//		
	//		{ChipBias_ON,  Writer_ACT, Reader_PSV, Heater_ACT, Fhs_SBY, -1}, //20
	//		{ChipBias_ON,  Writer_SBY, Reader_PSV, Heater_ACT, Fhs_ACT, -1}, //21
	//		
	//		{ChipBias_ON,  Writer_ACT, Reader_SBY, Heater_ACT, Fhs_SBY, -1}, //22
	//		{ChipBias_ON,  Writer_SBY, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //23
	//		{ChipBias_ON,  Writer_ACT, Reader_SBY, Heater_ACT, Fhs_SBY, -1}, //24
	//		{ChipBias_ON,  Writer_SBY, Reader_SBY, Heater_ACT, Fhs_ACT, -1}, //25
	//		
	//		{ChipBias_ON,  Writer_ACT, Reader_ACT, Heater_ACT, Fhs_SBY, -1}, //26
	//		{ChipBias_ON,  Writer_SBY, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //27
	//		{ChipBias_ON,  Writer_ACT, Reader_SBY, Heater_ACT, Fhs_SBY, -1}, //28
	//		{ChipBias_ON,  Writer_SBY, Reader_SBY, Heater_ACT, Fhs_ACT, -1}, //29
	//		
	//		{ChipBias_ON,  Writer_PSV, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //30
	//		{ChipBias_ON,  Writer_PSV, Reader_PSV, Heater_ACT, Fhs_ACT, -1}, //31
	//		{ChipBias_ON,  Writer_PSV, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //32
	//		{ChipBias_ON,  Writer_PSV, Reader_SBY, Heater_ACT, Fhs_ACT, -1}, //33
	//		{ChipBias_ON,  Writer_PSV, Reader_PSV, Heater_ACT, Fhs_ACT, -1}, //34
	//		{ChipBias_ON,  Writer_PSV, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //35
	//		{ChipBias_ON,  Writer_PSV, Reader_SBY, Heater_ACT, Fhs_ACT, -1}, //36
	//		{ChipBias_ON,  Writer_PSV, Reader_ACT, Heater_ACT, Fhs_ACT, -1}, //37
	//		{ChipBias_ON,  Writer_PSV, Reader_SBY, Heater_ACT, Fhs_ACT, -1}, //38
	//		
	//		{-1,           -1,         -1,         -1,         Fhs_OFF, -1}, //39
	//		{-1,           -1,         -1,         -1,         Fhs_OFF, -1}, //40
	//		{-1,           -1,         -1,         -1,         Fhs_SBY, -1}, //41
	//		{-1,           -1,         -1,         -1,         Fhs_SBY, -1}, //42
	//		{-1,           -1,         -1,         -1,         Fhs_OFF, -1}, //43
	//		{-1,           -1,         -1,         -1,         Fhs_SBY, -1}, //44
	//		{-1,           -1,         -1,         -1,         Fhs_ACT, -1}, //45
	//		{-1,           -1,         -1,         -1,         Fhs_SBY, -1}, //46
	//		{-1,           -1,         -1,         -1,         Fhs_ACT, -1}, //47
	//		{-1,           -1,         -1,         -1,         Fhs_SBY, -1}, //48
	//		{-1,           -1,         -1,         -1,         Fhs_ACT, -1}, //49
	//		{-1,           -1,         -1,         -1,         Fhs_SBY, -1}, //50
	//		{-1,           -1,         -1,         -1,         Fhs_ACT, -1}, //51		
	//	};
	//	
	//	int max_test = 52; //total number of test lines
	//	
	//	//JL: fail value offset = -1 000 000 
	//	fail = -1000000;
	//
	//	//init
	//	//clr_ServoW 
	//	ret = WriteSPI(1, 14, 0x00);//pg1_reg14 bit7(ServoW1)=0 
	//	ret = WriteSPI(2, 0, 0xc4);//pg2_reg0 bit[7:6](don't care)=11, bit3(ServoRd)=1, bit2(ServoW0)=0 
	//	ret = WriteSPI(2, 1, 0xff);//pg2_reg1 SWHSel<7:0> = 1111_1111
	//	
	//	ret = WriteSPI(2, 4, 0x10);//set_FHSEn, pg2_reg4, bit4=1
	//	ret = WriteSPI(2, 5, 0x08);//set_SBWFHSEn, pg2_reg5 bit3(FHSServo_En)=1
	//	
	//	for(i = 0; i < max_test; i++)
	//	{	
	//		fail = -1000000-i*1000; //example=: failure from digfunc_modes test 30, result = -1 0030 0002 if verify r_writer fails.
	//		if (Debug_Enable == true)
	//			sb->AppendLine("   "+i.ToString());
	//		//setup test:
	//		//additional setup steps
	//		switch(i)
	//		{
	//			case 0:
	//			case 1:
	//			case 2:
	//			case 3:
	//				ret = WriteSPI(1, 15, 0x40);//set_DMUX00 pg1_reg15 bit6(DMUXAMUXN)=1, bit[5:0](MUX[5:0])=0
	//				break;
	//			case 11: //testing DisSeqFlt
	//				ret = WriteSPI(1, 10, 0xfe); //enable DisSeqFlt, pg1_reg8=0xfe
	//				break;
	//			case 20: 
	//				ret = WriteSPI(1, 10, 0xff); //disagble DisSeqFlt, pg1_reg8=0xff
	//				break;
	//			case 30: //WrtPwrSave=1
	//				ret = WriteSPI(2, 13, 0x91); //WrtPwrSave=1, p2_reg13=0x91
	//				break;
	//			case 39:
	//				ret = WriteSPI(2, 13, 0x90); //WrtPwrSave=0, p2_reg13=0x90
	//				ret = WriteSPI(2, 5, 0x00); //clr_SBWFHSEn, pg2_reg5 bit3(FHSServo_En)=0				
	//		}			
	//		
	//		//set modes, register pg1_reg7
	//		if(setup_m[i, Reg_Modes] != -1)
	//			ret = WriteSPI(1, 7, setup_m[i, Reg_Modes]);
	//		//set servo, register pg1_reg14, pg2_reg0, 
	//		if(setup_m[i, Reg_Servo1] != -1)
	//			ret = WriteSPI(1, 14, setup_m[i, Reg_Servo1]);
	//		if(setup_m[i, Reg_Servo2] != -1)
	//			ret = WriteSPI(2, 0 , setup_m[i, Reg_Servo2]);
	//		//set FHS, register Pg2_reg4, pg2_reg15
	//		if(setup_m[i, Reg_Fhs1] != -1)
	//			ret = WriteSPI(2, 4 , setup_m[i, Reg_Fhs1]);
	//		if(setup_m[i, Reg_Fhs2] != -1)
	//			ret = WriteSPI(2, 15 , setup_m[i, Reg_Fhs2]);

	//		//drive pins state		
	//		if(setup_m[i, Pin_Mode] != -1)
	//		{
	//			ret = dm->DrivePin("MODE", setup_m[i, Pin_Mode]);
	//		}			
	//		if(setup_m[i, Pin_Rwn] != -1)				
	//			ret = dm->DrivePin("RWN", setup_m[i, Pin_Rwn]);
	//		
	//		//if (Debug_Enable == true)
	//		//{
	//		//	int reg1, reg2, reg3, reg4, reg5;
	//		//	ret = ReadReg(1, 7, reg1);
	//		//	ret = ReadReg(1, 14, reg2);
	//		//	ret = ReadReg(2, 0, reg3);
	//		//	ret = ReadReg(2, 4, reg4);
	//		//	ret = ReadReg(2, 15, reg5);

	//		//	int pin_rwn, pin_mode;
	//		//	ret = dm->ReadPin("RWN", pin_rwn);
	//		//	ret = dm->ReadPin("MODE", pin_mode);

	//		//	sb->AppendLine("   "+i.ToString() + ": RWN=" + pin_rwn.ToString() + " MODE=" + pin_mode.ToString() + 
	//		//		" Modes(pg1_reg7)=0x"+reg1.ToString("x")+
	//		//		" Servo1(pg1_reg14)=0x"+reg2.ToString("x")+
	//		//		" Servo2(pg2_reg0)=0x"+reg3.ToString("x")+
	//		//		" Fhs1(pg2_reg4)=0x"+reg4.ToString("x")+
	//		//		" Fhs2(pg2_reg15)=0x"+reg5.ToString("x"));
	//		//}

	//		//verification:
	//		//verify r_chipbias 
	//		if(ver_m[i, ChipBias] != -1)
	//		{
	//			ret = WriteSPI(3, 8, ChipBias_ROTestCtl);//ROTestCtl
	//			ret = ReadReg(3, 4, reg_val); //ROTestA
	//			reg_val &= ChipBias_Mask;
	//			if(reg_val != ver_m[i, ChipBias])
	//			{
	//				result = fail-1; 
	//				
	//				if (Debug_Enable == true)
	//					sb->AppendLine("      Fail, ChipBias=0x" +(reg_val >> 6).ToString("x")+". Expected value is 0x" + ver_m[i, ChipBias].ToString("x"));
	//				else
	//					break;
	//			}
	//			else if(Debug_Enable == true)
	//				sb->AppendLine("      Pass, ChipBias=0x" +(reg_val >> 6).ToString("x"));
	//		}
	//		
	//		//verify r_writer 
	//		if(ver_m[i, Writer] != -1)
	//		{
	//			ret = WriteSPI(3, 8, Writer_ROTestCtl);//ROTestCtl
	//			ret = ReadReg(3, 4, reg_val); //ROTestA
	//			reg_val &= Writer_Mask;
	//			if(reg_val != ver_m[i, Writer])
	//			{
	//				result = fail-2; 
	//				if (Debug_Enable == true)
	//					sb->AppendLine("      Fail, Writer=0x" + reg_val.ToString("x")+". Expected value is 0x" + ver_m[i, Writer].ToString("x"));
	//				else
	//					break;
	//			}
	//			else if(Debug_Enable == true)
	//				sb->AppendLine("      Pass, Writer=0x" + reg_val.ToString("x"));
	//		}
	//		
	//		//verify r_reader 
	//		//JL: note - if expected state is PSV, test will likely fail. Reader will transition to OFF state from PSV after 180us. Need to add a workaround here.
	//		//    from 2945 Ref manual -" when the reader is in the Standby or PwrSave state for longer than 180 μs, the internal reader state automatically transitions to Off,"
	//		if(ver_m[i, Reader] != -1)
	//		{
	//			ret = WriteSPI(3, 8, Reader_ROTestCtl);//ROTestCtl
	//			if(ver_m[i, Reader] == Reader_PSV) //workaround for Reader_PSV
	//			{
	//				if(setup_m[i, Pin_Rwn]==0)
	//					ret = dm->DrivePin("RWN", 1);
	//				ret = dm->DrivePin("MODE", 0);
	//				_util->Wait_Sec(10e-6);
	//				if(setup_m[i, Pin_Rwn]==0)
	//					ret = dm->DrivePin("RWN", setup_m[i, Pin_Rwn]);
	//				ret = dm->DrivePin("MODE", 1);
	//				_util->Wait_Sec(1e-6);
	//			}
	//			ret = ReadReg(3, 4, reg_val); //ROTestA
	//			reg_val &= Reader_Mask;
	//			if(reg_val != ver_m[i, Reader])
	//			{
	//				result = fail-3; 
	//				if (Debug_Enable == true)
	//					sb->AppendLine("      Fail, Reader=0x" + reg_val.ToString("x")+". Expected value is 0x" + ver_m[i, Reader].ToString("x"));
	//				else
	//					break;
	//			}
	//			else if(Debug_Enable == true)
	//				sb->AppendLine("      Pass, Reader=0x" + reg_val.ToString("x"));
	//		}
	//		
	//		//verify r_heater 
	//		if(ver_m[i, Heater] != -1)
	//		{
	//			ret = WriteSPI(3, 8, Heater_ROTestCtl);//ROTestCtl
	//			ret = ReadReg(3, 4, reg_val); //ROTestA
	//			reg_val &= Heater_Mask;
	//			if(reg_val != ver_m[i, Heater])
	//			{
	//				result = fail-4; 
	//				if (Debug_Enable == true)
	//					sb->AppendLine("      Fail, Heater=0x" +reg_val.ToString("x")+". Expected value is 0x" + ver_m[i, Heater].ToString("x"));
	//				else
	//					break;
	//			}
	//			else if(Debug_Enable == true)
	//				sb->AppendLine("      Pass, Heater=0x" +reg_val.ToString("x"));
	//		}
	//		
	//		//verify r_fhs 
	//		if(ver_m[i, Fhs] != -1)
	//		{
	//			ret = WriteSPI(3, 8, Fhs_ROTestCtl);//ROTestCtl
	//			ret = ReadReg(3, 4, reg_val); //ROTestA
	//			reg_val &= Fhs_Mask;
	//			if(reg_val != ver_m[i, Fhs])
	//			{
	//				result = fail-5; 
	//				if (Debug_Enable == true)
	//					sb->AppendLine("      Fail, FHS=0x" + (reg_val >> 5).ToString("x")+". Expected value is 0x" + ver_m[i, Fhs].ToString("x"));
	//				else
	//					break;
	//			}
	//			else if(Debug_Enable == true)
	//				sb->AppendLine("      Pass, FHS=0x" + (reg_val >> 5).ToString("x"));
	//		}
	//		
	//		//verify FSR
	//		if(ver_m[i, Fsr] != -1)
	//		{
	//			ret = WriteSPI(1, 8, 0); //Clear FSR
	//			ret = ReadReg(1, 8, reg_val); //Read FSR
	//			if(reg_val != ver_m[i, Fsr])
	//			{
	//				result = fail-6; 
	//				if (Debug_Enable == true)
	//					sb->AppendLine("      Fail, FSR=0x" + reg_val.ToString("x")+". Expected value is 0x" + ver_m[i, Fsr].ToString("x"));
	//				else
	//					break;
	//			}
	//			else if(Debug_Enable == true)
	//				sb->AppendLine("      Pass, FSR=0x" + reg_val.ToString("x"));
	//		}
	//	}
	//	
	//	//2. digfunc_r  
	//	//JL: fail value offset = -2 000 000 
	//	fail = -2000000;
	//	
	//	
	//	//3. digfunc_w
	//	//JL: fail value offset = -3 000 000 
	//	fail = -3000000;
	//	
	//	
	//	//4. digfunc_h
	//	//JL: fail value offset = -4 000 000 
	//	fail = -4000000;
	//	
	//	
	//	tf_SetResult(TPName[0], result + (int)GetOffset(TPDispName[0])); //JL: result = 0 is "pass"
	//	ret = OnOffSPI(0); 
	//	////////////////////////////////////////////
	//	ret = ResetDMPin(TPDispName[0]);
	//	CheckError(ret, __LINE__);

	//	//Power down supplies
	//	ret = smu->DriveVoltage("VEE", 0);
	//	CheckError(ret, __LINE__);
	//	ret = smu->DriveVoltage("VCC", 0);
	//	CheckError(ret, __LINE__);
	//	
	//	//IO setting
	//	//ret = ResetDIOPin(TPDispName[0]);
	//	//CheckError(ret, __LINE__);
	//	ret = ResetCBit();
	//	CheckError(ret, __LINE__);
	//	ret = ResetMuxIO();
	//	CheckError(ret, __LINE__);

	//	if (Debug_Enable == true)
	//	{
	//		sw->Write(sb);	
	//		sb = nullptr;
	//		sw->Close();
	//		sw = nullptr;

	//		Debug_Enable = false;
	//	}

	//	return ret;
	//}
//	int TestProgram::seq_rd2wr_bias(Site ^ site)
//	{
//		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}
//
//		int ret = 0;
//		
//		//Get test param from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//		
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));//
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));//
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));//
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));//
//		//double Drive_Io_A		= (double)(tf_TestItemCondition_Cast("Drive_Io_A"));//
//		//double Clamp_Vo_V		= (double)(tf_TestItemCondition_Cast("Clamp_Vo_V"));//
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));//
//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));//
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));//
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));//
//		//double Clamp_flt_A		= (double)(tf_TestItemCondition_Cast("Clamp_flt_A"));//
//		//double Drive_flt_V		= (double)(tf_TestItemCondition_Cast("Drive_flt_V"));//
//		double Input_Channel_Delay_s = 0;
//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));//
//		int SPD_Channel			= _glob->SPD_Channel_Number;
//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));//rd2wr_bias
//		
//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
//		
//		if (Debug_Enable == true)
//		{
//			sb = gcnew StringBuilder();
//			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
//		}
//				
//		double vih;
//        double vil;
//        double voh; 
//        double vol;
//        double ioh;
//		double iol;
//        double vch;
//        double vcl;
//		double vt;
//		
//		//IO setting
//		ret = SetupDigital(site);
//		CheckError(ret, __LINE__);		
//		//ret = DriveDIOPin(TPDispName[0]);
//		//CheckError(ret, __LINE__);
//		ret = DriveCBit(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = DriveMuxIO(TPDispName[0]);
//		CheckError(ret, __LINE__);
//
//		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
//		CheckError(ret, __LINE__);
//		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
//		CheckError(ret, __LINE__);
//		
//		ret = DriveDMPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//
//		vih = 2.5;
//        vil = 0.00;
//        voh = 0.75; 
//        vol = 0.75;
//        ioh = 0.002;
//		iol = 0.002;
//        vch = 6;
//        vcl = -0.1;
//		vt = 0;
//		
//		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPE");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPD");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPC");
//		CheckError(ret, __LINE__);
//		
//		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("RWN");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SYNC");
//		CheckError(ret, __LINE__);
//
//		//Configure Input Delay
//		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//		CheckError(ret, __LINE__);
//
//		if (Debug_Enable == true)
//		{
//			sb->AppendLine("-----------------------------------------------------------------------");
//			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("On_Delay_s=" + On_Delay_s);
//		}
//		
//		//JL: run Vector file to initialize the test
//		
//		ret += RunVectorFile("write_default_reg");
//		
//		ret = OnOffSPI(1);
//		/////////////////////////////////////
//		double voh_flt = 0.5;
//		double tmu_start_hysteresis = 0.02;
//		double tmu_stop_hysteresis = 0.02;
//		double tmu_start_threshold = voh_flt;
//		double tmu_stop_threshold = voh_flt;
//		
//		int number_of_samples = 1;
//		double tmu_timeout = 10e-3; 
//		int returned_sample_count = 0;
//		array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
//
//		//TMU start on SYNC pos slope, stop on FLTMUX pos slope
//		ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret += tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//		_util->Wait_Sec(Measure_Delay_s);
//		
//		ret += RunVectorFile(Vector_File);
//
//		for(int i = 0; i < total_tp; i++)
//		{
//			Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));
//			switch(i)
//			{
//				case 0: //Param 0		
//					ret += WriteSPI(2, 11, 0x80); //DMUX_EN, pg2_reg11[7]=1
//					ret += WriteSPI(3, 11, 0x10); //Disable Reader bias timer, pg3_reg11[4] = 1; After time-out, state machine provides fast recovery to active Read mode (35 ns).
//					//set DMUX Rdr_Read, MUX[6:0] = 44 = 010_1100b 
//					ret += WriteSPI(1, 15, 0x6c);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//					ret += WriteSPI(3, 13, 0x00);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//
////47s add to cheat TMU
//                  ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//                  ret += RunVectorFile(Vector_File);
//                  ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//
//					break;
//				case 1: //Param 1
//					ret += WriteSPI(3, 11, 0x00); //Disable Reader bias timer, pg3_reg11[4] = 0; After time-out, state machine provides slow recovery to active Read mode (460 ns).
//					break;
//				case 2: //Param 2
//					//set DMUX Rdr_HoldBiasTimer_Response, MUX[6:0] = 48 = 011_0000b 
//					ret += WriteSPI(1, 15, 0x70);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//					ret += WriteSPI(3, 13, 0x00);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//					
//					//change TMU start to neg slope of SYNC
//					ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//					_util->Wait_Sec(Measure_Delay_s);
//			}
//
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			//vector file rd2wr_bias:
//			//default RWN=1, SYNC=1 for 50us, then RWN=0 for 300us & and SYNC=0 1us after RWN=0
//			ret += RunVectorFile(Vector_File);
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			
//			tf_SetResult(TPName[i], sampled_result[0] + GetOffset(TPDispName[i]));	
//		}
//		/////////////////////////////////////
//		ret = OnOffSPI(0); 
//		CheckError(ret, __LINE__);
//		
//		ret = Digital_Init_State(site);
//		CheckError(ret, __LINE__);
//        
//		ret = ResetDMPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//        
//		//Power down supplies
//		ret = smu->DriveVoltage("VEE", 0);
//		CheckError(ret, __LINE__);
//		ret = smu->DriveVoltage("VCC", 0);
//		CheckError(ret, __LINE__);
//        
//		//IO setting
//		//JL: Removed ResetDIOPin(TPDispName[0]) according to latest 2935_47S source code
//		//ret = ResetDIOPin(TPDispName[0]);
//		//CheckError(ret, __LINE__);
//		ret = ResetCBit();
//		CheckError(ret, __LINE__);
//		ret = ResetMuxIO();
//		CheckError(ret, __LINE__);
//        
//		if (Debug_Enable == true)
//		{
//			sw->Write(sb);	
//			sb = nullptr;
//			sw->Close();
//			sw = nullptr;
//        
//			Debug_Enable = false;
//		}
//        
//		return ret;
//	}
//	int TestProgram::seq_dmux(Site ^ site) //JL: New test
//	{
//		
//		int ret = 0;
//		
//		//Get test name from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//		double Input_Channel_Delay_s = 0;
//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
//
//		if (Debug_Enable == true)
//		{
//			sb = gcnew StringBuilder();
//			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
//		}
//
//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
//				
//		double vih;
//		double vil;
//		double voh; 
//		double vol;
//		double ioh;
//		double iol;
//		double vch;
//		double vcl;
//		double vt;
//
//		double tmu_start_threshold = 0;
//		double tmu_stop_threshold = 0;
//		double tmu_start_hysteresis = 0;
//		double tmu_stop_hysteresis = 0;
//		int number_of_samples = 10;
//		double tmu_timeout = 10e-3; //JL: changed from 10e-3
//		int returned_sample_count = 0;
//		array<double> ^ sampled_result = gcnew array<double>(number_of_samples);
//		array<double> ^ sampled_result1 = gcnew array<double>(1);
//		//IO setting
//		ret += SetupDigital(site);
//		ret += DriveDIOPin(TPDispName[0]);
//		ret += DriveCBit(TPDispName[0]);
//		ret += DriveMuxIO(TPDispName[0]);
//
//		//Setup Power supplies
//		ret += smu->SetBandwidth("VCC", Bandwidth);
//		ret += smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//		ret += smu->DriveVoltage("VCC", 0);
//		ret += smu->OnSmuPin("VCC", true, false);
//
//		ret += smu->SetBandwidth("VEE", Bandwidth);
//		ret += smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
//		ret += smu->DriveVoltage("VEE", 0);
//		ret += smu->OnSmuPin("VEE", true, false);
//		_util->Wait_Sec(0.001);
//
//		ret += smu->DriveVoltage("VCC", Drive_Vcc_V);
//		ret += smu->DriveVoltage("VEE", Drive_Vee_V);
//		_util->Wait_Sec(On_Delay_s);
//
//		vih = 2.5;
//		vil = 0.00;
//		voh = 0.75; 
//		vol = 0.75;
//		ioh = 0.002;
//		iol = 0.002;
//		vch = 6;
//		vcl = -0.1;
//		vt = 0;
//
//		ret += DriveDMPin(TPDispName[0]);
//
//		ret += dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//		ret += dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//		ret += dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		ret += dm->DPINOn("SPE");
//
//		ret += dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//		ret += dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//		ret += dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		ret += dm->DPINOn("SPD");
//
//		ret += dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//		ret += dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//		ret += dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		ret += dm->DPINOn("SPC");
//
//		ret += dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
//		ret += dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
//		ret += dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		ret += dm->DPINOn("RWN");
//
//		//ret += dm->DPINOff("FLTMUX");
//		//ret += dm->Force("FLTMUX", DM_CONST_FORCE_STATE_PMU);
//		//ret += dm->ConfigurePMUSamplingTime("FLTMUX", NPLC, DM_CONST_PLC);
//		//ret += dm->ConfigurePMUOutputFunction("FLTMUX", DM_CONST_DICV);
//		//ret += dm->ConfigurePMUVoltageLimit("FLTMUX", 6, -2);
//		//ret += dm->ConfigurePMUCurrentLevel("FLTMUX", 0);
//		//ret += dm->DPINOn("FLTMUX");
//
//		//Configure Input Delay
//		ret += dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//		_util->Wait_Sec(On_Delay_s);
//
//		if (Debug_Enable == true)
//		{
//			sb->AppendLine("-----------------------------------------------------------------------");
//			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("On_Delay_s=" + On_Delay_s);
//		}
//
//		//Write DEFAULT registers 
//		ret = RunVectorFile("write_default_reg");
//		if (ret < 0) return ret;
//		
//		/////////////////////////////////////////////////////////////////
//		int pin_val = 0;
//
//		ret += OnOffSPI(1);
//
//		tmu_start_hysteresis = 0.02;
//		tmu_stop_hysteresis = 0.02;	
//
//		double voh_flt = 0.6;	
//		int retest_count;
//
//		tmu_start_threshold = voh_flt;
//		tmu_stop_threshold = voh_flt;
//		
//		ret += WriteSPI(2, 11, 0x80); //DMUX_EN
//		ret += WriteSPI(2, 13, 0x91); //WRTPWRSAVE, set bit0, default bit4=1, bit7=1
//		
//		// - Param 0 - ReaderClock_Div16
//
//		//configure FLTMUX to TMU Start & Stop
//		ret += OnOffCbit(18, 1); //TMU start - connect to FLTMUX
//		ret += OnOffCbit(19, 1); //TMU stop - connect to FLTMUX
//		
//		ret += WriteSPI(3, 7, 0x2); //RWTestCtl
//		ret += WriteSPI(3, 9, 0x40);//RWTestA, bit6=1
//		//MUX[6:0] = 30 = 001_1110b
//		ret += WriteSPI(1, 15, 0x5e);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		ret += WriteSPI(3, 13, 0);   //Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//			
//		ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret += tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//		_util->Wait_Sec(Measure_Delay_s);
//
//		retest_count=0;
//		do
//		{		
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(Measure_Delay_s);
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		
//
//			for(int i=0; i<returned_sample_count; i++)
//			{
//				if(sampled_result[i] > 60.79e-9  && sampled_result[i] < 10.2e-8)
//				{
//					tf_SetResult(TPName[0], (1/sampled_result[i]) + GetOffset(TPDispName[0])); //JL: in Mhz
//					retest_count = 99;
//					break;
//				}
//			}
//			retest_count++;
//			if(retest_count == 10) //return failed result after 10 unsuccessful retries
//				tf_SetResult(TPName[0], (1/sampled_result[0]) + GetOffset(TPDispName[0]));
//						
//		}
//		while(retest_count <10);
//
//		// - Param 1 - WriterClock_Div16
//		ret += WriteSPI(3, 7, 0x2); //RWTestCtl	//added by Sidi		ret += WriteSPI(3, 7, 0x2); 
//		ret += WriteSPI(3, 9, 0x20);//RWTestA, bit5=1
//		//MUX[6:0] = 33 = 010_0001b
//		ret += WriteSPI(1, 15, 0x61);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		ret += WriteSPI(3, 13, 0x0 );   //Bit7 = 0 + Mux[6]       + Bit[5:0] = 0   //sidi added
//		_util->Wait_Sec(Measure_Delay_s);
//
//		retest_count=0;
//		do
//		{		
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(Measure_Delay_s);
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		
//
//			for(int i=0; i<returned_sample_count; i++)
//			{
//				if(sampled_result[i] > 30.3e-9  && sampled_result[i] < 5.128e-8)
//				{
//					tf_SetResult(TPName[1], (1/sampled_result[i]) + GetOffset(TPDispName[1])); //JL: in Mhz
//					retest_count = 99;
//					break;
//				}
//			}
//			retest_count++;
//			if(retest_count == 10) //return failed result after 10 unsuccessful retries
//				tf_SetResult(TPName[1], (1/sampled_result[0]) + GetOffset(TPDispName[1]));
//						
//		}
//		while(retest_count <10);
//
//		// - Param 2 - AuxClock_Div16
//		ret += WriteSPI(3, 9, 0x10);//RWTestA, bit4=1
//		//MUX[6:0] = 36 = 010_0100b
//		ret += WriteSPI(1, 15, 0x64);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		_util->Wait_Sec(Measure_Delay_s);
//		
//		retest_count=0;
//		do
//		{		
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			_util->Wait_Sec(Measure_Delay_s);
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);		
//
//			for(int i=0; i<returned_sample_count; i++)
//			{
//				if(sampled_result[i] > 60.79e-9  && sampled_result[i] < 10.2e-8)
//				{
//					tf_SetResult(TPName[2], (1/sampled_result[i]) + GetOffset(TPDispName[2])); //JL: in Mhz
//					retest_count = 99;
//					break;
//				}
//			}
//			retest_count++;
//			if(retest_count == 10) //return failed result after 10 unsuccessful retries
//				tf_SetResult(TPName[2], (1/sampled_result[0]) + GetOffset(TPDispName[2]));
//						
//		}
//		while(retest_count <10);
//
//		// - Param 3 - MaskGeneralFaults_Initiate
//		ret += WriteSPI(3, 7, 0);//RWTestCtl
//		ret += WriteSPI(3, 9, 0);//RWTestA
//		//MUX[6:0] = 19 = 001_0011b
//		ret += WriteSPI(1, 15, 0x53);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//
//		//configure RWN to TMU Start
//		ret += OnOffCbit(18, 0); //TMU start - disconnect FLTMUX
//		ret += OnOffCbit(21, 1); //TMU start - connect RWN
//		
//		number_of_samples=1;
//
//		ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret += tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//
//		_util->Wait_Sec(Measure_Delay_s);
//		retest_count = 0;
//		sampled_result[0] = 0;
//		do
//		{
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//
//			ret += RunVectorFile(Vector_File);
//
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//
//			if(ret)			
//				ret = 0;
//			retest_count++;			
//		}
//		while((sampled_result[0] <10e-9 || sampled_result[0] > 50e-9) && retest_count <10);
// 
//		tf_SetResult(TPName[3], sampled_result[0] + GetOffset(TPDispName[3]));
//
//		// - Param 4 - MaskFaults_General		
//		//MUX[6:0] = 20 = 001_0100b
//		ret += WriteSPI(1, 15, 0x54);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		_util->Wait_Sec(Measure_Delay_s);
//		
//		sampled_result[0] = 0;
//		ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		ret += RunVectorFile(Vector_File);
//	
//		ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult(TPName[4], sampled_result[0] + GetOffset(TPDispName[4]));
//		
//		// - Param 5 - MaskHeaterFaults_Initiate
//		ret += OnOffSPI(1);
//		ret += WriteSPI(1, 13, 0); //WHEAT=0; disable heater in write mode
//		ret += WriteSPI(1, 12, 0xbc); //RHEAT=VHT_RD=188=0xbc
//		//Default value of pg1_reg14 = 0x2); PDAC_VDACN = 0; Dynamic fly-height mode = heater voltage mode.
//		ret += WriteSPI(1, 7, 0x33); //HEATER_ENABLE (DFHEN) = HEATER_ON (1); bit5 = 1; Dynamic fly-height enable. Default bit 0,1,4 are set.
//		ret += WriteSPI(2, 9, 0x21); //POWERRANGE=1, bit5. Default bit 0 is set.
//		ret += WriteSPI(2, 14, 0x20); //HEATER_BLANK="DFHWRDELN"=1, bit5. Default all 0.		
//		//MUX[6:0] = 21 = 001_0101b
//		ret += WriteSPI(1, 15, 0x55);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//
//		ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret += tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//		_util->Wait_Sec(Measure_Delay_s);
//
//		sampled_result[0] = 0;
//		ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		
//		ret += RunVectorFile("write_dmux");
//
//		ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult(TPName[5], sampled_result[0] + GetOffset(TPDispName[5]));
//		
//		// - Param 6 - MaskFaults_Heater
//		//MUX[6:0] = 22 = 001_0110b
//		ret += WriteSPI(1, 15, 0x56);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		_util->Wait_Sec(Measure_Delay_s);
//		
//		sampled_result[0] = 0;
//		ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//		
//		ret += RunVectorFile("write_dmux");
//
//		ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult(TPName[6], sampled_result[0] + GetOffset(TPDispName[6]));
//		
//		// - Param 7-10 - WtoRRec bit check
//		//MUX[6:0] = 43 = 010_1011b Rdr_Squelch
//		ret += WriteSPI(1, 15, 0x6b);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//	
//		for(int i=0; i<4; i++)
//		{
//			//permute W2RREC values from 0-3
//			int reg_dat = (i & 0x6) << 2;
//			ret += WriteSPI(2, 8, reg_dat); //Write to Read recovery time
//			_util->Wait_Sec(Measure_Delay_s);
//
//			sampled_result[0] = 0;
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			
//			ret += RunVectorFile("write_dmux");
//			
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			tf_SetResult(TPName[7 + i], sampled_result[0] + GetOffset(TPDispName[7 + i]));			
//		}
//		
//		// - Param 11 - Fault_Detect_LowVCCSupply pulse_width
//		ret += WriteSPI(1, 10, 0xfd); //enable Supply Flt, bit 1 = 0
//		ret += WriteSPI(3, 1, 0xc0);
//		
//		//MUX[6:0] = 64 = 100_0000b 
//		ret += WriteSPI(1, 15, 0x40);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		ret += WriteSPI(3, 13, 0x40);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//
//		ret += RunVectorFile("write_rwn0"); //set RWN=1
//		ret += dm->ReadPin("FLTMUX", pin_val);
//		ret += dm->ReadPin("RWN", pin_val);
//
//		ret += WriteSPI(3, 7, 21); //RWTestCtl
//		ret += WriteSPI(3, 9, 0xff);//RWTestA
//		ret += WriteSPI(3, 10, 0x20);//RWTestB bit[6:4] = TestMode_SupplyFault[2:0]
//
//		ret += OnOffCbit(21, 0); //TMU start - disconnect RWN
//		ret += OnOffCbit(18, 1); //TMU start - connect to FLTMUX
//
//		ret += dm->ReadPin("FLTMUX", pin_val);
//		ret += dm->ReadPin("RWN", pin_val);
//
//		//JL: TMU start on FLTMUX positive, stop on FLTMUX negative. Reuse same setting as previous tests.
//		ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret += tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//
//		//tmu_timeout = 60e-3;
//		_util->Wait_Sec(Measure_Delay_s);
//		retest_count = 0;
//		do
//		{
//			sampled_result[0] = 0;
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//					
//			ret += RunVectorFile("write_fault_sply_pulse");//takes 37ms
//
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			if(ret)
//			{
//				ret = 0;
//				retest_count++;
//			}
//			else
//				break;		
//		}
//		while(retest_count <10);
//		tf_SetResult(TPName[11], sampled_result[0] + GetOffset(TPDispName[11]));
//		
//		// - Param 12 - Fault_Detect_LowVEESupply pulse_width
//		//MUX[6:0] = 65 = 100_0001b 
//		ret += WriteSPI(1, 15, 0x41);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		ret += WriteSPI(3, 13, 0x40);//Bit7 = 0 + Mux[6]        + Bit[5:0] = 0
//		
//		ret += WriteSPI(3, 7, 22); //RWTestCtl
//		ret += WriteSPI(3, 9, 0xff);//RWTestA
//		ret += WriteSPI(3, 10, 0x40);//RWTestB bit[6:4] = TestMode_SupplyFault[2:0]
//		_util->Wait_Sec(Measure_Delay_s);
//
//		sampled_result[0] = 0;
//		ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//				
//		ret += RunVectorFile("write_fault_sply_pulse");
//
//		ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//		tf_SetResult(TPName[12], sampled_result[0] + GetOffset(TPDispName[12]));
//		
//		// - Param 13 - MskFltsHtr_PostCal
//		
//		//Write Default regs, then enable DMUX - JL: skipped, restore only registers touched above
//		ret += RunVectorFile("write_default_reg");
//		ret += WriteSPI(2, 11, 0x80);
//
//		////JL: from param 5
//		//ret += WriteSPI(1, 13, 0); 
//		//ret += WriteSPI(1, 12, 0); 	
//		//ret += WriteSPI(2, 9, 0); 
//		//ret += WriteSPI(2, 14, 0); 	
//		////JL: from param 7-10
//		//ret += WriteSPI(2, 8, 0); 
//		////JL: from param 11
//		//ret += WriteSPI(1, 10, 0xff); //disable all flt
//		//JL: from param 12
//		ret += WriteSPI(3, 7, 0); //RWTestCtl
//		ret += WriteSPI(3, 9, 0);//RWTestA
//		ret += WriteSPI(3, 10, 0);//RWTestB
//		
//		//MUX[6:0] = 22 = 001_0110b
//		ret += WriteSPI(1, 15, 0x56);//Bit7 = 0 + DMUXAMUXN = 1 + MUX[5:0]
//		
//		ret += WriteSPI(2, 13, 0x10); //MRRNGOVERRIDE bit7=0; default bit4=1, bit7=1
//		ret += WriteSPI(1, 7, 0x11); //idle mode. bit1=0, bit0=1. default 0, 1, 4 are set
//		
//		ret += OnOffCbit(18, 0); //TMU start - disconnect FLTMUX
//		ret += OnOffCbit(22, 1); //TMU start - connect SPE
//		_util->Wait_Sec(Measure_Delay_s);
//
//		//SPE positive is used for TMU start		
//		ret += tm->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
//		ret += tm->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
//		_util->Wait_Sec(Measure_Delay_s);
//
//		sampled_result[0] = 0;
//		retest_count = 0;
//		tmu_timeout = 10e-3;
//		do
//		{
//			ret += tm->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
//			
//			ret += WriteSPI(1, 15, 0x80); //CALIBRATIONCMD bit7=1. default all 0.
//			
//			ret += tm->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
//			if(ret)
//			{
//				ret = 0;
//				retest_count++;
//			}
//			else
//				break;	
//		}
//		while(retest_count < 10);
//
//		tf_SetResult(TPName[13], sampled_result[0] + GetOffset(TPDispName[13]));
//		
//		ret += OnOffSPI(0);
//		/////////////////////////////////////////////////////////////////
//		ret += ResetDMPin(TPDispName[0]);
//
//		//Power down supplies
//		ret += smu->DriveVoltage("VCC", 0);
//		ret += smu->DriveVoltage("VEE", 0);
//
//		//IO setting
//		ret += ResetDIOPin(TPDispName[0]);
//		ret += ResetCBit();
//		ret += ResetMuxIO();
//
//		if (Debug_Enable == true)
//		{
//			sw->Write(sb);	
//			sb = nullptr;
//			sw->Close();
//			sw = nullptr;
//
//			Debug_Enable = false;
//		}
//
//		return ret;
//
//	}
//	int TestProgram::seq_wr_flt_timing(Site ^ site)
//	{
//		if (ForceSingleSite == true) {if (testSite != ForceSingleSiteNumber) return 0;}
//
//		int ret = 0;
//
//		//Get test name from techFlow
//		int total_tp = (int)tf_TPCount();
//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
//
//		for (int i=0; i<total_tp; i++)
//		{
//			TPDispName[i] = tf_TestParameter_DisplayName(i);
//			TPName[i] = tf_TestParameter_Name(i);
//		}
//
//		String ^ TIDispName = tf_TestItem_DisplayName();
//
//		//Get test condition from techFlow
//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
//		double Input_Channel_Delay_s = 0;
//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
//		int SPD_Channel			= _glob->SPD_Channel_Number;
//
//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));
//
//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][testSite];
//
//		if (Debug_Enable == true)
//		{
//			sb = gcnew StringBuilder();
//			sw = gcnew StreamWriter("C:\\Aemulus\\Debug\\" + TIDispName + ".txt");
//		}
//				
//		double vih;
//        double vil;
//        double voh; 
//        double vol;
//        double ioh;
//		double iol;
//        double vch;
//        double vcl;
//		double vt;
//
//		int vector_engine_status = 0;
//		array<int>^ HistoryRam = gcnew array<int>(256);
//		int data = 0;
//
//		Stopwatch swatch;
//
//		//IO setting
//		ret = SetupDigital(site);
//		CheckError(ret, __LINE__);
//		ret = DriveDIOPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = DriveCBit(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = DriveMuxIO(TPDispName[0]);
//		CheckError(ret, __LINE__);
//
//		//Setup Power supplies
//		//ret = smu->SetBandwidth("VCC", Bandwidth);
//		//CheckError(ret, __LINE__);
//		//ret = smu->ClampCurrent("VCC", Clamp_Vcc_Current_A);
//		//CheckError(ret, __LINE__);
//		//ret = smu->DriveVoltage("VCC", 0);
//		//CheckError(ret, __LINE__);
//		//ret = smu->OnSmuPin("VCC", true, false);
//		//CheckError(ret, __LINE__);
//
//		//ret = smu->SetBandwidth("VEE", Bandwidth);
//		//CheckError(ret, __LINE__);
//		//ret = smu->ClampCurrent("VEE", Clamp_Vcc_Current_A);
//		//CheckError(ret, __LINE__);
//		//ret = smu->DriveVoltage("VEE", 0);
//		//CheckError(ret, __LINE__);
//		//ret = smu->OnSmuPin("VEE", true, false);
//		//CheckError(ret, __LINE__);
//
//		//_util->Wait_Sec(0.001);
//
//		ret = smu->DriveVoltage("VCC", Drive_Vcc_V);
//		CheckError(ret, __LINE__);
//		ret = smu->DriveVoltage("VEE", Drive_Vee_V);
//		CheckError(ret, __LINE__);
//
//		//_util->Wait_Sec(On_Delay_s);
//
//		vih = 2.5;
//        vil = 0.00;
//        voh = 0.75; 
//        vol = 0.75;
//        ioh = 0.002;
//		iol = 0.002;
//        vch = 6;
//        vcl = -0.1;
//		vt = 0;
//
//		ret = dm->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPE");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPD");
//		CheckError(ret, __LINE__);
//
//		ret = dm->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("SPC");
//		CheckError(ret, __LINE__);
//
//		ret = DriveDMPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//
//		//Configure Input Delay
//		ret = dm->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
//		CheckError(ret, __LINE__);
//
//		if (Debug_Enable == true)
//		{
//			sb->AppendLine("-----------------------------------------------------------------------");
//			sb->AppendLine("VCC: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("VEE: BW=" + Bandwidth.ToString() + ", Drive_V=" + Drive_Vcc_V.ToString() + ", Clamp_A=" + Clamp_Vcc_Current_A.ToString());
//			sb->AppendLine("SPE: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPD: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("SPC: Vih_V=" + vih.ToString() + ", Vil_V=" + vil.ToString() + ", Voh_=" + voh.ToString() + ", Vol_V=" + vol.ToString());
//			sb->AppendLine("On_Delay_s=" + On_Delay_s);
//		}
//		
//		/////////////////////////////////
//
//		ret = dm->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("RWN");
//		CheckError(ret, __LINE__);
//
//		vih = 1.8;
//		ret = dm->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("WDX");
//		CheckError(ret, __LINE__);
//
//		vih = 1.5;
//		ret = dm->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
//		CheckError(ret, __LINE__);
//		ret = dm->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
//		CheckError(ret, __LINE__);
//		ret = dm->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
//		CheckError(ret, __LINE__);
//		ret = dm->DPINOn("WDY");
//		CheckError(ret, __LINE__);
//
//		#ifndef USE_SPI
//		ret = RunVectorFile(Vector_File);
//		CheckError(ret, __LINE__);
//		#else
//		ret = OnOffSPI(1);
//		CheckError(ret, __LINE__);
//		ret = RunSPI(Vector_File);
//		CheckError(ret, __LINE__);
//		#endif
//
//		/* Code for 2935, different test flow on 2945
//		for(int j=30; j<50; j++) //Catalyst's result is i=38, freq=3.44828MHz
//		{
//			//In Aemulus test, a full cycle consist 2 pulses (high - low).
//			//In Catalyst test, a full cycle consist of 4 pulses (high - low - high - low). That means whatever freq set in Catalyst need to times 2 for Aemulus. Proved by observing scope shot. 
//			freq	= 1/(100e-9 + 5e-9*j); //start with 4MHz, follow catalyst
//			period	= 1/(freq*2);//times 2 is because 8 MHz for Aemulus.
//			
//			ret = dm->DPINPeriod("DM_2", 99, period); //always change no set 99 only
//			CheckError(ret, __LINE__);
//		
//			//sweep WDX and WDY freq
//			ret = dm->SPI_CH_UNSEL("DM_2", 0);
//			CheckError(ret, __LINE__);
//
//			ret = RunVectorFile("WDX_WDY_6400bits");
//			CheckError(ret, __LINE__);
//
//			ret = dm->SPI_CHSEL("DM_2", 0, "SPC", "SPE", "SPD", "SPD");
//			CheckError(ret, __LINE__);
//
//			//Read p1_reg6 and check for bit1 status
//			#ifndef USE_SPI
//			ret = ReadVector("read_p1_reg6_wr_flt_timing", data);
//			CheckError(ret, __LINE__);
//			#else
//			ret = ReadSPI("read_p1_reg6_wr_flt_timing", data);
//			CheckError(ret, __LINE__);
//			#endif
//			
//			result_adc = data & 0x02;
//
//			//Read p1_reg8 and check for bit2 status
//			#ifndef USE_SPI
//			ret = ReadVector("read_p1_reg8_wr_flt_timing", data);
//			CheckError(ret, __LINE__);
//			#else
//			ret = ReadSPI("read_p1_reg8_wr_flt_timing", data);
//			CheckError(ret, __LINE__);
//			#endif
//
//			result_adc2 = data & 0x04;
//
//			if((result_adc == 2) && (result_adc2 == 4)) //if any of the FLT bit is triggered, then break
//			{
//				break;
//			}
//			else //reset & loop
//			{
//				result_adc	= 0;
//				result_adc2 = 0;
//			}
//		} 
//
//		result_wr_timing = period;
//		*/
//		int lolim_result = 0; //0 indicate test pass, 1 fail.
//		int hilim_result = 0; 
//		double lolim = 50e-9; //50ns
//		double hilim = 100e-9; //100ns
//		int pin_val = 0;
//		int reg_val = 0;
//		int test_result = 0; //0 indicate test pass, 1 fail.
//		double period = 0;
//		double freq = 0;
//		
//		//pwr_up
//		ret = RunVectorFile("write_dig_faults"); //JL: write_dig_faults is the same as Catalyst vector "pwr_up"
//		
//		ret = OnOffSPI(1);
//
//		//enable WDataFLoFlt
//		ret += WriteSPI(1, 10, 0xbf);
//		//clear_fsr
//		ret += WriteSPI(1, 8, 0);
//
//		ret = OnOffSPI(0);
//		
//		for(int i=0; i<2; i++) //i=1 test lolim, i=2 test hilim
//		{	
//			if(i==0)//lolim settings
//			{
//				freq = 1/lolim/2.0;
//			}	
//			else //hilim settings
//			{
//				freq = 1/hilim/2.0;
//			}
//			//In Aemulus test, a full cycle consist 2 pulses (high - low).
//			//In Catalyst test, a full cycle consist of 4 pulses (high - low - high - low). That means whatever freq set in Catalyst need to times 2 for Aemulus. Proved by observing scope shot. 
//			
//			period	= 1/(freq*2);//times 2 is because 8 MHz for Aemulus.
//			
//			ret = dm->DPINPeriod("DM_2", 99, period); //always change no set 99 only
//			CheckError(ret, __LINE__);		
//			
//			//enable writer: RWN=0, toggles WDX/WDY
//			ret = RunVectorFile("WDX_WDY_6400bits");
//			CheckError(ret, __LINE__);
//			//by end of the vector file, RWN=1
//			
//			//check FLTMUX, verify no fault
//			//default RWN=1 > read mode. Verify no fault, FLTMUX=1
//			//JL: too late to check FLTMUX pin in test program, fault removed at the end of vector.
//			//    Best is to check in vector file, or not checking this at all.
//			/*ret += dm->ReadPin("FLTMUX", pin_val);
//			if(pin_val != 1)
//				test_result=1;	*/
//
//			ret = OnOffSPI(1);		
//			//chk_fsr_NoFaults
//			ret += ReadReg(1, 8, reg_val); //verify no fault in FSR
//			if(reg_val != 0)
//				test_result=1;
//			
//			//clear_fsr
//			ret += WriteSPI(1, 8, 0);
//						
//			ret = OnOffSPI(0);
//
//			if(i==0)//set lolim result
//				lolim_result = test_result;
//			else //set hilim result
//				hilim_result = test_result;
//		}
//		ret = OnOffSPI(1);
//		//mask all faults
//		ret += WriteSPI(1, 10, 0xff);
//		ret = OnOffSPI(0);
//		
//		tf_SetResult(TPName[0], (hilim_result && !lolim_result) + GetOffset(TPDispName[0])); //expect hilim to fail, lolim to pass. Return 1 if meeting expected results.
//		ret = OnOffSPI(0);
//		/////////////////////////////////
//
//		ret = ResetDMPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//
//		//Power down supplies
//		ret = smu->DriveVoltage("VEE", 0);
//		CheckError(ret, __LINE__);
//		ret = smu->DriveVoltage("VCC", 0);
//		CheckError(ret, __LINE__);
//
//		//IO setting
//		ret = ResetDIOPin(TPDispName[0]);
//		CheckError(ret, __LINE__);
//		ret = ResetCBit();
//		CheckError(ret, __LINE__);
//		ret = ResetMuxIO();
//		CheckError(ret, __LINE__);
//
//		if (Debug_Enable == true)
//		{
//			sw->Write(sb);	
//			sb = nullptr;
//			sw->Close();
//			sw = nullptr;
//
//			Debug_Enable = false;
//		}
//
//		return ret;
//	}
	//2945 specified func
	//double TestProgram::supply_thr_ppmu(String ^ pin, double pass_th, double fail_th,int flt_lvl)
	//{
	//	int ret = 0;
	//	int loop_count = 0;
	//	int had_pass = 0;
	//	int had_fail = 0;
	//	int pin_val = 0;
	//	double thresh, sply_restore;
	//	double flt_pin = 0;
	//	sply_restore = pass_th;
	//	ret += smu->DriveVoltage(pin, fabs(sply_restore));
	//	_util->Wait_Sec(100e-6);

	//	////debug
	//	//double vcc_val, vee_val;
	//	//ret = smu->Measure("VCC", 1, vcc_val);
	//	//ret = smu->Measure("VEE", 1, vee_val);
	//	//ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
	//	////end debug

	//	while(loop_count < 10 && fabs(pass_th - fail_th) > 0.001)
	//	{
	//		if (pass_th<fail_th) //to search for fault threshold from low to high
	//			thresh = pass_th + ((fail_th-pass_th)/2);
	//		else //to search for fault threshold from high to low
	//			thresh = fail_th + ((pass_th-fail_th)/2);
	//			
	//		if (sply_restore>thresh)
	//		{ //gradually reduce supply voltage by 0.1, 0.02, 0.01, 0.005V
	//			if (sply_restore>thresh+0.1) 
	//				ret += smu->DriveVoltage(pin, fabs(thresh+0.1));
	//			if (sply_restore>thresh+0.02)
	//				ret += smu->DriveVoltage(pin, fabs(thresh+0.02));
	//			if (sply_restore>thresh+0.01)
	//				ret += smu->DriveVoltage(pin, fabs(thresh+0.01));
	//			if (sply_restore>thresh+0.005)
	//				ret += smu->DriveVoltage(pin, fabs(thresh+0.005));
	//		}
	//		else
	//		{ //gradually increase supply voltage by 0.1, 0.02, 0.01, 0.005V
	//			if (sply_restore<thresh-0.1)
	//				ret += smu->DriveVoltage(pin, fabs(thresh-0.1));//JL: Note - SMU only allows +ve values
	//			if (sply_restore<thresh-0.02)
	//				ret += smu->DriveVoltage(pin, fabs(thresh-0.02));
	//			if (sply_restore<thresh-0.01)
	//				ret += smu->DriveVoltage(pin, fabs(thresh-0.01));
	//			if (sply_restore<thresh-0.005)
	//				ret += smu->DriveVoltage(pin, fabs(thresh-0.005));
	//		}
	//		//_util->Wait_Sec(1e-3);
	//		//ret = smu->Measure("VEE", 1, vee_val);
	//		ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
	//		if(flt_pin > 1) 
	//			pin_val = 1;
	//		else
	//			pin_val = 0;

	//		if(pin_val != flt_lvl) 
	//		{
	//			pass_th = thresh;
 //				had_pass = 1;
	//		}
	//		else
	//		{
	//			fail_th = thresh;
	//			had_fail = 1;
	//		}
	//		loop_count++;
	//		
	//		if(sply_restore > 0)
	//			ret += smu->DriveVoltage(pin, fabs(sply_restore-0.1));
	//		else
	//			ret += smu->DriveVoltage(pin, fabs(sply_restore+0.1));
	//		
	//		ret += smu->DriveVoltage(pin, fabs(sply_restore));
	//		_util->Wait_Sec(100e-6);
	//	}
	//	
	//	////debug
	//	//ret = smu->Measure("VCC", 1, vcc_val);
	//	//ret = smu->Measure("VEE", 1, vee_val);
	//	//ret = dm->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
	//	////end debug

	//	CheckError(ret, __LINE__);

	//	return ((pass_th+fail_th)/2);
	//}
	
	int TestProgram::InactiveSiteCheck(Site ^ site)
	{
		int ret = 0;
		int result = 0  ;
		
		String ^ TPDispName = tf_TestParameter_DisplayName(0);
		String ^ TPName = tf_TestParameter_Name(0);
			
		array<bool>^ run_test = gcnew array<bool>(_numOffset);
		IsRunTest(site, run_test);

		for(int idx=0; idx<_numOffset; idx++)
		{
			if ((idx != ForceSingleSiteNumber) && SingleSiteTest)
			{
				result = 0;
				//force open

				_glob->contact_fail[idx] = 1;
				_glob->contact_open_l_short_h[idx] = 0;

			}else{
				result = 1;
			}
			
			if(run_test[idx])
			{

				tf_SetResult_UUTOffset(TPName, result + (int)GetOffset(idx, TPDispName), idx);
		
			}
		}
		return ret;
	}


	int TestProgram::Digitizer_GetData(int UutOffsetIndex,int channel, int nbrSamples, int index)
	{
		//Convert 1D array to 2D array
		int ret = 0;
		ret = Digitizer_ClearData(UutOffsetIndex, index );

		if(UutOffsetIndex == 0) //Site0
		{
			//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_temp_Arr_S0);
			//ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_temp_Arr_S0);
			ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, nbrSamples, index);
			
			CheckError(UutOffsetIndex, ret, __LINE__);
			/*for(int i=0; i<nbrSamples; i++)
			{
				_glob->DIG_Data_Arr[UutOffsetIndex, i, index] = _glob->DIG_temp_Arr_S0[i];
			}*/
		}
		//else if(UutOffsetIndex == 1) //Site1
		//{
		//	//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_temp_Arr_S1);
		//	ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_temp_Arr_S1);

		//	CheckError(UutOffsetIndex, ret, __LINE__);
		//	for(int i=0; i<nbrSamples; i++)
		//	{
		//		_glob->DIG_Data_Arr[UutOffsetIndex, i, index] = _glob->DIG_temp_Arr_S1[i];
		//	}
		//}
		//else if(UutOffsetIndex == 2) //Site2
		//{
		//	//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_temp_Arr_S2);
		//	ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_temp_Arr_S2);
		//	CheckError(UutOffsetIndex, ret, __LINE__);
		//	for(int i=0; i<nbrSamples; i++)
		//	{
		//		_glob->DIG_Data_Arr[UutOffsetIndex, i, index] = _glob->DIG_temp_Arr_S2[i];
		//	}
		//}
		//else //Site3
		//{
		//	//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_temp_Arr_S3);
		//	ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_temp_Arr_S3);
		//	CheckError(UutOffsetIndex, ret, __LINE__);
		//	for(int i=0; i<nbrSamples; i++) 
		//	{
		//		_glob->DIG_Data_Arr[UutOffsetIndex, i, index] = _glob->DIG_temp_Arr_S3[i];
		//	}
		//}		

		return ret;
	}
	int TestProgram::Digitizer_ClearData(int UutOffsetIndex, int index)
	{
		//Clear all Digitier Global Array
		int ret = 0;

		if(UutOffsetIndex == 0) //Site0
		{
			for(int i=0; i<NORM_DIG_SAMPLE; i++)
			{
				_glob->DIG_Data_Arr[UutOffsetIndex, i, index] = 0;
				//_glob->DIG_temp_Arr_S0[i] = 0;
			}
		}
		else if(UutOffsetIndex == 1) //Site1
		{
			for(int i=0; i<NORM_DIG_SAMPLE; i++)
			{
				_glob->DIG_Data_Arr[UutOffsetIndex, i, index ] = 0;
				//_glob->DIG_temp_Arr_S1[i] = 0;
			}
		}
		else if(UutOffsetIndex == 2) //Site2
		{
			for(int i=0; i<NORM_DIG_SAMPLE; i++)
			{
				_glob->DIG_Data_Arr[UutOffsetIndex, i, index ] = 0;
				//_glob->DIG_temp_Arr_S2[i] = 0;
			}
		}
		else //Site3
		{
			for(int i=0; i<NORM_DIG_SAMPLE; i++)
			{
				_glob->DIG_Data_Arr[UutOffsetIndex, i, index ] = 0;
				//_glob->DIG_temp_Arr_S3[i] = 0;
			}
		}		

		return ret;
	}
	int TestProgram::Digitizer_GetBigData(int UutOffsetIndex,int channel, int nbrSamples)
	{
		//Convert 1D array to 2D array
		int ret = 0;
		ret = Digitizer_ClearBigData(UutOffsetIndex);

		if(UutOffsetIndex == 0) //Site0
		{
			//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_Big_temp_Arr_S0);
			//ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_Big_temp_Arr_S0);
			ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, nbrSamples);
			CheckError(UutOffsetIndex, ret, __LINE__);
			/*for(int i=0; i<nbrSamples; i++)
			{
				_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = _glob->DIG_Big_temp_Arr_S0[i];
			}*/
		}
		//else if(UutOffsetIndex == 1) //Site1
		//{
		//	//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_Big_temp_Arr_S1);

		//	ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_Big_temp_Arr_S1);

		//	CheckError(UutOffsetIndex, ret, __LINE__);
		//	for(int i=0; i<nbrSamples; i++)
		//	{
		//		_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = _glob->DIG_Big_temp_Arr_S1[i];
		//	}
		//}
		//else if(UutOffsetIndex == 2) //Site2
		//{
		//	//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_Big_temp_Arr_S2);
		//	ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_Big_temp_Arr_S2);
		//	CheckError(UutOffsetIndex, ret, __LINE__);
		//	for(int i=0; i<nbrSamples; i++)
		//	{
		//		_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = _glob->DIG_Big_temp_Arr_S2[i];
		//	}
		//}
		//else //Site3
		//{
		//	//ret = digitizer[UutOffsetIndex]->RetrieveData("DIGITIZER_CH", _glob->DIG_Big_temp_Arr_S3);
		//	ret = RetrieveDigitizerDataArray(UutOffsetIndex, channel, _glob->DIG_Big_temp_Arr_S3);
		//	CheckError(UutOffsetIndex, ret, __LINE__);
		//	for(int i=0; i<nbrSamples; i++) 
		//	{
		//		_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = _glob->DIG_Big_temp_Arr_S3[i];
		//	}
		//}		

		return ret;
	}
	int TestProgram::Digitizer_ClearBigData(int UutOffsetIndex)
	{
		//Clear all Digitier Global Array
		int ret = 0;

		if(UutOffsetIndex == 0) //Site0
		{
			for(int i=0; i<MAX_DIG_SAMPLE; i++)
			{
				_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = 0;
				//_glob->DIG_Big_temp_Arr_S0[i] = 0;
			}
		}
		else if(UutOffsetIndex == 1) //Site1
		{
			for(int i=0; i<MAX_DIG_SAMPLE; i++)
			{
				_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = 0;
				//_glob->DIG_Big_temp_Arr_S1[i] = 0;
			}
		}
		else if(UutOffsetIndex == 2) //Site2
		{
			for(int i=0; i<MAX_DIG_SAMPLE; i++)
			{
				_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = 0;
				//_glob->DIG_Big_temp_Arr_S2[i] = 0;
			}
		}
		else //Site3
		{
			for(int i=0; i<MAX_DIG_SAMPLE; i++)
			{
				_glob->DIG_Big_Data_Arr[UutOffsetIndex, i ] = 0;
				//_glob->DIG_Big_temp_Arr_S3[i] = 0;
			}
		}		

		return ret;
	}
	//
	int TestProgram::startDigitizerDGTAcquire(int UutOffsetIndex, int ch)
	{
		int ret = 0;

		int channel = 0;

		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else //if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		int DGTStart = 0x11;

		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, DGTStart, 0); //init start/stop
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, DGTStart, 0); //init start/stop

		return ret;
	}
	int TestProgram::stopDigitizerDGTAcquire(int UutOffsetIndex, int ch)
	{
		int ret = 0;

		int channel = 0;

		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else //if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		int Stop = 0x2;

		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, Stop, 0);
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, Stop, 0);

		return ret;
	}
	int TestProgram::stopDigitizerFFTAcquire(int UutOffsetIndex, int ch)
	{
		int ret = 0;

		int channel = 0;

		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else //if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		int FFTStop = 0x2;

		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, FFTStop, 0); //init start/stop
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, FFTStop, 0); //init start/stop
		
		CheckError(UutOffsetIndex, ret, __LINE__);

		return ret;
	}
	int TestProgram::waitDigitizerDGTComplete(int UutOffsetIndex, int ch)
	{
		int ret = 0;

		int channel = 0;

		Stopwatch swatch;
		double TimeOut_s = 0.1;

		bool timeout = true;

		int RDY = 0;

		int ReadRequest = 0x1000;
		
		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		int ReadStatus = 0;

		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < TimeOut_s)
		{
			swatch.Start();

			if (channel == 1)
				ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_STATUS, ReadStatus); 
			else
				ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_STATUS, ReadStatus); 
			CheckError(UutOffsetIndex, ret, __LINE__);

			RDY = ReadStatus & 0x80000000;

			if (RDY == 0x80000000)
			{
				timeout = false;
				break;
			}

			swatch.Stop();
		}

		if (timeout)
		{
			ret = stopDigitizerDGTAcquire(UutOffsetIndex, ch);
			return 0xBFFA4900; //ACQIRI'S_ERROR_ACQ_TIMEOUT
		}

		RDY = 0;
		ReadStatus = 0;
		timeout = true;

		//Check for read granted
		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, ReadRequest, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, ReadRequest, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);

		swatch.Reset();
		swatch.Start();
		swatch.Stop();

		while (swatch.Elapsed.TotalSeconds < TimeOut_s)
		{
			swatch.Start();

			if (channel == 1)
				ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_STATUS, ReadStatus); 
			else
				ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_STATUS, ReadStatus); 
			CheckError(UutOffsetIndex, ret, __LINE__);

			RDY = ReadStatus & 0x00400000;

			if (RDY == 0x00400000)
			{
				timeout = false;
				break;
			}

			swatch.Stop();
		}

		if (timeout)
		{
			ret = stopDigitizerDGTAcquire(UutOffsetIndex, ch);
			return 0xBFFA4900; //ACQIRIS_ERROR_ACQ_TIMEOUT
		}

		return ret;
	}
	int TestProgram::RetrieveDigitizerDataArray(int UutOffsetIndex, int ch, array <double> ^ % data)
	{
		int ret = 0;

		int channel = 0;

		int RDY = 0;

		int ReadRelease = 0x2000;
		int ReadStatus = 0;
		int StartAddr = 0x0;
		
		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else //if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		//array<int> ^ readdata = gcnew array<int>(data->Length);
		if(data->Length == MAX_DIG_SAMPLE)
		//array<int> ^ readdata = gcnew array<int>(2048);  // sidi insert for itr timing 
		//if(data->Length != MAX_DIG_SAMPLE)
		{
			for (int i=0; i<data->Length; i++)
				readdata_big[i] = 0;
		}else{
			for (int i=0; i<data->Length; i++)
				readdata[i] = 0;
		}

		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_START_ADDRESS, StartAddr, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH1_BUFFER_IDENTIFIER, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH2_BUFFER_IDENTIFIER, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);

		if(data->Length == MAX_DIG_SAMPLE)
		{
			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIOArray("DIGITIZER", REG_DATAPORT, readdata_big);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}else{
			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIOArray("DIGITIZER", REG_DATAPORT, readdata);
			CheckError(UutOffsetIndex, ret, __LINE__);
		}

		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, ReadRelease, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, ReadRelease, 0); 
			CheckError(UutOffsetIndex, ret, __LINE__);		

		int j = 0;
		int dataTemp = 0;

		if(data->Length == MAX_DIG_SAMPLE)
		{
			for (int i=0; i<data->Length/2; i++)
			{		
				dataTemp = ((readdata_big[i] << 16 ) >> 16);

				if (readdata_big[i] > 0)
					data[j] = (double)dataTemp / 32767;
				else
					data[j] = (double)dataTemp / 32768;

				j++;
				dataTemp = (readdata_big[i] >> 16);

				if (readdata_big[i] > 0)
					data[j] = (double)dataTemp / 32767;
				else
					data[j] = (double)dataTemp / 32768;

				j++;
			}
		}else{
			for (int i=0; i<data->Length/2; i++)
			{		
				dataTemp = ((readdata[i] << 16 ) >> 16);

				if (readdata[i] > 0)
					data[j] = (double)dataTemp / 32767;
				else
					data[j] = (double)dataTemp / 32768;

				j++;
				dataTemp = (readdata[i] >> 16);

				if (readdata[i] > 0)
					data[j] = (double)dataTemp / 32767;
				else
					data[j] = (double)dataTemp / 32768;

				j++;
			}
		
		
		}

		return ret;
	}
	//int TestProgram::RetrieveDigitizerDataArray(int UutOffsetIndex, int ch, array <double> ^ % data)
	//{
	//	int ret = 0;

	//	int channel = 0;

	//	int RDY = 0;

	//	int ReadRelease = 0x2000;
	//	int ReadStatus = 0;
	//	int StartAddr = 0x0;
	//	
	//	if (ch == 1 || ch == 0x80000000)
	//	{
	//		channel = 1;
	//	}
	//	else //if (ch == 2 || ch == 0x40000000)
	//	{
	//		channel = 2;
	//	}

	//	//array<int> ^ readdata = gcnew array<int>(data->Length);

	//	array<int> ^ readdata = gcnew array<int>(2048);  // sidi insert for itr timing 
	//	if(data->Length != MAX_DIG_SAMPLE)

	//	{
	//		for (int i=0; i<data->Length; i++)
	//			readdata_big[i] = 0;
	//	}else{
	//		for (int i=0; i<data->Length; i++)
	//			readdata[i] = 0;
	//	
	//	}

	//	
	//	int e =1;
	//	
	//	ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_START_ADDRESS, StartAddr, 0); 
	//	CheckError(UutOffsetIndex, ret, __LINE__);
	//	
	//	if (channel == 1)
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH1_BUFFER_IDENTIFIER, 0); 
	//	else
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH2_BUFFER_IDENTIFIER, 0); 
	//	CheckError(UutOffsetIndex, ret, __LINE__);

	//	if(data->Length == MAX_DIG_SAMPLE)

	//	{
	//		ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIOArray("DIGITIZER", REG_DATAPORT, readdata_big);
	//		CheckError(UutOffsetIndex, ret, __LINE__);
	//	}else{
	//		ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIOArray("DIGITIZER", REG_DATAPORT, readdata);
	//		CheckError(UutOffsetIndex, ret, __LINE__);
	//	}

	//	if (channel == 1)
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, ReadRelease, 0); 
	//	else
	//		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, ReadRelease, 0); 
	//		CheckError(UutOffsetIndex, ret, __LINE__);		

	//	int j = 0;
	//	int dataTemp = 0;

	//	if(data->Length == MAX_DIG_SAMPLE)


	//	{
	//		for (int i=0; i<data->Length/2; i++)
	//		{		
	//			dataTemp = ((readdata_big[i] << 16 ) >> 16);

	//			if (readdata_big[i] > 0)
	//				data[j] = (double)dataTemp / 32767;
	//			else
	//				data[j] = (double)dataTemp / 32768;

	//			j++;
	//			dataTemp = (readdata_big[i] >> 16);

	//			if (readdata_big[i] > 0)
	//				data[j] = (double)dataTemp / 32767;
	//			else
	//				data[j] = (double)dataTemp / 32768;

	//			j++;
	//		}
	//	}else{
	//		for (int i=0; i<data->Length/2; i++)
	//		{		
	//			dataTemp = ((readdata[i] << 16 ) >> 16);

	//			if (readdata[i] > 0)
	//				data[j] = (double)dataTemp / 32767;
	//			else
	//				data[j] = (double)dataTemp / 32768;

	//			j++;
	//			dataTemp = (readdata[i] >> 16);

	//			if (readdata[i] > 0)
	//				data[j] = (double)dataTemp / 32767;
	//			else
	//				data[j] = (double)dataTemp / 32768;

	//			j++;
	//		}
	//	
	//	
	//	}

	//	return ret;
	//}
	int TestProgram::RetrieveDigitizerDataArray(int UutOffsetIndex, int ch, int SampleSize, int index)
	{
		int ret = 0;

		int channel = 0;

		int RDY = 0;

		int ReadRelease = 0x2000;
		int ReadStatus = 0;
		int StartAddr = 0x0;
		
		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else //if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		//array<int> ^ readdata = gcnew array<int>(data->Length);

			for (int i=0; i<SampleSize; i++)
				readdata[i] = 0;
	
		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_START_ADDRESS, StartAddr, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH1_BUFFER_IDENTIFIER, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH2_BUFFER_IDENTIFIER, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);


			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIOArray("DIGITIZER", REG_DATAPORT, readdata);
			CheckError(UutOffsetIndex, ret, __LINE__);
	

		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, ReadRelease, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, ReadRelease, 0); 
			CheckError(UutOffsetIndex, ret, __LINE__);		

		int j = 0;
		int dataTemp = 0;


			for (int i=0; i<SampleSize/2; i++)
			{		
				dataTemp = ((readdata[i] << 16 ) >> 16);

				if (readdata[i] > 0)
					_glob->DIG_Data_Arr[UutOffsetIndex, j, index] = (double)dataTemp / 32767;
				else
					_glob->DIG_Data_Arr[UutOffsetIndex, j, index] = (double)dataTemp / 32768;

				j++;
				dataTemp = (readdata[i] >> 16);

				if (readdata[i] > 0)
					_glob->DIG_Data_Arr[UutOffsetIndex, j, index] = (double)dataTemp / 32767;
				else
					_glob->DIG_Data_Arr[UutOffsetIndex, j, index] = (double)dataTemp / 32768;

				j++;
			}
		


		return ret;
	}
	int TestProgram::RetrieveDigitizerDataArray(int UutOffsetIndex, int ch, int SampleSize)
	{
		int ret = 0;

		int channel = 0;

		int RDY = 0;

		int ReadRelease = 0x2000;
		int ReadStatus = 0;
		int StartAddr = 0x0;
		
		if (ch == 1 || ch == 0x80000000)
		{
			channel = 1;
		}
		else //if (ch == 2 || ch == 0x40000000)
		{
			channel = 2;
		}

		//array<int> ^ readdata = gcnew array<int>(data->Length);
		for (int i=0; i<SampleSize; i++)
				readdata_big[i] = 0;
		

		ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_START_ADDRESS, StartAddr, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);
		
		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH1_BUFFER_IDENTIFIER, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_BUFFER_IDENTIFIER, DAT_CH2_BUFFER_IDENTIFIER, 0); 
		CheckError(UutOffsetIndex, ret, __LINE__);

		ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIOArray("DIGITIZER", REG_DATAPORT, readdata_big);
		CheckError(UutOffsetIndex, ret, __LINE__);

		if (channel == 1)
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH1_CONTROL, ReadRelease, 0); 
		else
			ret = digitizer[UutOffsetIndex]->WriteLogicDeviceIO("DIGITIZER", REG_CH2_CONTROL, ReadRelease, 0); 
			CheckError(UutOffsetIndex, ret, __LINE__);		

		int j = 0;
		int dataTemp = 0;

	
			for (int i=0; i<SampleSize/2; i++)
			{		
				dataTemp = ((readdata_big[i] << 16 ) >> 16);

				if (readdata_big[i] > 0)
					_glob->DIG_Big_Data_Arr[UutOffsetIndex, j] = (double)dataTemp / 32767;
				else
					_glob->DIG_Big_Data_Arr[UutOffsetIndex, j] = (double)dataTemp / 32768;

				j++;
				dataTemp = (readdata_big[i] >> 16);

				if (readdata_big[i] > 0)
					_glob->DIG_Big_Data_Arr[UutOffsetIndex, j] = (double)dataTemp / 32767;
				else
					_glob->DIG_Big_Data_Arr[UutOffsetIndex, j] = (double)dataTemp / 32768;

				j++;
			}
	

		return ret;
	}


	int TestProgram::FindAmplitude(int UutOffsetIndex, array<double> ^ dat, double thres_v, double % amp)
	{
		int ret = 0;

		amp = 0;
		int peak_count = 0;
		double peak_voltage = 0;
		// thres_v is to define the window of the waveforms to be captured. 15mV rising/faling
		int ArrLength = dat->GetLength(0);
		int start, end = 0;
		double max = 0;
		int resol = 3; //resolution defines how many sample per loop to find the peak_voltage
		int count = 0;

		//find the start point of the waveforms, and flush the rest at the front
		for(int i=0; i<ArrLength; i++)
		{
			//if detected any 1 point > thres_v
			if((abs(dat[i])>thres_v) && i<ArrLength)
			{
				//move on further to another 4 continuous points to check if any more 1 point > thres_v, then window start
				for(int x=(i+1); x<(i+4); x++)
				{
					if(abs(dat[x])>thres_v)
					{
						start = i;
						break;
					}
				}

				if(start!=NULL)
					break;
			}

			else if(i>=ArrLength)
				amp = -999;
		}
		
		//find the end point of the waveforms, and flush the rest at the end
		for(int j=start; j<ArrLength; (j+=5))
		{
			if((abs(dat[j])<thres_v) && j<ArrLength)
			{
				//move on further to another 4 continuous points to check if any more 4 point < thres_v, then window end
				for(int x=(j+1); x<(j+5); x++)
				{
					if(abs(dat[x])<thres_v)
					 count++;
				}

				if(count>=4)
				{
					end = j;
					break;
				}
				
				count = 0;
			}

			else if(j>=ArrLength)
				amp = -999;
		}

		//find amplitude
		if(amp == 0)
		{
			for(int k=start; k<end; (k+=resol))
			{
				//compare 3 points to find the peak
				for(int n=k; n<(k+resol); n++)
				{
					if(n==k)
						max = abs(dat[n]);

					else if (abs(dat[n]) > max)
						max = abs(dat[n]);
				}

				peak_voltage = peak_voltage + max;
				peak_count++;
			}

			amp = peak_voltage/peak_count;
		}
		
		return ret;
	}
	//AC_TTR
	int TestProgram::logstatus(int UutOffsetIndex,  string sstr)
	{
		int ret = 0;
		int ReadStatus = 0;
		std::ofstream outfile;
		
		if( sstr=="-")
		{
		outfile.open("C://Aemulus//Debug//DGT.txt", ios::out);
		}else
		{
			outfile.open("C://Aemulus//Debug//DGT.txt", ios::out| ios::app);
			outfile << sstr.c_str() << endl;

			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH1_STATUS, ReadStatus);
			outfile << " 1  " << hex << ReadStatus << endl; 
			ret = digitizer[UutOffsetIndex]->ReadLogicDeviceIO("DIGITIZER", REG_CH2_STATUS, ReadStatus);
			outfile << " 2  " << hex << ReadStatus << endl << endl; 
		}
		outfile.close();
		
		return ret;

	}
	int TestProgram::PrntWfrm(string sstr, array <double> ^ % data)
	{
		int ret = 0;
		
		std::ofstream outfile;
		string filepath = "C://Aemulus//Debug//" + sstr + ".csv"; 
		outfile.open(filepath.c_str(), ios::out);
		outfile << sstr << endl;
		for (int i = 0; i < data->Length; i++)
		{
			outfile << data[i] << endl;
		
		}
		outfile.close();


		return ret;
	}
	int TestProgram::PrntWfrm(string sstr, array <int> ^ % data)
	{
		int ret = 0;
		
		std::ofstream outfile;
		string filepath = "C://Aemulus//Debug//" + sstr + ".csv"; 
		outfile.open(filepath.c_str(), ios::out);
		outfile << sstr << endl;
		for (int i = 0; i < data->Length; i++)
		{
			outfile << data[i] << endl;
		
		}
		outfile.close();


		return ret;
	}
	int TestProgram::seq_wr_timing3_combo(Site ^ site)
	{
		return DoThreadWithoutVee_AWG(gcnew ParameterizedThreadStart(this, &TestProgram::wr_timing3_combo), site);
	}

	int TestProgram::seq_rw_timing3(Site ^ site)
	{
		return DoThreadWithoutVee_AWG(gcnew ParameterizedThreadStart(this, &TestProgram::rw_timing3), site);
	}

	int TestProgram::seq_wtr_slow_combo(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::wtr_slow_combo), site);
	}

	int TestProgram::seq_hth_timing_2hd_3(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::hth_timing_2hd_3), site);
	}
	int TestProgram::seq_bias_timing3(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::bias_timing3), site);
	}
	int TestProgram::seq_itr_timing3(Site ^ site)
	{
		return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::itr_timing3), site);
	}
	//int TestProgram::seq_flt_timing2(Site ^ site)
	//{
	//	return DoThreadWithoutVee(gcnew ParameterizedThreadStart(this, &TestProgram::flt_timing2), site);
	//}
	
	void TestProgram::wr_timing3_combo(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			bool FindAmpEnable		= (bool)(tf_TestItemCondition_Cast("FindAmpEnable"));//enable skip FindAmplitude to reduce test time
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

			double sync_rwn_timing	= 0;

			if (calfactor->ContainsKey("SYNC_RWN_DELAY"))
				sync_rwn_timing = calfactor["SYNC_RWN_DELAY"][idx];

			int sync_rwn_timing_index = (int)(sync_rwn_timing / 1e-9); //digitizer sampling interval is 1ns

			String ^ Vector_File	= String::Empty;
			String ^ Vector_File_1  = String::Empty;

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);

			//_util->Wait_Sec(On_Delay_s);

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 
			double amp_0deg, amp_90deg, amp_180deg, amp_270deg = 0;

			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

			
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			double vout_pp = 0.0;

			int max_loop = 50;

			//On K3, K4
			ret = DriveCBit(idx, TPDispName[0], 1);
			CheckError(idx, ret, __LINE__);

			#pragma region "Calibration of Vpp"
			if (Vswg_timing_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				array<double> ^ dataArray = gcnew array<double>(nbrSamples);
				
				double Vswg_cal = 0;
				int loop_count = 0;

				Vswg_cal = Vswg;

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						ret = Digitizer_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
						CheckError(idx, ret, __LINE__);
						
						do_once = 1;
					}

 					ret = DigitizerFFT_CaptureVpp(idx,sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
					CheckError(idx, ret, __LINE__);

					if (ret)
					{

						ret = stopDigitizerFFTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						ret = 0;

						goto test_end;
					}

				
					if (Debug_Enable == true)
					{
						ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
						CheckError(idx, ret, __LINE__);
							
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int i = 0; i < nbrSamples; i++) 
						{
							outFile << dataArrayP[i] << endl;
						}
						outFile.close();
					}

					if (Math::Abs(Vswg - vout_pp) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;
						
							ret = stopDigitizerFFTAcquire(idx, sourcePattern);
							CheckError(idx, ret, __LINE__);
							
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
			
					ret = stopDigitizerFFTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
							
				ret = stopDigitizerFFTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				
				ret = acm[idx]->StopFG("ACM_CH"); 
				CheckError(idx, ret, __LINE__);

				Vswg_timing_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
				//Vswg_timing_at_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
			}
			#pragma endregion "Calibration of Vpp"	

			#pragma region "Setting up digitizer, ACM and DM"

			//DM seting
			//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);	
			//CheckError(idx, ret, __LINE__);

			//AWG setting
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ChannelWaveShape("ACM_CH", ACM_CONST_SINE); //sine
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ChannelFrequency("ACM_CH", Fswg);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ChannelPhase("ACM_CH", 0);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ChannelOffset("ACM_CH", 0);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ChannelAmplitude("ACM_CH", 0);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ModulationAmplitudeConfig("ACM_CH", 1, Vswg_timing_calibrated[idx.ToString() + "_" + TIDispName]/2);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
			CheckError(idx, ret, __LINE__);
		
			int awg_trigger_source = 0;
			int WaveformSetNo = 0;

			
			for (int i = 0; i < 100; i++) _glob->waveAmplitude[i] = (int)((Math::Pow(2, 15)-1));  //Max value in the signed 16-bit waveform

			ret = acm[idx]->AWGWaveformFlush("ACM");
			CheckError(idx, ret, __LINE__);

			ret = acm[idx]->AWGWaveformLoad("ACM_CH", 0, _glob->waveAmplitude->Length, 0, _glob->waveAmplitude); //The waveform is transfered to the onboard RAM. Waveform number is 0
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->AWGQueueWaveform("ACM_CH", 0, ACM_CONST_EXTTRIG, 0, 2, 0); //Waveform is queued. AWG 0, Waveform 0, 2 cycle, and external trigger=2; auto-trigger=0
			CheckError(idx, ret, __LINE__);
	
			trigLevel = 300;	//% of FS, or mV if external trigger is used
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			trigSlope = 1; //negative
			timeOut_ms = 100;

			ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(idx, ret, __LINE__);
			//ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			//CheckError(idx, ret, __LINE__);
			//ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			//CheckError(idx, ret, __LINE__);

			//Digitizer setting
			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

				if (hardwareResource->Alias->Contains("ExtTrigIn1"))
				{
					sourcePattern = 0x80000000;
				
					ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26); //PXITRIGGER0
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_FALL);
					CheckError(idx, ret, __LINE__);

					awg_trigger_source = 4000 + PXITRIGGER0;

					WaveformSetNo = 0;

				}
				else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
				{
					sourcePattern = 0x40000000;

					
					ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 2, 26); //PXITRIGGER1
					CheckError(idx, ret, __LINE__);

					ret = acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER1, ACM_CONST_TRIG_FALL);
					CheckError(idx, ret, __LINE__);

					awg_trigger_source = 4000 + PXITRIGGER1;

					WaveformSetNo = 1;

				}

		

			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

				ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, 0x80000000);

				//automatic setting: CH1-TrigIn1, CH2-TrigIn2
				ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
				CheckError(idx, ret, __LINE__);

				////apply digitizer setting
				//ret = startDigitizerDGTAcquire(idx, sourcePattern); //dummy acquisition to apply config
				//CheckError(idx, ret, __LINE__);
				//ret = stopDigitizerDGTAcquire(idx, sourcePattern);
				//CheckError(idx, ret, __LINE__);

				//apply digitizer setting
				ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
				CheckError(idx, ret, __LINE__);
				ret = digitizer[idx]->StopAcquire("DIGITIZER");
				CheckError(idx, ret, __LINE__);
		
			#pragma endregion "Setting up digitizer, ACM and DM"

			#pragma region "Looking for SigGen trigger delay"

			int trigger_delay_index = 0;

			if (wr_timing_siggen_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{

				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				//array<double> ^ dataArray = gcnew array<double>(nbrSamples);

				ret = dm[idx]->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
				CheckError(idx, ret, __LINE__);

				ret = acm[idx]->ChannelPhase("ACM_CH", 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->StartAWG("ACM_CH");
				CheckError(idx, ret, __LINE__);
				
				ret = startDigitizerDGTAcquire(idx, sourcePattern);

				_util->Wait_Sec(0.5e-3);
				ret = RunVectorFile(idx, "wr_timing_ext_trigger");
				CheckError(idx, ret, __LINE__);
				//ret = digitizer[idx]->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				
				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				
				if (ret < 0) 
				{
					//ret = digitizer[idx]->StopAcquire("DIGITIZER");
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}
				if (ret == 0)
				{
					//ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP);
					ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
					CheckError(idx, ret, __LINE__);

//PrntWfrm("awg_del", dataArrayP);
				}
				else
				{
					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}

				for (int i=0; i<dataArrayP->Length; i++)
				{
					if (dataArrayP[i] > 0.01)
					{
						trigger_delay_index = i;
						break;
					}
				}

				wr_timing_siggen_del_index->Add(idx.ToString() + "_" + TIDispName, trigger_delay_index);
			}

			trigger_delay_index = wr_timing_siggen_del_index[idx.ToString() + "_" + TIDispName];
			/*if (trigger_delay_index == 0)
			{
				if (trigger_delay_index_current_count < trigger_delay_index_retest_count)
				{
					trigger_delay_index_current_count++;
					wr_timing_siggen_del_index->Clear();
					goto TRG_DEL_INDEX_RETEST;
				}
			}*/

			#pragma endregion "Looking for SigGen trigger delay"

			#pragma region "Setting up WRn vector"

			int vector_set_no = _glob->VectorArrSetNo;

			if (wr_timing_vset->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				//Ensure trigger_delay_index is a multiple of 100ns (digitizer sampling rate = 1ns), if not increase it till it is
				while (trigger_delay_index % 100)
				{
					trigger_delay_index++;
					
					if (trigger_delay_index % 100 == 0)
						break;
				}

				//Check WRN and SYNC pin numbers
				int WRN_Channel = 0;
				int DM_TO_ACM_Channel = 0;
				try
				{
					//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("RWN")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						WRN_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						WRN_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						WRN_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						WRN_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						WRN_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						WRN_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						WRN_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						WRN_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						WRN_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						WRN_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						WRN_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						WRN_Channel = 9;

					hardwareResource = resourceManager[idx]->ResolveResource("DM_TO_ACM")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						DM_TO_ACM_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						DM_TO_ACM_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						DM_TO_ACM_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						DM_TO_ACM_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						DM_TO_ACM_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						DM_TO_ACM_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						DM_TO_ACM_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						DM_TO_ACM_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						DM_TO_ACM_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						DM_TO_ACM_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						DM_TO_ACM_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						DM_TO_ACM_Channel = 9;

					if (resourceManager[idx])
						delete resourceManager[idx];
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				//Set up vector
				int vector_size = 0;
				int h_size = 0;
				int l_size = 10; //padd 10x "0" each, at beginning and end of vectors
				//if (trigger_delay_index > 10) 
				//{
					//divide by 5 because trigger_delay_index is per 1ns, but vector_size is per 5ns vector rate
				//	h_size = (trigger_delay_index - 10) / 5;
				//}
				//else
				{
					h_size = trigger_delay_index / 100;
				}
				vector_size = (2 * l_size + h_size);
				array<int> ^ group0_vectors = gcnew array<int>(vector_size);
				array<int> ^ group1_vectors = gcnew array<int>(vector_size);

				//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
				int LL = 0x0; //Logic Low
				int LH = 0x1; //Logic High 
				int CL = 0x2; //Compare Low
				int CH = 0x3; //Compare High
				int triX = 0x4; //Tri-state & Don't Compare

				int WRN = 0;
				if (WRN_Channel > 5)
					WRN = ((WRN_Channel-6) * 3 + 1);
				else
					WRN = WRN_Channel * 3 + 1;
				
				int DM_TO_ACM = 0;
				if (DM_TO_ACM_Channel > 5)
					DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
				else
					DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

				for (int i=0; i<vector_size; i++)
				{
					group0_vectors[i] = 0x0;
					group1_vectors[i] = 0x0;

					if (i < l_size)
					{
						//group0_vectors[i] |= 0x0;
						//group1_vectors[i] |= 0x0;

						if (WRN_Channel < 6)
						{
							group0_vectors[i] |= LH<<WRN;
							group1_vectors[i] |= 0x0;
						}
						else if (WRN_Channel > 5)
						{
							group0_vectors[i] |= 0x0;
							group1_vectors[i] |= LH<<WRN;
						}
					}
					else if (i >= (h_size + l_size))
					{
						//group0_vectors[i] |= 0x0;
						//group1_vectors[i] |= 0x0;
						if (WRN_Channel < 6)
						{
							group0_vectors[i] |= LH<<WRN;
							group1_vectors[i] |= 0x0;
						}
						else if (WRN_Channel > 5)
						{
							group0_vectors[i] |= 0x0;
							group1_vectors[i] |= LH<<WRN;
						}
					}
					else
					{
					if (WRN_Channel < 6 && DM_TO_ACM_Channel < 6)
					{
						//group0_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
						group0_vectors[i] |= 0x1 | LL<<WRN | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1;
		
						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel && k!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel > 5 && DM_TO_ACM_Channel > 5)
					{
						group0_vectors[i] |= 0x1;
						//group1_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
						group1_vectors[i] |= 0x1 | LL<<WRN | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if ((k+6) != WRN_Channel && (k+6)!= DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else if (WRN_Channel < 6 && DM_TO_ACM_Channel > 5)
					{
						//group0_vectors[i] |= 0x1 | LH<<WRN;
						group0_vectors[i] |= 0x1 | LL<<WRN;
						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != WRN_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= DM_TO_ACM_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
						}
					}
					else // if (WRN_Channel > 5 && DM_TO_ACM_Channel < 6)
					{
						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
						//group1_vectors[i] |= 0x1 | LH<<WRN;
						group1_vectors[i] |= 0x1 | LL<<WRN;

						//set up other channels to tri-state/don't care
						for (int k=0; k<6; k++)
						{
							if (k != DM_TO_ACM_Channel)
							{
								group0_vectors[i] |= (triX<<(k*3+1));
							}
							if ((k+6)!= WRN_Channel)
							{
								group1_vectors[i] |= (triX<<(k*3+1));
							}
							}
						}	
					}
				}

				int timing_set_no = 0;
				//int vector_set_no = _glob->VectorArrSetNo;
				ret = dm[idx]->DPINPeriod("DM_2", timing_set_no, 100e-9);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable == true)
				{
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					//CheckError(idx, ret, __LINE__);
				}

				wr_timing_vset->Add(idx.ToString() + "_" + TIDispName, vector_set_no);
			}
			
			#pragma endregion "Setting up WRn vector"

			#pragma region "Looking for digitizer trigger delay (vector method)"

			int retest_count = 0;

			// reduce sampling count
			//nbrSamples = 512;
			//ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			//CheckError(idx, ret, __LINE__);

	//DIG_TRG_DEL_RETEST:

			int digitizer_trigger_delay_index = 0;

			//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
			//CheckError(idx, ret, __LINE__);

			if (wr_timing_dig_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{

				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				
				double vThreshold = 0.1;

				//CBIT13 (Connect SWG to DM_TO_ACM)
				ret = DriveCBit(idx, TPDispName[0], 3);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = dm[idx]->DPINOn("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				//ret = digitizer[idx]->StartAcquire("DIGITIZER");
				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = dm[idx]->RunVector("DM_2", vector_set_no);
				//CheckError(idx, ret, __LINE__);
				
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(idx, ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}

				if (vector_engine_status != 0)
				{
					//ret = digitizer[idx]->StopAcquire("DIGITIZER");
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);

					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}

				//ret = digitizer[idx]->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					//ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);
				}
				if (ret == 0)
				{
					//ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP);
					ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
					CheckError(idx, ret, __LINE__);
			
//PrntWfrm("dig_del", dataArrayP);
				
					for (int k=0; k<dataArrayP->Length; k++)
					{
						if(dataArrayP[k] < vThreshold)
						{
							digitizer_trigger_delay_index = k;

							//if (digitizer_trigger_delay_index > 40)
							//{
							//	retest_count++;

							//	if (retest_count < TIMING_RESET_COUNT)
							//	{
							//		goto DIG_TRG_DEL_RETEST;
							//	}
							//}

							break;
						}
					}			
				}

				ret = dm[idx]->DPINOff("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				wr_timing_dig_del_index->Add(idx.ToString() + "_" + TIDispName, digitizer_trigger_delay_index);
			}

			digitizer_trigger_delay_index = wr_timing_dig_del_index[idx.ToString() + "_" + TIDispName];

			#pragma endregion "Looking for digitizer trigger delay (vector method)"

			#pragma region "Test"
		//	ret = DriveCBit(idx, TPDispName[0], 1);
		//	CheckError(idx, ret, __LINE__);

			//Off K3, K4
			ret = DriveCBit(idx, TPDispName[0], 0);
			CheckError(idx, ret, __LINE__);

			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);

			//Trigger:
			//	Digitizer - Falling edge
			//	AWG - Rising edge

			//ret = acm[idx]->AWGTriggerExternalConfig("ACM_CH", 4000 + PXITRIGGER0, ACM_CONST_TRIG_RISE); 
			ret = acm[idx]->AWGTriggerExternalConfig("ACM_CH", awg_trigger_source, ACM_CONST_TRIG_RISE);
			CheckError(idx, ret, __LINE__);

			double vpp = 0;
			double ac_timing = 0;
			double dc_timing = 0;
	
			
			for (int i=0; i<6; i++)
			{
				ret = Digitizer_ClearData(idx, i);
			}
		
			// dataarray = 0, dc = 1, deg0 = 2, deg90 = 3, deg180 = 4, deg270 = 5;

			double vThres = 0;		//rev54 TP is 0.5/2;
			int index = -1;

			for (int i=0; i<total_tp; i++)
			{
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}

				if ((TPName[i]->Contains("DC") == true)) //start test here
				{
					//////////////////////////////////
					//DC (no waveform)
					//////////////////////////////////

					//ret = digitizer[idx]->StartAcquire("DIGITIZER");
					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					//_util->Wait_Sec(0.5e-3);
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					//CheckError(idx, ret, __LINE__);
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
						CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
							break;

						swatch.Stop();
					}
					if (vector_engine_status != 0)
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
					}
					ret = waitDigitizerDGTComplete(idx, sourcePattern);
					if (ret < 0) 
					{
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);
					}
					if (ret == 0)
					{
					
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);
					
//PrntWfrm("DC", 	dataArrayP);			
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] <<endl;
							}
							outFile.close();
						}

						int j = 0;
						for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<nbrSamples; k++)
						{
							_glob->DIG_Data_Arr[idx, j, 1] = _glob->DIG_Data_Arr[idx, k, 0];
							j++;
						}
					}

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 1]) > vThres)
						{
							index = k;
							break;
						}
					}

					if (index != -1)
					{
						dc_timing = index * sampInterval;
					}
					else
					{
						dc_timing = 0;
					}

					result[i] = dc_timing;

					//////////////////////////////////
					//AC
					//////////////////////////////////

					//0 deg
					ret = acm[idx]->ChannelPhase("ACM_CH", 0);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StartAWG("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(0.5e-3);
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					CheckError(idx, ret, __LINE__);
					
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
						CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
							break;

						swatch.Stop();
					}
					if (vector_engine_status != 0)
					{
						stopDigitizerDGTAcquire(idx, sourcePattern);
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
					}
					
					ret = waitDigitizerDGTComplete(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);

					if (ret < 0) 
					{
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);
					}
					if (ret == 0)
					{
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);

//PrntWfrm("Deg0", dataArrayP);

						int j = 0;
 						for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<nbrSamples; k++)
						{
							_glob->DIG_Data_Arr[idx, j, 2]=_glob->DIG_Data_Arr[idx, k, 0];
							j++;
						}
					}

					//90 deg
					ret = acm[idx]->ChannelPhase("ACM_CH", 90);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StartAWG("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(0.5e-3);
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					CheckError(idx, ret, __LINE__);
					
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
						CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
							break;

						swatch.Stop();
					}
					if (vector_engine_status != 0)
					{
						
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
					}
					
					ret = waitDigitizerDGTComplete(idx, sourcePattern);
					if (ret < 0) 
					{
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);
					}
					if (ret == 0)
					{
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);

//PrntWfrm("Deg90", dataArrayP);

						int j = 0;
						for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<nbrSamples; k++)
						{
							_glob->DIG_Data_Arr[idx, j, 3]=_glob->DIG_Data_Arr[idx, k, 0];
							j++;
						}
					}

					//180 deg
					ret = acm[idx]->ChannelPhase("ACM_CH", 180);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StartAWG("ACM_CH");
					CheckError(idx, ret, __LINE__);
					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(0.5e-3);
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					CheckError(idx, ret, __LINE__);
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
						CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
							break;

						swatch.Stop();
					}
					if (vector_engine_status != 0)
					{
						//ret = digitizer[idx]->StopAcquire("DIGITIZER");
						ret = stopDigitizerDGTAcquire(idx,sourcePattern);
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
					}
					ret = digitizer[idx]->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
					if (ret < 0) 
					{
						ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);
					}
					if (ret == 0)
					{
						
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);
//PrntWfrm("Deg180", dataArrayP);
				
						int j = 0;
						for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<nbrSamples; k++)
						{
							_glob->DIG_Data_Arr[idx, j, 4]=_glob->DIG_Data_Arr[idx, k, 0];
							j++;
						}
					}

					//270deg
					ret = acm[idx]->ChannelPhase("ACM_CH", 270);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StartAWG("ACM_CH");
					CheckError(idx, ret, __LINE__);
					//ret = digitizer[idx]->StartAcquire("DIGITIZER");
					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					_util->Wait_Sec(0.5e-3);
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					CheckError(idx, ret, __LINE__);
					
					swatch.Reset();
					swatch.Start();
					swatch.Stop();

					while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
					{
						swatch.Start();

						ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
						CheckError(idx, ret, __LINE__);

						if (vector_engine_status == 0)
							break;

						swatch.Stop();
					}
					if (vector_engine_status != 0)
					{
						//ret = digitizer[idx]->StopAcquire("DIGITIZER");
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
					}
					//ret = digitizer[idx]->WaitForEndOfAcquisition("DIGITIZER", timeOut_ms);
					ret = waitDigitizerDGTComplete(idx, sourcePattern);
					
					if (ret < 0) 
					{
						//ret = digitizer[idx]->StopAcquire("DIGITIZER");
						CheckError(idx, ret, __LINE__);
					}
					if (ret == 0)
					{
						//ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP);
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);
//PrntWfrm("Deg270", dataArrayP);				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata4.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] <<endl;
							}
							outFile.close();
						}

						int j = 0;
						for (int k=(digitizer_trigger_delay_index-sync_rwn_timing_index); k<nbrSamples; k++)
						{
							_glob->DIG_Data_Arr[idx, j,  5] = _glob->DIG_Data_Arr[idx, k, 0];
							j++;
						}
					}

					if(FindAmpEnable == true)
					{
						vThres = 0.28; // this is the first entry of threshold value. A new best fit value will be calculated by the formula

						//multiply factor
						if(idx == 0)
						{
							for (int n=0; n<nbrSamples; n++)
							{
								_glob->DIG_temp_Arr_S0[n] = _glob->DIG_Data_Arr[idx, n, 2] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr2_S0[n] = _glob->DIG_Data_Arr[idx, n, 3] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr3_S0[n] = _glob->DIG_Data_Arr[idx, n, 4] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr4_S0[n] = _glob->DIG_Data_Arr[idx, n, 5] * diff2se_digitizer_factor;
							}

							//find new vThres
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr_S0, vThres, amp_0deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr2_S0, vThres, amp_90deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr3_S0, vThres, amp_180deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr4_S0, vThres, amp_270deg);
						}

						if(idx == 1)
						{
							for (int n=0; n<nbrSamples; n++)
							{
								_glob->DIG_temp_Arr_S1[n] = _glob->DIG_Data_Arr[idx, n, 2] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr2_S1[n] = _glob->DIG_Data_Arr[idx, n, 3] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr3_S1[n] = _glob->DIG_Data_Arr[idx, n, 4] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr4_S1[n] = _glob->DIG_Data_Arr[idx, n, 5] * diff2se_digitizer_factor;
							}

							//find new vThres
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr_S1, vThres, amp_0deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr2_S1, vThres, amp_90deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr3_S1, vThres, amp_180deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr4_S1, vThres, amp_270deg);
						}

						if(idx == 2)
						{
							for (int n=0; n<nbrSamples; n++)
							{
								_glob->DIG_temp_Arr_S2[n] = _glob->DIG_Data_Arr[idx, n, 2] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr2_S2[n] = _glob->DIG_Data_Arr[idx, n, 3] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr3_S2[n] = _glob->DIG_Data_Arr[idx, n, 4] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr4_S2[n] = _glob->DIG_Data_Arr[idx, n, 5] * diff2se_digitizer_factor;
							}

							//find new vThres
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr_S2, vThres, amp_0deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr2_S2, vThres, amp_90deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr3_S2, vThres, amp_180deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr4_S2, vThres, amp_270deg);
						}

						if(idx == 3)
						{
							for (int n=0; n<nbrSamples; n++)
							{
								_glob->DIG_temp_Arr_S3[n] = _glob->DIG_Data_Arr[idx, n, 2] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr2_S3[n] = _glob->DIG_Data_Arr[idx, n, 3] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr3_S3[n] = _glob->DIG_Data_Arr[idx, n, 4] * diff2se_digitizer_factor;
								_glob->DIG_temp_Arr4_S3[n] = _glob->DIG_Data_Arr[idx, n, 5] * diff2se_digitizer_factor;
							}

							//find new vThres
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr_S3, vThres, amp_0deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr2_S3, vThres, amp_90deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr3_S3, vThres, amp_180deg);
							ret = FindAmplitude(idx, _glob->DIG_temp_Arr4_S3, vThres, amp_270deg);
						}

						vThres = (amp_0deg + amp_90deg + amp_180deg + amp_270deg)/4 *0.9; //90% of the amplitude	
					}

					else 
						vThres = 0.285;

					int refind_once = 0;

REFIND:

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 2] * diff2se_digitizer_factor) > vThres ||
							Math::Abs(_glob->DIG_Data_Arr[idx, k, 3] * diff2se_digitizer_factor) > vThres ||
							Math::Abs(_glob->DIG_Data_Arr[idx, k, 4] * diff2se_digitizer_factor) > vThres ||
							Math::Abs(_glob->DIG_Data_Arr[idx, k, 5] * diff2se_digitizer_factor) > vThres)
						{
							index = k;

							if (index > 50)
							{
 								int here = 0;
							}

							break;
						}
					}

					if (index != -1)
					{
						ac_timing = index * sampInterval;
					}
					else
					{
						if(refind_once == 0)
						{
						   vThres = 0.285; //if auto FindAmplitude is not able to find threshold, set back to defaul vThres and find again.
						   refind_once = 1;
						   goto REFIND;
						}
						ac_timing = 999;
					}

					//Calculate vpp

					if (ac_timing != 999)
					{
						
						int j = 0;
						for (int k=200; k<328; k++)
						{
							_glob->dataArray_vpp[j] = _glob->DIG_Data_Arr[idx, k, 2];
							j++;
						}

						vpp = _fft->GetVpp(_glob->dataArray_vpp, sampInterval, NONE, false);

						vpp = vpp * diff2se_digitizer_factor;
					}
					else
					{
						vpp = 999;
					}
				}

				if (TPName[i]->Contains("AC") == true)
				{
					result[i] = ac_timing;
				}
				
				if (TPName[i]->Contains("hsd_sync") == true)
				{
					result[i] = Math::Abs(sync_rwn_timing);
				}
				
				if (TPName[i]->Contains("vpp") == true)
				{
					result[i] = vpp;
				}

				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
			}
			#pragma endregion "Test"

	test_end:

			//ret = digitizer[idx]->StopAcquire("DIGITIZER");
			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);

			//Turn off modulation
			//ret = acm[idx]->ModulationAmplitudeConfig("ACM_CH", 0, 0);
			//CheckError(idx, ret, __LINE__);

			ret = Digital_Init_State(idx); 
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 0, 0);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::rw_timing3(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<int> ^ result = gcnew array<int>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double sync_rwn_timing = 0;

			if (calfactor->ContainsKey("SYNC_RWN_DELAY"))
				sync_rwn_timing = calfactor["SYNC_RWN_DELAY"][idx];

			int sync_rwn_timing_index = (int)(sync_rwn_timing / 1e-9); //digitizer sampling interval is 1ns

			double Max_Thres		= 0;
			double Min_Thres		= 0;
			int	WRn_Trigger_Edge	= 0; //0=Rising, 1=Falling

			String ^ Vector_File	= String::Empty;
			String ^ Vector_File_1  = String::Empty;

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//ret = DriveMuxIO(idx, TPDispName[0]);
			//CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			//On K3, K4
			ret = DriveCBit(idx, TPDispName[0], 1);
			CheckError(idx, ret, __LINE__);

			#pragma region "Setting up digitizer and DM"

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 1024; //1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 

			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 300;	//% of FS, or mV if external trigger is used
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 100;

			//DM seting
			ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
			CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->DPINPeriod("DM_2", 0, DM_CONST_VECTOR_PERIOD_100NS);
			//CheckError(idx, ret, __LINE__);

			//Digitizer setting
			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

				if (hardwareResource->Alias->Contains("ExtTrigIn1"))
				{
					sourcePattern = 0x80000000;
				}
				else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
				{
					sourcePattern = 0x40000000;
				}

				if (resourceManager[idx])
					delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			ret = acm[idx]->StopFG("ACM_CH");
			CheckError(idx, ret, __LINE__);

			//ret = digitizer[idx]->Reset("DIGITIZER");
			//CheckError(idx, ret, __LINE__);
			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(idx, ret, __LINE__);
			

			//apply digitizer setting
			ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->StopAcquire("DIGITIZER");
			CheckError(idx, ret, __LINE__);
	

			#pragma endregion "Setting up digitizer and DM"

			#pragma region "Setting up WRn vector"

			int vector_set_no = _glob->VectorArrSetNo + 1;

			if (rw_timing_vset->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				//Check WRN and SYNC pin numbers
				int WRN_Channel = 0;
				int DM_TO_ACM_Channel = 0;
				try
				{
					//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("RWN")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						WRN_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						WRN_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						WRN_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						WRN_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						WRN_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						WRN_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						WRN_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						WRN_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						WRN_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						WRN_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						WRN_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						WRN_Channel = 9;

					hardwareResource = resourceManager[idx]->ResolveResource("DM_TO_ACM")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						DM_TO_ACM_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						DM_TO_ACM_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						DM_TO_ACM_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						DM_TO_ACM_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						DM_TO_ACM_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						DM_TO_ACM_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						DM_TO_ACM_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						DM_TO_ACM_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						DM_TO_ACM_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						DM_TO_ACM_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						DM_TO_ACM_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						DM_TO_ACM_Channel = 9;

					//if (resourceManager[idx])
					//	delete resourceManager[idx];
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				//Set up vector (L -> H)
				int vector_size = 0;
				int l_size = 1; //=100ns (100ns is the selected timing set value)
				int h_size = 1; 

				vector_size = (h_size + l_size);
				array<int> ^ group0_vectors = gcnew array<int>(vector_size);
				array<int> ^ group1_vectors = gcnew array<int>(vector_size);

				//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
				int LL = 0x0; //Logic Low
				int LH = 0x1; //Logic High 
				int CL = 0x2; //Compare Low
				int CH = 0x3; //Compare High
				int triX = 0x4; //Tri-state & Don't Compare

				int WRN = 0;
				if (WRN_Channel > 5)
					WRN = ((WRN_Channel-6) * 3 + 1);
				else
					WRN = WRN_Channel * 3 + 1;
				
				int DM_TO_ACM = 0;
				if (DM_TO_ACM_Channel > 5)
					DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
				else
					DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

				for (int i=0; i<vector_size; i++)
				{
					group0_vectors[i] = 0x0;
					group1_vectors[i] = 0x0;

					if (i < h_size) 
					{
						group0_vectors[i] |= 0x0;
						group1_vectors[i] |= 0x0;
					}
					else
					{
						if (WRN_Channel < 6 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1;
			
							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != WRN_Channel && k!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (WRN_Channel > 5 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1;
							group1_vectors[i] |= 0x1 | LH<<WRN | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if ((k+6) != WRN_Channel && (k+6)!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (WRN_Channel < 6 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1 | LH<<WRN;
							group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != WRN_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= DM_TO_ACM_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else // if (WRN_Channel > 5 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1 | LH<<WRN;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= WRN_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}	
					}
				}

				int timing_set_no = 0;
				//int vector_set_no = _glob->VectorArrSetNo + 1;
				ret = dm[idx]->DPINPeriod("DM_2", timing_set_no, 100e-9);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable == true)
				{
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					//CheckError(idx, ret, __LINE__);
				}

				//rw_timing_vset->Add(idx.ToString() + "_" + TIDispName, vector_set_no);
			}
			
			#pragma endregion "Setting up WRn vector"

			#pragma region "Looking for digitizer trigger delay (vector method)"

			int digitizer_trigger_delay_index = 0;

			int retest_count = 0;

	//DIG_TRG_DEL_RETEST:

			double vThreshold = 0.1;

			if (rw_timing_dig_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{

				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				ret = dm[idx]->DPINOn("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = dm[idx]->RunVector("DM_2", vector_set_no);
				//CheckError(idx, ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(idx, ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
					CheckError(idx, ret, __LINE__);
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << endl;
						}
						outFile.close();
					}
				
					for (int k=0; k<dataArrayP->Length; k++)
					{
						if(dataArrayP[k] > vThreshold) //pos
						{
							digitizer_trigger_delay_index = k;

							//if (digitizer_trigger_delay_index > 40)
							//{
							//	retest_count++;

							//	if (retest_count < TIMING_RESET_COUNT)
							//	{
							//		goto DIG_TRG_DEL_RETEST;
							//	}
							//}

							break;
						}
					}			
				}

				ret = dm[idx]->DPINOff("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				rw_timing_dig_del_index->Add(idx.ToString() + "_" + TIDispName, digitizer_trigger_delay_index);
			}

			digitizer_trigger_delay_index = rw_timing_dig_del_index[idx.ToString() + "_" + TIDispName];

			#pragma endregion "Looking for digitizer trigger delay (vector method)"

			#pragma region "Test"

			//Off K3, K4
			//ret = DriveCBit(idx, TPDispName[0], 0);
			//CheckError(idx, ret, __LINE__);

			double timing = 0;


			double vThres = 15e-3; //amplitude change (diff voltage of P and N)
			int digitizer_trigger_edge_to_wrn_edge_delay_index = 1*100; //100ns (fixed in vector file)
			int index = -1;
			
		//	ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
		//	CheckError(idx, ret, __LINE__);

			for (int i=0; i<total_tp; i++)
			{
				Max_Thres = (double)(tf_TPCondition_Cast(TPName[i], "Max_Thres"));
				Min_Thres = (double)(tf_TPCondition_Cast(TPName[i], "Min_Thres"));
				WRn_Trigger_Edge = (int)(tf_TPCondition_Cast(TPName[i], "WRn_Trigger_Edge"));

				if(i % 4 == 0)
				{
					ret = DriveCBit(idx, TPDispName[i], 0);
					CheckError(idx, ret, __LINE__);
					//Connect digitizer to WRxP
					ret = DriveCBit(idx, TPDispName[i], 2);
					CheckError(idx, ret, __LINE__);

					ret = DriveMuxIO(idx, TPDispName[i], 0);
					CheckError(idx, ret, __LINE__);
				}
				
				if (tf_TPCondition_exist(TPName[i], "Vector_File_1") == true)
				{
					Vector_File_1 = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File_1"));
						
					ret = RunVectorFile(idx, Vector_File_1);
					CheckError(idx, ret, __LINE__);
				}
				
				if (tf_TPCondition_exist(TPName[i], "Vector_File") == true)
				{
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				}
					
				{
					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					
					_util->Wait_Sec(0.5e-3);
					Vector_File = "write_rw_timing_trig_" + WRn_Trigger_Edge.ToString();
					
					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
					
					ret = waitDigitizerDGTComplete(idx, sourcePattern);
					if (ret < 0) 
					{
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);
					}
					if (ret == 0)
					{
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);
				
						if (Debug_Enable == true)
						
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] <<endl;
							}
							outFile.close();
						}
						
						ret = Digitizer_ClearData(idx, 1);
						int j = 0;
						for (int k=(digitizer_trigger_delay_index+digitizer_trigger_edge_to_wrn_edge_delay_index-sync_rwn_timing_index); k<nbrSamples; k++)
						{
							_glob->DIG_Data_Arr[idx, j, 1] = _glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor;
							j++;
						}
					}

					index = -1;

					int ana_sample = 20;
					array<double> ^ dtmp = gcnew array<double>(ana_sample);
					double max = 0;
					double min = 0;

					int max_index = 0;
					int min_index = 0;

					int found = 0;

					//for (int k=0; k<nbrSamples; k=k+ana_sample)
					for (int k=0; k<nbrSamples; k++)
					{
						//if (((k+ana_sample) % ana_sample == 0) && (k+ana_sample) <= nbrSamples)
						if (k >= ana_sample-1)
						{
							//dtmp[0] = dataArray[k];
							//dtmp[1] = dataArray[k+1];
							//dtmp[2] = dataArray[k+2];
							//dtmp[3] = dataArray[k+3];
							//dtmp[4] = dataArray[k+4];

							for (int z=0; z<ana_sample; z++)
							{
								dtmp[z] = _glob->DIG_Data_Arr[idx, k-(ana_sample-z-1), 1];


							}
							max = 0;
							min = 0;

							for (int m=0; m<ana_sample; m++)
							{			
								if (m == 0)
								{
									max = dtmp[m];
									min = dtmp[m];
								}
								else
								{
									if (dtmp[m] > max)
									{
										max = dtmp[m];
										max_index = m;
									}

									if (dtmp[m] < min)
									{
										min = dtmp[m];
										min_index = m;
									}
								}

								if ((m > 0) && Math::Abs(max - min) > vThres)
								{
									//index = k;
									if (max_index > min_index)
										index = k - (ana_sample-1) + max_index;
									else
										index = k - (ana_sample-1) + min_index;

									found = 1;
									break;
								}
							}	
						}

						if (found == 1)
							break;
					}

					if (index != -1)
					{
						timing = index * sampInterval;
					}
					else
					{
						timing = 999;
					}

					if (timing >= (Min_Thres-0.2e-9) &&  timing <= (Max_Thres+0.2e-9)) //to avoid decimation issue of double data type
					{
						result[i] = 1;
					}else{
   						result[i] = 0;
_util->SampleRes("rw_timing", i);
_util->SampleRes("rw_timing", timing);
_util->SampleRes("rw_timing", "\n");

					}
				}
			
				tf_SetResult_UUTOffset(TPName[i], result[i] + (int)GetOffset(idx, TPDispName[i]), idx);
			}
			#pragma endregion "Test"

			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);

			ret = Digital_Init_State(idx); 
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);

		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::wtr_slow_combo(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			String ^ Vector_File_Init	= String::Empty;
			String ^ Vector_File		= String::Empty;

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_DC"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("RWN");
			CheckError(idx, ret, __LINE__);

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			#pragma region "Setting"

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples =  MAX_DIG_SAMPLE; //320000
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 1;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 

			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

				if (hardwareResource->Alias->Contains("ExtTrigIn1"))
				{
					sourcePattern = 0x80000000;
				}
				else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
				{
					sourcePattern = 0x40000000;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 1;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 300;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 100;
		
			int Decimation_Factor = 100;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			ret = Digitizer_Configure(idx, _glob->digitizer_setting);
			CheckError(idx, ret, __LINE__); 


			//ret = digitizer[idx]->Reset("DIGITIZER");
			//CheckError(idx, ret, __LINE__);
			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(idx, ret, __LINE__);

			//apply digitizer setting
			ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->StopAcquire("DIGITIZER");
			CheckError(idx, ret, __LINE__);

			//DM seting
			ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
			CheckError(idx, ret, __LINE__);

			#pragma endregion "Setting"	

			#pragma region "Test"
			
			//combined head cell

			for (int j = 0; j < HDS * 3; j = j + 3)
			{
			
				if (tf_TPCondition_exist(TPName[j], "Vector_File_Init") == true)
				{
					Vector_File_Init = (String ^)(tf_TPCondition_Cast(TPName[j], "Vector_File_Init"));

					if(!USE_SPI)
					{
						ret = RunVectorFile(idx, "write_default_reg");
						CheckError(idx, ret, __LINE__);
						ret = RunVectorFile(idx, Vector_File_Init);
						CheckError(idx, ret, __LINE__);
					}else{
						ret = OnOffSPI(idx, 1);
						ret = RunSPI(idx, "write_default_reg");
						CheckError(idx, ret, __LINE__);
						ret = RunSPI(idx, Vector_File_Init);
						CheckError(idx, ret, __LINE__);
						ret = OnOffSPI(idx, 0);
					}
						
				}

			//	ret = Digitizer_ClearBigData(idx);
		
				double vThres = 0.07;
				int index = -1;
				double vpp = 0;
	
				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile(idx, "write_rwn_sync");
				CheckError(idx, ret, __LINE__);

				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}

				//Retrieve Digitizer data
				Digitizer_GetBigData(idx, sourcePattern, nbrSamples);	
	
				if (Debug_Enable == true)
				{
					ofstream outFile("C:\\Aemulus\\Debug\\wtrSlow_raw.txt");
					for (int i = 0; i < nbrSamples; i++) 
					{
						outFile << _glob->DIG_Big_Data_Arr[idx, i] << endl;
					}
					outFile.close();
				}

				double vp_peak = 0;
				double vn_peak = 0;

				double vp_peak_index = 0;
				double vn_peak_index = 0;

				int found = 0;
						
				for (int i=0; i<nbrSamples; i=i+100) //as if 10MHz sampling rate
				{
					if (i == 0)
					{
						vp_peak = _glob->DIG_Big_Data_Arr[idx, i ];
						vn_peak = _glob->DIG_Big_Data_Arr[idx, i];
					}

					if (_glob->DIG_Big_Data_Arr[idx, i] > vp_peak)
					{
						vp_peak = _glob->DIG_Big_Data_Arr[idx, i];
						vp_peak_index = i / 100;
					}

					if (_glob->DIG_Big_Data_Arr[idx, i] < vn_peak)
					{
						vn_peak = _glob->DIG_Big_Data_Arr[idx, i];
						vn_peak_index = i / 100;
					}

					if (found == 0)
					{
						if (Math::Abs(_glob->DIG_Big_Data_Arr[idx, i ]) * diff2se_digitizer_factor > vThres)
						{
							result[j] = (i/100) * sampInterval + 1e-6; //+1us, follow Catalyst
							found = 1;
						}
					}
				}

				if (found == 0)
				{
					result[j] = 1e-6;
				}

				if (Math::Abs(vp_peak) > Math::Abs(vn_peak))
				{
					result[j+1] = vp_peak * diff2se_digitizer_factor;
					result[j+2] = vp_peak_index * sampInterval + 1e-6; //+1us, follow Catalyst
				}
				else
				{
					result[j+1] = vn_peak * diff2se_digitizer_factor;
					result[j+2] = vn_peak_index * sampInterval + 1e-6; //+1us, follow Catalyst
				}

			}
			
			for (int i=0; i<total_tp; i++)
			{
				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
			}

			#pragma endregion "Test"

			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
		//	ret = Digitizer_ClearData(idx);

			ret = Digital_Init_State(idx); 
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			ret = OnOffSPI(idx, 0);	

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
		
	}
	void TestProgram::hth_timing_2hd_3(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

			double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

			String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			String ^ Vector_File		= String::Empty;

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][idx];
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("RWN");
			//CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 1024; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 

			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

		//	array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

			double vout_pp = 0.0;

			int max_loop = 50;

			//On K3, K4
			ret = DriveCBit(idx, TPDispName[0], 1);
			CheckError(idx, ret, __LINE__);

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			#pragma region "Calibration of Vpp"
			if (Vswg_hth_timing_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{

				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

				double Vswg_cal = 0;
				int loop_count = 0;

				Vswg_cal = Vswg;

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						ret = Digitizer_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
						CheckError(idx, ret, __LINE__);
						
						do_once = 1;
					}

 					ret = DigitizerFFT_CaptureVpp(idx,sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
					CheckError(idx, ret, __LINE__);

					if (ret)
					{

						ret = stopDigitizerFFTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						ret = 0;

						goto test_end;
					}

				
					if (Debug_Enable == true)
					{
						ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
						CheckError(idx, ret, __LINE__);
							
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int i = 0; i < nbrSamples; i++) 
						{
							outFile << dataArrayP[i] << endl;
						}
						outFile.close();
					}

					if (Math::Abs(Vswg - vout_pp) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;
						
							ret = stopDigitizerFFTAcquire(idx, sourcePattern);
							CheckError(idx, ret, __LINE__);
							
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
			
					ret = stopDigitizerFFTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
							
				ret = stopDigitizerFFTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				
				ret = acm[idx]->StopFG("ACM_CH"); 
				CheckError(idx, ret, __LINE__);

				Vswg_hth_timing_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
				//Vswg_hth_timing_at_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
			}
	
			#pragma endregion "Calibration of Vpp"	

			#pragma region "Setting"

			ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
			CheckError(idx, ret, __LINE__);

			//Trigger:
			//	Digitizer - Falling edge (sync with SPE)

			//DM seting
			ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
			CheckError(idx, ret, __LINE__);

			//Digitizer setting
			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

				if (hardwareResource->Alias->Contains("ExtTrigIn1"))
				{
					sourcePattern = 0x80000000;
				}
				else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
				{
					sourcePattern = 0x40000000;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			trigLevel = 300;	//% of FS, or mV if external trigger is used
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

			trigSlope = 1; //negative

			timeOut_ms = 100;

			ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(idx, ret, __LINE__);

			//apply digitizer setting
			ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->StopAcquire("DIGITIZER");
			CheckError(idx, ret, __LINE__);	

			#pragma endregion "Setting"	

			#pragma region "Setting up SPE vector"

			int vector_set_no = _glob->VectorArrSetNo + 1;

			if (hth_timing_vset->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				//Check SPE and SYNC pin numbers
				int SPE_Channel = 0;
				int DM_TO_ACM_Channel = 0;
				try
				{
					//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("SPE")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						SPE_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						SPE_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						SPE_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						SPE_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						SPE_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						SPE_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						SPE_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						SPE_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						SPE_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						SPE_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						SPE_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						SPE_Channel = 9;

					hardwareResource = resourceManager[idx]->ResolveResource("DM_TO_ACM")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						DM_TO_ACM_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						DM_TO_ACM_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						DM_TO_ACM_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						DM_TO_ACM_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						DM_TO_ACM_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						DM_TO_ACM_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						DM_TO_ACM_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						DM_TO_ACM_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						DM_TO_ACM_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						DM_TO_ACM_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						DM_TO_ACM_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						DM_TO_ACM_Channel = 9;

					//if (resourceManager[idx])
					//	delete resourceManager[idx];
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				//Set up vector (H -> L)
				int vector_size = 0;
				int l_size = 1; //=100ns (100ns is the selected timing set value)
				int h_size = 1; 

				vector_size = (h_size + l_size);
				array<int> ^ group0_vectors = gcnew array<int>(vector_size);
				array<int> ^ group1_vectors = gcnew array<int>(vector_size);

				//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
				int LL = 0x0; //Logic Low
				int LH = 0x1; //Logic High 
				int CL = 0x2; //Compare Low
				int CH = 0x3; //Compare High
				int triX = 0x4; //Tri-state & Don't Compare

				int SPE = 0;
				if (SPE_Channel > 5)
					SPE = ((SPE_Channel-6) * 3 + 1);
				else
					SPE = SPE_Channel * 3 + 1;
				
				int DM_TO_ACM = 0;
				if (DM_TO_ACM_Channel > 5)
					DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
				else
					DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

				for (int i=0; i<vector_size; i++)
				{
					group0_vectors[i] = 0x0;
					group1_vectors[i] = 0x0;

					if (i < h_size) 
					{
						if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1;
			
							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1;
							group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1 | LH<<SPE;
							group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != SPE_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= DM_TO_ACM_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1 | LH<<SPE;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= SPE_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}	
					}
					else
					{
						group0_vectors[i] |= 0x0;
						group1_vectors[i] |= 0x0;
					}
				}

				int timing_set_no = 0;
				//int vector_set_no = _glob->VectorArrSetNo + 1;
				ret = dm[idx]->DPINPeriod("DM_2", timing_set_no, 100e-9);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable == true)
				{
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					//CheckError(idx, ret, __LINE__);
				}
				hth_timing_vset->Add(idx.ToString() + "_" + TIDispName, vector_set_no);

			}
			
			#pragma endregion "Setting up SPE vector"

			#pragma region "Looking for digitizer trigger delay (vector method)"

			int digitizer_trigger_delay_index = 0;

			int retest_count = 0;

	//DIG_TRG_DEL_RETEST:

			double vThreshold = 0.1;

			if (hth_timing_dig_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				//CBIT13 (Connect SWG to DM_TO_ACM)
				ret = OnOffCbit(idx, 13, 1);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOn("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = dm[idx]->RunVector("DM_2", vector_set_no);
				//CheckError(idx, ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(idx, ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}
				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = digitizer[idx]->StopAcquire("DIGITIZER");
					CheckError(idx, ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
					CheckError(idx, ret, __LINE__);
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] <<endl;
						}
						outFile.close();
					}
				
					for (int k=0; k<dataArrayP->Length; k++)
					{
						if(dataArrayP[k] < vThreshold) //neg
						{
							digitizer_trigger_delay_index = k;

							//if (digitizer_trigger_delay_index > 40)
							//{
							//	retest_count++;

							//	if (retest_count < TIMING_RESET_COUNT)
							//	{
							//		goto DIG_TRG_DEL_RETEST;
							//	}
							//}

							break;
						}
					}			
				}

				ret = dm[idx]->DPINOff("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = OnOffCbit(idx, 13, 0);
				CheckError(idx, ret, __LINE__);
				
				hth_timing_dig_del_index->Add(idx.ToString() + "_" + TIDispName, digitizer_trigger_delay_index);
			}

			digitizer_trigger_delay_index = hth_timing_dig_del_index[idx.ToString() + "_" + TIDispName];
			

			#pragma endregion "Looking for digitizer trigger delay (vector method)"

			#pragma region "Test"

			//Off K3, K4
			ret = DriveCBit(idx, TPDispName[0], 0);
			CheckError(idx, ret, __LINE__);

			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);

			//ret = acm[idx]->ResetChannel("ACM_CH");
			//CheckError(idx, ret, __LINE__);

			ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_hth_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_hth_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			double ac_timing = 0;
			double dc_timing = 0;
			
			double vThres = 0.2;  // 0.3
			int index = -1;

			int retestCount = 0;

			for (int i=0; i<total_tp; i++)
			{

RETEST:
				ret = RunVectorFile(idx, Vector_File_Init);
				CheckError(idx, ret, __LINE__);

				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

				if ((TPName[i]->Contains("0to1") == true)) //start test here
				{
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);
				}
				else
				{
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
				}	

				_util->Wait_Sec(0.5e-3);

				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile(idx, Vector_File);
				CheckError(idx, ret, __LINE__);

				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}

				if ((TPName[i]->Contains("0to1") == false)) //start test here
				{
					//////////////////////////////////
					//DC (no waveform)
					//////////////////////////////////
					
					if (ret == 0)
					{
						//ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);

						CheckError(idx, ret, __LINE__);
			//PrntWfrm("hth_dc", dataArrayP);	
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] << endl;
							}
							outFile.close();
						}
					}

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
						{
							index = k;
							break;
						}
					}

					if (index != -1)
					{
						dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
					}
					else
					{
						dc_timing = 0;
					}

					result[i] = dc_timing;
				}
				else
				{
					//////////////////////////////////
					//AC
					//////////////////////////////////
		
					if (ret == 0)
					{
						//ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);
				
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\hth_tim_rawdata.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] << endl;
							}
							outFile.close();
						}
					}

					index = -1;
					int off_time_count = 0;
					int off_time_start_index = 0;
					int found = 0;
					for (int k=0; k<nbrSamples; k++)
					{
						//Look for 50 consecutive points where amplitude < vThres (to confirm off time)

						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) < vThres)
						{
							off_time_count++;

							if (off_time_count == 50)
							{
								found = 1;
								off_time_start_index = k - 50 + 1;
								break;
							}
						}
						else
						{
							off_time_count = 0;
						}
					}

					if (found == 1)
					{
						for (int k=off_time_start_index; k<nbrSamples; k++)
						{
							if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
							{
								
								//index = k - off_time_start_index;
								index = k; 
								break;
							}
						}
					}

					if (index != -1)
					{
						ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
					}
					else
					{
						ac_timing = 999;
					}

					result[i] = ac_timing;
				}


					double max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
					double min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));

					if ((result[i] < min_limit) || (result[i] > max_limit))
					{
						if (retest_count < TIMING_RESET_COUNT)
						{
							retest_count++;
							goto RETEST;
						}
					}


				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);



			}
			#pragma endregion "Test"

	test_end:

			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			//ret = acm[idx]->ResetChannel("ACM_CH");
			//CheckError(idx, ret, __LINE__);

			ret = Digital_Init_State(idx); 
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 0, 0);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}

	void TestProgram::bias_timing3(Object^ object)
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

			double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

			String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			String ^ Vector_File_Bias1	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Bias1"));
			String ^ Vector_File		= String::Empty;

			double diff2se_digitizer_factor = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_200M"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_200M"][idx];
			//diff2se_digitizer_factor = 3.3;
					
			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->DPINOn("RWN");
			//CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);

			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 512; //8192; //must be 2^n
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 

			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

			//array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

			double vout_pp = 0.0;

			int max_loop = 50;

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			//On K3, K4
			ret = DriveCBit(idx, TPDispName[0], 1);
			CheckError(idx, ret, __LINE__);

			#pragma region "Calibration of Vpp"
			if (Vswg_bias_timing_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

				double Vswg_cal = 0;
				int loop_count = 0;

				Vswg_cal = Vswg;

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						ret = Digitizer_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
						CheckError(idx, ret, __LINE__);
						
						do_once = 1;
					}

 					ret = DigitizerFFT_CaptureVpp(idx,sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
					CheckError(idx, ret, __LINE__);

					if (ret)
					{

						ret = stopDigitizerFFTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						ret = 0;

						goto test_end;
					}

				
					if (Debug_Enable == true)
					{
						ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);			
						CheckError(idx, ret, __LINE__);
							
						ofstream outFile("C:\\Aemulus\\Debug\\CalVpp_rawdata.txt");
						for (int i = 0; i < nbrSamples; i++) 
						{
							outFile << dataArrayP[i] << endl;
						}
						outFile.close();
					}

					if (Math::Abs(Vswg - vout_pp) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;
						
							ret = stopDigitizerFFTAcquire(idx, sourcePattern);
							CheckError(idx, ret, __LINE__);
							
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
			
					ret = stopDigitizerFFTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
							
				ret = stopDigitizerFFTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				
				ret = acm[idx]->StopFG("ACM_CH"); 
				CheckError(idx, ret, __LINE__);
				
				
				
				
				
				Vswg_bias_timing_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
				Vswg_bias_timing_at_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
				
			}
			#pragma endregion "Calibration of Vpp"	

			ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(idx, ret, __LINE__);
			

			#pragma region "Setting"

			//Trigger:
			//	Digitizer - Falling edge (sync with SPE)

			//DM seting
			ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
			CheckError(idx, ret, __LINE__);

			//Digitizer setting
			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

				if (hardwareResource->Alias->Contains("ExtTrigIn1"))
				{
					sourcePattern = 0x80000000;
				}
				else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
				{
					sourcePattern = 0x40000000;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			trigLevel = 300;	//% of FS, or mV if external trigger is used
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

			trigSlope = 1; //negative

			timeOut_ms = 100;

			ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, 0x80000000);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(idx, ret, __LINE__);

			//apply digitizer setting
			ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->StopAcquire("DIGITIZER");
			CheckError(idx, ret, __LINE__);


			#pragma endregion "Setting"	

			int vector_set_no = _glob->VectorArrSetNo + 1;
			
			#pragma region "Setting up SPE vector"
			
			if (bias_timing_vset->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				
				//Check SPE and SYNC pin numbers
				int SPE_Channel = 0;
				int DM_TO_ACM_Channel = 0;
				try
				{
					//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("SPE")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						SPE_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						SPE_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						SPE_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						SPE_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						SPE_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						SPE_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						SPE_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						SPE_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						SPE_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						SPE_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						SPE_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						SPE_Channel = 9;

					hardwareResource = resourceManager[idx]->ResolveResource("DM_TO_ACM")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						DM_TO_ACM_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						DM_TO_ACM_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						DM_TO_ACM_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						DM_TO_ACM_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						DM_TO_ACM_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						DM_TO_ACM_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						DM_TO_ACM_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						DM_TO_ACM_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						DM_TO_ACM_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						DM_TO_ACM_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						DM_TO_ACM_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						DM_TO_ACM_Channel = 9;

					//if (resourceManager[idx])
					//	delete resourceManager[idx];
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				//Set up vector (H -> L)
				int vector_size = 0;
				int l_size = 1; //=100ns (100ns is the selected timing set value)
				int h_size = 1; 

				vector_size = (h_size + l_size);
				array<int> ^ group0_vectors = gcnew array<int>(vector_size);
				array<int> ^ group1_vectors = gcnew array<int>(vector_size);

				//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
				int LL = 0x0; //Logic Low
				int LH = 0x1; //Logic High 
				int CL = 0x2; //Compare Low
				int CH = 0x3; //Compare High
				int triX = 0x4; //Tri-state & Don't Compare

				int SPE = 0;
				if (SPE_Channel > 5)
					SPE = ((SPE_Channel-6) * 3 + 1);
				else
					SPE = SPE_Channel * 3 + 1;
				
				int DM_TO_ACM = 0;
				if (DM_TO_ACM_Channel > 5)
					DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
				else
					DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

				for (int i=0; i<vector_size; i++)
				{
					group0_vectors[i] = 0x0;
					group1_vectors[i] = 0x0;

					if (i < h_size) 
					{
						if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1;
			
							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1;
							group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1 | LH<<SPE;
							group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != SPE_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= DM_TO_ACM_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1 | LH<<SPE;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= SPE_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}	
					}
					else
					{
						group0_vectors[i] |= 0x0;
						group1_vectors[i] |= 0x0;
					}
					
			

				}

				int timing_set_no = 0;
				//int vector_set_no = _glob->VectorArrSetNo + 1;
				ret = dm[idx]->DPINPeriod("DM_2", timing_set_no, 100e-9);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable == true)
				{
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					//CheckError(idx, ret, __LINE__);
				}
				bias_timing_vset->Add(idx.ToString() + "_" + TIDispName, vector_set_no);
			}
			
			#pragma endregion "Setting up SPE vector"

			#pragma region "Looking for digitizer trigger delay (vector method)"

			int digitizer_trigger_delay_index = 0;

			int retest_count = 0;

	//DIG_TRG_DEL_RETEST:

			double vThreshold = 0.1;

			if (bias_timing_dig_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				//CBIT13 (Connect SWG to DM_TO_ACM)
				ret = OnOffCbit(idx, 13, 1);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOn("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = dm[idx]->RunVector("DM_2", vector_set_no);
				//CheckError(idx, ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(idx, ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}

				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
					CheckError(idx, ret, __LINE__);
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] <<endl;
						}
						outFile.close();
					}
				
					for (int k=0; k<dataArrayP->Length; k++)
					{
						if(dataArrayP[k] < vThreshold) //neg
						{
							digitizer_trigger_delay_index = k;

							//if (digitizer_trigger_delay_index > 40)
							//{
							//	retest_count++;

							//	if (retest_count < TIMING_RESET_COUNT)
							//	{
							//		goto DIG_TRG_DEL_RETEST;
							//	}
							//}

							break;
						}
					}			
				}

				ret = dm[idx]->DPINOff("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = OnOffCbit(idx, 13, 0);
				CheckError(idx, ret, __LINE__);
				
				bias_timing_dig_del_index->Add(idx.ToString() + "_" + TIDispName, digitizer_trigger_delay_index);
			}
			digitizer_trigger_delay_index = bias_timing_dig_del_index[idx.ToString() + "_" + TIDispName];
			

			#pragma endregion "Looking for digitizer trigger delay (vector method)"

			#pragma region "Test"

			//Off K3, K4
			ret = DriveCBit(idx, TPDispName[0], 0);
			CheckError(idx, ret, __LINE__);

			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);


			//ret = acm[idx]->StopFG("ACM_CH"); 
			//CheckError(idx, ret, __LINE__);
			
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_bias_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_bias_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0);
			//ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH",2.58/2, -1 * 2.58/2, Fswg, 0);
			
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(1e-3);
			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			double ac_timing = 0;
			double dc_timing = 0;
			
			
			ret = RunVectorFile(idx, Vector_File_Init);
			CheckError(idx, ret, __LINE__);

			double vThres = 0;
			int index = -1;

			double max_limit = 0;
			double min_limit = 0;

			int retestCount = 0;

			for (int i=0; i<total_tp; i++)
			{

RETEST:

				if ((TPName[i]->Contains("AC") == true)) //start test here
				{
					ret = acm[idx]->RunFG("ACM_CH", 0, true);
					CheckError(idx, ret, __LINE__);
					vThres = 0.25;

				}
				else
				{
					ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_OFF, ACM_CONST_IMPEDANCE_50OHM);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					vThres = 0.25 + 0.25;  //baseline at 0.25 level
				}	

				_util->Wait_Sec(0.5e-3);

				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);

				_util->Wait_Sec(0.5e-3);

				ret = RunVectorFile(idx, Vector_File_Bias1);
				CheckError(idx, ret, __LINE__);
				

				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}

				if ((TPName[i]->Contains("AC") == false)) //start test here
				{
					//////////////////////////////////
					//DC (no waveform)
					//////////////////////////////////
					
					if (ret == 0)
					{
						
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);

						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\Bias_timing_DC.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] <<endl;
							}
							outFile.close();
						}
					}

					index = -1;
					for (int k=0; k<nbrSamples; k++)
					{
						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
						{
							index = k;
							break;
						}
					}

					if (index != -1)
					{
						dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
					}
					else
					{
						dc_timing = 0;
					}

					result[i] = dc_timing;
				}
				else
				{
					//////////////////////////////////
					//AC
					//////////////////////////////////
		
					if (ret == 0)
					{
						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
						CheckError(idx, ret, __LINE__);
			
						if (Debug_Enable == true)
						{
							ofstream outFile("C:\\Aemulus\\Debug\\BIAS_Timing_AC.txt");
							for (int k = 0; k < nbrSamples; k++) 
							{
								outFile << _glob->DIG_Data_Arr[idx, k, 0] <<endl;
							}
							outFile.close();
						}
					}

					index = -1;
					int off_time_count = 0;
					int off_time_start_index = 0;
					int found = 0;
					for (int k=0; k<nbrSamples; k++)
					{
						//Look for 50 consecutive points where amplitude < vThres (to confirm off time)

						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) < 0.1)
						{
							off_time_count++;

							if (off_time_count == 50)
							{
								found = 1;
								off_time_start_index = k - 50 + 1;
								break;
							}
						}
						else
						{
							off_time_count = 0;
						}
					}

					if (found == 1)
					{
						for (int k=off_time_start_index; k<nbrSamples; k++)
						{
							if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
							{
								//index = k - off_time_start_index;
								index = k;
								break;
							}
						}
					}

					if (index != -1)
					{
						ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
					}
					else
					{
						ac_timing = 999;
					}

					result[i] = ac_timing;
				}
				
				// check retest
				max_limit = (double)(tf_TPHighLimit_Cast(TPName[i]));
				min_limit = (double)(tf_TPLowLimit_Cast(TPName[i]));
				
				if   ((( result[i] > max_limit ) || ( result[i] < min_limit ))  && (retestCount < 3))
				{
					retestCount++;

						//if (Debug_Enable == true)
							String ^ filepath = "C:\\Aemulus\\Debug\\rawdata_" + _glob->Xcoord[idx].ToString() + "_" + _glob->Ycoord[idx].ToString() + ".txt";
							
							StreamWriter^ sw = gcnew StreamWriter(filepath);
							for (int k = 0; k < nbrSamples; k++) 
							{
								sw->WriteLine(_glob->DIG_Data_Arr[idx, k, 0].ToString()); 
							}
							sw->Close();
							goto RETEST;

				}else{
					retestCount = 0;
				}
				
				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
			}
			#pragma endregion "Test"
	
	
test_end:

			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);

			ret = Digital_Init_State(idx); 
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 0, 0);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}		
	}


	void TestProgram::itr_timing3(Object^ object)		//ML working copy
	{
		TestProgramData^ d = (TestProgramData^)object;

		Site^ site = d->t_site;
		int idx = d->UutOffsetIndex;

		int ret = 0;

		try 
		{
			//Get test name from techFlow
			int total_tp = (int)tf_TPCount();
			array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
			array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
			array<double> ^ result = gcnew array<double>(total_tp);

			for (int i=0; i<total_tp; i++)
			{
				TPDispName[i] = tf_TestParameter_DisplayName(i);
				TPName[i] = tf_TestParameter_Name(i);
				result[i] = 0;
			}

			String ^ TIDispName = tf_TestItem_DisplayName();

			//Get test condition from techFlow
			int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
			double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
			double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
			double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
			double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
			double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
			double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
			Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
			double Input_Channel_Delay_s = 0;
			double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

			double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
			double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

			double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

			String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
			String ^ Vector_File		= String::Empty;

			double diff2se_digitizer_factor = 1;

			double diff2se_digitizer_factor_dc = 1;

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_100M"))
				diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_100M"][idx];

			if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
				diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC"][idx];

			double vih;
			double vil;
			double voh; 
			double vol;
			double ioh;
			double iol;
			double vch;
			double vcl;
			double vt;

			int vector_engine_status = 0;

			Stopwatch swatch;

			//IO setting
			ret = SetupDigital(idx);
			CheckError(idx, ret, __LINE__);
			ret = DriveCBit(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			ret = DriveMuxIO(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			//Setup Power supplies
			//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VCC", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VCC", true, false);
			//CheckError(idx, ret, __LINE__);

			//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->OnSmuPin("VEE", true, false);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(0.001);

			ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
			CheckError(idx, ret, __LINE__);
			//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
			//CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = DriveDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);

			vih = 2.5;
			vil = 0.00;
			voh = 0.75; 
			vol = 0.75;
			ioh = 0.002;
			iol = 0.002;
			vch = 6;
			vcl = -0.1;
			vt = 0;

			ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPE");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPD");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINOn("SPC");
			CheckError(idx, ret, __LINE__);

			ret = dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
			CheckError(idx, ret, __LINE__);
			ret = dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			CheckError(idx, ret, __LINE__);

			//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
			//	CheckError(idx, ret, __LINE__);
			//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
			//	CheckError(idx, ret, __LINE__);

			//Configure Input Delay
			ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
			CheckError(idx, ret, __LINE__);
			//_util->Wait_Sec(On_Delay_s);

			ret = RunVectorFile(idx, "write_default_reg");
			CheckError(idx, ret, __LINE__);
			ret = RunVectorFile(idx, "Vector_File_Init");
			CheckError(idx, ret, __LINE__);
			
			//Digitizer setting
			int mode = 0;	//0 = normal data acquisition (digitizer)
							//2 = averaging mode (it makes the instrument run as a real-time averager)
			int flag = 0;	//0 = normal
							//1 = ‘Start on Trigger’ mode
			double sampInterval = 1e-9;
			double delayTime = 0.0;
			int nbrSamples = 1024; //8192; //must be 2^n		//use 2048 instead of 1024 for 2945
			int nbrSegments = 1;
			int coupling = 3;	//0 Ground (Averagers ONLY)
								//1 DC, 1 M-ohm
								//2 AC, 1 M-ohm
								//3 DC, 50 M-ohm
								//4 AC, 50 M-ohm
			int bandwidth = 0;	//0 no bandwidth limit (default)
								//1 bandwidth limit at 25 MHz
								//2 bandwidth limit at 700 MHz
								//3 bandwidth limit at 200 MHz
								//4 bandwidth limit at 20 MHz
								//5 bandwidth limit at 35 MHz
			double fullScale = 2.0; //1V or 2V
			double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
									//2V range: ±4 V (max signal = ±6.3 V)
			long trigClass = 0;		//0 edge trigger 

			long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
											//0x000n0002 for Channel 2

			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

				if (hardwareResource->Alias->Contains("Ch1"))
				{
					sourcePattern = 0x00000001;
				}
				else if (hardwareResource->Alias->Contains("Ch2"))
				{
					sourcePattern = 0x00000002;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			long trigCoupling = 0;	//0 DC
									//1 AC
									//2 HF Reject (if available)
									//3 DC, 50 (ext. trigger only, if available)
									//4 AC, 50 (ext. trigger only, if available)
			long trigSlope = 0;	//0 Positive
								//1 Negative
								//2 out of Window
								//3 into Window
								//4 HF divide
								//5 Spike Stretcher
			double trigLevel = 0;	//% of FS 
									//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
			int timeOut_ms = 1;

			//array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

			double vout_pp = 0.0;

			int max_loop = 50;

			//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
		
			int Decimation_Factor = 1;

			_glob->digitizer_setting[0] = sampInterval;
			_glob->digitizer_setting[1] = delayTime;
			_glob->digitizer_setting[2] = (double)nbrSamples;
			_glob->digitizer_setting[3] = (double)nbrSegments;
			_glob->digitizer_setting[4] = fullScale; 
			_glob->digitizer_setting[5] = offset;
			_glob->digitizer_setting[6] = (double)coupling;
			_glob->digitizer_setting[7] = (double)bandwidth;
			_glob->digitizer_setting[8] = (double)trigClass;
			_glob->digitizer_setting[9] = (double)sourcePattern;
			_glob->digitizer_setting[10] = (double)trigCoupling;
			_glob->digitizer_setting[11] = (double)trigSlope;
			_glob->digitizer_setting[12] = trigLevel;
			_glob->digitizer_setting[13] = (double)timeOut_ms;
			_glob->digitizer_setting[14] = (double)Decimation_Factor;

			//On K3, K4
			ret = DriveCBit(idx, TPDispName[0], 1);
			CheckError(idx, ret, __LINE__);

			#pragma region "Calibration of Vpp"
			if (Vswg_itr_timing_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

				double Vswg_cal = 0;
				int loop_count = 0;

				Vswg_cal = Vswg;

				ret = acm[idx]->ResetChannel("ACM_CH");
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
				CheckError(idx, ret, __LINE__);
				ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);
				ret = acm[idx]->RunFG("ACM_CH", 0, true);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(Measure_Delay_s);

				int do_once = 0;
				while(loop_count <= max_loop)
				{
					if (do_once == 0)
					{
						ret = Digitizer_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
						CheckError(idx, ret, __LINE__); 

						ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
						CheckError(idx, ret, __LINE__);
						
						do_once = 1;
					}

 					ret = DigitizerFFT_CaptureVpp(idx,sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
					CheckError(idx, ret, __LINE__);

					if (ret)
					{

						ret = stopDigitizerFFTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						
						for (int i=0; i<total_tp; i++)
						{
							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
						}

						ret = 0;

						goto test_end;
					}

				
					if (Debug_Enable == true)
					{
						ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
						CheckError(idx, ret, __LINE__);
							
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
						for (int i = 0; i < nbrSamples; i++) 
						{
							outFile << dataArrayP[i] << endl;
						}
						outFile.close();
					}

					if (Math::Abs(Vswg - vout_pp) < (4e-3))
					{
						break;
					}
					else
					{
						Vswg_cal = Vswg_cal + (Vswg - vout_pp);

						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
						ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
						if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
						{
							CheckError(idx, ret, __LINE__);	
						}

						if (ret != 0) 
						{
							ret = 0;
						
							ret = stopDigitizerFFTAcquire(idx, sourcePattern);
							CheckError(idx, ret, __LINE__);
							
							ret = acm[idx]->StopFG("ACM_CH"); 
							CheckError(idx, ret, __LINE__);

							//off K3, K4
							ret = DriveCBit(idx, TPDispName[0], 0);
							CheckError(idx, ret, __LINE__);

							for (int i=0; i<total_tp; i++)
							{
								tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
							}

							goto test_end;
						}

						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
						_util->Wait_Sec(Measure_Delay_s);
					}
		
					loop_count++;
				}

				if (loop_count > max_loop)
				{
			
					ret = stopDigitizerFFTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
					ret = acm[idx]->StopFG("ACM_CH"); 
					CheckError(idx, ret, __LINE__);
					
					for (int i=0; i<total_tp; i++)
					{
						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
					}

					goto test_end;
				}
							
				ret = stopDigitizerFFTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				
				ret = acm[idx]->StopFG("ACM_CH"); 
				CheckError(idx, ret, __LINE__);

				Vswg_itr_timing_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
				Vswg_itr_timing_at_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
			}
			
			#pragma endregion "Calibration of Vpp"	

			#pragma region "Setting"

			ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
			CheckError(idx, ret, __LINE__);


			//Trigger:
			//	Digitizer - Falling edge (sync with SPE)

			//DM seting
			ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
			CheckError(idx, ret, __LINE__);

			//Digitizer setting
			try
			{
				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

				if (hardwareResource->Alias->Contains("ExtTrigIn1"))
				{
					sourcePattern = 0x80000000;
				}
				else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
				{
					sourcePattern = 0x40000000;
				}

				//if (resourceManager[idx])
				//	delete resourceManager[idx];
			}
			catch (Exception ^ e)
			{
				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
			}

			trigLevel = 300;	//% of FS, or mV if external trigger is used
								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

			trigSlope = 1; //negative

			timeOut_ms = 100;

			ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, 0x80000000);
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
			CheckError(idx, ret, __LINE__);

			//apply digitizer setting
			ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
			CheckError(idx, ret, __LINE__);
			ret = digitizer[idx]->StopAcquire("DIGITIZER");
			CheckError(idx, ret, __LINE__);


			#pragma endregion "Setting"	

			int vector_set_no = _glob->VectorArrSetNo + 1;
			#pragma region "Setting up SPE vector"
			if (itr_timing_vset->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				//Check SPE and SYNC pin numbers
				int SPE_Channel = 0;
				int DM_TO_ACM_Channel = 0;
				try
				{
					//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

					Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("SPE")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						SPE_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						SPE_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						SPE_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						SPE_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						SPE_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						SPE_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						SPE_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						SPE_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						SPE_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						SPE_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						SPE_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						SPE_Channel = 9;

					hardwareResource = resourceManager[idx]->ResolveResource("DM_TO_ACM")[0];

					if (hardwareResource->Alias->Contains("Ch10"))
						DM_TO_ACM_Channel = 10;
					else if (hardwareResource->Alias->Contains("Ch11"))
						DM_TO_ACM_Channel = 11;
					else if (hardwareResource->Alias->Contains("Ch0"))
						DM_TO_ACM_Channel = 0;
					else if (hardwareResource->Alias->Contains("Ch1"))
						DM_TO_ACM_Channel = 1;
					else if (hardwareResource->Alias->Contains("Ch2"))
						DM_TO_ACM_Channel = 2;
					else if (hardwareResource->Alias->Contains("Ch3"))
						DM_TO_ACM_Channel = 3;
					else if (hardwareResource->Alias->Contains("Ch4"))
						DM_TO_ACM_Channel = 4;
					else if (hardwareResource->Alias->Contains("Ch5"))
						DM_TO_ACM_Channel = 5;
					else if (hardwareResource->Alias->Contains("Ch6"))
						DM_TO_ACM_Channel = 6;
					else if (hardwareResource->Alias->Contains("Ch7"))
						DM_TO_ACM_Channel = 7;
					else if (hardwareResource->Alias->Contains("Ch8"))
						DM_TO_ACM_Channel = 8;
					else if (hardwareResource->Alias->Contains("Ch9"))
						DM_TO_ACM_Channel = 9;

					//if (resourceManager[idx])
					//	delete resourceManager[idx];
				}
				catch (Exception ^ e)
				{
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
				}

				//Set up vector (H -> L)
				int vector_size = 0;
				int l_size = 1; //=100ns (100ns is the selected timing set value)
				int h_size = 1; 

				vector_size = (h_size + l_size);
				array<int> ^ group0_vectors = gcnew array<int>(vector_size);
				array<int> ^ group1_vectors = gcnew array<int>(vector_size);

				//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
				int LL = 0x0; //Logic Low
				int LH = 0x1; //Logic High 
				int CL = 0x2; //Compare Low
				int CH = 0x3; //Compare High
				int triX = 0x4; //Tri-state & Don't Compare

				int SPE = 0;
				if (SPE_Channel > 5)
					SPE = ((SPE_Channel-6) * 3 + 1);
				else
					SPE = SPE_Channel * 3 + 1;
				
				int DM_TO_ACM = 0;
				if (DM_TO_ACM_Channel > 5)
					DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
				else
					DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

				for (int i=0; i<vector_size; i++)
				{
					group0_vectors[i] = 0x0;
					group1_vectors[i] = 0x0;

					if (i < h_size) 
					{
						if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1;
			
							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1;
							group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
						{
							group0_vectors[i] |= 0x1 | LH<<SPE;
							group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != SPE_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= DM_TO_ACM_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}
						else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
						{
							group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
							group1_vectors[i] |= 0x1 | LH<<SPE;

							//set up other channels to tri-state/don't care
							for (int k=0; k<6; k++)
							{
								if (k != DM_TO_ACM_Channel)
								{
									group0_vectors[i] |= (triX<<(k*3+1));
								}
								if ((k+6)!= SPE_Channel)
								{
									group1_vectors[i] |= (triX<<(k*3+1));
								}
							}
						}	
					}
					else
					{
						group0_vectors[i] |= 0x0;
						group1_vectors[i] |= 0x0;
					}
					
			

				}

				

				int timing_set_no = 0;
				//int vector_set_no = _glob->VectorArrSetNo + 1;
				ret = dm[idx]->DPINPeriod("DM_2", timing_set_no, 100e-9);
				CheckError(idx, ret, __LINE__);
				ret = dm[idx]->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
				CheckError(idx, ret, __LINE__);

				if (Debug_Enable == true)
				{
					ret = dm[idx]->RunVector("DM_2", vector_set_no);
					//CheckError(idx, ret, __LINE__);
				}
				itr_timing_vset->Add(idx.ToString() + "_" + TIDispName, vector_set_no);
			}
			
			#pragma endregion "Setting up SPE vector"

			#pragma region "Looking for digitizer trigger delay (vector method)"

			int digitizer_trigger_delay_index = 0;

			int retest_count = 0;

	//DIG_TRG_DEL_RETEST:

			double vThreshold = 0.1;

			if (itr_timing_dig_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
			{
				array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
				//CBIT13 (Connect SWG to DM_TO_ACM)
				ret = OnOffCbit(idx, 13, 1);
				CheckError(idx, ret, __LINE__);

				ret = dm[idx]->DPINOn("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = startDigitizerDGTAcquire(idx, sourcePattern);
				CheckError(idx, ret, __LINE__);
				_util->Wait_Sec(1e-3);

				ret = dm[idx]->RunVector("DM_2", vector_set_no);
				//CheckError(idx, ret, __LINE__);
				swatch.Reset();
				swatch.Start();
				swatch.Stop();

				while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
				{
					swatch.Start();

					ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
					CheckError(idx, ret, __LINE__);

					if (vector_engine_status == 0)
						break;

					swatch.Stop();
				}
				if (vector_engine_status != 0)
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
				}

				ret = waitDigitizerDGTComplete(idx, sourcePattern);
				if (ret < 0) 
				{
					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);
				}
				if (ret == 0)
				{
					ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
					CheckError(idx, ret, __LINE__);
			
					if (Debug_Enable == true)
					{
						ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
						for (int k = 0; k < nbrSamples; k++) 
						{
							outFile << dataArrayP[k] << endl;
						}
						outFile.close();
					}
				
					for (int k=0; k<dataArrayP->Length; k++)
					{
						if(dataArrayP[k] < vThreshold) //neg
						{
							digitizer_trigger_delay_index = k;

							//if (digitizer_trigger_delay_index > 40)
							//{
							//	retest_count++;

							//	if (retest_count < TIMING_RESET_COUNT)
							//	{
							//		goto DIG_TRG_DEL_RETEST;
							//	}
							//}

							break;
						}
					}			
				}

				ret = dm[idx]->DPINOff("DM_TO_ACM");
				CheckError(idx, ret, __LINE__);

				ret = OnOffCbit(idx, 13, 0);
				CheckError(idx, ret, __LINE__);
				
				itr_timing_dig_del_index->Add(idx.ToString() + "_" + TIDispName, digitizer_trigger_delay_index);
			}
			digitizer_trigger_delay_index = itr_timing_dig_del_index[idx.ToString() + "_" + TIDispName];
			

			#pragma endregion "Looking for digitizer trigger delay (vector method)"

			#pragma region "Test"

			//Off K3, K4
			ret = DriveCBit(idx, TPDispName[0], 0);
			CheckError(idx, ret, __LINE__);

			//On K1, K2
			ret = DriveCBit(idx, TPDispName[0], 2);
			CheckError(idx, ret, __LINE__);

			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_itr_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_itr_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
			CheckError(idx, ret, __LINE__);

			ret = acm[idx]->RunFG("ACM_CH", 0, true);
			CheckError(idx, ret, __LINE__);

			double ac_timing = 0;
			double dc_timing = 0;
			

			double vThres = 0.1;
			int index = -1;
			double vpp = 0;

			for (int i=0; i<total_tp; i++)
			{
				if (TPName[i]->Contains("Vsettle") == false)
				{
				
					ret = RunVectorFile(idx, "write_p1_reg7_mode_active");
					CheckError(idx, ret, __LINE__);
					
					Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

					if (TPName[i]->Contains("AC") == true) //start test here
					{
						ret = acm[idx]->RunFG("ACM_CH", 0, true);
						CheckError(idx, ret, __LINE__);
					}
					else
					{
						ret = acm[idx]->StopFG("ACM_CH"); 
						CheckError(idx, ret, __LINE__);
					}	

					_util->Wait_Sec(0.5e-3);

					ret = startDigitizerDGTAcquire(idx, sourcePattern);
					CheckError(idx, ret, __LINE__);

					_util->Wait_Sec(0.5e-3);

					ret = RunVectorFile(idx, Vector_File);
					CheckError(idx, ret, __LINE__);
				
					ret = waitDigitizerDGTComplete(idx, sourcePattern);
					if (ret < 0) 
					{
						ret = stopDigitizerDGTAcquire(idx, sourcePattern);
						CheckError(idx, ret, __LINE__);
					}

					if ((TPName[i]->Contains("DC") == true)) //start test here
					{
						//////////////////////////////////
						//DC (no waveform)
						//////////////////////////////////
						
						if (ret == 0)
						{
							
							ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
							CheckError(idx, ret, __LINE__);
					
							if (Debug_Enable == true)
							{
								ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
								for (int k = 0; k < nbrSamples; k++) 
								{
									outFile << _glob->DIG_Data_Arr[idx, k, 0] << endl;
								}
								outFile.close();
							}
						}

						index = -1;
						for (int k=0; k<nbrSamples; k++)
						{
							if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
							{
								index = k;
								break;
							}
						}

						if (index != -1)
						{
							dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
						}
						else
						{
							dc_timing = 0;
						}

						result[i] = dc_timing;
					}
					else
					{
						//////////////////////////////////
						//AC
						//////////////////////////////////
			
						if (ret == 0)
						{
							ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
							CheckError(idx, ret, __LINE__);
					
							if (Debug_Enable == true)
							{
								ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
								for (int k = 0; k < nbrSamples; k++) 
								{
									outFile << _glob->DIG_Data_Arr[idx, k, 0] << endl;
								}
								outFile.close();
							}
						}

						index = -1;
						for (int k=0; k<nbrSamples; k++)
						{
							if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
							{
								index = k;
								break;
							}
						}

						if (index != -1)
						{
							ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
						}
						else
						{
							ac_timing = 999;
						}

						result[i] = ac_timing;

						//Calculate vpp of the settled voltage

						if (ac_timing != 999)
						{
							double average = 0;
							for (int k=digitizer_trigger_delay_index; k<index; k++)
							{
								average += _glob->DIG_Data_Arr[idx, k, 0];
							}

							vpp = average / (index-digitizer_trigger_delay_index);

							vpp = vpp * diff2se_digitizer_factor_dc;
						}
						else
						{
							vpp = 999;
						}

						result[i+1] = vpp;
					}
				}

				tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
			}

			#pragma endregion "Test"

	test_end:
			
			ret = stopDigitizerDGTAcquire(idx, sourcePattern);
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->StopFG("ACM_CH"); 
			CheckError(idx, ret, __LINE__);
			ret = acm[idx]->ResetChannel("ACM_CH");
			CheckError(idx, ret, __LINE__);

			ret = Digital_Init_State(idx); 
			CheckError(idx, ret, __LINE__);
			ret = ResetDMPin(idx, TPDispName[0]);
			CheckError(idx, ret, __LINE__);
			//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 0, 0);
			//CheckError(idx, ret, __LINE__);

			//Power down supplies
			//ret = smu[idx]->DriveVoltage("VEE", 0);
			//CheckError(idx, ret, __LINE__);
			ret = smu[idx]->DriveVoltage("VCC", 0);
			CheckError(idx, ret, __LINE__);

			//IO setting
			ret = ResetCBit(idx);
			CheckError(idx, ret, __LINE__);
			ret = ResetMuxIO(idx);
			CheckError(idx, ret, __LINE__);
		}
		catch (Exception^ ex) 
		{
			d->Exception = ex;
			d->ErrorCode = ret;
		}
	}


	//void TestProgram::itr_timing3(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);
	//		array<double> ^ result = gcnew array<double>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//			result[i] = 0;
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));

	//		double Vswg				= (double)(tf_TestItemCondition_Cast("Vswg"));
	//		double Fswg				= (double)(tf_TestItemCondition_Cast("Fswg"));

	//		double sync_rwn_timing	= 0;//-5.2e-9; //from scope/char data

	//		String ^ Vector_File_Init	= (String ^)(tf_TestItemCondition_Cast("Vector_File_Init"));
	//		String ^ Vector_File		= String::Empty;

	//		double diff2se_digitizer_factor = 1;

	//		double diff2se_digitizer_factor_dc = 1;

	//		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_100M"))
	//			diff2se_digitizer_factor = calfactor["DIFF2SE_DIGITIZER_100M"][idx];

	//		if (calfactor->ContainsKey("DIFF2SE_DIGITIZER_DC"))
	//			diff2se_digitizer_factor_dc = calfactor["DIFF2SE_DIGITIZER_DC"][idx];

	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(On_Delay_s);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("DM_TO_ACM", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("DM_TO_ACM", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("DM_TO_ACM", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);

	//		//	ret = dm[idx]->Force("VCM_SE_DIFF_CONVERT", DM_CONST_FORCE_STATE_DIO);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = dm[idx]->DPINLevel("VCM_SE_DIFF_CONVERT", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = dm[idx]->SetPinDirection("VCM_SE_DIFF_CONVERT", DM_CONST_DIR_OUTPUT);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = dm[idx]->DrivePin("VCM_SE_DIFF_CONVERT", 0);
	//		//	CheckError(idx, ret, __LINE__);
	//		//	ret = dm[idx]->DPINOn("VCM_SE_DIFF_CONVERT");
	//		//	CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);
	//		//_util->Wait_Sec(On_Delay_s);

	//		ret = RunVectorFile(idx, "write_default_reg");
	//		CheckError(idx, ret, __LINE__);
	//		ret = RunVectorFile(idx, "Vector_File_Init");
	//		CheckError(idx, ret, __LINE__);
	//		
	//		//Digitizer setting
	//		int mode = 0;	//0 = normal data acquisition (digitizer)
	//						//2 = averaging mode (it makes the instrument run as a real-time averager)
	//		int flag = 0;	//0 = normal
	//						//1 = ‘Start on Trigger’ mode
	//		double sampInterval = 1e-9;  //sidi 1e-9
	//		double delayTime = 0.0;
	//		int nbrSamples = 2048; //8192; //must be 2^n 1024
	//		int nbrSegments = 1;
	//		int coupling = 3;	//0 Ground (Averagers ONLY)
	//							//1 DC, 1 M-ohm
	//							//2 AC, 1 M-ohm
	//							//3 DC, 50 M-ohm
	//							//4 AC, 50 M-ohm
	//		int bandwidth = 0;	//0 no bandwidth limit (default)
	//							//1 bandwidth limit at 25 MHz
	//							//2 bandwidth limit at 700 MHz
	//							//3 bandwidth limit at 200 MHz
	//							//4 bandwidth limit at 20 MHz
	//							//5 bandwidth limit at 35 MHz
	//		double fullScale = 2.0; //1V or 2V
	//		double offset = 0.0;	//1V range: ±2 V (max signal = ±3.6 V)
	//								//2V range: ±4 V (max signal = ±6.3 V)
	//		long trigClass = 0;		//0 edge trigger 

	//		long sourcePattern = 0x00000001;//0x000n0001 for Channel 1
	//										//0x000n0002 for Channel 2

	//		try
	//		{
	//			//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

	//			Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_CH")[0];

	//			if (hardwareResource->Alias->Contains("Ch1"))
	//			{
	//				sourcePattern = 0x00000001;
	//			}
	//			else if (hardwareResource->Alias->Contains("Ch2"))
	//			{
	//				sourcePattern = 0x00000002;
	//			}

	//			//if (resourceManager[idx])
	//			//	delete resourceManager[idx];
	//		}
	//		catch (Exception ^ e)
	//		{
	//			throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
	//		}

	//		long trigCoupling = 0;	//0 DC
	//								//1 AC
	//								//2 HF Reject (if available)
	//								//3 DC, 50 (ext. trigger only, if available)
	//								//4 AC, 50 (ext. trigger only, if available)
	//		long trigSlope = 0;	//0 Positive
	//							//1 Negative
	//							//2 out of Window
	//							//3 into Window
	//							//4 HF divide
	//							//5 Spike Stretcher
	//		double trigLevel = 0;	//% of FS 
	//								//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;
	//		int timeOut_ms = 1;

	//		//array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

	//		double vout_pp = 0.0;

	//		int max_loop = 50;

	//		//array<double> ^ digitizer_setting = gcnew array<double>(FFT_SETTING_SIZE);
	//	
	//		int Decimation_Factor = 1;

	//		_glob->digitizer_setting[0] = sampInterval;
	//		_glob->digitizer_setting[1] = delayTime;
	//		_glob->digitizer_setting[2] = (double)nbrSamples;
	//		_glob->digitizer_setting[3] = (double)nbrSegments;
	//		_glob->digitizer_setting[4] = fullScale; 
	//		_glob->digitizer_setting[5] = offset;
	//		_glob->digitizer_setting[6] = (double)coupling;
	//		_glob->digitizer_setting[7] = (double)bandwidth;
	//		_glob->digitizer_setting[8] = (double)trigClass;
	//		_glob->digitizer_setting[9] = (double)sourcePattern;
	//		_glob->digitizer_setting[10] = (double)trigCoupling;
	//		_glob->digitizer_setting[11] = (double)trigSlope;
	//		_glob->digitizer_setting[12] = trigLevel;
	//		_glob->digitizer_setting[13] = (double)timeOut_ms;
	//		_glob->digitizer_setting[14] = (double)Decimation_Factor;

	//		//On K3, K4
	//		ret = DriveCBit(idx, TPDispName[0], 1);
	//		CheckError(idx, ret, __LINE__);

	//		#pragma region "Calibration of Vpp"
	//		if (Vswg_itr_timing_calibrated->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
	//		{
	//			array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);

	//			double Vswg_cal = 0;
	//			int loop_count = 0;

	//			Vswg_cal = Vswg;

	//			ret = acm[idx]->ResetChannel("ACM_CH");
	//			CheckError(idx, ret, __LINE__);
	//			ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
	//			CheckError(idx, ret, __LINE__);
	//			ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
	//			CheckError(idx, ret, __LINE__);
	//			ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
	//			CheckError(idx, ret, __LINE__);
	//			_util->Wait_Sec(1e-3);
	//			ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//			CheckError(idx, ret, __LINE__);
	//			_util->Wait_Sec(Measure_Delay_s);

	//			int do_once = 0;
	//			while(loop_count <= max_loop)
	//			{
	//				if (do_once == 0)
	//				{
	//					ret = Digitizer_Configure(idx, _glob->digitizer_setting);
	//					CheckError(idx, ret, __LINE__); 

	//					ret = DigitizerFFT_Configure(idx, _glob->digitizer_setting);
	//					CheckError(idx, ret, __LINE__); 

	//					ret = digitizer[idx]->ConfigureTriggerSource("DIGITIZER_CH", trigCoupling, trigSlope, trigLevel, 0.0);
	//					CheckError(idx, ret, __LINE__);
	//					
	//					do_once = 1;
	//				}

 //					ret = DigitizerFFT_CaptureVpp(idx,sourcePattern, _glob->digitizer_setting, diff2se_digitizer_factor, vout_pp);
	//				CheckError(idx, ret, __LINE__);

	//				if (ret)
	//				{

	//					ret = stopDigitizerFFTAcquire(idx, sourcePattern);
	//					CheckError(idx, ret, __LINE__);

	//					ret = acm[idx]->StopFG("ACM_CH"); 
	//					CheckError(idx, ret, __LINE__);
	//					
	//					for (int i=0; i<total_tp; i++)
	//					{
	//						tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//					}

	//					ret = 0;

	//					goto test_end;
	//				}

	//			
	//				if (Debug_Enable == true)
	//				{
	//					ret = digitizer[idx]->RetrieveData("DIGITIZER_CH", dataArrayP); 
	//					CheckError(idx, ret, __LINE__);
	//						
	//					ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
	//					for (int i = 0; i < nbrSamples; i++) 
	//					{
	//						outFile << dataArrayP[i] << endl;
	//					}
	//					outFile.close();
	//				}

	//				if (Math::Abs(Vswg - vout_pp) < (4e-3))
	//				{
	//					break;
	//				}
	//				else
	//				{
	//					Vswg_cal = Vswg_cal + (Vswg - vout_pp);

	//					ret = acm[idx]->StopFG("ACM_CH"); 
	//					CheckError(idx, ret, __LINE__);
	//					ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_cal/2, -1 * Vswg_cal/2, Fswg, 0);
	//					if (ret != 0xAE0900A0 && ret != 0xAE0F000E) //exceed amplitude supported by ACM - AEMPXIE_E_BAD_ARGUMENTS/AEMAWG_E_EXCEED_VOLTAGE_SPEC
	//					{
	//						CheckError(idx, ret, __LINE__);	
	//					}

	//					if (ret != 0) 
	//					{
	//						ret = 0;
	//					
	//						ret = stopDigitizerFFTAcquire(idx, sourcePattern);
	//						CheckError(idx, ret, __LINE__);
	//						
	//						ret = acm[idx]->StopFG("ACM_CH"); 
	//						CheckError(idx, ret, __LINE__);

	//						//off K3, K4
	//						ret = DriveCBit(idx, TPDispName[0], 0);
	//						CheckError(idx, ret, __LINE__);

	//						for (int i=0; i<total_tp; i++)
	//						{
	//							tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//						}

	//						goto test_end;
	//					}

	//					ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//					CheckError(idx, ret, __LINE__);
	//					_util->Wait_Sec(Measure_Delay_s);
	//				}
	//	
	//				loop_count++;
	//			}

	//			if (loop_count > max_loop)
	//			{
	//		
	//				ret = stopDigitizerFFTAcquire(idx, sourcePattern);
	//				CheckError(idx, ret, __LINE__);
	//				ret = acm[idx]->StopFG("ACM_CH"); 
	//				CheckError(idx, ret, __LINE__);
	//				
	//				for (int i=0; i<total_tp; i++)
	//				{
	//					tf_SetResult_UUTOffset(TPName[i], (double)(INVALID_RESULT), idx);
	//				}

	//				goto test_end;
	//			}
	//						
	//			ret = stopDigitizerFFTAcquire(idx, sourcePattern);
	//			CheckError(idx, ret, __LINE__);
	//			
	//			ret = acm[idx]->StopFG("ACM_CH"); 
	//			CheckError(idx, ret, __LINE__);

	//			Vswg_itr_timing_calibrated->Add(idx.ToString() + "_" + TIDispName, Vswg_cal);
	//			Vswg_itr_timing_at_dut->Add(idx.ToString() + "_" + TIDispName, vout_pp);
	//		}
	//		
	//		#pragma endregion "Calibration of Vpp"	

	//		#pragma region "Setting"

	//		ret = digitizer[idx]->ConfigureOperationMode("DIGITIZER", 0, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = digitizer[idx]->ConfigureHorizontal("DIGITIZER", sampInterval, delayTime);
	//		CheckError(idx, ret, __LINE__);
	//		ret = digitizer[idx]->ConfigureMemory("DIGITIZER", nbrSamples, nbrSegments);
	//		CheckError(idx, ret, __LINE__);
	//		ret = digitizer[idx]->ConfigureVertical("DIGITIZER_CH", fullScale, offset, coupling, bandwidth);
	//		CheckError(idx, ret, __LINE__);


	//		//Trigger:
	//		//	Digitizer - Falling edge (sync with SPE)

	//		//DM seting
	//		ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 1, 26);
	//		CheckError(idx, ret, __LINE__);

	//		//Digitizer setting
	//		try
	//		{
	//			//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

	//			Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("DIGITIZER_EXT_TRIGIN")[0];

	//			if (hardwareResource->Alias->Contains("ExtTrigIn1"))
	//			{
	//				sourcePattern = 0x80000000;
	//			}
	//			else if (hardwareResource->Alias->Contains("ExtTrigIn2"))
	//			{
	//				sourcePattern = 0x40000000;
	//			}

	//			//if (resourceManager[idx])
	//			//	delete resourceManager[idx];
	//		}
	//		catch (Exception ^ e)
	//		{
	//			throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
	//		}

	//		trigLevel = 300;	//% of FS, or mV if external trigger is used
	//							//TriggerLevelPercent = 100*(TriggerLevelVolts + vOffset)/Fsrange;

	//		trigSlope = 1; //negative

	//		timeOut_ms = 100;

	//		ret = digitizer[idx]->ConfigureTriggerClass("DIGITIZER", trigClass, 0x80000000);
	//		CheckError(idx, ret, __LINE__);
	//		ret = digitizer[idx]->ConfigureExtTriggerSource("DIGITIZER_EXT_TRIGIN", trigCoupling, trigSlope, trigLevel);
	//		CheckError(idx, ret, __LINE__);

	//		//apply digitizer setting
	//		ret = digitizer[idx]->StartAcquire("DIGITIZER"); //dummy acquisition to apply config
	//		CheckError(idx, ret, __LINE__);
	//		ret = digitizer[idx]->StopAcquire("DIGITIZER");
	//		CheckError(idx, ret, __LINE__);


	//		#pragma endregion "Setting"	

	//		int vector_set_no = _glob->VectorArrSetNo + 1;
	//		#pragma region "Setting up SPE vector"
	//		if (itr_timing_vset->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
	//		{
	//			//Check SPE and SYNC pin numbers
	//			int SPE_Channel = 0;
	//			int DM_TO_ACM_Channel = 0;
	//			try
	//			{
	//				//resourceManager[idx] = gcnew ResourceManager(HardwareProfile, testHead, idx);

	//				Resource ^ hardwareResource = resourceManager[idx]->ResolveResource("SPE")[0];

	//				if (hardwareResource->Alias->Contains("Ch10"))
	//					SPE_Channel = 10;
	//				else if (hardwareResource->Alias->Contains("Ch11"))
	//					SPE_Channel = 11;
	//				else if (hardwareResource->Alias->Contains("Ch0"))
	//					SPE_Channel = 0;
	//				else if (hardwareResource->Alias->Contains("Ch1"))
	//					SPE_Channel = 1;
	//				else if (hardwareResource->Alias->Contains("Ch2"))
	//					SPE_Channel = 2;
	//				else if (hardwareResource->Alias->Contains("Ch3"))
	//					SPE_Channel = 3;
	//				else if (hardwareResource->Alias->Contains("Ch4"))
	//					SPE_Channel = 4;
	//				else if (hardwareResource->Alias->Contains("Ch5"))
	//					SPE_Channel = 5;
	//				else if (hardwareResource->Alias->Contains("Ch6"))
	//					SPE_Channel = 6;
	//				else if (hardwareResource->Alias->Contains("Ch7"))
	//					SPE_Channel = 7;
	//				else if (hardwareResource->Alias->Contains("Ch8"))
	//					SPE_Channel = 8;
	//				else if (hardwareResource->Alias->Contains("Ch9"))
	//					SPE_Channel = 9;

	//				hardwareResource = resourceManager[idx]->ResolveResource("DM_TO_ACM")[0];

	//				if (hardwareResource->Alias->Contains("Ch10"))
	//					DM_TO_ACM_Channel = 10;
	//				else if (hardwareResource->Alias->Contains("Ch11"))
	//					DM_TO_ACM_Channel = 11;
	//				else if (hardwareResource->Alias->Contains("Ch0"))
	//					DM_TO_ACM_Channel = 0;
	//				else if (hardwareResource->Alias->Contains("Ch1"))
	//					DM_TO_ACM_Channel = 1;
	//				else if (hardwareResource->Alias->Contains("Ch2"))
	//					DM_TO_ACM_Channel = 2;
	//				else if (hardwareResource->Alias->Contains("Ch3"))
	//					DM_TO_ACM_Channel = 3;
	//				else if (hardwareResource->Alias->Contains("Ch4"))
	//					DM_TO_ACM_Channel = 4;
	//				else if (hardwareResource->Alias->Contains("Ch5"))
	//					DM_TO_ACM_Channel = 5;
	//				else if (hardwareResource->Alias->Contains("Ch6"))
	//					DM_TO_ACM_Channel = 6;
	//				else if (hardwareResource->Alias->Contains("Ch7"))
	//					DM_TO_ACM_Channel = 7;
	//				else if (hardwareResource->Alias->Contains("Ch8"))
	//					DM_TO_ACM_Channel = 8;
	//				else if (hardwareResource->Alias->Contains("Ch9"))
	//					DM_TO_ACM_Channel = 9;

	//				//if (resourceManager[idx])
	//				//	delete resourceManager[idx];
	//			}
	//			catch (Exception ^ e)
	//			{
	//				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Load resource manager error! (" + e->ToString() + ")", ER_GENERAL);
	//			}

	//			//Set up vector (H -> L)
	//			int vector_size = 0;
	//			int l_size = 1; //=100ns (100ns is the selected timing set value)
	//			int h_size = 1; 

	//			vector_size = (h_size + l_size);
	//			array<int> ^ group0_vectors = gcnew array<int>(vector_size);
	//			array<int> ^ group1_vectors = gcnew array<int>(vector_size);

	//			//[18:16] channel5_format, [15:13] channel4_format, [12:10] channel3_format, [9:7] channel2_format, [6:4] channel1_format, [3:1] channel0_format, [0] triggerout
	//			int LL = 0x0; //Logic Low
	//			int LH = 0x1; //Logic High 
	//			int CL = 0x2; //Compare Low
	//			int CH = 0x3; //Compare High
	//			int triX = 0x4; //Tri-state & Don't Compare

	//			int SPE = 0;
	//			if (SPE_Channel > 5)
	//				SPE = ((SPE_Channel-6) * 3 + 1);
	//			else
	//				SPE = SPE_Channel * 3 + 1;
	//			
	//			int DM_TO_ACM = 0;
	//			if (DM_TO_ACM_Channel > 5)
	//				DM_TO_ACM = ((DM_TO_ACM_Channel-6) * 3 + 1);
	//			else
	//				DM_TO_ACM = DM_TO_ACM_Channel * 3 + 1;

	//			for (int i=0; i<vector_size; i++)
	//			{
	//				group0_vectors[i] = 0x0;
	//				group1_vectors[i] = 0x0;

	//				if (i < h_size) 
	//				{
	//					if (SPE_Channel < 6 && DM_TO_ACM_Channel < 6)
	//					{
	//						group0_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;
	//						group1_vectors[i] |= 0x1;
	//		
	//						//set up other channels to tri-state/don't care
	//						for (int k=0; k<6; k++)
	//						{
	//							if (k != SPE_Channel && k!= DM_TO_ACM_Channel)
	//							{
	//								group0_vectors[i] |= (triX<<(k*3+1));
	//								group1_vectors[i] |= (triX<<(k*3+1));
	//							}
	//						}
	//					}
	//					else if (SPE_Channel > 5 && DM_TO_ACM_Channel > 5)
	//					{
	//						group0_vectors[i] |= 0x1;
	//						group1_vectors[i] |= 0x1 | LH<<SPE | LH<<DM_TO_ACM;

	//						//set up other channels to tri-state/don't care
	//						for (int k=0; k<6; k++)
	//						{
	//							if ((k+6) != SPE_Channel && (k+6)!= DM_TO_ACM_Channel)
	//							{
	//								group0_vectors[i] |= (triX<<(k*3+1));
	//								group1_vectors[i] |= (triX<<(k*3+1));
	//							}
	//						}
	//					}
	//					else if (SPE_Channel < 6 && DM_TO_ACM_Channel > 5)
	//					{
	//						group0_vectors[i] |= 0x1 | LH<<SPE;
	//						group1_vectors[i] |= 0x1 | LH<<DM_TO_ACM;

	//						//set up other channels to tri-state/don't care
	//						for (int k=0; k<6; k++)
	//						{
	//							if (k != SPE_Channel)
	//							{
	//								group0_vectors[i] |= (triX<<(k*3+1));
	//							}
	//							if ((k+6)!= DM_TO_ACM_Channel)
	//							{
	//								group1_vectors[i] |= (triX<<(k*3+1));
	//							}
	//						}
	//					}
	//					else // if (SPE_Channel > 5 && DM_TO_ACM_Channel < 6)
	//					{
	//						group0_vectors[i] |= 0x1 | LH<<DM_TO_ACM;
	//						group1_vectors[i] |= 0x1 | LH<<SPE;

	//						//set up other channels to tri-state/don't care
	//						for (int k=0; k<6; k++)
	//						{
	//							if (k != DM_TO_ACM_Channel)
	//							{
	//								group0_vectors[i] |= (triX<<(k*3+1));
	//							}
	//							if ((k+6)!= SPE_Channel)
	//							{
	//								group1_vectors[i] |= (triX<<(k*3+1));
	//							}
	//						}
	//					}	
	//				}
	//				else
	//				{
	//					group0_vectors[i] |= 0x0;
	//					group1_vectors[i] |= 0x0;
	//				}
	//				
	//		

	//			}

	//			

	//			int timing_set_no = 0;
	//			//int vector_set_no = _glob->VectorArrSetNo + 1;
	//			ret = dm[idx]->DPINPeriod("DM_2", timing_set_no, 100e-9);
	//			CheckError(idx, ret, __LINE__);
	//			ret = dm[idx]->DPINVecLoadArray("DM_2", DM_CONST_BIDIRECTIONAL_IO, timing_set_no, 0, vector_set_no, vector_size, group0_vectors, group1_vectors);
	//			CheckError(idx, ret, __LINE__);

	//			if (Debug_Enable == true)
	//			{
	//				ret = dm[idx]->RunVector("DM_2", vector_set_no);
	//				//CheckError(idx, ret, __LINE__);
	//			}
	//			itr_timing_vset->Add(idx.ToString() + "_" + TIDispName, vector_set_no);
	//		}
	//		
	//		#pragma endregion "Setting up SPE vector"

	//		#pragma region "Looking for digitizer trigger delay (vector method)"

	//		int digitizer_trigger_delay_index = 0;

	//		int retest_count = 0;

	////DIG_TRG_DEL_RETEST:

	//		double vThreshold = 0.1;

	//		if (itr_timing_dig_del_index->ContainsKey(idx.ToString() + "_" + TIDispName) == false)
	//		{
	//			array<double> ^ dataArrayP = gcnew array<double>(nbrSamples);
	//			//CBIT13 (Connect SWG to DM_TO_ACM)
	//			ret = OnOffCbit(idx, 13, 1);
	//			CheckError(idx, ret, __LINE__);

	//			ret = dm[idx]->DPINOn("DM_TO_ACM");
	//			CheckError(idx, ret, __LINE__);

	//			ret = startDigitizerDGTAcquire(idx, sourcePattern);
	//			CheckError(idx, ret, __LINE__);
	//			_util->Wait_Sec(1e-3);

	//			ret = dm[idx]->RunVector("DM_2", vector_set_no);
	//			//CheckError(idx, ret, __LINE__);
	//			swatch.Reset();
	//			swatch.Start();
	//			swatch.Stop();

	//			while (swatch.Elapsed.TotalSeconds < Vector_Timeout_s)
	//			{
	//				swatch.Start();

	//				ret = dm[idx]->AcquireVecEngineStatus("DM_2", vector_engine_status);
	//				CheckError(idx, ret, __LINE__);

	//				if (vector_engine_status == 0)
	//					break;

	//				swatch.Stop();
	//			}
	//			if (vector_engine_status != 0)
	//			{
	//				ret = stopDigitizerDGTAcquire(idx, sourcePattern);
	//				throw gcnew Aemulus::Hardware::AlarmException("Site " + idx.ToString() + ": Vector engine timeout @ line#" + __LINE__, ER_TIMEOUT);
	//			}

	//			ret = waitDigitizerDGTComplete(idx, sourcePattern);
	//			if (ret < 0) 
	//			{
	//				ret = stopDigitizerDGTAcquire(idx, sourcePattern);
	//				CheckError(idx, ret, __LINE__);
	//			}
	//			if (ret == 0)
	//			{
	//				ret = RetrieveDigitizerDataArray(idx, sourcePattern, dataArrayP);
	//				CheckError(idx, ret, __LINE__);
	//		
	//				if (Debug_Enable == true)
	//				{
	//					ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
	//					for (int k = 0; k < nbrSamples; k++) 
	//					{
	//						outFile << dataArrayP[k] << endl;
	//					}
	//					outFile.close();
	//				}
	//			
	//				for (int k=0; k<dataArrayP->Length; k++)
	//				{
	//					if(dataArrayP[k] < vThreshold) //neg
	//					{
	//						digitizer_trigger_delay_index = k;

	//						//if (digitizer_trigger_delay_index > 40)
	//						//{
	//						//	retest_count++;

	//						//	if (retest_count < TIMING_RESET_COUNT)
	//						//	{
	//						//		goto DIG_TRG_DEL_RETEST;
	//						//	}
	//						//}

	//						break;
	//					}
	//				}			
	//			}

	//			ret = dm[idx]->DPINOff("DM_TO_ACM");
	//			CheckError(idx, ret, __LINE__);

	//			ret = OnOffCbit(idx, 13, 0);
	//			CheckError(idx, ret, __LINE__);
	//			
	//			itr_timing_dig_del_index->Add(idx.ToString() + "_" + TIDispName, digitizer_trigger_delay_index);
	//		}
	//		digitizer_trigger_delay_index = itr_timing_dig_del_index[idx.ToString() + "_" + TIDispName];
	//		

	//		#pragma endregion "Looking for digitizer trigger delay (vector method)"

	//		#pragma region "Test"

	//		//Off K3, K4
	//		ret = DriveCBit(idx, TPDispName[0], 0);
	//		CheckError(idx, ret, __LINE__);

	//		//On K1, K2
	//		ret = DriveCBit(idx, TPDispName[0], 2);
	//		CheckError(idx, ret, __LINE__);

	//		ret = acm[idx]->ResetChannel("ACM_CH");
	//		CheckError(idx, ret, __LINE__);
	//		ret = acm[idx]->ConfigureChannelOperationMode("ACM_CH", ACM_CONST_MODE_FUNCTION_GENERATOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = acm[idx]->ConfigureFGSineWaveform("ACM_CH", Vswg_itr_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, -1 * Vswg_itr_timing_calibrated[idx.ToString() + "_" + TIDispName]/2, Fswg, 0);
	//		CheckError(idx, ret, __LINE__);
	//		ret = acm[idx]->ConfigureOutputSwitch("ACM_CH", ACM_CONST_SWITCH_ON, ACM_CONST_IMPEDANCE_50OHM);
	//		CheckError(idx, ret, __LINE__);

	//		ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//		CheckError(idx, ret, __LINE__);

	//		double ac_timing = 0;
	//		double dc_timing = 0;
	//		

	//		double vThres = 0.1;
	//		int index = -1;
	//		double vpp = 0;

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			if (TPName[i]->Contains("Vsettle") == false)
	//			{
	//			
	//				ret = RunVectorFile(idx, "write_p1_reg9_mode_active");
	//				CheckError(idx, ret, __LINE__);
	//				
	//				Vector_File = (String ^)(tf_TPCondition_Cast(TPName[i], "Vector_File"));

	//				if (TPName[i]->Contains("AC") == true) //start test here
	//				{
	//					ret = acm[idx]->RunFG("ACM_CH", 0, true);
	//					CheckError(idx, ret, __LINE__);
	//				}
	//				else
	//				{
	//					ret = acm[idx]->StopFG("ACM_CH"); 
	//					CheckError(idx, ret, __LINE__);
	//				}	

	//				_util->Wait_Sec(0.5e-3);

	//				ret = startDigitizerDGTAcquire(idx, sourcePattern);
	//				CheckError(idx, ret, __LINE__);

	//				_util->Wait_Sec(0.5e-3);

	//				ret = RunVectorFile(idx, Vector_File);
	//				CheckError(idx, ret, __LINE__);
	//			
	//				ret = waitDigitizerDGTComplete(idx, sourcePattern);
	//				if (ret < 0) 
	//				{
	//					ret = stopDigitizerDGTAcquire(idx, sourcePattern);
	//					CheckError(idx, ret, __LINE__);
	//				}

	// 

	//				if ((TPName[i]->Contains("DC") == true)) //start test here
	//				{
	//					//////////////////////////////////
	//					//DC (no waveform)
	//					//////////////////////////////////
	//					
	//					if (ret == 0)
	//					{
	//		

	//						ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0); 
	//						CheckError(idx, ret, __LINE__);
	//				
	//						if (Debug_Enable == true)
	//						{
	//							ofstream outFile("C:\\Aemulus\\Debug\\rawdata1.txt");
	//						for (int k = 0; k < nbrSamples; k++) 
	//							{
	//							outFile << _glob->DIG_Data_Arr[idx, k, 0] << endl;
	//			
	//						}
	//						outFile.close();
	//						}
	//					}

	//					index = -1;
	//					for (int k=0; k<nbrSamples; k++)  
	//					{
	//						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)
	//
	//						{
	//							index = k;
	//							break;
	//						}
	//					}

	//					if (index != -1)
	//					{
	//						dc_timing = (index - digitizer_trigger_delay_index) * sampInterval;
	//					}
	//					else
	//					{
	//						dc_timing = 0;
	//					}

	//					result[i] = dc_timing;
	//				}
	//				else
	//				{
	//					//////////////////////////////////
	//					//AC
	//					//////////////////////////////////
	//		
	//					if (ret == 0)
	//					{
	//											
	//						
	//					ret = Digitizer_GetData(idx, sourcePattern, nbrSamples, 0);
	//						CheckError(idx, ret, __LINE__);
	//				
	//						if (Debug_Enable == true)
	//						{
	//							ofstream outFile("C:\\Aemulus\\Debug\\rawdata.txt");
	//						for (int k = 0; k < nbrSamples; k++) 
	//							{
	//								outFile << _glob->DIG_Data_Arr[idx, k, 0] << endl;
	//							}
	//							outFile.close();
	//						}
	//					}

	//					index = -1;
	//					for (int k=0; k<nbrSamples; k++)  
	//					{
	//						if (Math::Abs(_glob->DIG_Data_Arr[idx, k, 0] * diff2se_digitizer_factor) > vThres)

	//						{
	//							index = k;
	//							break;
	//						}
	//					}

	//					if (index != -1)
	//					{
	//						ac_timing = (index - digitizer_trigger_delay_index) * sampInterval;
	//					}
	//					else
	//					{
	//						ac_timing = 999;
	//					}

	//					result[i] = ac_timing;

	//					//Calculate vpp of the settled voltage

	//					if (ac_timing != 999)
	//					{
	//						double average = 0;
	//						for (int k=digitizer_trigger_delay_index; k<index; k++)
	//						{
	//							average += _glob->DIG_Data_Arr[idx, k, 0];
	//						}

	//						vpp = average / (index-digitizer_trigger_delay_index);

	//						vpp = vpp * diff2se_digitizer_factor_dc;
	//					}
	//					else
	//					{
	//						vpp = 999;
	//					}

	//					result[i+1] = vpp;
	//				}
	//			}

	//			tf_SetResult_UUTOffset(TPName[i], result[i] + GetOffset(idx, TPDispName[i]), idx);
	//		}

	//		#pragma endregion "Test"

	//test_end:
	//		
	//		ret = stopDigitizerDGTAcquire(idx, sourcePattern);
	//		CheckError(idx, ret, __LINE__);
	//		ret = acm[idx]->StopFG("ACM_CH"); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = acm[idx]->ResetChannel("ACM_CH");
	//		CheckError(idx, ret, __LINE__);

	//		ret = Digital_Init_State(idx); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = dm[idx]->ConfigureOutputTriggerSelect("DM_2", 0, 0);
	//		//CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//void TestProgram::wr_flt_timing2(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;

	//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		int vector_engine_status = 0;
	//		array<int>^ HistoryRam = gcnew array<int>(256);
	//		int data = 0;

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		double period			= 0;
	//		double freq				= 0;
	//		int result_adc			= 0;
	//		int result_adc2			= 0;
	//		double result_wr_timing	= 0;

	//		/////////////////////////////////

	//		ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("RWN");
	//		CheckError(idx, ret, __LINE__);

	//		vih = 1.8;
	//		ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("WDX");
	//		CheckError(idx, ret, __LINE__);

	//		vih = 1.5;
	//		ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("WDY");
	//		CheckError(idx, ret, __LINE__);

	//		if(!USE_SPI) 
	//		{
	//			ret = RunVectorFile(idx, Vector_File);
	//			CheckError(idx, ret, __LINE__);
	//		} 
	//		else 
	//		{
	//			ret = OnOffSPI(idx, 1);
	//			CheckError(idx, ret, __LINE__);
	//			ret = RunSPI(idx, Vector_File);
	//			CheckError(idx, ret, __LINE__);
	//		}

	//		for(int j=30; j<50; j++) //Catalyst's result is i=38, freq=3.44828MHz
	//		{
	//			//In Aemulus test, a full cycle consist 2 pulses (high - low).
	//			//In Catalyst test, a full cycle consist of 4 pulses (high - low - high - low). That means whatever freq set in Catalyst need to times 2 for Aemulus. Proved by observing scope shot. 
	//			freq	= 1/(100e-9 + 5e-9*j); //start with 4MHz, follow catalyst
	//			period	= 1/(freq*2);//times 2 is because 8 MHz for Aemulus.
	//			
	//			ret = dm[idx]->DPINPeriod("DM_2", 99, period); //always change no set 99 only
	//			CheckError(idx, ret, __LINE__);
	//		
	//			//sweep WDX and WDY freq
	//			ret = dm[idx]->SPI_CH_UNSEL("DM_2", 0);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, "WDX_WDY_6400bits");
	//			CheckError(idx, ret, __LINE__);

	//			ret = dm[idx]->SPI_CHSEL("DM_2", 0, "SPC", "SPE", "SPD", "SPD");
	//			CheckError(idx, ret, __LINE__);

	//			//Read p1_reg6 and check for bit1 status
	//			if(!USE_SPI) 
	//			{
	//				ret = ReadVector(idx, "read_p1_reg6_wr_flt_timing", data);
	//				CheckError(idx, ret, __LINE__);
	//			} 
	//			else
	//			{
	//				ret = ReadSPI(idx, "read_p1_reg6_wr_flt_timing", data);
	//				CheckError(idx, ret, __LINE__);
	//			}
	//			
	//			result_adc = data & 0x02;

	//			//Read p1_reg8 and check for bit2 status
	//			if(!USE_SPI) 
	//			{
	//				ret = ReadVector(idx, "read_p1_reg8_wr_flt_timing", data);
	//				CheckError(idx, ret, __LINE__);
	//			} 
	//			else 
	//			{
	//				ret = ReadSPI(idx, "read_p1_reg8_wr_flt_timing", data);
	//				CheckError(idx, ret, __LINE__);
	//			}

	//			result_adc2 = data & 0x04;

	//			if((result_adc == 2) && (result_adc2 == 4)) //if any of the FLT bit is triggered, then break
	//			{
	//				break;
	//			}
	//			else //reset & loop
	//			{
	//				result_adc	= 0;
	//				result_adc2 = 0;
	//			}
	//		}

	//		result_wr_timing = period;

	//		tf_SetResult_UUTOffset(TPName[0], result_wr_timing + GetOffset(idx, TPDispName[0]), idx);

	//		/////////////////////////////////

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		
	//		if(USE_SPI)
	//		{
	//			ret = OnOffSPI(idx, 0);
	//			CheckError(idx, ret, __LINE__);
	//		}
	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}
	//void TestProgram::flt_timing2(Object^ object)
	//{
	//	TestProgramData^ d = (TestProgramData^)object;

	//	Site^ site = d->t_site;
	//	int idx = d->UutOffsetIndex;

	//	int ret = 0;

	//	try 
	//	{
	//		//Get test name from techFlow
	//		int total_tp = (int)tf_TPCount();
	//		array<String ^> ^ TPName = gcnew array<String ^>(total_tp);
	//		array<String ^> ^ TPDispName = gcnew array<String ^>(total_tp);

	//		for (int i=0; i<total_tp; i++)
	//		{
	//			TPDispName[i] = tf_TestParameter_DisplayName(i);
	//			TPName[i] = tf_TestParameter_Name(i);
	//		}

	//		String ^ TIDispName = tf_TestItem_DisplayName();

	//		//Get test condition from techFlow
	//		int Bandwidth			= (int)(tf_TestItemCondition_Cast("Bandwidth"));
	//		double Drive_Vcc_V		= (double)(tf_TestItemCondition_Cast("Drive_Vcc_V"));
	//		double Drive_Vee_V		= (double)(tf_TestItemCondition_Cast("Drive_Vee_V"));
	//		double Clamp_Vcc_Current_A	= (double)(tf_TestItemCondition_Cast("Clamp_Vcc_Current_A"));
	//		double On_Delay_s		= (double)(tf_TestItemCondition_Cast("On_Delay_s"));
	//		double Measure_Delay_s	= (double)(tf_TestItemCondition_Cast("Measure_Delay_s"));
	//		double Vector_Timeout_s = (double)(tf_TestItemCondition_Cast("Vector_Timeout_s"));
	//		Debug_Enable			= (bool)(tf_TestItemCondition_Cast("Debug_Enable"));
	//		double Input_Channel_Delay_s = 0;
	//		double NPLC				= (double)(tf_TestItemCondition_Cast("NPLC"));
	//		int SPD_Channel			= _glob->SPD_Channel_Number;

	//		String ^ Vector_File	= (String ^)(tf_TestItemCondition_Cast("Vector_File"));

	//		if (calfactor->ContainsKey("INPUT_CHANNEL_DELAY_NORM"))
	//			Input_Channel_Delay_s = calfactor["INPUT_CHANNEL_DELAY_NORM"][idx];

	//		array<double> ^ result_uts_delay	= gcnew array<double>(HDS);
	//		array<double> ^ result_stu_delay	= gcnew array<double>(HDS);

	//		for (int i=0; i<HDS; i++)
	//		{
	//			result_uts_delay[i] = 0;
	//			result_stu_delay[i] = 0;
	//		}
	//				
	//		double vih;
	//		double vil;
	//		double voh; 
	//		double vol;
	//		double ioh;
	//		double iol;
	//		double vch;
	//		double vcl;
	//		double vt;

	//		double tmu_start_threshold = 0;
	//		double tmu_stop_threshold = 0;
	//		double tmu_start_hysteresis = 0;
	//		double tmu_stop_hysteresis = 0;
	//		int number_of_samples = 0;
	//		double tmu_timeout = 0;
	//		int returned_sample_count = 0;
	//		array<double> ^ sampled_result;
	//		int retest_count = 0;

	//		int vector_engine_status = 0;

	//		Stopwatch swatch;

	//		//IO setting
	//		ret = SetupDigital(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveCBit(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);
	//		ret = DriveMuxIO(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Setup Power supplies
	//		//ret = smu[idx]->SetBandwidth("VCC", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VCC", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VCC", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VCC", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//ret = smu[idx]->SetBandwidth("VEE", Bandwidth);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->ClampCurrent("VEE", Clamp_Vcc_Current_A);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->OnSmuPin("VEE", true, false);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(0.001);

	//		ret = smu[idx]->DriveVoltage("VCC", Drive_Vcc_V);
	//		CheckError(idx, ret, __LINE__);
	//		//ret = smu[idx]->DriveVoltage("VEE", Drive_Vee_V);
	//		//CheckError(idx, ret, __LINE__);

	//		//_util->Wait_Sec(On_Delay_s);

	//		ret = DriveDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		vih = 2.5;
	//		vil = 0.00;
	//		voh = 0.75; 
	//		vol = 0.75;
	//		ioh = 0.002;
	//		iol = 0.002;
	//		vch = 6;
	//		vcl = -0.1;
	//		vt = 0;

	//		ret = dm[idx]->Force("SPE", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPE", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPE", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPE");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPD", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPD", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPD", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPD");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SPC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SPC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SPC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SPC");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("WDX", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("WDX", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("WDX", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("WDX");
	//		CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("WDY", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("WDY", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("WDY", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("WDY");
	//		CheckError(idx, ret, __LINE__);

	//		//ret = dm[idx]->Force("RWN", DM_CONST_FORCE_STATE_VECTOR);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = dm[idx]->ConfigurePEAttribute("RWN", 1, 0, 0, 0); 
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = dm[idx]->DPINLevel("RWN", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		//CheckError(idx, ret, __LINE__);
	//		//ret = dm[idx]->DPINOn("RWN");
	//		//CheckError(idx, ret, __LINE__);

	//		ret = dm[idx]->Force("SYNC", DM_CONST_FORCE_STATE_VECTOR);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->ConfigurePEAttribute("SYNC", 1, 0, 0, 0); 
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINLevel("SYNC", vih, vil, voh, vol, ioh, iol, vch, vcl, vt);
	//		CheckError(idx, ret, __LINE__);
	//		ret = dm[idx]->DPINOn("SYNC");
	//		CheckError(idx, ret, __LINE__);

	//		//Configure Input Delay
	//		ret = dm[idx]->ConfigureInputChannelDelay("SPD", Input_Channel_Delay_s);
	//		CheckError(idx, ret, __LINE__);

	//		//Must use vector method

	//		ret = RunVectorFile(idx, Vector_File);
	//		CheckError(idx, ret, __LINE__);

	//		/////////////////////////////////

	//		tmu_start_threshold = 0.2; //0.75;
	//		tmu_stop_threshold = 0.2; //0.75;
	//		tmu_start_hysteresis = 0.02;//0.2;
	//		tmu_stop_hysteresis = 0.02;//0.2;
	//		number_of_samples = 1;
	//		tmu_timeout = 10e-3;
	//		sampled_result = gcnew array<double>(number_of_samples);
	//		retest_count = 0;

	//		double max_limit = 0;
	//		double min_limit = 0;

	//		for (int i=0; i<number_of_samples; i++)
	//		{
	//			sampled_result[i] = 0;
	//		}

	//		/////////////////////////////////

	//		for (int i=0; i<HDS; i++) //each head cell contains 2 results
	//		{
	//			tmu_start_threshold = 0.8; //0.75;
	//			tmu_stop_threshold = 0.8; //0.75;

	//			Vector_File = (String ^)(tf_TestItemCondition_Cast("Vector_File_Hd" + i));

	//			ret = RunVectorFile(idx, Vector_File);
	//			CheckError(idx, ret, __LINE__);

	//			///////////////
	//			// STU

	//			ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
	//			CheckError(idx, ret, __LINE__);

	//			ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
	//			CheckError(idx, ret, __LINE__);

	//			_util->Wait_Sec(0.5e-3);

	//			retest_count = 0;

	//STU_RETEST:

	//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, "write_flt_stu"); //sync btw WDX/WDY & SYNC pin
	//			CheckError(idx, ret, __LINE__);

	//			_util->Wait_Sec(0.1e-3);
	//		
	//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
	//			
	//			if (ret)
	//			{
	//				ret = 0;

	//				if (retest_count < TIMING_RESET_COUNT)
	//				{
	//					retest_count++;
	//					goto STU_RETEST;
	//				}
	//			}
	//			else
	//			{
	//				max_limit = (double)(tf_TPHighLimit_Cast(TPName[0]));
	//				min_limit = (double)(tf_TPLowLimit_Cast(TPName[0]));
	//				if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
	//				{
	//					if (retest_count < TIMING_RESET_COUNT)
	//					{
	//						retest_count++;
	//						goto STU_RETEST;
	//					}
	//				}
	//			}

	//			if (Double::IsNaN(sampled_result[0]) == false)
	//				result_stu_delay[i] = sampled_result[0];

	//			///////////////
	//			// UTS

	//			tmu_start_threshold = 0.98; //0.75;
	//			tmu_stop_threshold = 0.98; //0.75;

	//			ret = tm[idx]->ConfigureStart("TM_CH", TM_CONST_SLOPE_POSITIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_start_threshold, tmu_start_hysteresis, 0);
	//			CheckError(idx, ret, __LINE__);

	//			ret = tm[idx]->ConfigureStop("TM_CH", TM_CONST_SLOPE_NEGATIVE, 0, TM_CONST_RANGE_0_50OHM, tmu_stop_threshold, tmu_stop_hysteresis, 0);
	//			CheckError(idx, ret, __LINE__);

	//			//_util->Wait_Sec(1e-3);

	//			retest_count = 0;

	//UTS_RETEST:

	//			ret = tm[idx]->Arm("TM_CH", number_of_samples, TM_CONST_SOFTWARE_ARM, 0, 0, 0, 0, tmu_timeout, 0);
	//			CheckError(idx, ret, __LINE__);

	//			ret = RunVectorFile(idx, "write_flt_uts");
	//			CheckError(idx, ret, __LINE__);
	//			
	//			_util->Wait_Sec(0.5e-3);
	//		
	//			ret = tm[idx]->RetrieveResults("TM_CH", 0, returned_sample_count, sampled_result);
	//			
	//			if (ret)
	//			{
	//				ret = 0;

	//				if (retest_count < TIMING_RESET_COUNT)
	//				{
	//					retest_count++;
	//					goto UTS_RETEST;
	//				}
	//			}
	//			else
	//			{
	//				max_limit = (double)(tf_TPHighLimit_Cast(TPName[2]));
	//				min_limit = (double)(tf_TPLowLimit_Cast(TPName[2]));
	//				if ((sampled_result[0] < min_limit) || (sampled_result[0] > max_limit))
	//				{
	//					if (retest_count < TIMING_RESET_COUNT)
	//					{
	//						retest_count++;
	//						goto UTS_RETEST;
	//					}
	//				}
	//			}

	//			if (Double::IsNaN(sampled_result[0]) == false)
	//				result_uts_delay[i] = sampled_result[0];
	//		}

	//		tf_SetResult_UUTOffset(TPName[0], result_stu_delay[0] + GetOffset(idx, TPDispName[0]), idx);
	//		tf_SetResult_UUTOffset(TPName[1], result_stu_delay[1] + GetOffset(idx, TPDispName[1]), idx);
	//		tf_SetResult_UUTOffset(TPName[2], result_uts_delay[0] + GetOffset(idx, TPDispName[2]), idx);
	//		tf_SetResult_UUTOffset(TPName[3], result_uts_delay[1] + GetOffset(idx, TPDispName[3]), idx);

	//		/////////////////////////////////

	//		ret = Digital_Init_State(idx);
	//		CheckError(idx, ret, __LINE__);

	//		ret = ResetDMPin(idx, TPDispName[0]);
	//		CheckError(idx, ret, __LINE__);

	//		//Power down supplies
	//		//ret = smu[idx]->DriveVoltage("VEE", 0);
	//		//CheckError(idx, ret, __LINE__);
	//		ret = smu[idx]->DriveVoltage("VCC", 0);
	//		CheckError(idx, ret, __LINE__);

	//		//IO setting
	//		ret = ResetCBit(idx);
	//		CheckError(idx, ret, __LINE__);
	//		ret = ResetMuxIO(idx);
	//		CheckError(idx, ret, __LINE__);
	//	}
	//	catch (Exception^ ex) 
	//	{
	//		d->Exception = ex;
	//		d->ErrorCode = ret;
	//	}
	//}

	void TestProgram::PrintContStat(void)
	{
		int dataCount = 0;
		double Dev = 0.0;
		double DevSq = 0.0;
		double SumOfSq = 0.0;

		for (int i = 0 ; i < 31; i++)	  // Loop All pin
		{
			dataCount = Cont_Data_idx[i];

			if ((dataCount != 0) && (Cont_Data_meas[i] != 0)) 
			{
			
				Cont_Data_sum[i] = Cont_Data[i, dataCount - 1] + Cont_Data_sum[i];
				Cont_Data_mean[i] =  Cont_Data_sum[i] /	dataCount  ;
				// max and min


				// stdev
				for (int j = 0 ; j < dataCount; j++)
				{
					
					Dev = Cont_Data[i,j] - Cont_Data_mean[i];
					DevSq = Dev * Dev;
					SumOfSq	= SumOfSq + DevSq; 
				}

				double a  = pow(SumOfSq / dataCount, 0.5 );
				Cont_Data_stdev[i] = a;
			
			}
		}	


		// print result to file

		
		string filepath = "C:/Aemulus/Debug/Cont_Stat.txt";

		ofstream myfile;
		myfile.open(filepath.c_str(), ofstream::out);
		std::cout.precision(6);
		std::cout.setf( std::ios::fixed, std:: ios::floatfield );

		int i = 0;
		
		myfile << "Samples:\t" << SampleCount << "\n\n"; 
		myfile << "Pin\t\t\tMean\t\tStdev\n\n";
		
		myfile << "GNDS" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "RWN" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "SPD" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "SPC" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "SPE" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "FLTMUX" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "DMY_FST" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "WDX" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "WDY" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "RDP" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "RDN" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "VCC" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "VEE" << "\t\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HR0P" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HR0N" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HR0_D" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HR1P" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HR1N" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HR1_D" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HW0X" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HW0Y" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HW1X" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HW1Y" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HT0W" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HT1W" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HT0R" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HT1R" << "\t\t" << Cont_Data_mean[i] << "\t\t"<< Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HS0P" << "\t\t" << Cont_Data_mean[i] <<"\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HS0N" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HS1P" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		myfile << "HS1N" << "\t\t" << Cont_Data_mean[i] << "\t\t" << Cont_Data_stdev[i] << "\n" ;  i++;
		
		myfile.close();

		SampleCount++;

		for (int i = 0; i < 31; i++)
		{
			  Cont_Data_meas[i] = 0;		
		}




	}	
	void TestProgram::RecContData(double result, int C_idx)
	{
		if (EnableContStat)
		{
			int DataCount = Cont_Data_idx[C_idx] ;
			Cont_Data[C_idx,  DataCount]  = result;
			Cont_Data_idx[C_idx]++	;
			Cont_Data_meas[C_idx] = 1;
					
		}
	}



	//2945 specified funcfion
	double TestProgram::supply_thr_ppmu(int idx, String ^ pin, double pass_th, double fail_th, int flt_lvl)
	{
		int ret = 0;
		int loop_count = 0;
		int had_pass = 0;
		int had_fail = 0;
		int pin_val = 0;
		double thresh, sply_restore;
		double flt_pin = 0;
		sply_restore = pass_th;
		ret = smu[idx]->DriveVoltage(pin, fabs(sply_restore));
		_util->Wait_Sec(100e-6);

		////debug
		//double vcc_val, vee_val;
		//ret = smu->Measure("VCC", 1, vcc_val);
		//ret = smu->Measure("VEE", 1, vee_val);
		//ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
		////end debug

		while(loop_count < 10 && fabs(pass_th - fail_th) > 0.001)
		{
			if (pass_th<fail_th) //to search for fault threshold from low to high
				thresh = pass_th + ((fail_th-pass_th)/2);
			else //to search for fault threshold from high to low
				thresh = fail_th + ((pass_th-fail_th)/2);
				
			if (sply_restore>thresh)
			{ //gradually reduce supply voltage by 0.1, 0.02, 0.01, 0.005V
				if (sply_restore>thresh+0.1) 
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh+0.1));
				if (sply_restore>thresh+0.02)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh+0.02));
				if (sply_restore>thresh+0.01)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh+0.01));
				if (sply_restore>thresh+0.005)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh+0.005));
			}
			else
			{ //gradually increase supply voltage by 0.1, 0.02, 0.01, 0.005V
				if (sply_restore<thresh-0.1)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh-0.1));//JL: Note - SMU only allows +ve values
				if (sply_restore<thresh-0.02)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh-0.02));
				if (sply_restore<thresh-0.01)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh-0.01));
				if (sply_restore<thresh-0.005)
					ret = smu[idx]->DriveVoltage(pin, fabs(thresh-0.005));
			}
			//_util->Wait_Sec(1e-3);
			//ret = smu[idx]->Measure("VEE", 1, vee_val);
			ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
			if(flt_pin > 1) 
				pin_val = 1;
			else
				pin_val = 0;

			if(pin_val != flt_lvl) 
			{
				pass_th = thresh;
 				had_pass = 1;
			}
			else
			{
				fail_th = thresh;
				had_fail = 1;
			}
			loop_count++;
			
			if(sply_restore > 0)
				ret = smu[idx]->DriveVoltage(pin, fabs(sply_restore-0.1));
			else
				ret = smu[idx]->DriveVoltage(pin, fabs(sply_restore+0.1));
			
			ret = smu[idx]->DriveVoltage(pin, fabs(sply_restore));
			_util->Wait_Sec(100e-6);
		}
		
		////debug
		//ret = smu[idx]->Measure("VCC", 1, vcc_val);
		//ret = smu[idx]->Measure("VEE", 1, vee_val);
		//ret = dm[idx]->PMUMeasure("FLTMUX", DM_CONST_MEASUREVOLTAGE, flt_pin);
		////end debug

		CheckError(idx, ret, __LINE__);

		return ((pass_th+fail_th)/2);
	}
}
